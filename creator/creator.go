//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
package creator ;import (_fg "bytes";_f "encoding/xml";_ge "errors";_b "fmt";_geg "github.com/gorilla/i18n/linebreak";_ba "github.com/unidoc/unichart/render";_ee "github.com/unidoc/unipdf/v3/common";_da "github.com/unidoc/unipdf/v3/contentstream";_gad "github.com/unidoc/unipdf/v3/contentstream/draw";
_bf "github.com/unidoc/unipdf/v3/core";_bd "github.com/unidoc/unipdf/v3/internal/graphic2d/svg";_edb "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_fe "github.com/unidoc/unipdf/v3/internal/license";_eb "github.com/unidoc/unipdf/v3/internal/transform";
_bbd "github.com/unidoc/unipdf/v3/model";_c "golang.org/x/text/unicode/bidi";_ab "image";_ga "io";_d "log";_bbg "math";_a "os";_bc "regexp";_g "sort";_bb "strconv";_dd "strings";_ed "text/template";_fa "unicode";);

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
//
// Note: Currently Styled Paragraph doesn't support TextVerticalAlignmentBottom
// as that option only used for aligning text chunks.
//
// In order to change the vertical alignment of individual text chunks, use TextChunk.VerticalAlignment.
func (_afac *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_afac ._adbg =align ;};func _aeeg (_fdfec *templateProcessor ,_bcgaf *templateNode )(interface{},error ){return _fdfec .parseStyledParagraph (_bcgaf );};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_caegf *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _eeae (x1 ,y1 ,x2 ,y2 )};func (_cgfb *TableCell )height (_ceege float64 )float64 {var _ecede float64 ;switch _cggd :=_cgfb ._ffed .(type ){case *Paragraph :if _cggd ._bacce {_cggd .SetWidth (_ceege -_cgfb ._bfef -_cggd ._ggfad .Left -_cggd ._ggfad .Right );
};_ecede =_cggd .Height ()+_cggd ._ggfad .Top +_cggd ._ggfad .Bottom ;if !_cgfb ._bdcge ._eedb {_ecede +=(0.5*_cggd ._gfddf *_cggd ._degf );};case *StyledParagraph :if _cggd ._abbea {_cggd .SetWidth (_ceege -_cgfb ._bfef -_cggd ._dadf .Left -_cggd ._dadf .Right );
};_ecede =_cggd .Height ()+_cggd ._dadf .Top +_cggd ._dadf .Bottom ;if !_cgfb ._bdcge ._eedb {_ecede +=(0.5*_cggd .getTextHeight ());};case *Image :_cggd .applyFitMode (_ceege -_cgfb ._bfef );_ecede =_cggd .Height ()+_cggd ._ecd .Top +_cggd ._ecd .Bottom ;
case *Table :_cggd .updateRowHeights (_ceege -_cgfb ._bfef -_cggd ._afcg .Left -_cggd ._afcg .Right );_ecede =_cggd .Height ()+_cggd ._afcg .Top +_cggd ._afcg .Bottom ;case *List :_ecede =_cggd .ctxHeight (_ceege -_cgfb ._bfef )+_cggd ._ddba .Top +_cggd ._ddba .Bottom ;
case *Division :_ecede =_cggd .ctxHeight (_ceege -_cgfb ._bfef )+_cggd ._ggea .Top +_cggd ._ggea .Bottom +_cggd ._eabe .Top +_cggd ._eabe .Bottom ;case *Chart :_ecede =_cggd .Height ()+_cggd ._ceac .Top +_cggd ._ceac .Bottom ;case *Rectangle :_cggd .applyFitMode (_ceege -_cgfb ._bfef );
_ecede =_cggd .Height ()+_cggd ._caegfd .Top +_cggd ._caegfd .Bottom +_cggd ._egdc ;case *Ellipse :_cggd .applyFitMode (_ceege -_cgfb ._bfef );_ecede =_cggd .Height ()+_cggd ._fdcb .Top +_cggd ._fdcb .Bottom ;case *Line :_ecede =_cggd .Height ()+_cggd ._babe .Top +_cggd ._babe .Bottom ;
};return _ecede ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_bccb *Creator )NewImage (img *_bbd .Image )(*Image ,error ){return _eggc (img )};func _ffge (_bae string ,_dgc _bf .PdfObject ,_dcff *_bbd .PdfPageResources )_bf .PdfObjectName {_gdd :=_dd .TrimRightFunc (_dd .TrimSpace (_bae ),func (_deb rune )bool {return _fa .IsNumber (_deb )});
if _gdd ==""{_gdd ="\u0046\u006f\u006e\u0074";};_dff :=0;_feg :=_bf .PdfObjectName (_bae );for {_bfa ,_ega :=_dcff .GetFontByName (_feg );if !_ega ||_bfa ==_dgc {break ;};_dff ++;_feg =_bf .PdfObjectName (_b .Sprintf ("\u0025\u0073\u0025\u0064",_gdd ,_dff ));
};return _feg ;};func (_dgfbd *templateProcessor )parseList (_cgca *templateNode )(interface{},error ){_eaabd :=_dgfbd .creator .NewList ();for _ ,_bfaa :=range _cgca ._ebeg .Attr {_gbag :=_bfaa .Value ;switch _ddac :=_bfaa .Name .Local ;_ddac {case "\u0069\u006e\u0064\u0065\u006e\u0074":_eaabd .SetIndent (_dgfbd .parseFloatAttr (_ddac ,_gbag ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_efgd :=_dgfbd .parseMarginAttr (_ddac ,_gbag );_eaabd .SetMargins (_efgd .Left ,_efgd .Right ,_efgd .Top ,_efgd .Bottom );default:_dgfbd .nodeLogDebug (_cgca ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u0073\u0074 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ddac );
};};return _eaabd ,nil ;};func _gdcd (_daef ,_fcdc ,_eaab ,_cgfd ,_gaddc ,_bgaa float64 )*Curve {_ccff :=&Curve {};_ccff ._baec =_daef ;_ccff ._acfd =_fcdc ;_ccff ._eeaf =_eaab ;_ccff ._eadc =_cgfd ;_ccff ._cefce =_gaddc ;_ccff ._eddf =_bgaa ;_ccff ._dgda =ColorBlack ;
_ccff ._ffgc =1.0;return _ccff ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_cfea *TOC )SetLinePageStyle (style TextStyle ){_cfea ._gfgag =style };

// Margins returns the margins of the component.
func (_ddgd *Division )Margins ()(_afbf ,_fbcg ,_ebad ,_egag float64 ){return _ddgd ._ggea .Left ,_ddgd ._ggea .Right ,_ddgd ._ggea .Top ,_ddgd ._ggea .Bottom ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// TOC returns the table of contents component of the creator.
func (_cgf *Creator )TOC ()*TOC {return _cgf ._ggab };

// SetMargins sets the margins of the graphic svg component.
func (_dbbc *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_dbbc ._gac .Left =left ;_dbbc ._gac .Right =right ;_dbbc ._gac .Top =top ;_dbbc ._gac .Bottom =bottom ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_afbb *Creator )SetPageSize (size PageSize ){_afbb ._baba =size ;_afbb ._afgc =size [0];_afbb ._ebeb =size [1];_bcgea :=0.1*_afbb ._afgc ;_afbb ._gbf .Left =_bcgea ;_afbb ._gbf .Right =_bcgea ;_afbb ._gbf .Top =_bcgea ;_afbb ._gbf .Bottom =_bcgea ;
};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//
//	[number] [title]      [separator] [page]
//
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_efaae *StyledParagraph ;_dcbb []*TOCLine ;_febc TextStyle ;_abgfe TextStyle ;_dbfaf TextStyle ;_gfgag TextStyle ;_abdbb string ;_addd float64 ;_eada Margins ;_cgcad Positioning ;_gecg TextStyle ;_fbfca bool ;};type pageTransformations struct{_aeef *_eb .Matrix ;
_eacc bool ;_ebbg bool ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_eeaa *Creator )NewStyledParagraph ()*StyledParagraph {return _ggcdc (_eeaa .NewTextStyle ())};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _dcc ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_bfae :=&Creator {};_bfae ._afbe =[]*_bbd .PdfPage {};_bfae ._acba =map[*_bbd .PdfPage ]*Block {};_bfae ._dacbc =map[*_bbd .PdfPage ]*pageTransformations {};
_bfae .SetPageSize (PageSizeLetter );_bcge :=0.1*_bfae ._afgc ;_bfae ._gbf .Left =_bcge ;_bfae ._gbf .Right =_bcge ;_bfae ._gbf .Top =_bcge ;_bfae ._gbf .Bottom =_bcge ;var _bafg error ;_bfae ._aaaf ,_bafg =_bbd .NewStandard14Font (_bbd .HelveticaName );
if _bafg !=nil {_bfae ._aaaf =_bbd .DefaultFont ();};_bfae ._dggc ,_bafg =_bbd .NewStandard14Font (_bbd .HelveticaBoldName );if _bafg !=nil {_bfae ._aaaf =_bbd .DefaultFont ();};_bfae ._ggab =_bfae .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");
_bfae .AddOutlines =true ;_bfae ._cda =_bbd .NewOutline ();_fe .TrackUse (_dcc );return _bfae ;};var PPI float64 =72;

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_ceacf *Division )Width ()float64 {return 0};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_geff *Chapter )GetHeading ()*Paragraph {return _geff ._fgef };func (_ca *Block )addContents (_gc *_da .ContentStreamOperations ){_ca ._ec .WrapIfNeeded ();_gc .WrapIfNeeded ();*_ca ._ec =append (*_ca ._ec ,*_gc ...);};func _deed (_ddgdb []_gad .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_cgbc :&_gad .PolyBezierCurve {Curves :_ddgdb ,BorderColor :_bbd .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_faba :1.0,_bbga :1.0};
};

// IsRelative checks if the positioning is relative.
func (_bfd Positioning )IsRelative ()bool {return _bfd ==PositionRelative };func _fffd (_fbcffb *templateProcessor ,_bccbc *templateNode )(interface{},error ){return _fbcffb .parseListMarker (_bccbc );};func (_acbaf *Invoice )drawInformation ()*Table {_bdfd :=_bfdec (2);
_cccdf :=append ([][2]*InvoiceCell {_acbaf ._aca ,_acbaf ._cadc ,_acbaf ._cdfc },_acbaf ._geaa ...);for _ ,_beaee :=range _cccdf {_fbdbc ,_efad :=_beaee [0],_beaee [1];if _efad .Value ==""{continue ;};_bcbdf :=_bdfd .NewCell ();_bcbdf .SetBackgroundColor (_fbdbc .BackgroundColor );
_acbaf .setCellBorder (_bcbdf ,_fbdbc );_fbdg :=_ggcdc (_fbdbc .TextStyle );_fbdg .Append (_fbdbc .Value );_fbdg .SetMargins (0,0,2,1);_bcbdf .SetContent (_fbdg );_bcbdf =_bdfd .NewCell ();_bcbdf .SetBackgroundColor (_efad .BackgroundColor );_acbaf .setCellBorder (_bcbdf ,_efad );
_fbdg =_ggcdc (_efad .TextStyle );_fbdg .Append (_efad .Value );_fbdg .SetMargins (0,0,2,1);_bcbdf .SetContent (_fbdg );};return _bdfd ;};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//
//	red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_eage :float64 (r )/255.0,_eaee :float64 (g )/255.0,_gfe :float64 (b )/255.0};};

// NewImageFromData creates an Image from image data.
func (_eeea *Creator )NewImageFromData (data []byte )(*Image ,error ){return _bcff (data )};func (_cdfba *Invoice )newColumn (_cbefb string ,_cdfg CellHorizontalAlignment )*InvoiceCell {_accg :=&InvoiceCell {_cdfba ._edga ,_cbefb };_accg .Alignment =_cdfg ;
return _accg ;};

// SetTotal sets the total of the invoice.
func (_bec *Invoice )SetTotal (value string ){_bec ._eegf [1].Value =value };func (_gagc *LinearShading )shadingModel ()*_bbd .PdfShadingType2 {_acbea :=_gad .NewPoint (_gagc ._fagf .Llx +_gagc ._fagf .Width ()/2,_gagc ._fagf .Lly +_gagc ._fagf .Height ()/2);
_eaba :=_gad .NewPoint (_gagc ._fagf .Llx ,_gagc ._fagf .Lly +_gagc ._fagf .Height ()/2).Add (-_acbea .X ,-_acbea .Y ).Rotate (_gagc ._gegea ).Add (_acbea .X ,_acbea .Y );_eaba =_gad .NewPoint (_bbg .Max (_bbg .Min (_eaba .X ,_gagc ._fagf .Urx ),_gagc ._fagf .Llx ),_bbg .Max (_bbg .Min (_eaba .Y ,_gagc ._fagf .Ury ),_gagc ._fagf .Lly ));
_dfbad :=_gad .NewPoint (_gagc ._fagf .Urx ,_gagc ._fagf .Lly +_gagc ._fagf .Height ()/2).Add (-_acbea .X ,-_acbea .Y ).Rotate (_gagc ._gegea ).Add (_acbea .X ,_acbea .Y );_dfbad =_gad .NewPoint (_bbg .Min (_bbg .Max (_dfbad .X ,_gagc ._fagf .Llx ),_gagc ._fagf .Urx ),_bbg .Min (_bbg .Max (_dfbad .Y ,_gagc ._fagf .Lly ),_gagc ._fagf .Ury ));
_bfcg :=_bbd .NewPdfShadingType2 ();_bfcg .PdfShading .ShadingType =_bf .MakeInteger (2);_bfcg .PdfShading .ColorSpace =_bbd .NewPdfColorspaceDeviceRGB ();_bfcg .PdfShading .AntiAlias =_bf .MakeBool (_gagc ._ebade ._gdfd );_bfcg .Coords =_bf .MakeArrayFromFloats ([]float64 {_eaba .X ,_eaba .Y ,_dfbad .X ,_dfbad .Y });
_bfcg .Extend =_bf .MakeArray (_bf .MakeBool (_gagc ._ebade ._aeaa [0]),_bf .MakeBool (_gagc ._ebade ._aeaa [1]));_bfcg .Function =_gagc ._ebade .generatePdfFunctions ();return _bfcg ;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_ccgg *List )Marker ()*TextChunk {return &_ccgg ._cafc };func (_gdg cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_cega :=_gdg ._dfag ;return 1-(_gdg ._fegag *(1-_cega )+_cega ),1-(_gdg ._acbg *(1-_cega )+_cega ),1-(_gdg ._aggdc *(1-_cega )+_cega );
};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_cdfaf *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_cdfaf ._fagf =&_bbd .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};func (_fda *Block )duplicate ()*Block {_af :=&Block {};*_af =*_fda ;_bdg :=_da .ContentStreamOperations {};
_bdg =append (_bdg ,*_fda ._ec ...);_af ._ec =&_bdg ;return _af ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_fegf DrawContext )([]*Block ,DrawContext ,error );};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_fgae *Invoice )SetAddressStyle (style TextStyle ){_fgae ._dbbe =style };func _eebfg (_dbbeg string )*_bbd .PdfAnnotation {_cfbf :=_bbd .NewPdfAnnotationLink ();_ggdba :=_bbd .NewBorderStyle ();_ggdba .SetBorderWidth (0);_cfbf .BS =_ggdba .ToPdfObject ();
_cdeed :=_bbd .NewPdfActionURI ();_cdeed .URI =_bf .MakeString (_dbbeg );_cfbf .SetAction (_cdeed .PdfAction );return _cfbf .PdfAnnotation ;};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_bgbg *Division )Height ()float64 {var _egc float64 ;for _ ,_bdgb :=range _bgbg ._befg {switch _gafeb :=_bdgb .(type ){case marginDrawable :_ ,_ ,_cgd ,_abca :=_gafeb .GetMargins ();_egc +=_gafeb .Height ()+_cgd +_abca ;default:_egc +=_gafeb .Height ();
};};return _egc ;};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_gegb *Chapter )Add (d Drawable )error {if Drawable (_gegb )==d {_ee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _ge .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _feeb :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_gegb ._gba =append (_gegb ._gba ,d );case containerDrawable :_gbg ,_bcfc :=_feeb .ContainerComponent (_gegb );
if _bcfc !=nil {return _bcfc ;};_gegb ._gba =append (_gegb ._gba ,_gbg );default:_ee .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _ge .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// Text sets the text content of the Paragraph.
func (_cbbc *Paragraph )Text ()string {return _cbbc ._bcecc };

// SetFillColor sets the fill color of the ellipse.
func (_bbfed *Ellipse )SetFillColor (col Color ){_bbfed ._bfde =col };func _geeed (_fgfad ,_dbcea ,_acffb ,_gcfg float64 )*Rectangle {return &Rectangle {_bgcbe :_fgfad ,_aagb :_dbcea ,_cdagc :_acffb ,_ddbcg :_gcfg ,_efee :PositionAbsolute ,_fbcfb :1.0,_acbae :ColorBlack ,_egdc :1.0,_cegge :1.0};
};func (_dfbb *Image )rotatedSize ()(float64 ,float64 ){_agcce :=_dfbb ._bfdf ;_dbbcg :=_dfbb ._bcec ;_gagd :=_dfbb ._bbed ;if _gagd ==0{return _agcce ,_dbbcg ;};_bcgc :=_gad .Path {Points :[]_gad .Point {_gad .NewPoint (0,0).Rotate (_gagd ),_gad .NewPoint (_agcce ,0).Rotate (_gagd ),_gad .NewPoint (0,_dbbcg ).Rotate (_gagd ),_gad .NewPoint (_agcce ,_dbbcg ).Rotate (_gagd )}}.GetBoundingBox ();
return _bcgc .Width ,_bcgc .Height ;};

// Scale block by specified factors in the x and y directions.
func (_abe *Block )Scale (sx ,sy float64 ){_beg :=_da .NewContentCreator ().Scale (sx ,sy ).Operations ();*_abe ._ec =append (*_beg ,*_abe ._ec ...);_abe ._ec .WrapIfNeeded ();_abe ._eg *=sx ;_abe ._gg *=sy ;};

// Height returns the height of the graphic svg.
func (_gefg *GraphicSVG )Height ()float64 {return _gefg ._gdbd .Height };func (_cdaaa *templateProcessor )parseHorizontalAlignmentAttr (_cffb ,_fddba string )HorizontalAlignment {_ee .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_cffb ,_fddba );
_bagde :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_fddba ];return _bagde ;};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_baebg *RadialShading )SetExtends (start bool ,end bool ){_baebg ._daacc .SetExtends (start ,end )};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_abbc *Creator )SetOptimizer (optimizer _bbd .Optimizer ){_abbc ._eadg =optimizer };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_edeg Drawable )(Drawable ,error );};

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_adaea *Rectangle )Height ()float64 {return _adaea ._ddbcg };

// SetStyleBottom sets border style for bottom side.
func (_aceb *border )SetStyleBottom (style CellBorderStyle ){_aceb ._gec =style };func _fggd (_dgcef *Block ,_abaf *Paragraph ,_ecbde DrawContext )(DrawContext ,error ){_fdb :=1;_gagf :=_bf .PdfObjectName ("\u0046\u006f\u006e\u0074"+_bb .Itoa (_fdb ));
for _dgcef ._ce .HasFontByName (_gagf ){_fdb ++;_gagf =_bf .PdfObjectName ("\u0046\u006f\u006e\u0074"+_bb .Itoa (_fdb ));};_eagee :=_dgcef ._ce .SetFontByName (_gagf ,_abaf ._bebf .ToPdfObject ());if _eagee !=nil {return _ecbde ,_eagee ;};_abaf .wrapText ();
_gbec :=_da .NewContentCreator ();_gbec .Add_q ();_cefbe :=_ecbde .PageHeight -_ecbde .Y -_abaf ._gfddf *_abaf ._degf ;_gbec .Translate (_ecbde .X ,_cefbe );if _abaf ._eagec !=0{_gbec .RotateDeg (_abaf ._eagec );};_fbga :=_dcgf (_abaf ._bbbf );_eagee =_agab (_dgcef ,_fbga ,_abaf ._bbbf ,func ()Rectangle {return Rectangle {_bgcbe :_ecbde .X ,_aagb :_cefbe ,_cdagc :_abaf .getMaxLineWidth ()/1000.0,_ddbcg :_abaf .Height ()};
});if _eagee !=nil {return _ecbde ,_eagee ;};_gbec .Add_BT ().SetNonStrokingColor (_fbga ).Add_Tf (_gagf ,_abaf ._gfddf ).Add_TL (_abaf ._gfddf *_abaf ._degf );for _fcaf ,_caaff :=range _abaf ._fffef {if _fcaf !=0{_gbec .Add_Tstar ();};_fgfgg :=[]rune (_caaff );
_debeb :=0.0;_dadb :=0;for _ffde ,_gcbe :=range _fgfgg {if _gcbe ==' '{_dadb ++;continue ;};if _gcbe =='\u000A'{continue ;};_dddafd ,_cgabf :=_abaf ._bebf .GetRuneMetrics (_gcbe );if !_cgabf {_ee .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_ffde ,_gcbe ,_gcbe ,_abaf ._bebf .BaseFont (),_abaf ._bebf .Subtype ());
return _ecbde ,_ge .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_debeb +=_abaf ._gfddf *_dddafd .Wx ;};var _geabb []_bf .PdfObject ;_ccdd ,_defbd :=_abaf ._bebf .GetRuneMetrics (' ');
if !_defbd {return _ecbde ,_ge .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_ffaef :=_ccdd .Wx ;switch _abaf ._dacg {case TextAlignmentJustify :if _dadb > 0&&_fcaf < len (_abaf ._fffef )-1{_ffaef =(_abaf ._cfedb *1000.0-_debeb )/float64 (_dadb )/_abaf ._gfddf ;
};case TextAlignmentCenter :_abfd :=_debeb +float64 (_dadb )*_ffaef *_abaf ._gfddf ;_bgca :=(_abaf ._cfedb *1000.0-_abfd )/2/_abaf ._gfddf ;_geabb =append (_geabb ,_bf .MakeFloat (-_bgca ));case TextAlignmentRight :_gbgb :=_debeb +float64 (_dadb )*_ffaef *_abaf ._gfddf ;
_bbfb :=(_abaf ._cfedb *1000.0-_gbgb )/_abaf ._gfddf ;_geabb =append (_geabb ,_bf .MakeFloat (-_bbfb ));};_dbcf :=_abaf ._bebf .Encoder ();var _bfge []byte ;for _ ,_eefac :=range _fgfgg {if _eefac =='\u000A'{continue ;};if _eefac ==' '{if len (_bfge )> 0{_geabb =append (_geabb ,_bf .MakeStringFromBytes (_bfge ));
_bfge =nil ;};_geabb =append (_geabb ,_bf .MakeFloat (-_ffaef ));}else {if _ ,_baag :=_dbcf .RuneToCharcode (_eefac );!_baag {_eagee =UnsupportedRuneError {Message :_b .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_eefac ,_eefac ),Rune :_eefac };
_ecbde ._eccc =append (_ecbde ._eccc ,_eagee );_ee .Log .Debug (_eagee .Error ());if _ecbde ._bdbc <=0{continue ;};_eefac =_ecbde ._bdbc ;};_bfge =append (_bfge ,_dbcf .Encode (string (_eefac ))...);};};if len (_bfge )> 0{_geabb =append (_geabb ,_bf .MakeStringFromBytes (_bfge ));
};_gbec .Add_TJ (_geabb ...);};_gbec .Add_ET ();_gbec .Add_Q ();_fdccg :=_gbec .Operations ();_fdccg .WrapIfNeeded ();_dgcef .addContents (_fdccg );if _abaf ._geee .IsRelative (){_bdbab :=_abaf .Height ();_ecbde .Y +=_bdbab ;_ecbde .Height -=_bdbab ;if _ecbde .Inline {_ecbde .X +=_abaf .Width ()+_abaf ._ggfad .Right ;
};};return _ecbde ,nil ;};

// SetBorderRadius sets the radius of the background corners.
func (_be *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_be .BorderRadiusTopLeft =topLeft ;_be .BorderRadiusTopRight =topRight ;_be .BorderRadiusBottomLeft =bottomLeft ;_be .BorderRadiusBottomRight =bottomRight ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// SetMargins sets the margins of the chart component.
func (_bcef *Chart )SetMargins (left ,right ,top ,bottom float64 ){_bcef ._ceac .Left =left ;_bcef ._ceac .Right =right ;_bcef ._ceac .Top =top ;_bcef ._ceac .Bottom =bottom ;};

// Vertical returns total vertical (top + bottom) margin.
func (_afe *Margins )Vertical ()float64 {return _afe .Bottom +_afe .Top };

// SetSideBorderWidth sets the cell's side border width.
func (_fecb *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_fecb ._accd =width ;_fecb ._adcb =width ;_fecb ._caec =width ;_fecb ._gbad =width ;case CellBorderSideTop :_fecb ._accd =width ;case CellBorderSideBottom :_fecb ._adcb =width ;
case CellBorderSideLeft :_fecb ._caec =width ;case CellBorderSideRight :_fecb ._gbad =width ;};};func (_cebd *List )split (_agbd DrawContext )(_deg ,_abfb *List ){var (_baccc float64 ;_gcafd ,_fdaab []*listItem ;);_edad :=_agbd .Width -_cebd ._ddba .Horizontal ()-_cebd ._eaef -_cebd .markerWidth ();
_gaddcd :=_cebd .markerWidth ();for _eebe ,_acff :=range _cebd ._gebg {_fcgf :=_acff .ctxHeight (_edad );_baccc +=_fcgf ;if _baccc <=_agbd .Height {_gcafd =append (_gcafd ,_acff );}else {switch _fddg :=_acff ._dgfd .(type ){case *List :_egfaa :=_agbd ;
_egfaa .Height =_bbg .Floor (_fcgf -(_baccc -_agbd .Height ));_efg ,_abae :=_fddg .split (_egfaa );if _efg !=nil {_gegg :=_afc ();_gegg ._badgf =_acff ._badgf ;_gegg ._dgfd =_efg ;_gcafd =append (_gcafd ,_gegg );};if _abae !=nil {_dgac :=_fddg ._cafc .Style .FontSize ;
_fdef ,_ffgcf :=_fddg ._cafc .Style .Font .GetRuneMetrics (' ');if _ffgcf {_dgac =_fddg ._cafc .Style .FontSize *_fdef .Wx *_fddg ._cafc .Style .horizontalScale ()/1000.0;};_ffagb :=_dd .Repeat ("\u0020",int (_gaddcd /_dgac ));_ffbc :=_afc ();_ffbc ._badgf =*NewTextChunk (_ffagb ,_fddg ._cafc .Style );
_ffbc ._dgfd =_abae ;_fdaab =append (_fdaab ,_ffbc );_fdaab =append (_fdaab ,_cebd ._gebg [_eebe +1:]...);};default:_fdaab =_cebd ._gebg [_eebe :];};if len (_fdaab )> 0{break ;};};};if len (_gcafd )> 0{_deg =_fbg (_cebd ._ddbae );*_deg =*_cebd ;_deg ._gebg =_gcafd ;
};if len (_fdaab )> 0{_abfb =_fbg (_cebd ._ddbae );*_abfb =*_cebd ;_abfb ._gebg =_fdaab ;};return _deg ,_abfb ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_acf *Block )SetPos (x ,y float64 ){_acf ._daf =PositionAbsolute ;_acf ._ea =x ;_acf ._fd =y };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_dfec *StyledParagraph )SetTextAlignment (align TextAlignment ){_dfec ._eceb =align };func (_ggggb *templateProcessor )parseInt64Attr (_cdcac ,_bdgdb string )int64 {_ee .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_cdcac ,_bdgdb );
_aeafb ,_ :=_bb .ParseInt (_bdgdb ,10,64);return _aeafb ;};func (_accf rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _accf ._eage ,_accf ._eaee ,_accf ._gfe ;};func (_egca *Ellipse )applyFitMode (_cgeb float64 ){_cgeb -=_egca ._fdcb .Left +_egca ._fdcb .Right ;
switch _egca ._aacb {case FitModeFillWidth :_egca .ScaleToWidth (_cgeb );};};func _cbbcb (_feaf string )bool {_abgad :=func (_ggdea rune )bool {return _ggdea =='\u000A'};_dcdf :=_dd .TrimFunc (_feaf ,_abgad );_gffd :=_c .Paragraph {};_ ,_efecb :=_gffd .SetString (_dcdf );
if _efecb !=nil {return true ;};_cdcgc ,_efecb :=_gffd .Order ();if _efecb !=nil {return true ;};if _cdcgc .NumRuns ()< 1{return true ;};return _gffd .IsLeftToRight ();};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_decg *TableCell )SetBorderLineStyle (style _gad .LineStyle ){_decg ._cgccf =style };

// Title returns the title of the invoice.
func (_cdaga *Invoice )Title ()string {return _cdaga ._aabb };

// SetLineWidth sets the line width.
func (_cdge *Line )SetLineWidth (width float64 ){_cdge ._fffb =width };func (_dfaae *templateProcessor )parseTextOverflowAttr (_bdagc ,_dabag string )TextOverflow {_ee .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_bdagc ,_dabag );
_ageg :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_dabag ];return _ageg ;};func (_aggbd *Table )updateRowHeights (_ggbd float64 ){for _ ,_dbcfg :=range _aggbd ._gggdf {_ffga :=_dbcfg .width (_aggbd ._ecgg ,_ggbd );
_edca :=_dbcfg .height (_ffga );_cgfg :=_aggbd ._abaa [_dbcfg ._cddg +_dbcfg ._fcabc -2];if _dbcfg ._fcabc > 1{_feeea :=0.0;_cbag :=_aggbd ._abaa [_dbcfg ._cddg -1:(_dbcfg ._cddg +_dbcfg ._fcabc -1)];for _ ,_fgceg :=range _cbag {_feeea +=_fgceg ;};if _edca <=_feeea {continue ;
};};if _edca > _cgfg {_fgaeb :=_edca /float64 (_dbcfg ._fcabc );if _fgaeb > _cgfg {for _afege :=1;_afege <=_dbcfg ._fcabc ;_afege ++{if _fgaeb > _aggbd ._abaa [_dbcfg ._cddg +_afege -2]{_aggbd ._abaa [_dbcfg ._cddg +_afege -2]=_fgaeb ;};};};};};};

// SetSideBorderStyle sets the cell's side border style.
func (_fdfbe *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_fdfbe ._adebbb =style ;_fdfbe ._ggdb =style ;_fdfbe ._adac =style ;_fdfbe ._ggag =style ;case CellBorderSideTop :_fdfbe ._adebbb =style ;
case CellBorderSideBottom :_fdfbe ._ggdb =style ;case CellBorderSideLeft :_fdfbe ._adac =style ;case CellBorderSideRight :_fdfbe ._ggag =style ;};};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetOpacity sets opacity for Image.
func (_bdbg *Image )SetOpacity (opacity float64 ){_bdbg ._gcce =opacity };

// SetDate sets the date of the invoice.
func (_fcfe *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_fcfe ._cadc [1].Value =date ;return _fcfe ._cadc [0],_fcfe ._cadc [1];};

// Scale scales Image by a constant factor, both width and height.
func (_cdde *Image )Scale (xFactor ,yFactor float64 ){_cdde ._bfdf =xFactor *_cdde ._bfdf ;_cdde ._bcec =yFactor *_cdde ._bcec ;};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_ddc *Division )SetPadding (left ,right ,top ,bottom float64 ){_ddc ._eabe .Left =left ;_ddc ._eabe .Right =right ;_ddc ._eabe .Top =top ;_ddc ._eabe .Bottom =bottom ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_afbe []*_bbd .PdfPage ;_acba map[*_bbd .PdfPage ]*Block ;_dacbc map[*_bbd .PdfPage ]*pageTransformations ;_faee *_bbd .PdfPage ;_baba PageSize ;_ffdd DrawContext ;_gbf Margins ;_afgc ,_ebeb float64 ;_cbga int ;_bdcb func (_daaa FrontpageFunctionArgs );
_bef func (_dgce *TOC )error ;_aaa func (_efba *Block ,_gfa HeaderFunctionArgs );_bgg func (_acgg *Block ,_gfeb FooterFunctionArgs );_efd func (_adae PageFinalizeFunctionArgs )error ;_cfdb func (_gadg *_bbd .PdfWriter )error ;_dbg bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_ggab *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_cda *_bbd .Outline ;_bagg *_bbd .PdfOutlineTreeNode ;_bagc *_bbd .PdfAcroForm ;_fdga _bf .PdfObject ;_eadg _bbd .Optimizer ;_bbca []*_bbd .PdfFont ;_aaaf *_bbd .PdfFont ;_dggc *_bbd .PdfFont ;};func (_bcbdc *StyledParagraph )wrapWordChunks (){if !_bcbdc ._cgdf {return ;
};var (_cggfg []*TextChunk ;_efca *_bbd .PdfFont ;);for _ ,_ebbgf :=range _bcbdc ._gacc {_abga :=[]rune (_ebbgf .Text );if _efca ==nil {_efca =_ebbgf .Style .Font ;};_cgeg :=_ebbgf ._gdege ;_eaegf :=_ebbgf .VerticalAlignment ;if len (_cggfg )> 0{if len (_abga )==1&&_fa .IsPunct (_abga [0])&&_ebbgf .Style .Font ==_efca {_dcad :=[]rune (_cggfg [len (_cggfg )-1].Text );
_cggfg [len (_cggfg )-1].Text =string (append (_dcad ,_abga [0]));continue ;}else {_ ,_fdff :=_bb .Atoi (_ebbgf .Text );if _fdff ==nil {_abeb :=[]rune (_cggfg [len (_cggfg )-1].Text );_dfbe :=len (_abeb );if _dfbe >=2{_ ,_dgaeb :=_bb .Atoi (string (_abeb [_dfbe -2]));
if _dgaeb ==nil &&_fa .IsPunct (_abeb [_dfbe -1]){_cggfg [len (_cggfg )-1].Text =string (append (_abeb ,_abga ...));continue ;};};};};};_bcdf ,_cefe :=_ggced (_ebbgf .Text );if _cefe !=nil {_ee .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_cefe );
_bcdf =[]string {_ebbgf .Text };};for _ ,_ebbeb :=range _bcdf {_gdbf :=NewTextChunk (_ebbeb ,_ebbgf .Style );_gdbf ._gdege =_geafg (_cgeg );_gdbf .VerticalAlignment =_eaegf ;_cggfg =append (_cggfg ,_gdbf );};_efca =_ebbgf .Style .Font ;};if len (_cggfg )> 0{_bcbdc ._gacc =_cggfg ;
};};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_agb *Block )DrawTemplate (c *Creator ,r _ga .Reader ,data interface{},options *TemplateOptions )error {return _bgaf (c ,r ,data ,options ,_agb );};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_bbbaf *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_cddd :=NewTextChunk (text ,_bbbaf ._fbcb );_cddd ._gdege =_eebfg (url );return _bbbaf .appendChunk (_cddd );};const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;AnchorTopLeft ;
AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_acaac *TOCLine )SetLink (page int64 ,x ,y float64 ){_acaac ._fggb =x ;_acaac ._bdeg =y ;_acaac ._bgge =page ;_ecbce :=_acaac ._ebca ._fbcb .Color ;_acaac .Number .Style .Color =_ecbce ;_acaac .Title .Style .Color =_ecbce ;_acaac .Separator .Style .Color =_ecbce ;
_acaac .Page .Style .Color =_ecbce ;};

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_cfef *GraphicSVG )ScaleToHeight (h float64 ){_abea :=_cfef ._gdbd .Width /_cfef ._gdbd .Height ;_cfef ._gdbd .Height =h ;_cfef ._gdbd .Width =h *_abea ;_cfef ._gdbd .SetScaling (_abea ,_abea );};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_aeae *LinearShading )AddShadingResource (block *Block )(_aabd _bf .PdfObjectName ,_afaf error ){_gaga :=1;_aabd =_bf .PdfObjectName ("\u0053\u0068"+_bb .Itoa (_gaga ));for block ._ce .HasShadingByName (_aabd ){_gaga ++;_aabd =_bf .PdfObjectName ("\u0053\u0068"+_bb .Itoa (_gaga ));
};if _bfdda :=block ._ce .SetShadingByName (_aabd ,_aeae .shadingModel ().ToPdfObject ());_bfdda !=nil {return "",_bfdda ;};return _aabd ,nil ;};func (_effad *templateProcessor )parseFloatArray (_bcecb ,_bccbg string )[]float64 {_ee .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bcecb ,_bccbg );
_ggadg :=_dd .Fields (_bccbg );_cgdff :=make ([]float64 ,0,len (_ggadg ));for _ ,_eccf :=range _ggadg {_aagd ,_ :=_bb .ParseFloat (_eccf ,64);_cgdff =append (_cgdff ,_aagd );};return _cgdff ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_gbgg *TOC )SetLineSeparator (separator string ){_gbgg ._abdbb =separator };

// SetWidth sets the width of the ellipse.
func (_ebg *Ellipse )SetWidth (width float64 ){_ebg ._dgga =width };

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_edeeg *shading )SetAntiAlias (enable bool ){_edeeg ._gdfd =enable };

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_abg *Creator )AddPage (page *_bbd .PdfPage )error {_bgd ,_aff :=_abg .wrapPageIfNeeded (page );if _aff !=nil {return _aff ;};if _bgd !=nil {page =_bgd ;};_efbe ,_aff :=page .GetMediaBox ();if _aff !=nil {_ee .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_aff );
return _aff ;};_efbe .Normalize ();_adf ,_decf :=_efbe .Llx ,_efbe .Lly ;_aedd :=_efbe ;if _ggda :=page .CropBox ;_ggda !=nil &&*_ggda !=*_efbe {_ggda .Normalize ();_adf ,_decf =_ggda .Llx ,_ggda .Lly ;_aedd =_ggda ;};_bgcg :=_eb .IdentityMatrix ();_aeefb ,_aff :=page .GetRotate ();
if _aff !=nil {_ee .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_aff .Error ());
};_caee :=_aeefb %360!=0&&_aeefb %90==0;if _caee {_egab :=float64 ((360+_aeefb %360)%360);if _egab ==90{_bgcg =_bgcg .Translate (_aedd .Width (),0);}else if _egab ==180{_bgcg =_bgcg .Translate (_aedd .Width (),_aedd .Height ());}else if _egab ==270{_bgcg =_bgcg .Translate (0,_aedd .Height ());
};_bgcg =_bgcg .Mult (_eb .RotationMatrix (_egab *_bbg .Pi /180));_bgcg =_bgcg .Round (0.000001);_debc :=_daecc (_aedd ,_bgcg );_aedd =_debc ;_aedd .Normalize ();};if _adf !=0||_decf !=0{_bgcg =_eb .TranslationMatrix (_adf ,_decf ).Mult (_bgcg );};if !_bgcg .Identity (){_bgcg =_bgcg .Round (0.000001);
_abg ._dacbc [page ]=&pageTransformations {_aeef :&_bgcg };};_abg ._afgc =_aedd .Width ();_abg ._ebeb =_aedd .Height ();_abg .initContext ();_abg ._afbe =append (_abg ._afbe ,page );_abg ._ffdd .Page ++;return nil ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_bgeb *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _bgeb ._dgcf ==nil {if _gcaf :=_bgeb .makeXObject ();_gcaf !=nil {return nil ,ctx ,_gcaf ;};};var _ggbg []*Block ;_cabg :=ctx ;_fbff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _bgeb ._fgcd .IsRelative (){_bgeb .applyFitMode (ctx .Width );ctx .X +=_bgeb ._ecd .Left ;ctx .Y +=_bgeb ._ecd .Top ;ctx .Width -=_bgeb ._ecd .Left +_bgeb ._ecd .Right ;ctx .Height -=_bgeb ._ecd .Top +_bgeb ._ecd .Bottom ;if _bgeb ._bcec > ctx .Height {_ggbg =append (_ggbg ,_fbff );
_fbff =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gced :=ctx ;_gced .Y =ctx .Margins .Top +_bgeb ._ecd .Top ;_gced .X =ctx .Margins .Left +_bgeb ._ecd .Left ;_gced .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_bgeb ._ecd .Top -_bgeb ._ecd .Bottom ;
_gced .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bgeb ._ecd .Left -_bgeb ._ecd .Right ;ctx =_gced ;};}else {ctx .X =_bgeb ._agcca ;ctx .Y =_bgeb ._fgba ;};ctx ,_dafdf :=_dddg (_fbff ,_bgeb ,ctx );if _dafdf !=nil {return nil ,ctx ,_dafdf ;
};_ggbg =append (_ggbg ,_fbff );if _bgeb ._fgcd .IsAbsolute (){ctx =_cabg ;}else {ctx .X =_cabg .X ;ctx .Width =_cabg .Width ;ctx .Y +=_bgeb ._ecd .Bottom ;};return _ggbg ,ctx ,nil ;};func (_begeg *RadialShading )shadingModel ()*_bbd .PdfShadingType3 {_fbdcb ,_fcead ,_faefg :=_begeg ._daacc ._cfgfd .ToRGB ();
var _afea _gad .Point ;switch _begeg ._ceafc {case AnchorBottomLeft :_afea =_gad .Point {X :_begeg ._fcbd .Llx ,Y :_begeg ._fcbd .Lly };case AnchorBottomRight :_afea =_gad .Point {X :_begeg ._fcbd .Urx ,Y :_begeg ._fcbd .Ury -_begeg ._fcbd .Height ()};
case AnchorTopLeft :_afea =_gad .Point {X :_begeg ._fcbd .Llx ,Y :_begeg ._fcbd .Lly +_begeg ._fcbd .Height ()};case AnchorTopRight :_afea =_gad .Point {X :_begeg ._fcbd .Urx ,Y :_begeg ._fcbd .Ury };case AnchorLeft :_afea =_gad .Point {X :_begeg ._fcbd .Llx ,Y :_begeg ._fcbd .Lly +_begeg ._fcbd .Height ()/2};
case AnchorTop :_afea =_gad .Point {X :_begeg ._fcbd .Llx +_begeg ._fcbd .Width ()/2,Y :_begeg ._fcbd .Ury };case AnchorRight :_afea =_gad .Point {X :_begeg ._fcbd .Urx ,Y :_begeg ._fcbd .Lly +_begeg ._fcbd .Height ()/2};case AnchorBottom :_afea =_gad .Point {X :_begeg ._fcbd .Urx +_begeg ._fcbd .Width ()/2,Y :_begeg ._fcbd .Lly };
default:_afea =_gad .NewPoint (_begeg ._fcbd .Llx +_begeg ._fcbd .Width ()/2,_begeg ._fcbd .Lly +_begeg ._fcbd .Height ()/2);};_caabd :=_begeg ._bbac ;_fadba :=_begeg ._accge ;_fcdd :=_afea .X +_begeg ._eecda ;_ggbbe :=_afea .Y +_begeg ._dfagd ;if _caabd ==-1.0{_caabd =0.0;
};if _fadba ==-1.0{var _ddbcd []float64 ;_ggeag :=_bbg .Pow (_fcdd -_begeg ._fcbd .Llx ,2)+_bbg .Pow (_ggbbe -_begeg ._fcbd .Lly ,2);_ddbcd =append (_ddbcd ,_bbg .Abs (_ggeag ));_gcec :=_bbg .Pow (_fcdd -_begeg ._fcbd .Llx ,2)+_bbg .Pow (_begeg ._fcbd .Lly +_begeg ._fcbd .Height ()-_ggbbe ,2);
_ddbcd =append (_ddbcd ,_bbg .Abs (_gcec ));_febg :=_bbg .Pow (_begeg ._fcbd .Urx -_fcdd ,2)+_bbg .Pow (_ggbbe -_begeg ._fcbd .Ury -_begeg ._fcbd .Height (),2);_ddbcd =append (_ddbcd ,_bbg .Abs (_febg ));_baggd :=_bbg .Pow (_begeg ._fcbd .Urx -_fcdd ,2)+_bbg .Pow (_begeg ._fcbd .Ury -_ggbbe ,2);
_ddbcd =append (_ddbcd ,_bbg .Abs (_baggd ));_g .Slice (_ddbcd ,func (_cdff ,_ebeea int )bool {return _cdff > _ebeea });_fadba =_bbg .Sqrt (_ddbcd [0]);};_begaa :=&_bbd .PdfRectangle {Llx :_fcdd -_fadba ,Lly :_ggbbe -_fadba ,Urx :_fcdd +_fadba ,Ury :_ggbbe +_fadba };
_aecc :=_bbd .NewPdfShadingType3 ();_aecc .PdfShading .ShadingType =_bf .MakeInteger (3);_aecc .PdfShading .ColorSpace =_bbd .NewPdfColorspaceDeviceRGB ();_aecc .PdfShading .Background =_bf .MakeArrayFromFloats ([]float64 {_fbdcb ,_fcead ,_faefg });_aecc .PdfShading .BBox =_begaa ;
_aecc .PdfShading .AntiAlias =_bf .MakeBool (_begeg ._daacc ._gdfd );_aecc .Coords =_bf .MakeArrayFromFloats ([]float64 {_fcdd ,_ggbbe ,_caabd ,_fcdd ,_ggbbe ,_fadba });_aecc .Domain =_bf .MakeArrayFromFloats ([]float64 {0.0,1.0});_aecc .Extend =_bf .MakeArray (_bf .MakeBool (_begeg ._daacc ._aeaa [0]),_bf .MakeBool (_begeg ._daacc ._aeaa [1]));
_aecc .Function =_begeg ._daacc .generatePdfFunctions ();return _aecc ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fade *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcgfg :=ctx ;_gefb :=[]func (_fbdc DrawContext )([]*Block ,DrawContext ,error ){_fade .generateHeaderBlocks ,_fade .generateInformationBlocks ,_fade .generateLineBlocks ,_fade .generateTotalBlocks ,_fade .generateNoteBlocks };
var _cecg []*Block ;for _ ,_bgceb :=range _gefb {_gace ,_bfded ,_daag :=_bgceb (ctx );if _daag !=nil {return _cecg ,ctx ,_daag ;};if len (_cecg )==0{_cecg =_gace ;}else if len (_gace )> 0{_cecg [len (_cecg )-1].mergeBlocks (_gace [0]);_cecg =append (_cecg ,_gace [1:]...);
};ctx =_bfded ;};if _fade ._gfgg .IsRelative (){ctx .X =_dcgfg .X ;};if _fade ._gfgg .IsAbsolute (){return _cecg ,_dcgfg ,nil ;};return _cecg ,ctx ,nil ;};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_daacc *shading ;_fcbd *_bbd .PdfRectangle ;_ceafc AnchorPoint ;_eecda float64 ;_dfagd float64 ;_bbac float64 ;_accge float64 ;};

// Height returns the height of the line.
func (_fgeg *Line )Height ()float64 {_dffgf :=_fgeg ._fffb ;if _fgeg ._fcgb ==_fgeg ._eefg {_dffgf /=2;};return _bbg .Abs (_fgeg ._bfbgf -_fgeg ._aeea )+_dffgf ;};func (_eaefd *StyledParagraph )split (_aedab DrawContext )(_ecac ,_efefa *StyledParagraph ,_bedc error ){if _bedc =_eaefd .wrapChunks (false );
_bedc !=nil {return nil ,nil ,_bedc ;};if len (_eaefd ._gegeg )==1&&_eaefd ._dedbc > _aedab .Height {return _eaefd ,nil ,nil ;};_adccb :=func (_bfac []*TextChunk ,_dgcg []*TextChunk )[]*TextChunk {if len (_dgcg )==0{return _bfac ;};_efde :=len (_bfac );
if _efde ==0{return append (_bfac ,_dgcg ...);};if _bfac [_efde -1].Style ==_dgcg [0].Style {_bfac [_efde -1].Text +=_dgcg [0].Text ;}else {_bfac =append (_bfac ,_dgcg [0]);};return append (_bfac ,_dgcg [1:]...);};_abgf :=func (_eggb *StyledParagraph ,_eebea []*TextChunk )*StyledParagraph {if len (_eebea )==0{return nil ;
};_fdffg :=*_eggb ;_fdffg ._gacc =_eebea ;return &_fdffg ;};var (_aefgg float64 ;_fccbd []*TextChunk ;_fgcde []*TextChunk ;);for _ ,_dgfb :=range _eaefd ._gegeg {var _eecdg float64 ;_ggcb :=make ([]*TextChunk ,0,len (_dgfb ));for _ ,_bceb :=range _dgfb {if _fdfb :=_bceb .Style .FontSize ;
_fdfb > _eecdg {_eecdg =_fdfb ;};_ggcb =append (_ggcb ,_bceb .clone ());};_eecdg *=_eaefd ._dedbc ;if _eaefd ._dageg .IsRelative (){if _aefgg +_eecdg > _aedab .Height {_fgcde =_adccb (_fgcde ,_ggcb );}else {_fccbd =_adccb (_fccbd ,_ggcb );};};_aefgg +=_eecdg ;
};_eaefd ._gegeg =nil ;if len (_fgcde )==0{return _eaefd ,nil ,nil ;};return _abgf (_eaefd ,_fccbd ),_abgf (_eaefd ,_fgcde ),nil ;};func (_cbbcf *templateProcessor )parseFloatAttr (_bffbe ,_aedbg string )float64 {_ee .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_bffbe ,_aedbg );
_beaec ,_ :=_bb .ParseFloat (_aedbg ,64);return _beaec ;};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_bebd *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bebd ._babe .Left ,_bebd ._babe .Right ,_bebd ._babe .Top ,_bebd ._babe .Bottom ;};func (_fcdfe *templateProcessor )parseLinkAttr (_cagb ,_eaccb string )*_bbd .PdfAnnotation {_eaccb =_dd .TrimSpace (_eaccb );
if _dd .HasPrefix (_eaccb ,"\u0075\u0072\u006c(\u0027")&&_dd .HasSuffix (_eaccb ,"\u0027\u0029")&&len (_eaccb )> 7{return _eebfg (_eaccb [5:len (_eaccb )-2]);};if _dd .HasPrefix (_eaccb ,"\u0070\u0061\u0067e\u0028")&&_dd .HasSuffix (_eaccb ,"\u0029")&&len (_eaccb )> 6{var (_ddddf error ;
_edbgf int64 ;_ggefa float64 ;_baad float64 ;_ggbge =1.0;_ggagg =_dd .Split (_eaccb [5:len (_eaccb )-1],"\u002c"););_edbgf ,_ddddf =_bb .ParseInt (_dd .TrimSpace (_ggagg [0]),10,64);if _ddddf !=nil {_ee .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ddddf );
return nil ;};if len (_ggagg )>=2{_ggefa ,_ddddf =_bb .ParseFloat (_dd .TrimSpace (_ggagg [1]),64);if _ddddf !=nil {_ee .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0058\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ddddf );
return nil ;};};if len (_ggagg )>=3{_baad ,_ddddf =_bb .ParseFloat (_dd .TrimSpace (_ggagg [2]),64);if _ddddf !=nil {_ee .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0059\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ddddf );
return nil ;};};if len (_ggagg )>=4{_ggbge ,_ddddf =_bb .ParseFloat (_dd .TrimSpace (_ggagg [3]),64);if _ddddf !=nil {_ee .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u007a\u006f\u006f\u006d\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u003a\u0020\u0025\u0076",_ddddf );
return nil ;};};return _cagc (_edbgf -1,_ggefa ,_baad ,_ggbge );};return nil ;};func (_gcdg *templateProcessor )parseFitModeAttr (_egdb ,_dcgb string )FitMode {_ee .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_egdb ,_dcgb );
_fcabg :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_dcgb ];return _fcabg ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;
CellVerticalAlignmentBottom ;);

// SetBorderOpacity sets the border opacity.
func (_gadde *Polygon )SetBorderOpacity (opacity float64 ){_gadde ._fbeb =opacity };

// SetInline sets the inline mode of the division.
func (_cfac *Division )SetInline (inline bool ){_cfac ._abgc =inline };

// Notes returns the notes section of the invoice as a title-content pair.
func (_dgag *Invoice )Notes ()(string ,string ){return _dgag ._eccg [0],_dgag ._eccg [1]};

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _efbee (svgStr )};func (_gca *Block )addContentsByString (_ffe string )error {_gge :=_da .NewContentStreamParser (_ffe );_ecc ,_fdac :=_gge .Parse ();if _fdac !=nil {return _fdac ;
};_gca ._ec .WrapIfNeeded ();_ecc .WrapIfNeeded ();*_gca ._ec =append (*_gca ._ec ,*_ecc ...);return nil ;};func _fbg (_fefbe TextStyle )*List {return &List {_cafc :TextChunk {Text :"\u2022\u0020",Style :_fefbe },_eaef :0,_cbeab :true ,_egfd :PositionRelative ,_ddbae :_fefbe };
};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_cgab *Division )SetMargins (left ,right ,top ,bottom float64 ){_cgab ._ggea .Left =left ;_cgab ._ggea .Right =right ;_cgab ._ggea .Top =top ;_cgab ._ggea .Bottom =bottom ;};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_egaa *Ellipse )FillOpacity ()float64 {return _egaa ._bcgab };

// MoveY moves the drawing context to absolute position y.
func (_cec *Creator )MoveY (y float64 ){_cec ._ffdd .Y =y };

// Crop crops the Image to the specified bounds.
func (_adeb *Image )Crop (x0 ,y0 ,x1 ,y1 int ){_fccg ,_aggaec :=_adeb ._dcce .ToGoImage ();if _aggaec !=nil {_d .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0074o\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_aggaec );
};var _eaaff _ab .Image ;_efef :=_ab .Rect (x0 ,y0 ,x1 ,y1 );if _afgg :=_efef .Intersect (_fccg .Bounds ());!_efef .Empty (){_dade :=_ab .NewRGBA (_ab .Rect (0,0,_efef .Dx (),_efef .Dy ()));for _caba :=_afgg .Min .Y ;_caba < _afgg .Max .Y ;_caba ++{for _fea :=_afgg .Min .X ;
_fea < _afgg .Max .X ;_fea ++{_dade .Set (_fea -_afgg .Min .X ,_caba -_afgg .Min .Y ,_fccg .At (_fea ,_caba ));};};_eaaff =_dade ;}else {_eaaff =&_ab .RGBA {};};_gccae ,_aggaec :=_bbd .ImageHandling .NewImageFromGoImage (_eaaff );if _aggaec !=nil {_d .Fatalf ("\u0045\u0072\u0072\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0066\u0072\u006fm\u0020\u0047\u006f\u0020\u0049m\u0061\u0067e\u003a\u0020\u0025\u0076",_aggaec );
};_bacc :=float64 (_gccae .Width );_gdfa :=float64 (_gccae .Height );_adeb ._dcce =_gccae ;_adeb ._accbf =_bacc ;_adeb ._cdad =_gdfa ;_adeb ._bfdf =_bacc ;_adeb ._bcec =_gdfa ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_cabgc *TOCLine )LevelOffset ()float64 {return _cabgc ._ebadg };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_gbaab *Invoice )TotalLines ()[][2]*InvoiceCell {_bcgcb :=[][2]*InvoiceCell {_gbaab ._ffda };_bcgcb =append (_bcgcb ,_gbaab ._bgebb ...);return append (_bcgcb ,_gbaab ._eegf );};

// SetStyle sets the style of the line (solid or dashed).
func (_bdab *Line )SetStyle (style _gad .LineStyle ){_bdab ._dedd =style };

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_fgdcd *Rectangle )SetCoords (x ,y float64 ){_fgdcd ._bgcbe =x ;_fgdcd ._aagb =y };type componentRenderer interface{Draw (_afdgf Drawable )error ;};func (_fbaa *templateProcessor )parseChart (_dedf *templateNode )(interface{},error ){var _abbg string ;
for _ ,_gfedc :=range _dedf ._ebeg .Attr {_fcgfe :=_gfedc .Value ;switch _caedf :=_gfedc .Name .Local ;_caedf {case "\u0073\u0072\u0063":_abbg =_fcgfe ;};};if _abbg ==""{_fbaa .nodeLogError (_dedf ,"\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_ecfd ;};_dgec ,_gacd :=_fbaa ._afgef .ChartMap [_abbg ];if !_gacd {_fbaa .nodeLogError (_dedf ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_abbg );
return nil ,_ecfd ;};_aedfg :=NewChart (_dgec );for _ ,_cfdaa :=range _dedf ._ebeg .Attr {_aeffa :=_cfdaa .Value ;switch _bade :=_cfdaa .Name .Local ;_bade {case "\u0078":_aedfg .SetPos (_fbaa .parseFloatAttr (_bade ,_aeffa ),_aedfg ._ecfb );case "\u0079":_aedfg .SetPos (_aedfg ._bdaf ,_fbaa .parseFloatAttr (_bade ,_aeffa ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_fbgbg :=_fbaa .parseMarginAttr (_bade ,_aeffa );_aedfg .SetMargins (_fbgbg .Left ,_fbgbg .Right ,_fbgbg .Top ,_fbgbg .Bottom );case "\u0077\u0069\u0064t\u0068":_aedfg ._eebf .SetWidth (int (_fbaa .parseFloatAttr (_bade ,_aeffa )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_aedfg ._eebf .SetHeight (int (_fbaa .parseFloatAttr (_bade ,_aeffa )));case "\u0073\u0072\u0063":break ;default:_fbaa .nodeLogDebug (_dedf ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_bade );
};};return _aedfg ,nil ;};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_dfbg *Ellipse )SetFitMode (fitMode FitMode ){_dfbg ._aacb =fitMode };

// Invoice represents a configurable invoice template.
type Invoice struct{_aabb string ;_dcbc *Image ;_ecff *InvoiceAddress ;_bege *InvoiceAddress ;_bbee string ;_aca [2]*InvoiceCell ;_cadc [2]*InvoiceCell ;_cdfc [2]*InvoiceCell ;_geaa [][2]*InvoiceCell ;_agbb []*InvoiceCell ;_gddbf [][]*InvoiceCell ;_ffda [2]*InvoiceCell ;
_eegf [2]*InvoiceCell ;_bgebb [][2]*InvoiceCell ;_eccg [2]string ;_caeed [2]string ;_gbae [][2]string ;_faeg TextStyle ;_bdag TextStyle ;_dccef TextStyle ;_dbbe TextStyle ;_abf TextStyle ;_ddbe TextStyle ;_ccfb TextStyle ;_babf InvoiceCellProps ;_edga InvoiceCellProps ;
_ecaa InvoiceCellProps ;_aefg InvoiceCellProps ;_gfgg Positioning ;};func (_cfafe *Table )getLastCellFromCol (_cfaed int )(int ,*TableCell ){for _fcddf :=len (_cfafe ._gggdf )-1;_fcddf >=0;_fcddf --{if _cfafe ._gggdf [_fcddf ]._aeec ==_cfaed {return _fcddf ,_cfafe ._gggdf [_fcddf ];
};};return 0,nil ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_fggcd *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _fggcd ._fcgb ,_fggcd ._aeea ,_fggcd ._eefg ,_fggcd ._bfbgf ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_caca *Table )SetPos (x ,y float64 ){_caca ._ffdf =PositionAbsolute ;_caca ._dcfa =x ;_caca ._fdacc =y ;};

// SetLevel sets the indentation level of the TOC line.
func (_acgca *TOCLine )SetLevel (level uint ){_acgca ._fffag =level ;_acgca ._ebca ._dadf .Left =_acgca ._ggcac +float64 (_acgca ._fffag -1)*_acgca ._ebadg ;};func (_dba *Block )mergeBlocks (_aee *Block )error {_ace :=_dec (_dba ._ec ,_dba ._ce ,_aee ._ec ,_aee ._ce );
if _ace !=nil {return _ace ;};for _ ,_bgc :=range _aee ._cb {_dba .AddAnnotation (_bgc );};return nil ;};

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_dfde *Rectangle )Width ()float64 {return _dfde ._cdagc };func (_baebe *templateProcessor )processGradientColorPair (_acab []string )(_cfcbd []Color ,_bead []float64 ){for _ ,_decfb :=range _acab {var (_agbade =_dd .Fields (_decfb );_edeec =len (_agbade );
);if _edeec ==0{continue ;};_egdab :="";if _edeec > 1{_egdab =_dd .TrimSpace (_agbade [1]);};_ebgc :=-1.0;if _dd .HasSuffix (_egdab ,"\u0025"){_aadg ,_ccdee :=_bb .ParseFloat (_egdab [:len (_egdab )-1],64);if _ccdee !=nil {_ee .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0069n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076",_ccdee );
};_ebgc =_aadg /100.0;};_baabd :=_baebe .parseColor (_dd .TrimSpace (_agbade [0]));if _baabd !=nil {_cfcbd =append (_cfcbd ,_baabd );_bead =append (_bead ,_ebgc );};};if len (_cfcbd )!=len (_bead ){_ee .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u006c\u0069\u006e\u0065\u0061\u0072\u0020\u0067\u0072\u0061\u0064i\u0065\u006e\u0074\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0064\u0065\u0066\u0069\u006e\u0069\u0074\u0069\u006f\u006e\u0021");
return nil ,nil ;};_edaag :=-1;_eccfa :=0.0;for _egga ,_gbga :=range _bead {if _gbga ==-1.0{if _egga ==0{_gbga =0.0;_bead [_egga ]=0.0;continue ;};_edaag ++;if _egga < len (_bead )-1{continue ;}else {_gbga =1.0;_bead [_egga ]=1.0;};};_cdbgd :=_edaag +1;
for _bface :=_egga -_edaag ;_bface < _egga ;_bface ++{_bead [_bface ]=_eccfa +(float64 (_bface )*(_gbga -_eccfa )/float64 (_cdbgd ));};_eccfa =_gbga ;_edaag =-1;};return _cfcbd ,_bead ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fddgb *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acfa :=ctx ;_gccec ,ctx ,_abbgb :=_fddgb ._efaae .GeneratePageBlocks (ctx );if _abbgb !=nil {return _gccec ,ctx ,_abbgb ;};for _ ,_fcdcc :=range _fddgb ._dcbb {_bcfdd :=_fcdcc ._bgge ;
if !_fddgb ._fbfca {_fcdcc ._bgge =0;};_adba ,_bddbd ,_daggd :=_fcdcc .GeneratePageBlocks (ctx );_fcdcc ._bgge =_bcfdd ;if _daggd !=nil {return _gccec ,ctx ,_daggd ;};if len (_adba )< 1{continue ;};_gccec [len (_gccec )-1].mergeBlocks (_adba [0]);_gccec =append (_gccec ,_adba [1:]...);
ctx =_bddbd ;};if _fddgb ._cgcad .IsRelative (){ctx .X =_acfa .X ;};if _fddgb ._cgcad .IsAbsolute (){return _gccec ,_acfa ,nil ;};return _gccec ,ctx ,nil ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_egbf *Image )ScaleToWidth (w float64 ){_bcce :=_egbf ._bcec /_egbf ._bfdf ;_egbf ._bfdf =w ;_egbf ._bcec =w *_bcce ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_fegag :_bbg .Max (_bbg .Min (c ,1.0),0.0),_acbg :_bbg .Max (_bbg .Min (m ,1.0),0.0),_aggdc :_bbg .Max (_bbg .Min (y ,1.0),0.0),_dfag :_bbg .Max (_bbg .Min (k ,1.0),0.0)};};const (PositionRelative Positioning =iota ;
PositionAbsolute ;);

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_cba *_gad .CurvePolygon ;_eedg float64 ;_dggg float64 ;_fgcaa Color ;};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_cbbb *Ellipse )SetPositioning (position Positioning ){_cbbb ._cafbc =position };

// SetDueDate sets the due date of the invoice.
func (_gbcf *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_gbcf ._cdfc [1].Value =dueDate ;return _gbcf ._cdfc [0],_gbcf ._cdfc [1];};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;func (_egcc *shading )generatePdfFunctions ()[]_bbd .PdfFunction {if len (_egcc ._eeee )==0{return nil ;}else if len (_egcc ._eeee )<=2{_fdfg ,_fecd ,_bfbfc :=_egcc ._eeee [0]._fgce .ToRGB ();_ecdb ,_gdgg ,_afge :=_egcc ._eeee [len (_egcc ._eeee )-1]._fgce .ToRGB ();
return []_bbd .PdfFunction {&_bbd .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_fdfg ,_fecd ,_bfbfc },C1 :[]float64 {_ecdb ,_gdgg ,_afge }}};}else {_becc :=[]_bbd .PdfFunction {};_fbgg :=[]float64 {};
for _abba :=0;_abba < len (_egcc ._eeee )-1;_abba ++{_aedg ,_egeg ,_ccab :=_egcc ._eeee [_abba ]._fgce .ToRGB ();_dfcf ,_cgbca ,_ebbab :=_egcc ._eeee [_abba +1]._fgce .ToRGB ();_fegea :=&_bbd .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_aedg ,_egeg ,_ccab },C1 :[]float64 {_dfcf ,_cgbca ,_ebbab }};
_becc =append (_becc ,_fegea );if _abba > 0{_fbgg =append (_fbgg ,_egcc ._eeee [_abba ]._gabg );};};_ccgff :=[]float64 {};for range _becc {_ccgff =append (_ccgff ,[]float64 {0.0,1.0}...);};return []_bbd .PdfFunction {&_bbd .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_becc ,Bounds :_fbgg ,Encode :_ccgff }};
};};

// SetPositioning sets the positioning of the line (absolute or relative).
func (_ffcf *Line )SetPositioning (positioning Positioning ){_ffcf ._dabg =positioning };func _acbga (_gecde *templateProcessor ,_cafdb *templateNode )(interface{},error ){return _gecde .parseChapterHeading (_cafdb );};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_cbf *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_ecgd *_bbd .PdfWriter )error ){_cbf ._cfdb =pdfWriterAccessFunc ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_efbad *FilledCurve )AppendCurve (curve _gad .CubicBezierCurve )*FilledCurve {_efbad ._dbca =append (_efbad ._dbca ,curve );return _efbad ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_eca int ;_feb string ;_fgef *Paragraph ;_gba []Drawable ;_gfg int ;_ffef bool ;_efb bool ;_cfb Positioning ;_egf ,_gde float64 ;_cee Margins ;_bcd *Chapter ;_abc *TOC ;_babb *_bbd .Outline ;_gce *_bbd .OutlineItem ;_ddf uint ;};

// Link returns link information for this line.
func (_ebgbd *TOCLine )Link ()(_cagce int64 ,_geeg ,_bdgae float64 ){return _ebgbd ._bgge ,_ebgbd ._fggb ,_ebgbd ._bdeg ;};

// SetBorderColor sets the border color for the path.
func (_faec *FilledCurve )SetBorderColor (color Color ){_faec ._badb =color };

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_fbccg *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fbccg ._caegfd .Left ,_fbccg ._caegfd .Right ,_fbccg ._caegfd .Top ,_fbccg ._caegfd .Bottom ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_ebee *Creator )NewChapter (title string )*Chapter {_ebee ._cbga ++;_gebca :=_ebee .NewTextStyle ();_gebca .FontSize =16;return _dfea (nil ,_ebee ._ggab ,_ebee ._cda ,title ,_ebee ._cbga ,_gebca );};func _eefe (_ccge string ,_dggcg bool )string {_cgfa :=_ccge ;
if _cgfa ==""{return "";};_gbbcb :=_c .Paragraph {};_ ,_gcfgd :=_gbbcb .SetString (_ccge );if _gcfgd !=nil {return _cgfa ;};_dafccf ,_gcfgd :=_gbbcb .Order ();if _gcfgd !=nil {return _cgfa ;};_afbc :=_dafccf .NumRuns ();_bdgg :=make ([]string ,_afbc );
for _gdgcc :=0;_gdgcc < _dafccf .NumRuns ();_gdgcc ++{_aeada :=_dafccf .Run (_gdgcc );_begegf :=_aeada .String ();if _aeada .Direction ()==_c .RightToLeft {_begegf =_c .ReverseString (_begegf );};if _dggcg {_bdgg [_gdgcc ]=_begegf ;}else {_bdgg [_afbc -1]=_begegf ;
};_afbc --;};if len (_bdgg )!=_dafccf .NumRuns (){return _ccge ;};_cgfa =_dd .Join (_bdgg ,"");return _cgfa ;};func _ffcfb (_egdec *_bbd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_egdec ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};type rgbColor struct{_eage ,_eaee ,_gfe float64 };

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_bcca *Line )Width ()float64 {return _bbg .Abs (_bcca ._eefg -_bcca ._fcgb )};

// Scale scales the ellipse dimensions by the specified factors.
func (_ebab *Ellipse )Scale (xFactor ,yFactor float64 ){_ebab ._dgga =xFactor *_ebab ._dgga ;_ebab ._dgdg =yFactor *_ebab ._dgdg ;};

// FitMode returns the fit mode of the image.
func (_gfef *Image )FitMode ()FitMode {return _gfef ._gfeea };type cmykColor struct{_fegag ,_acbg ,_aggdc ,_dfag float64 };

// SetFillColor sets the fill color for the path.
func (_cfbg *FilledCurve )SetFillColor (color Color ){_cfbg ._dcabf =color };

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_ebcdg *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_ebcdg ._gdbdg =alignment };

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//
//	red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_fegag :_bbg .Min (float64 (c ),100)/100.0,_acbg :_bbg .Min (float64 (m ),100)/100.0,_aggdc :_bbg .Min (float64 (y ),100)/100.0,_dfag :_bbg .Min (float64 (k ),100)/100.0};};

// GeneratePageBlocks generates a page break block.
func (_fbba *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fgbg :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_dcag :=ctx ;_dcag .Y =ctx .Margins .Top ;
_dcag .X =ctx .Margins .Left ;_dcag .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_dcag .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_dcag ;return _fgbg ,ctx ,nil ;};func (_daccc *StyledParagraph )getLineMetrics (_fcdb int )(_dagac ,_eddc ,_bcgfe float64 ){if _daccc ._gegeg ==nil ||len (_daccc ._gegeg )==0{_daccc .wrapText ();
};if _fcdb < 0||_fcdb > len (_daccc ._gegeg )-1{_ee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_fcdb );
return 0,0,0;};_gaced :=_daccc ._gegeg [_fcdb ];for _ ,_bcbf :=range _gaced {_baaea :=_dfcfd (_bcbf .Style .Font ,_bcbf .Style .FontSize );if _baaea ._acdff > _dagac {_dagac =_baaea ._acdff ;};if _baaea ._fbbdb < _bcgfe {_bcgfe =_baaea ._fbbdb ;};if _gfcb :=_bcbf .Style .FontSize ;
_gfcb > _eddc {_eddc =_gfcb ;};};return _dagac ,_eddc ,_bcgfe ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_adab *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_fffc *Invoice )SetColumns (cols []*InvoiceCell ){_fffc ._agbb =cols };func (_ffbee *templateProcessor )parseCellVerticalAlignmentAttr (_fffbd ,_gdec string )CellVerticalAlignment {_ee .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fffbd ,_gdec );
_dfbff :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_gdec ];return _dfbff ;};


// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_daad *Creator )Flip (flipH ,flipV bool )error {_fbcc :=_daad .getActivePage ();if _fbcc ==nil {return _ge .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_ddbf ,_gcf :=_daad ._dacbc [_fbcc ];if !_gcf {_ddbf =&pageTransformations {};
_daad ._dacbc [_fbcc ]=_ddbf ;};_ddbf ._eacc =flipH ;_ddbf ._ebbg =flipV ;return nil ;};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_fcf *Ellipse )ScaleToWidth (w float64 ){_gcff :=_fcf ._dgdg /_fcf ._dgga ;_fcf ._dgga =w ;_fcf ._dgdg =w *_gcff ;};func (_ccgad *templateProcessor )parsePositioningAttr (_ceba ,_eecbc string )Positioning {_ee .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ceba ,_eecbc );
_fbafb :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_eecbc ];return _fbafb ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetMargins sets the Paragraph's margins.
func (_acebd *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_acebd ._dadf .Left =left ;_acebd ._dadf .Right =right ;_acebd ._dadf .Top =top ;_acebd ._dadf .Bottom =bottom ;};

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_gfac *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _eeeec (x ,y ,innerRadius ,outerRadius ,colorPoints );};func _geeef (_dbeae *templateProcessor ,_eedfc *templateNode )(interface{},error ){return _dbeae .parseListItem (_eedfc );
};func (_ceee *Creator )initContext (){_ceee ._ffdd .X =_ceee ._gbf .Left ;_ceee ._ffdd .Y =_ceee ._gbf .Top ;_ceee ._ffdd .Width =_ceee ._afgc -_ceee ._gbf .Right -_ceee ._gbf .Left ;_ceee ._ffdd .Height =_ceee ._ebeb -_ceee ._gbf .Bottom -_ceee ._gbf .Top ;
_ceee ._ffdd .PageHeight =_ceee ._ebeb ;_ceee ._ffdd .PageWidth =_ceee ._afgc ;_ceee ._ffdd .Margins =_ceee ._gbf ;_ceee ._ffdd ._bdbc =_ceee .UnsupportedCharacterReplacement ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_adec *Invoice )NoteStyle ()TextStyle {return _adec ._ddbe };

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_eacec *LinearShading )AddPatternResource (block *Block )(_dfee _bf .PdfObjectName ,_eedf error ){_ceag :=1;_baee :=_bf .PdfObjectName ("\u0050"+_bb .Itoa (_ceag ));for block ._ce .HasPatternByName (_baee ){_ceag ++;_baee =_bf .PdfObjectName ("\u0050"+_bb .Itoa (_ceag ));
};if _bgeeb :=block ._ce .SetPatternByName (_baee ,_eacec .ToPdfShadingPattern ().ToPdfObject ());_bgeeb !=nil {return "",_bgeeb ;};return _baee ,nil ;};

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_bccf *Ellipse )GetCoords ()(float64 ,float64 ){return _bccf ._cfga ,_bccf ._adcc };type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// CurCol returns the currently active cell's column number.
func (_dcafag *Table )CurCol ()int {_dafb :=(_dcafag ._dace -1)%(_dcafag ._efbf )+1;return _dafb };

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_ecfce *Creator )MoveTo (x ,y float64 ){_ecfce ._ffdd .X =x ;_ecfce ._ffdd .Y =y };func (_ecdbf *templateProcessor )nodeError (_ddbfe *templateNode ,_dcaec string ,_adbc ...interface{})error {return _b .Errorf (_ecdbf .getNodeErrorLocation (_ddbfe ,_dcaec ,_adbc ...));
};

// SetFillColor sets the fill color of the rectangle.
func (_bcba *Rectangle )SetFillColor (col Color ){_bcba ._eade =col };

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _ddge (path )};

// WriteToFile writes the Creator output to file specified by path.
func (_fdgf *Creator )WriteToFile (outputPath string )error {_ccdf ,_cddc :=_a .Create (outputPath );if _cddc !=nil {return _cddc ;};defer _ccdf .Close ();return _fdgf .Write (_ccdf );};

// SetBorderWidth sets the border width.
func (_eddd *Polygon )SetBorderWidth (borderWidth float64 ){_eddd ._bbbe .BorderWidth =borderWidth };func _ddfd (_gbba _ab .Image )(*Image ,error ){_dgcdf ,_eccd :=_bbd .ImageHandling .NewImageFromGoImage (_gbba );if _eccd !=nil {return nil ,_eccd ;};return _eggc (_dgcdf );
};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_dadgb *TOC )SetHeading (text string ,style TextStyle ){_fgfaa :=_dadgb .Heading ();_fgfaa .Reset ();_aegeb :=_fgfaa .Append (text );_aegeb .Style =style ;};

// NewDivision returns a new Division container component.
func (_cgg *Creator )NewDivision ()*Division {return _cebc ()};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ead :=&Block {};_ead ._ec =&_da .ContentStreamOperations {};_ead ._ce =_bbd .NewPdfPageResources ();_ead ._eg =width ;_ead ._gg =height ;return _ead ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_cebg *StyledParagraph )SetText (text string )*TextChunk {_cebg .Reset ();return _cebg .Append (text );};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_cggc *Image )ScaleToHeight (h float64 ){_caff :=_cggc ._bfdf /_cggc ._bcec ;_cggc ._bcec =h ;_cggc ._bfdf =h *_caff ;};

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_gbee *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_gbee ._caegfd .Left =left ;_gbee ._caegfd .Right =right ;_gbee ._caegfd .Top =top ;_gbee ._caegfd .Bottom =bottom ;};func _geafg (_cfge *_bbd .PdfAnnotation )*_bbd .PdfAnnotation {if _cfge ==nil {return nil ;
};var _ggcae *_bbd .PdfAnnotation ;switch _cgaa :=_cfge .GetContext ().(type ){case *_bbd .PdfAnnotationLink :if _acgc :=_ggee (_cgaa );_acgc !=nil {_ggcae =_acgc .PdfAnnotation ;};};return _ggcae ;};

// Logo returns the logo of the invoice.
func (_egeag *Invoice )Logo ()*Image {return _egeag ._dcbc };

// SetAngle sets Image rotation angle in degrees.
func (_gabe *Image )SetAngle (angle float64 ){_gabe ._bbed =angle };

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_faae *Invoice )InfoLines ()[][2]*InvoiceCell {_gdddf :=[][2]*InvoiceCell {_faae ._aca ,_faae ._cadc ,_faae ._cdfc };return append (_gdddf ,_faae ._geaa ...);};func (_cgeac *StyledParagraph )appendChunk (_debb *TextChunk )*TextChunk {_cgeac ._gacc =append (_cgeac ._gacc ,_debb );
_cgeac .wrapText ();return _debb ;};

// SetBorderWidth sets the border width.
func (_afbg *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_afbg ._cgbc .BorderWidth =borderWidth ;};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;func _baa (_fcg string )string {_aaf :=_bbdf .FindAllString (_fcg ,-1);if len (_aaf )==0{_fcg =_fcg +"\u0030";}else {_edef ,_dbcg :=_bb .Atoi (_aaf [len (_aaf )-1]);if _dbcg !=nil {_ee .Log .Debug ("\u0045r\u0072\u006f\u0072 \u0063\u006f\u006ev\u0065rt\u0069\u006e\u0067\u0020\u0064\u0069\u0067i\u0074\u0020\u0063\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0069\u006e\u0020\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0073\u0020\u006e\u0061\u006de,\u0020f\u0061\u006c\u006c\u0062\u0061\u0063k\u0020\u0074\u006f\u0020\u0062a\u0073\u0069\u0063\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u003a \u0025\u0076",_dbcg );
_fcg =_fcg +"\u0030";}else {_edef ++;_fbc :=_dd .LastIndex (_fcg ,_aaf [len (_aaf )-1]);if _fbc ==-1{_fcg =_b .Sprintf ("\u0025\u0073\u0025\u0064",_fcg [:len (_fcg )-1],_edef );}else {_fcg =_fcg [:_fbc ]+_bb .Itoa (_edef );};};};return _fcg ;};func (_fbgd *TOCLine )getLineLink ()*_bbd .PdfAnnotation {if _fbgd ._bgge <=0{return nil ;
};return _cagc (_fbgd ._bgge -1,_fbgd ._fggb ,_fbgd ._bdeg ,0);};

// Height returns the total height of all rows.
func (_fbggd *Table )Height ()float64 {_daff :=float64 (0.0);for _ ,_fdfa :=range _fbggd ._abaa {_daff +=_fdfa ;};return _daff ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_bccc *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_bccc ._dcbb =append (_bccc ._dcbb ,line );return line ;};

// Width returns the width of the Paragraph.
func (_dcef *Paragraph )Width ()float64 {if _dcef ._bacce &&int (_dcef ._cfedb )> 0{return _dcef ._cfedb ;};return _dcef .getTextWidth ()/1000.0;};

// SetMargins sets the Paragraph's margins.
func (_dgfgb *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_dgfgb ._ggfad .Left =left ;_dgfgb ._ggfad .Right =right ;_dgfgb ._ggfad .Top =top ;_dgfgb ._ggfad .Bottom =bottom ;};

// Width returns the width of the ellipse.
func (_gcbf *Ellipse )Width ()float64 {return _gcbf ._dgga };

// SetWidth sets the width of the rectangle.
func (_begc *Rectangle )SetWidth (width float64 ){_begc ._cdagc =width };func (_cgfcfg *templateProcessor )parseDivision (_bage *templateNode )(interface{},error ){_adgaaf :=_cgfcfg .creator .NewDivision ();for _ ,_defbf :=range _bage ._ebeg .Attr {_abed :=_defbf .Value ;
switch _bgcba :=_defbf .Name .Local ;_bgcba {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_adgaaf .EnablePageWrap (_cgfcfg .parseBoolAttr (_bgcba ,_abed ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cgga :=_cgfcfg .parseMarginAttr (_bgcba ,_abed );
_adgaaf .SetMargins (_cgga .Left ,_cgga .Right ,_cgga .Top ,_cgga .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_dcfc :=_cgfcfg .parseMarginAttr (_bgcba ,_abed );_adgaaf .SetPadding (_dcfc .Left ,_dcfc .Right ,_dcfc .Top ,_dcfc .Bottom );default:_cgfcfg .nodeLogDebug (_bage ,"U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_bgcba );
};};return _adgaaf ,nil ;};type border struct{_dgf float64 ;_fcb float64 ;_fce float64 ;_cg float64 ;_cfd Color ;_fcc Color ;_dafd float64 ;_ege Color ;_bca float64 ;_dfe Color ;_dbf float64 ;_cdc Color ;_eeb float64 ;LineStyle _gad .LineStyle ;_ccf CellBorderStyle ;
_aadc CellBorderStyle ;_ggg CellBorderStyle ;_gec CellBorderStyle ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// NewCellProps returns the default properties of an invoice cell.
func (_gdbb *Invoice )NewCellProps ()InvoiceCellProps {_dcdc :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_gdbb ._faeg ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_dcdc ,BorderColor :_dcdc ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// SetTitleStyle sets the style properties of the invoice title.
func (_ffce *Invoice )SetTitleStyle (style TextStyle ){_ffce ._dccef =style };

// Opacity returns the opacity of the line.
func (_deac *Line )Opacity ()float64 {return _deac ._ffbdb };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_bgcbe float64 ;_aagb float64 ;_cdagc float64 ;_ddbcg float64 ;_efee Positioning ;_eade Color ;_fbcfb float64 ;_acbae Color ;_egdc float64 ;_cegge float64 ;_bfbf float64 ;_gefff float64 ;_fgegb float64 ;_bcfag float64 ;_caegfd Margins ;
_dgba FitMode ;};

// GetOptimizer returns current PDF optimizer.
func (_fcca *Creator )GetOptimizer ()_bbd .Optimizer {return _fcca ._eadg };

// NewTOC creates a new table of contents.
func (_agbc *Creator )NewTOC (title string )*TOC {_gcgg :=_agbc .NewTextStyle ();_gcgg .Font =_agbc ._dggc ;return _cdgbb (title ,_agbc .NewTextStyle (),_gcgg );};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_gdege *_bbd .PdfAnnotation ;_daadb bool ;

// The vertical alignment of the text chunk.
VerticalAlignment TextVerticalAlignment ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_eeeb *LinearShading )ToPdfShadingPattern ()*_bbd .PdfShadingPatternType2 {_ffgdg ,_fgaeg ,_adbd :=_eeeb ._ebade ._cfgfd .ToRGB ();_cegc :=_eeeb .shadingModel ();_cegc .PdfShading .Background =_bf .MakeArrayFromFloats ([]float64 {_ffgdg ,_fgaeg ,_adbd });
_dbcd :=_bbd .NewPdfShadingPatternType2 ();_dbcd .Shading =_cegc ;return _dbcd ;};

// Positioning returns the type of positioning the ellipse is set to use.
func (_bgbb *Ellipse )Positioning ()Positioning {return _bgbb ._cafbc };

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};func _gdeb (_dbdc *templateProcessor ,_bcbc *templateNode )(interface{},error ){return _dbdc .parseDivision (_bcbc );};

// The Image type is used to draw an image onto PDF.
type Image struct{_dgcf *_bbd .XObjectImage ;_dcce *_bbd .Image ;_bbed float64 ;_bfdf ,_bcec float64 ;_accbf ,_cdad float64 ;_fgcd Positioning ;_gdbdg HorizontalAlignment ;_agcca float64 ;_fgba float64 ;_gcce float64 ;_ecd Margins ;_eddfg ,_fcfd float64 ;
_ccfa _bf .StreamEncoder ;_gfeea FitMode ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_bcdg *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _bcdg ._ddba .Left ,_bcdg ._ddba .Right ,_bcdg ._ddba .Top ,_bcdg ._ddba .Bottom ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_fdc *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fdc ._ceac .Left ,_fdc ._ceac .Right ,_fdc ._ceac .Top ,_fdc ._ceac .Bottom ;};

// Lines returns all the rows of the invoice line items table.
func (_ggce *Invoice )Lines ()[][]*InvoiceCell {return _ggce ._gddbf };

// SetBorderWidth sets the border width.
func (_deda *CurvePolygon )SetBorderWidth (borderWidth float64 ){_deda ._cba .BorderWidth =borderWidth };func _bgdb (_ggaec *templateProcessor ,_fcgff *templateNode )(interface{},error ){return _ggaec .parsePageBreak (_fcgff );};

// NewColumn returns a new column for the line items invoice table.
func (_ecbc *Invoice )NewColumn (description string )*InvoiceCell {return _ecbc .newColumn (description ,CellHorizontalAlignmentLeft );};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_dbgg *Creator )SetForms (form *_bbd .PdfAcroForm )error {_dbgg ._bagc =form ;return nil };type fontMetrics struct{_acdff float64 ;_ffaf float64 ;_bcecg float64 ;_fbbdb float64 ;};

// Width returns Image's document width.
func (_defd *Image )Width ()float64 {return _defd ._bfdf };

// SetRowPosition sets cell row position.
func (_befde *TableCell )SetRowPosition (row int ){_befde ._cddg =row };

// NewCell returns a new invoice table cell.
func (_bfda *Invoice )NewCell (value string )*InvoiceCell {return _bfda .newCell (value ,_bfda .NewCellProps ());};func (_aecg *List )ctxHeight (_cege float64 )float64 {_cege -=_aecg ._eaef ;var _aagc float64 ;for _ ,_cceeb :=range _aecg ._gebg {_aagc +=_cceeb .ctxHeight (_cege );
};return _aagc ;};func (_dfdeg *templateProcessor )parseChapterHeading (_gagae *templateNode )(interface{},error ){if _gagae ._afbge ==nil {_dfdeg .nodeLogError (_gagae ,"\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_gcgf ;};_gbabgg ,_dcfd :=_gagae ._afbge ._dceb .(*Chapter );if !_dcfd {_dfdeg .nodeLogError (_gagae ,"\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_gagae ._afbge ._dceb );
return nil ,_gcgf ;};_adfc :=_gbabgg .GetHeading ();if _ ,_cgbgf :=_dfdeg .parseParagraph (_gagae ,_adfc );_cgbgf !=nil {return nil ,_cgbgf ;};return _adfc ,nil ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_agfe *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_gbbd :=NewTextChunk (text ,_agfe ._fbcb );_gbbd ._gdege =_cagc (page -1,x ,y ,zoom );return _agfe .appendChunk (_gbbd );};

// SetFont sets the Paragraph's font.
func (_ebcdb *Paragraph )SetFont (font *_bbd .PdfFont ){_ebcdb ._bebf =font };

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_fbfa *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fbfa ._gac .Left ,_fbfa ._gac .Right ,_fbfa ._gac .Top ,_fbfa ._gac .Bottom ;};func (_fcdf *templateProcessor )parseLineStyleAttr (_egbd ,_bdfbb string )_gad .LineStyle {_ee .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_egbd ,_bdfbb );
_dfbea :=map[string ]_gad .LineStyle {"\u0073\u006f\u006ci\u0064":_gad .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_gad .LineStyleDashed }[_bdfbb ];return _dfbea ;};func (_bee *pageTransformations )applyFlip (_bgf *_bbd .PdfPage )error {_ggfa ,_dgeg :=_bee ._eacc ,_bee ._ebbg ;
if !_ggfa &&!_dgeg {return nil ;};if _bgf ==nil {return _ge .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_cacec ,_aefa :=_bgf .GetMediaBox ();if _aefa !=nil {return _aefa ;};_bcga ,_dddf :=_cacec .Width (),_cacec .Height ();
_aaff ,_aefa :=_bgf .GetRotate ();if _aefa !=nil {_ee .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_aefa .Error ());
};if _dcab :=_aaff %360!=0&&_aaff %90==0;_dcab {if _baf :=(360+_aaff %360)%360;_baf ==90||_baf ==270{_ggfa ,_dgeg =_dgeg ,_ggfa ;};};_aedc ,_accfb :=1.0,0.0;if _ggfa {_aedc ,_accfb =-1.0,-_bcga ;};_cgea ,_gfgb :=1.0,0.0;if _dgeg {_cgea ,_gfgb =-1.0,-_dddf ;
};_ggfc :=_da .NewContentCreator ().Scale (_aedc ,_cgea ).Translate (_accfb ,_gfgb );_aedf ,_aefa :=_bf .MakeStream (_ggfc .Bytes (),_bf .NewFlateEncoder ());if _aefa !=nil {return _aefa ;};_gggb :=_bf .MakeArray (_aedf );_gggb .Append (_bgf .GetContentStreamObjs ()...);
_bgf .Contents =_gggb ;return nil ;};

// Height returns the Block's height.
func (_aa *Block )Height ()float64 {return _aa ._gg };

// NewCurvePolygon creates a new curve polygon.
func (_aabg *Creator )NewCurvePolygon (rings [][]_gad .CubicBezierCurve )*CurvePolygon {return _fdd (rings );};

// SetFillOpacity sets the fill opacity of the rectangle.
func (_bcbdb *Rectangle )SetFillOpacity (opacity float64 ){_bcbdb ._fbcfb =opacity };

// BorderWidth returns the border width of the ellipse.
func (_deea *Ellipse )BorderWidth ()float64 {return _deea ._cbab };

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_cfggb *Paragraph )SetColor (col Color ){_cfggb ._bbbf =col };

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_edbg *Block )SetMargins (left ,right ,top ,bottom float64 ){_edbg ._cf .Left =left ;_edbg ._cf .Right =right ;_edbg ._cf .Top =top ;_edbg ._cf .Bottom =bottom ;};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_eega *Image )SetFitMode (fitMode FitMode ){_eega ._gfeea =fitMode };

// SetPos sets absolute positioning with specified coordinates.
func (_dfbba *Paragraph )SetPos (x ,y float64 ){_dfbba ._geee =PositionAbsolute ;_dfbba ._bagf =x ;_dfbba ._egce =y ;};func _ddge (_fbcf string )(*GraphicSVG ,error ){_ecag ,_ebddc :=_bd .ParseFromFile (_fbcf );if _ebddc !=nil {return nil ,_ebddc ;};return _adfd (_ecag );
};

// GeneratePageBlocks draw graphic svg into block.
func (_ddbc *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acda :=ctx ;_cffe :=_ddbc ._aedcf .IsRelative ();var _ggaed []*Block ;if _cffe {_afa :=1.0;_bbge :=_ddbc ._gac .Top ;if _ddbc ._gdbd .Height > ctx .Height -_ddbc ._gac .Top {_ggaed =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _bedfc error ;if _ ,ctx ,_bedfc =_gaebg ().GeneratePageBlocks (ctx );_bedfc !=nil {return nil ,ctx ,_bedfc ;};_bbge =0;};ctx .X +=_ddbc ._gac .Left +_afa ;ctx .Y +=_bbge ;ctx .Width -=_ddbc ._gac .Left +_ddbc ._gac .Right +2*_afa ;ctx .Height -=_bbge ;
}else {ctx .X =_ddbc ._ddfe ;ctx .Y =_ddbc ._bgbba ;};_dgfg :=_da .NewContentCreator ();_dgfg .Translate (0,ctx .PageHeight );_dgfg .Scale (1,-1);_dgfg .Translate (ctx .X ,ctx .Y );_fcbba :=_ddbc ._gdbd .Width /_ddbc ._gdbd .ViewBox .W ;_gbe :=_ddbc ._gdbd .Height /_ddbc ._gdbd .ViewBox .H ;
_dgde :=0.0;_fgea :=0.0;if _cffe {_dgde =_ddbc ._ddfe -(_ddbc ._gdbd .ViewBox .X *_bbg .Max (_fcbba ,_gbe ));_fgea =_ddbc ._bgbba -(_ddbc ._gdbd .ViewBox .Y *_bbg .Max (_fcbba ,_gbe ));};_ddbc ._gdbd .ToContentCreator (_dgfg ,_fcbba ,_gbe ,_dgde ,_fgea );
_eebfb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _acfeb :=_eebfb .addContentsByString (_dgfg .String ());_acfeb !=nil {return nil ,ctx ,_acfeb ;};if _cffe {_ebbf :=_ddbc .Height ()+_ddbc ._gac .Bottom ;ctx .Y +=_ebbf ;ctx .Height -=_ebbf ;}else {ctx =_acda ;
};_ggaed =append (_ggaed ,_eebfb );return _ggaed ,ctx ,nil ;};func (_cgbe *templateProcessor )parseBorderRadiusAttr (_dddae ,_cagg string )(_ebgcd ,_fgadeg ,_fbfcb ,_gdefa float64 ){_ee .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_dddae ,_cagg );
switch _ebbd :=_dd .Fields (_cagg );len (_ebbd ){case 1:_ebgcd ,_ =_bb .ParseFloat (_ebbd [0],64);_fgadeg =_ebgcd ;_fbfcb =_ebgcd ;_gdefa =_ebgcd ;case 2:_ebgcd ,_ =_bb .ParseFloat (_ebbd [0],64);_fbfcb =_ebgcd ;_fgadeg ,_ =_bb .ParseFloat (_ebbd [1],64);
_gdefa =_fgadeg ;case 3:_ebgcd ,_ =_bb .ParseFloat (_ebbd [0],64);_fgadeg ,_ =_bb .ParseFloat (_ebbd [1],64);_gdefa =_fgadeg ;_fbfcb ,_ =_bb .ParseFloat (_ebbd [2],64);case 4:_ebgcd ,_ =_bb .ParseFloat (_ebbd [0],64);_fgadeg ,_ =_bb .ParseFloat (_ebbd [1],64);
_fbfcb ,_ =_bb .ParseFloat (_ebbd [2],64);_gdefa ,_ =_bb .ParseFloat (_ebbd [3],64);};return _ebgcd ,_fgadeg ,_fbfcb ,_gdefa ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_baga *Image )SetWidth (w float64 ){_baga ._bfdf =w };

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_fbbg *Image )GetHorizontalAlignment ()HorizontalAlignment {return _fbbg ._gdbdg };

// GeneratePageBlocks draws the filled curve on page blocks.
func (_fedf *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cgfdf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eddb ,_ ,_bggc :=_fedf .draw (_cgfdf ,"");if _bggc !=nil {return nil ,ctx ,_bggc ;};_bggc =_cgfdf .addContentsByString (string (_eddb ));
if _bggc !=nil {return nil ,ctx ,_bggc ;};return []*Block {_cgfdf },ctx ,nil ;};

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_ebade *shading ;_fagf *_bbd .PdfRectangle ;_gegea float64 ;};func (_egbb *templateProcessor )parsePageBreak (_cebfb *templateNode )(interface{},error ){return _gaebg (),nil ;};func (_agda *StyledParagraph )getTextHeight ()float64 {var _dfdb float64 ;
for _ ,_gfgccfc :=range _agda ._gacc {_eadeg :=_gfgccfc .Style .FontSize *_agda ._dedbc ;if _eadeg > _dfdb {_dfdb =_eadeg ;};};return _dfdb ;};type templateTag struct{_bfed map[string ]struct{};_eecgd func (*templateProcessor ,*templateNode )(interface{},error );
};

// MoveX moves the drawing context to absolute position x.
func (_aacc *Creator )MoveX (x float64 ){_aacc ._ffdd .X =x };func _deggf (_edde *templateProcessor ,_ffdec *templateNode )(interface{},error ){return _edde .parseTable (_ffdec );};func _defde (_cdbf ,_acdfg ,_dfeac TextChunk ,_ggafd uint ,_cdgde TextStyle )*TOCLine {_badc :=_ggcdc (_cdgde );
_badc .SetEnableWrap (true );_badc .SetTextAlignment (TextAlignmentLeft );_badc .SetMargins (0,0,2,2);_fcfa :=&TOCLine {_ebca :_badc ,Number :_cdbf ,Title :_acdfg ,Page :_dfeac ,Separator :TextChunk {Text :"\u002e",Style :_cdgde },_ggcac :0,_fffag :_ggafd ,_ebadg :10,_cgcba :PositionRelative };
_badc ._dadf .Left =_fcfa ._ggcac +float64 (_fcfa ._fffag -1)*_fcfa ._ebadg ;_badc ._cbee =_fcfa .prepareParagraph ;return _fcfa ;};func (_ffdc *Paragraph )getTextLineWidth (_bccd string )float64 {var _cbgec float64 ;for _ ,_gcacf :=range _bccd {if _gcacf =='\u000A'{continue ;
};_afcd ,_abde :=_ffdc ._bebf .GetRuneMetrics (_gcacf );if !_abde {_ee .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_gcacf ,_gcacf );
return -1;};_cbgec +=_ffdc ._gfddf *_afcd .Wx ;};return _cbgec ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dcaed *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _dcaed ._eegf [0],_dcaed ._eegf [1]};

// SetFillColor sets the fill color.
func (_aefe *CurvePolygon )SetFillColor (color Color ){_aefe ._fgcaa =color ;_aefe ._cba .FillColor =_dcgf (color );};

// SetRowHeight sets the height for a specified row.
func (_aebgd *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_aebgd ._abaa ){return _ge .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aebgd ._abaa [row -1]=h ;return nil ;
};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// FillColor returns the fill color of the rectangle.
func (_cabb *Rectangle )FillColor ()Color {return _cabb ._eade };func _befgb (_fbgbb ,_gdefg ,_egfeb string ,_cedd uint ,_abcad TextStyle )*TOCLine {return _defde (TextChunk {Text :_fbgbb ,Style :_abcad },TextChunk {Text :_gdefg ,Style :_abcad },TextChunk {Text :_egfeb ,Style :_abcad },_cedd ,_abcad );
};

// NewPolygon creates a new polygon.
func (_acca *Creator )NewPolygon (points [][]_gad .Point )*Polygon {return _daac (points )};

// Heading returns the heading component of the table of contents.
func (_egdcd *TOC )Heading ()*StyledParagraph {return _egdcd ._efaae };

// SetBorderOpacity sets the border opacity of the ellipse.
func (_beea *Ellipse )SetBorderOpacity (opacity float64 ){_beea ._eaf =opacity };

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_efgc *_gad .Polyline ;_cgfef float64 ;};func (_eadb *StyledParagraph )getTextLineWidth (_aaac []*TextChunk )float64 {var _gdfea float64 ;_ecbb :=len (_aaac );for _bcdd ,_bcgga :=range _aaac {_dbda :=&_bcgga .Style ;_aefc :=len (_bcgga .Text );
for _dadg ,_ggbf :=range _bcgga .Text {if _ggbf =='\u000A'{continue ;};_fccb ,_eeef :=_dbda .Font .GetRuneMetrics (_ggbf );if !_eeef {_ee .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ggbf );
return -1;};_gdfea +=_dbda .FontSize *_fccb .Wx *_dbda .horizontalScale ();if _ggbf !=' '&&(_bcdd !=_ecbb -1||_dadg !=_aefc -1){_gdfea +=_dbda .CharSpacing *1000.0;};};};return _gdfea ;};

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_ggbce *Rectangle )SetFitMode (fitMode FitMode ){_ggbce ._dgba =fitMode };

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_abfbb *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eedbg :=_abfbb ;if _abfbb ._bcfad {_eedbg =_abfbb .clone ();};return _dffgd (_eedbg ,ctx );};func (_dgagd *Line )computeCoords (_ebba DrawContext )(_ebcf ,_egba ,_egaab ,_bcfb float64 ){_ebcf =_ebba .X ;
_egaab =_ebcf +_dgagd ._eefg -_dgagd ._fcgb ;_ebcg :=_dgagd ._fffb ;if _dgagd ._fcgb ==_dgagd ._eefg {_ebcg /=2;};if _dgagd ._aeea < _dgagd ._bfbgf {_egba =_ebba .PageHeight -_ebba .Y -_ebcg ;_bcfb =_egba -_dgagd ._bfbgf +_dgagd ._aeea ;}else {_bcfb =_ebba .PageHeight -_ebba .Y -_ebcg ;
_egba =_bcfb -_dgagd ._aeea +_dgagd ._bfbgf ;};switch _dgagd ._egfe {case FitModeFillWidth :_egaab =_ebcf +_ebba .Width ;};return _ebcf ,_egba ,_egaab ,_bcfb ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_bbbe *_gad .Polygon ;_cfeea float64 ;_fbeb float64 ;_fbceb Color ;};

// NewList creates a new list.
func (_dffg *Creator )NewList ()*List {return _fbg (_dffg .NewTextStyle ())};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};func (_affe *Division )ctxHeight (_bcafc float64 )float64 {_bcafc -=_affe ._ggea .Left +_affe ._ggea .Right +_affe ._eabe .Left +_affe ._eabe .Right ;
var _bafa float64 ;for _ ,_gdfe :=range _affe ._befg {_bafa +=_gcgga (_gdfe ,_bcafc );};return _bafa ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_gcdd *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_cefa :=[2]*InvoiceCell {_gcdd .newCell (description ,_gcdd ._babf ),_gcdd .newCell (value ,_gcdd ._babf )};_gcdd ._geaa =append (_gcdd ._geaa ,_cefa );return _cefa [0],_cefa [1];
};

// EnableWordWrap sets the paragraph word wrap flag.
func (_abac *StyledParagraph )EnableWordWrap (val bool ){_abac ._cgdf =val };

// LineWidth returns the width of the line.
func (_abad *Line )LineWidth ()float64 {return _abad ._fffb };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// AddSection adds a new content section at the end of the invoice.
func (_ddeb *Invoice )AddSection (title ,content string ){_ddeb ._gbae =append (_ddeb ._gbae ,[2]string {title ,content });};

// SetColor sets the line color.
func (_edaa *Curve )SetColor (col Color ){_edaa ._dgda =col };var _bbdf =_bc .MustCompile ("\u005c\u0064\u002b");func _cebc ()*Division {return &Division {_acd :true }};func (_acbgf *Paragraph )getTextMetrics ()(_cbdc ,_gbbag ,_bceda float64 ){_eddgb :=_dfcfd (_acbgf ._bebf ,_acbgf ._gfddf );
if _eddgb ._acdff > _cbdc {_cbdc =_eddgb ._acdff ;};if _eddgb ._fbbdb < _bceda {_bceda =_eddgb ._fbbdb ;};if _fadfe :=_acbgf ._gfddf ;_fadfe > _gbbag {_gbbag =_fadfe ;};return _cbdc ,_gbbag ,_bceda ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_gfdd *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _befgb (number ,title ,page ,level ,_gfdd .NewTextStyle ());};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_aafea *StyledParagraph )Height ()float64 {_aafea .wrapText ();var _dggae float64 ;for _ ,_deae :=range _aafea ._gegeg {var _aedec float64 ;for _ ,_gfdcg :=range _deae {_eabab :=_aafea ._dedbc *_gfdcg .Style .FontSize ;if _eabab > _aedec {_aedec =_eabab ;
};};_dggae +=_aedec ;};return _dggae ;};func (_fefg *listItem )ctxHeight (_faca float64 )float64 {var _eebg float64 ;switch _cgfed :=_fefg ._dgfd .(type ){case *Paragraph :if _cgfed ._bacce {_cgfed .SetWidth (_faca -_cgfed ._ggfad .Horizontal ());};_eebg =_cgfed .Height ()+_cgfed ._ggfad .Vertical ();
_eebg +=0.5*_cgfed ._gfddf *_cgfed ._degf ;case *StyledParagraph :if _cgfed ._abbea {_cgfed .SetWidth (_faca -_cgfed ._dadf .Horizontal ());};_eebg =_cgfed .Height ()+_cgfed ._dadf .Vertical ();_eebg +=0.5*_cgfed .getTextHeight ();case *List :_bfcbf :=_faca -_fefg ._badgf .Width ()-_cgfed ._ddba .Horizontal ()-_cgfed ._eaef ;
_eebg =_cgfed .ctxHeight (_bfcbf )+_cgfed ._ddba .Vertical ();case *Image :_eebg =_cgfed .Height ()+_cgfed ._ecd .Vertical ();case *Division :_adfa :=_faca -_fefg ._badgf .Width ()-_cgfed ._ggea .Horizontal ();_eebg =_cgfed .ctxHeight (_adfa )+_cgfed ._ggea .Vertical ();
case *Table :_edfb :=_faca -_fefg ._badgf .Width ()-_cgfed ._afcg .Horizontal ();_cgfed .updateRowHeights (_edfb );_eebg =_cgfed .Height ()+_cgfed ._afcg .Vertical ();default:_eebg =_fefg ._dgfd .Height ();};return _eebg ;};

// SetBackgroundColor sets the cell's background color.
func (_ddgef *TableCell )SetBackgroundColor (col Color ){_ddgef ._cgfcf =col };

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_efdb *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbbad :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cdaf ,_agfc :=_gbbad .setOpacity (_efdb ._cgfef ,_efdb ._cgfef );if _agfc !=nil {return nil ,ctx ,_agfc ;};
_aafg :=_efdb ._efgc .Points ;for _gfc :=range _aafg {_cfgc :=&_aafg [_gfc ];_cfgc .Y =ctx .PageHeight -_cfgc .Y ;};_agccf ,_ ,_agfc :=_efdb ._efgc .Draw (_cdaf );if _agfc !=nil {return nil ,ctx ,_agfc ;};if _agfc =_gbbad .addContentsByString (string (_agccf ));
_agfc !=nil {return nil ,ctx ,_agfc ;};return []*Block {_gbbad },ctx ,nil ;};

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_bdcdg *Rectangle )BorderOpacity ()float64 {return _bdcdg ._cegge };

// FillColor returns the fill color of the ellipse.
func (_fgdc *Ellipse )FillColor ()Color {return _fgdc ._bfde };func _cfgeg (_edbgb float64 ,_degcbc float64 )float64 {return _bbg .Round (_edbgb /_degcbc )*_degcbc };

// Positioning returns the type of positioning the line is set to use.
func (_deag *Line )Positioning ()Positioning {return _deag ._dabg };func (_bfcc *Paragraph )getMaxLineWidth ()float64 {if _bfcc ._fffef ==nil ||len (_bfcc ._fffef )==0{_bfcc .wrapText ();};var _cbfd float64 ;for _ ,_gbab :=range _bfcc ._fffef {_fgcf :=_bfcc .getTextLineWidth (_gbab );
if _fgcf > _cbfd {_cbfd =_fgcf ;};};return _cbfd ;};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_edgd *RadialShading )AddShadingResource (block *Block )(_dadbe _bf .PdfObjectName ,_eaabb error ){_dedaa :=1;_dadbe =_bf .PdfObjectName ("\u0053\u0068"+_bb .Itoa (_dedaa ));for block ._ce .HasShadingByName (_dadbe ){_dedaa ++;_dadbe =_bf .PdfObjectName ("\u0053\u0068"+_bb .Itoa (_dedaa ));
};if _ddebd :=block ._ce .SetShadingByName (_dadbe ,_edgd .shadingModel ().ToPdfObject ());_ddebd !=nil {return "",_ddebd ;};return _dadbe ,nil ;};

// SetLogo sets the logo of the invoice.
func (_dfdc *Invoice )SetLogo (logo *Image ){_dfdc ._dcbc =logo };

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
// - *Table
// - *Division
// - *List
func (_bff *Division )Add (d VectorDrawable )error {switch _eege :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division ,*List :case containerDrawable :_fgec ,_acggc :=_eege .ContainerComponent (_bff );
if _acggc !=nil {return _acggc ;};_feebd ,_aeeb :=_fgec .(VectorDrawable );if !_aeeb {return _b .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_fgec );
};d =_feebd ;default:return _ge .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_bff ._befg =append (_bff ._befg ,d );return nil ;};func _aged (_daacf []_gad .Point )*Polyline {return &Polyline {_efgc :&_gad .Polyline {Points :_daacf ,LineColor :_bbd .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_cgfef :1.0};
};func (_afdd *templateProcessor )parseTextChunk (_cecc *templateNode ,_aeff *TextChunk )(interface{},error ){if _cecc ._afbge ==nil {_afdd .nodeLogError (_cecc ,"\u0054\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_gcgf ;};var (_cfcc =_afdd .creator .NewTextStyle ();_dagec bool ;);for _ ,_cfec :=range _cecc ._ebeg .Attr {if _cfec .Name .Local =="\u006c\u0069\u006e\u006b"{_efbb ,_bafaa :=_cecc ._afbge ._dceb .(*StyledParagraph );if !_bafaa {_afdd .nodeLogError (_cecc ,"\u004c\u0069\u006e\u006b \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065 \u006f\u006e\u006c\u0079\u0020\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0070\u0061\u0072\u0061\u0067r\u0061\u0070\u0068\u0027\u0073\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e");
_dagec =true ;}else {_cfcc =_efbb ._fbcb ;};break ;};};if _aeff ==nil {_aeff =NewTextChunk ("",_cfcc );};for _ ,_egbaa :=range _cecc ._ebeg .Attr {_afcf :=_egbaa .Value ;switch _cbbce :=_egbaa .Name .Local ;_cbbce {case "\u0063\u006f\u006co\u0072":_aeff .Style .Color =_afdd .parseColorAttr (_cbbce ,_afcf );
case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_aeff .Style .OutlineColor =_afdd .parseColorAttr (_cbbce ,_afcf );case "\u0066\u006f\u006e\u0074":_aeff .Style .Font =_afdd .parseFontAttr (_cbbce ,_afcf );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_aeff .Style .FontSize =_afdd .parseFloatAttr (_cbbce ,_afcf );
case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_aeff .Style .OutlineSize =_afdd .parseFloatAttr (_cbbce ,_afcf );case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_aeff .Style .CharSpacing =_afdd .parseFloatAttr (_cbbce ,_afcf );
case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_aeff .Style .HorizontalScaling =_afdd .parseFloatAttr (_cbbce ,_afcf );case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_aeff .Style .RenderingMode =_afdd .parseTextRenderingModeAttr (_cbbce ,_afcf );
case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_aeff .Style .Underline =_afdd .parseBoolAttr (_cbbce ,_afcf );case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_aeff .Style .UnderlineStyle .Color =_afdd .parseColorAttr (_cbbce ,_afcf );
case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_aeff .Style .UnderlineStyle .Offset =_afdd .parseFloatAttr (_cbbce ,_afcf );case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_aeff .Style .UnderlineStyle .Thickness =_afdd .parseFloatAttr (_cbbce ,_afcf );
case "\u006c\u0069\u006e\u006b":if !_dagec {_aeff ._gdege =_afdd .parseLinkAttr (_cbbce ,_afcf );};case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_aeff .Style .TextRise =_afdd .parseFloatAttr (_cbbce ,_afcf );default:_afdd .nodeLogDebug (_cecc ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_cbbce );
};};return _aeff ,nil ;};func _ddfb (_ggaf string )(*Image ,error ){_fggc ,_cceea :=_a .Open (_ggaf );if _cceea !=nil {return nil ,_cceea ;};defer _fggc .Close ();_agef ,_cceea :=_bbd .ImageHandling .Read (_fggc );if _cceea !=nil {_ee .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cceea );
return nil ,_cceea ;};return _eggc (_agef );};func _fegfd (_bgga *templateProcessor ,_fbdcae *templateNode )(interface{},error ){return _bgga .parseList (_fbdcae );};func (_bgbgf *Table )wrapContent (_fafd DrawContext )error {if _bgbgf ._bcfad {return nil ;
};_bgbgf .sortCells ();_begdd :=func (_ecgb *TableCell ,_gffc int ,_cfgga int ,_acbde int )(_fgbfa int ){if _acbde < 1{return -1;};_dfgfa :=0;for _eafcb :=_cfgga +1;_eafcb < len (_bgbgf ._gggdf )-1;_eafcb ++{_beeb :=_bgbgf ._gggdf [_eafcb ];if _beeb ._cddg ==_acbde &&_dfgfa !=_cfgga {_dfgfa =_eafcb ;
if (_beeb ._aeec < _ecgb ._aeec &&_bgbgf ._efbf > _beeb ._aeec )||_ecgb ._aeec < _bgbgf ._efbf {continue ;};break ;};};_bbbeb :=float64 (0.0);for _gccg :=0;_gccg < _ecgb ._fcabc ;_gccg ++{_bbbeb +=_bgbgf ._abaa [_ecgb ._cddg +_gccg -1];};_geffe :=_ecgb .width (_bgbgf ._ecgg ,_fafd .Width );
var (_fged VectorDrawable ;_fbccf =false ;);switch _defe :=_ecgb ._ffed .(type ){case *StyledParagraph :_adbb :=_fafd ;_adbb .Height =_bbg .Floor (_bbbeb -_defe ._dadf .Top -_defe ._dadf .Bottom -0.5*_defe .getTextHeight ());_adbb .Width =_geffe ;_affae ,_fggde ,_bgdcfg :=_defe .split (_adbb );
if _bgdcfg !=nil {_ee .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_bgdcfg .Error ());};if _affae !=nil &&_fggde !=nil {_bgbgf ._gggdf [_cfgga ]._ffed =_affae ;
_fged =_fggde ;_fbccf =true ;};};_bgbgf ._gggdf [_cfgga ]._fcabc =_ecgb ._fcabc ;_fafd .Height =_fafd .PageHeight -_fafd .Margins .Top -_fafd .Margins .Bottom ;_eedbe :=_ecgb .cloneProps (nil );if _fbccf {_eedbe ._ffed =_fged ;};_eedbe ._fcabc =_gffc ;
_eedbe ._cddg =_acbde +1;_eedbe ._aeec =_ecgb ._aeec ;if _eedbe ._cddg +_eedbe ._fcabc -1> _bgbgf ._gcgba {for _cbed :=_bgbgf ._gcgba ;_cbed < _eedbe ._cddg +_eedbe ._fcabc -1;_cbed ++{_bgbgf ._gcgba ++;_bgbgf ._abaa =append (_bgbgf ._abaa ,_bgbgf ._bcgeag );
};};_bgbgf ._gggdf =append (_bgbgf ._gggdf [:_dfgfa +1],append ([]*TableCell {_eedbe },_bgbgf ._gggdf [_dfgfa +1:]...)...);return _dfgfa +1;};_fagfg :=func (_egega *TableCell ,_bafc int ,_ccag int ,_cbcaa float64 )(_fdcg int ){_baea :=_egega .width (_bgbgf ._ecgg ,_fafd .Width );
_eagag :=_cbcaa ;_dgbf :=1;_beeeb :=_fafd .Height ;if _beeeb > 0{for _eagag > _beeeb {_eagag -=_fafd .Height ;_beeeb =_fafd .PageHeight -_fafd .Margins .Top -_fafd .Margins .Bottom ;_dgbf ++;};};var (_abab VectorDrawable ;_eagaa =false ;);switch _cbbf :=_egega ._ffed .(type ){case *StyledParagraph :_gcbg :=_fafd ;
_gcbg .Height =_bbg .Floor (_fafd .Height -_cbbf ._dadf .Top -_cbbf ._dadf .Bottom -0.5*_cbbf .getTextHeight ());_gcbg .Width =_baea ;_eeeg ,_cdged ,_facf :=_cbbf .split (_gcbg );if _facf !=nil {_ee .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_facf .Error ());
};if _eeeg !=nil &&_cdged !=nil {_bgbgf ._gggdf [_bafc ]._ffed =_eeeg ;_abab =_cdged ;_eagaa =true ;};};if _dgbf < 2{return -1;};if _bgbgf ._gggdf [_bafc ]._cddg +_dgbf -1> _bgbgf ._gcgba {for _ceeb :=0;_ceeb < _dgbf ;_ceeb ++{_bgbgf ._gcgba ++;_bgbgf ._abaa =append (_bgbgf ._abaa ,_bgbgf ._bcgeag );
};};_fcda :=_cbcaa /float64 (_dgbf );for _gdfba :=0;_gdfba < _dgbf ;_gdfba ++{_bgbgf ._abaa [_ccag +_gdfba -1]=_fcda ;};_fafd .Height =_fafd .PageHeight -_fafd .Margins .Top -_fafd .Margins .Bottom ;_gccbe :=_egega .cloneProps (nil );if _eagaa {_gccbe ._ffed =_abab ;
};_gccbe ._fcabc =1;_gccbe ._cddg =_ccag +_dgbf -1;_gccbe ._aeec =_egega ._aeec ;_bgbgf ._gggdf =append (_bgbgf ._gggdf ,_gccbe );return len (_bgbgf ._gggdf );};_fadbaa :=1;_fegc :=-1;for _cgbcac :=0;_cgbcac < len (_bgbgf ._gggdf );_cgbcac ++{_fecf :=_bgbgf ._gggdf [_cgbcac ];
if _fegc ==_cgbcac {_fadbaa =_fecf ._cddg ;};if _fecf ._fcabc < 2{if _gcda :=_bgbgf ._abaa [_fecf ._cddg -1];_gcda > _fafd .Height {_fegc =_fagfg (_fecf ,_cgbcac ,_fecf ._cddg ,_gcda );continue ;};continue ;};_bgef :=float64 (0);for _debcg :=0;_debcg < _fecf ._fcabc ;
_debcg ++{_bgef +=_bgbgf ._abaa [_fecf ._cddg +_debcg -1];};_gegbf :=float64 (0);for _dbec :=_fadbaa -1;_dbec < _fecf ._cddg -1;_dbec ++{_gegbf +=_bgbgf ._abaa [_dbec ];};if _bgef <=(_fafd .Height -_gegbf ){continue ;};_abcac :=float64 (0.0);_aded :=_fecf ._fcabc ;
_cebbg :=-1;_abbd :=1;for _bdfa :=1;_bdfa <=_fecf ._fcabc ;_bdfa ++{if (_abcac +_bgbgf ._abaa [_fecf ._cddg +_bdfa -2])> (_fafd .Height -_gegbf ){_abbd --;break ;};_cebbg =_fecf ._cddg +_bdfa -1;_aded =_fecf ._fcabc -_bdfa ;_abcac +=_bgbgf ._abaa [_fecf ._cddg +_bdfa -2];
_abbd ++;};if _fecf ._fcabc ==_aded {_fafd .Height =_fafd .PageHeight -_fafd .Margins .Top -_fafd .Margins .Bottom ;_fadbaa =_fecf ._cddg ;_cgbcac --;continue ;};if _aded > 0&&_fecf ._fcabc > _abbd {_fecf ._fcabc =_abbd ;_fegc =_begdd (_fecf ,_aded ,_cgbcac ,_cebbg );
if _cgbcac +1==_fegc {_cgbcac --;};};_fadbaa =_fecf ._cddg ;};_bgbgf .sortCells ();return nil ;};

// SetBorderWidth sets the border width of the ellipse.
func (_cbcd *Ellipse )SetBorderWidth (bw float64 ){_cbcd ._cbab =bw };func (_gdfae *StyledParagraph )wrapText ()error {return _gdfae .wrapChunks (true )};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_edaba *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbfcf :=ctx ;var _eded []*Block ;_aeefc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _edaba ._geee .IsRelative (){ctx .X +=_edaba ._ggfad .Left ;ctx .Y +=_edaba ._ggfad .Top ;
ctx .Width -=_edaba ._ggfad .Left +_edaba ._ggfad .Right ;ctx .Height -=_edaba ._ggfad .Top ;_edaba .SetWidth (ctx .Width );if _edaba .Height ()> ctx .Height {_eded =append (_eded ,_aeefc );_aeefc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;
_edefe :=ctx ;_edefe .Y =ctx .Margins .Top ;_edefe .X =ctx .Margins .Left +_edaba ._ggfad .Left ;_edefe .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_edefe .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_edaba ._ggfad .Left -_edaba ._ggfad .Right ;
ctx =_edefe ;};}else {if int (_edaba ._cfedb )<=0{_edaba .SetWidth (_edaba .getTextWidth ());};ctx .X =_edaba ._bagf ;ctx .Y =_edaba ._egce ;};ctx ,_gfdc :=_fggd (_aeefc ,_edaba ,ctx );if _gfdc !=nil {_ee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gfdc );
return nil ,ctx ,_gfdc ;};_eded =append (_eded ,_aeefc );if _edaba ._geee .IsRelative (){ctx .Y +=_edaba ._ggfad .Bottom ;ctx .Height -=_edaba ._ggfad .Bottom ;if !ctx .Inline {ctx .X =_fbfcf .X ;ctx .Width =_fbfcf .Width ;};return _eded ,ctx ,nil ;};return _eded ,_fbfcf ,nil ;
};func _fag (_caeb Color ,_fdab float64 )*ColorPoint {return &ColorPoint {_fgce :_caeb ,_gabg :_fdab }};func (_afgfe *templateProcessor )parseCellAlignmentAttr (_abcgf ,_fdbc string )CellHorizontalAlignment {_ee .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_abcgf ,_fdbc );
_gdefd :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_fdbc ];return _gdefd ;
};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_fadb *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_fgadc :=_ggcdc (_fadb ._ddbae );_fgadc .Append (text );_affb ,_cbca :=_fadb .Add (_fgadc );return _fgadc ,_affb ,_cbca ;};

// List represents a list of items.
// The representation of a list item is as follows:
//
//	[marker] [content]
//
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_gebg []*listItem ;_ddba Margins ;_cafc TextChunk ;_eaef float64 ;_cbeab bool ;_egfd Positioning ;_ddbae TextStyle ;};

// DashPattern returns the dash pattern of the line.
func (_dcfg *Line )DashPattern ()(_aafe []int64 ,_ggeg int64 ){return _dcfg ._daab ,_dcfg ._edae };func _ggcdc (_gfgccf TextStyle )*StyledParagraph {return &StyledParagraph {_gacc :[]*TextChunk {},_abeaf :_gfgccf ,_fbcb :_ffcfb (_gfgccf .Font ),_dedbc :1.0,_eceb :TextAlignmentLeft ,_abbea :true ,_ccddf :true ,_cgdf :false ,_fabd :0,_fbefe :1,_bcac :1,_dageg :PositionRelative };
};func (_aeg *Block )translate (_bfb ,_ffa float64 ){_gaf :=_da .NewContentCreator ().Translate (_bfb ,-_ffa ).Operations ();*_aeg ._ec =append (*_gaf ,*_aeg ._ec ...);_aeg ._ec .WrapIfNeeded ();};func _gcgga (_bbdfd VectorDrawable ,_daga float64 )float64 {switch _afdge :=_bbdfd .(type ){case *Paragraph :if _afdge ._bacce {_afdge .SetWidth (_daga -_afdge ._ggfad .Left -_afdge ._ggfad .Right );
};return _afdge .Height ()+_afdge ._ggfad .Top +_afdge ._ggfad .Bottom ;case *StyledParagraph :if _afdge ._abbea {_afdge .SetWidth (_daga -_afdge ._dadf .Left -_afdge ._dadf .Right );};return _afdge .Height ()+_afdge ._dadf .Top +_afdge ._dadf .Bottom ;
case *Image :_afdge .applyFitMode (_daga );return _afdge .Height ()+_afdge ._ecd .Top +_afdge ._ecd .Bottom ;case *Rectangle :_afdge .applyFitMode (_daga );return _afdge .Height ()+_afdge ._caegfd .Top +_afdge ._caegfd .Bottom +_afdge ._egdc ;case *Ellipse :_afdge .applyFitMode (_daga );
return _afdge .Height ()+_afdge ._fdcb .Top +_afdge ._fdcb .Bottom ;case *Division :return _afdge .ctxHeight (_daga )+_afdge ._ggea .Top +_afdge ._ggea .Bottom +_afdge ._eabe .Top +_afdge ._eabe .Bottom ;case *Table :_afdge .updateRowHeights (_daga -_afdge ._afcg .Left -_afdge ._afcg .Right );
return _afdge .Height ()+_afdge ._afcg .Top +_afdge ._afcg .Bottom ;case *List :return _afdge .ctxHeight (_daga )+_afdge ._ddba .Top +_afdge ._ddba .Bottom ;case marginDrawable :_ ,_ ,_bcgf ,_cafb :=_afdge .GetMargins ();return _afdge .Height ()+_bcgf +_cafb ;
default:return _afdge .Height ();};};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_gfga *Invoice )SetNoteStyle (style TextStyle ){_gfga ._ddbe =style };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_fecab *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_ggfgc ,_agggd :=_fecab .Wrap (width );if _agggd !=nil {return nil ,_agggd ;};_ddacf :=int (height /_fecab .Style .FontSize );if _ddacf >=len (_ggfgc ){return nil ,nil ;};_ddfgf :="\u000a";
_fecab .Text =_dd .Replace (_dd .Join (_ggfgc [:_ddacf ],"\u0020"),_ddfgf +"\u0020",_ddfgf ,-1);_addfa :=_dd .Replace (_dd .Join (_ggfgc [_ddacf :],"\u0020"),_ddfgf +"\u0020",_ddfgf ,-1);return NewTextChunk (_addfa ,_fecab .Style ),nil ;};

// SetBorderColor sets border color of the rectangle.
func (_cgbcf *Rectangle )SetBorderColor (col Color ){_cgbcf ._acbae =col };

// AppendColumn appends a column to the line items table.
func (_fgab *Invoice )AppendColumn (description string )*InvoiceCell {_fffe :=_fgab .NewColumn (description );_fgab ._agbb =append (_fgab ._agbb ,_fffe );return _fffe ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_gcdde *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gcdde ._dadf .Left ,_gcdde ._dadf .Right ,_gcdde ._dadf .Top ,_gcdde ._dadf .Bottom ;};func (_dgfgd *StyledParagraph )wrapChunks (_gaec bool )error {if !_dgfgd ._abbea ||int (_dgfgd ._ccac )<=0{_dgfgd ._gegeg =[][]*TextChunk {_dgfgd ._gacc };
return nil ;};if _dgfgd ._cgdf {_dgfgd .wrapWordChunks ();};_dgfgd ._gegeg =[][]*TextChunk {};var _beeg []*TextChunk ;var _gbbc float64 ;_afed :=_fa .IsSpace ;if !_gaec {_afed =func (rune )bool {return false };};_bebc :=_cfgeg (_dgfgd ._ccac *1000.0,0.000001);
for _ ,_bbaeb :=range _dgfgd ._gacc {_fdea :=_bbaeb .Style ;_egfed :=_bbaeb ._gdege ;_dfef :=_bbaeb .VerticalAlignment ;var (_aeaf []rune ;_gfge []float64 ;);_faac :=_cbbcb (_bbaeb .Text );for _ ,_acag :=range _bbaeb .Text {if _acag =='\u000A'{if !_gaec {_aeaf =append (_aeaf ,_acag );
};_beeg =append (_beeg ,&TextChunk {Text :_dd .TrimRightFunc (string (_aeaf ),_afed ),Style :_fdea ,_gdege :_geafg (_egfed ),VerticalAlignment :_dfef });_dgfgd ._gegeg =append (_dgfgd ._gegeg ,_beeg );_beeg =nil ;_gbbc =0;_aeaf =nil ;_gfge =nil ;continue ;
};_fgdd :=_acag ==' ';_aaca ,_cgfeff :=_fdea .Font .GetRuneMetrics (_acag );if !_cgfeff {_ee .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_acag );
return _ge .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_ebabb :=_fdea .FontSize *_aaca .Wx *_fdea .horizontalScale ();_cgfdfc :=_ebabb ;if !_fgdd {_cgfdfc =_ebabb +_fdea .CharSpacing *1000.0;
};if _gbbc +_ebabb > _bebc {_effa :=-1;if !_fgdd {for _gagb :=len (_aeaf )-1;_gagb >=0;_gagb --{if _aeaf [_gagb ]==' '{_effa =_gagb ;break ;};};};if _dgfgd ._cgdf {_bcfdb :=len (_beeg );if _bcfdb > 0{_beeg [_bcfdb -1].Text =_dd .TrimRightFunc (_beeg [_bcfdb -1].Text ,_afed );
_dgfgd ._gegeg =append (_dgfgd ._gegeg ,_beeg );_beeg =[]*TextChunk {};};_aeaf =append (_aeaf ,_acag );_gfge =append (_gfge ,_cgfdfc );if _effa >=0{_aeaf =_aeaf [_effa +1:];_gfge =_gfge [_effa +1:];};_gbbc =0;for _ ,_acce :=range _gfge {_gbbc +=_acce ;
};if _gbbc > _bebc {_ebfa :=string (_aeaf [:len (_aeaf )-1]);_ebfa =_eefe (_ebfa ,_faac );if !_gaec &&_fgdd {_ebfa +="\u0020";};_beeg =append (_beeg ,&TextChunk {Text :_dd .TrimRightFunc (_ebfa ,_afed ),Style :_fdea ,_gdege :_geafg (_egfed ),VerticalAlignment :_dfef });
_dgfgd ._gegeg =append (_dgfgd ._gegeg ,_beeg );_beeg =[]*TextChunk {};_aeaf =[]rune {_acag };_gfge =[]float64 {_cgfdfc };_gbbc =_cgfdfc ;};continue ;};_bcgb :=string (_aeaf );if _effa >=0{_bcgb =string (_aeaf [0:_effa +1]);_aeaf =_aeaf [_effa +1:];_aeaf =append (_aeaf ,_acag );
_gfge =_gfge [_effa +1:];_gfge =append (_gfge ,_cgfdfc );_gbbc =0;for _ ,_agge :=range _gfge {_gbbc +=_agge ;};}else {if _fgdd {_gbbc =0;_aeaf =[]rune {};_gfge =[]float64 {};}else {_gbbc =_cgfdfc ;_aeaf =[]rune {_acag };_gfge =[]float64 {_cgfdfc };};};
_bcgb =_eefe (_bcgb ,_faac );if !_gaec &&_fgdd {_bcgb +="\u0020";};_beeg =append (_beeg ,&TextChunk {Text :_dd .TrimRightFunc (_bcgb ,_afed ),Style :_fdea ,_gdege :_geafg (_egfed ),VerticalAlignment :_dfef });_dgfgd ._gegeg =append (_dgfgd ._gegeg ,_beeg );
_beeg =[]*TextChunk {};}else {_gbbc +=_cgfdfc ;_aeaf =append (_aeaf ,_acag );_gfge =append (_gfge ,_cgfdfc );};};if len (_aeaf )> 0{_cfca :=_eefe (string (_aeaf ),_faac );_beeg =append (_beeg ,&TextChunk {Text :_cfca ,Style :_fdea ,_gdege :_geafg (_egfed ),VerticalAlignment :_dfef });
};};if len (_beeg )> 0{_dgfgd ._gegeg =append (_dgfgd ._gegeg ,_beeg );};return nil ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_dbca []_gad .CubicBezierCurve ;FillEnabled bool ;_dcabf Color ;BorderEnabled bool ;BorderWidth float64 ;_badb Color ;};func (_afba *templateProcessor )parseListMarker (_dcege *templateNode )(interface{},error ){if _dcege ._afbge ==nil {_afba .nodeLogError (_dcege ,"\u004c\u0069\u0073\u0074\u0020\u006da\u0072\u006b\u0065\u0072\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0063a\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_gcgf ;};var _ebegc *TextChunk ;switch _bgfd :=_dcege ._afbge ._dceb .(type ){case *List :_ebegc =&_bgfd ._cafc ;case *listItem :_ebegc =&_bgfd ._badgf ;default:_afba .nodeLogError (_dcege ,"\u0025\u0076 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u006e\u006f\u0064\u0065\u0020\u0066\u006f\u0072\u0020\u006c\u0069\u0073\u0074\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e",_bgfd );
return nil ,_gcgf ;};if _ ,_dfefg :=_afba .parseTextChunk (_dcege ,_ebegc );_dfefg !=nil {_afba .nodeLogError (_dcege ,"\u0043\u006f\u0075ld\u0020\u006e\u006f\u0074\u0020\u0070\u0061\u0072\u0073e\u0020l\u0069s\u0074 \u006d\u0061\u0072\u006b\u0065\u0072\u003a\u0020\u0060\u0025\u0076\u0060\u002e",_dfefg );
return nil ,nil ;};return _ebegc ,nil ;};func _bddgc (_caebg []*ColorPoint )*LinearShading {return &LinearShading {_ebade :&shading {_cfgfd :ColorWhite ,_gdfd :false ,_aeaa :[]bool {false ,false },_eeee :_caebg },_fagf :&_bbd .PdfRectangle {}};};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_aceeg *Table )Width ()float64 {return 0};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_gcacd *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _defde (number ,title ,page ,level ,style );};

// SetFillOpacity sets the fill opacity.
func (_gbaa *CurvePolygon )SetFillOpacity (opacity float64 ){_gbaa ._eedg =opacity };func _agab (_gceg *Block ,_eageeg _bbd .PdfColor ,_bbbc Color ,_feae func ()Rectangle )error {switch _dgdaf :=_eageeg .(type ){case *_bbd .PdfColorPatternType2 :_aecbe ,_ggafb :=_bbbc .(*LinearShading );
if !_ggafb {return _b .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_faff :=_feae ();_aecbe .SetBoundingBox (_faff ._bgcbe ,_faff ._aagb ,_faff ._cdagc ,_faff ._ddbcg );
_fedad ,_gdea :=_aecbe .AddPatternResource (_gceg );if _gdea !=nil {return _b .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_gdea );
};_dgdaf .PatternName =_fedad ;case *_bbd .PdfColorPatternType3 :_ffaa ,_dcfga :=_bbbc .(*RadialShading );if !_dcfga {return _b .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_abbe :=_feae ();_ffaa .SetBoundingBox (_abbe ._bgcbe ,_abbe ._aagb ,_abbe ._cdagc ,_abbe ._ddbcg );_fabcg ,_bddg :=_ffaa .AddPatternResource (_gceg );if _bddg !=nil {return _b .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_bddg );
};_dgdaf .PatternName =_fabcg ;};return nil ;};

// Horizontal returns total horizontal (left + right) margin.
func (_cdd *Margins )Horizontal ()float64 {return _cdd .Left +_cdd .Right };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_agbe *Paragraph )SetMaxLines (maxLines int ){_agbe ._gbdf =maxLines ;_agbe .wrapText ()};

// SkipCells skips over a specified number of cells in the table.
func (_dcdcfc *Table )SkipCells (num int ){if num < 0{_ee .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _bbbcc :=0;_bbbcc < num ;_bbbcc ++{_dcdcfc .NewCell ();};};

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_gdbd *_bd .GraphicSVG ;_aedcf Positioning ;_ddfe float64 ;_bgbba float64 ;_gac Margins ;};

// SetAngle sets the rotation angle of the text.
func (_becb *StyledParagraph )SetAngle (angle float64 ){_becb ._fabd =angle };

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_faecd *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _faecd ._aca [0],_faecd ._aca [1]};

// SetShowLinks sets visibility of links for the TOC lines.
func (_bddb *TOC )SetShowLinks (showLinks bool ){_bddb ._fbfca =showLinks };var _bcfge =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_eecgd :_aeeg },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_bfed :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_eecgd :_ebadef },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_eecgd :_gdeb },"\u0074\u0061\u0062l\u0065":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_eecgd :_deggf },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_bfed :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_eecgd :_fddgf },"\u006c\u0069\u006e\u0065":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_eecgd :_bdfda },"\u0072e\u0063\u0074\u0061\u006e\u0067\u006ce":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_eecgd :_fcdfc },"\u0065l\u006c\u0069\u0070\u0073\u0065":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_eecgd :_cgbbe },"\u0069\u006d\u0061g\u0065":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_eecgd :_gbgaf },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_eecgd :_bfbdb },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_bfed :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_eecgd :_acbga },"\u0063\u0068\u0061r\u0074":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_eecgd :_aabcf },"\u0070\u0061\u0067\u0065\u002d\u0062\u0072\u0065\u0061\u006b":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_eecgd :_bgdb },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_bfed :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_eecgd :_edggd },"\u006c\u0069\u0073\u0074":&templateTag {_bfed :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_eecgd :_fegfd },"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":&templateTag {_bfed :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{}},_eecgd :_geeef },"l\u0069\u0073\u0074\u002d\u006d\u0061\u0072\u006b\u0065\u0072":&templateTag {_bfed :map[string ]struct{}{"\u006c\u0069\u0073\u0074":struct{}{},"\u006ci\u0073\u0074\u002d\u0069\u0074\u0065m":struct{}{}},_eecgd :_fffd }};


// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_bdga *LinearShading )SetBackgroundColor (backgroundColor Color ){_bdga ._ebade .SetBackgroundColor (backgroundColor );};

// SetBackground sets the background properties of the component.
func (_eaddd *Division )SetBackground (background *Background ){_eaddd ._cacc =background };

// Padding returns the padding of the component.
func (_dada *Division )Padding ()(_cbb ,_egea ,_cgcb ,_fefc float64 ){return _dada ._eabe .Left ,_dada ._eabe .Right ,_dada ._eabe .Top ,_dada ._eabe .Bottom ;};

// Height returns the height of the chart.
func (_fecg *Chart )Height ()float64 {return float64 (_fecg ._eebf .Height ())};func _daac (_aeggd [][]_gad .Point )*Polygon {return &Polygon {_bbbe :&_gad .Polygon {Points :_aeggd },_cfeea :1.0,_fbeb :1.0};};func (_ebcd *Division )drawBackground (_bdaa []*Block ,_ecab ,_ecae DrawContext ,_bbfe bool )([]*Block ,error ){_bfag :=len (_bdaa );
if _bfag ==0||_ebcd ._cacc ==nil {return _bdaa ,nil ;};_cbea :=make ([]*Block ,0,len (_bdaa ));for _eecg ,_bfe :=range _bdaa {var (_caefa =_ebcd ._cacc .BorderRadiusTopLeft ;_dbcgd =_ebcd ._cacc .BorderRadiusTopRight ;_febd =_ebcd ._cacc .BorderRadiusBottomLeft ;
_gbbg =_ebcd ._cacc .BorderRadiusBottomRight ;);_cdcg :=_ecab ;_cdcg .Page +=_eecg ;if _eecg ==0{if _bbfe {_cbea =append (_cbea ,_bfe );continue ;};if _bfag ==1{_cdcg .Height =_ecae .Y -_ecab .Y ;};}else {_cdcg .X =_cdcg .Margins .Left +_ebcd ._ggea .Left ;
_cdcg .Y =_cdcg .Margins .Top ;_cdcg .Width =_cdcg .PageWidth -_cdcg .Margins .Left -_cdcg .Margins .Right -_ebcd ._ggea .Left -_ebcd ._ggea .Right ;if _eecg ==_bfag -1{_cdcg .Height =_ecae .Y -_cdcg .Margins .Top -_ebcd ._ggea .Top ;}else {_cdcg .Height =_cdcg .PageHeight -_cdcg .Margins .Top -_cdcg .Margins .Bottom ;
};if !_bbfe {_caefa =0;_dbcgd =0;};};if _bfag > 1&&_eecg !=_bfag -1{_febd =0;_gbbg =0;};_fbdb :=_geeed (_cdcg .X ,_cdcg .Y ,_cdcg .Width ,_cdcg .Height );_fbdb .SetFillColor (_ebcd ._cacc .FillColor );_fbdb .SetBorderColor (_ebcd ._cacc .BorderColor );
_fbdb .SetBorderWidth (_ebcd ._cacc .BorderSize );_fbdb .SetBorderRadius (_caefa ,_dbcgd ,_febd ,_gbbg );_aada ,_ ,_acdd :=_fbdb .GeneratePageBlocks (_cdcg );if _acdd !=nil {return nil ,_acdd ;};if len (_aada )==0{continue ;};_fege :=_aada [0];if _acdd =_fege .mergeBlocks (_bfe );
_acdd !=nil {return nil ,_acdd ;};_cbea =append (_cbea ,_fege );};return _cbea ,nil ;};

// SetHeight sets the height of the ellipse.
func (_dffe *Ellipse )SetHeight (height float64 ){_dffe ._dgdg =height };

// Height returns the current page height.
func (_eecd *Creator )Height ()float64 {return _eecd ._ebeb };

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_cfgg *Creator )DrawTemplate (r _ga .Reader ,data interface{},options *TemplateOptions )error {return _bgaf (_cfgg ,r ,data ,options ,_cfgg );};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_ddcd *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_ddcd ._fcbd =&_bbd .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// SetMargins sets the margins of the paragraph.
func (_dgae *List )SetMargins (left ,right ,top ,bottom float64 ){_dgae ._ddba .Left =left ;_dgae ._ddba .Right =right ;_dgae ._ddba .Top =top ;_dgae ._ddba .Bottom =bottom ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};func _ggee (_egfgf *_bbd .PdfAnnotationLink )*_bbd .PdfAnnotationLink {if _egfgf ==nil {return nil ;};_abfbbc :=_bbd .NewPdfAnnotationLink ();_abfbbc .BS =_egfgf .BS ;_abfbbc .A =_egfgf .A ;if _ecagec ,_eabb :=_egfgf .GetAction ();
_eabb ==nil &&_ecagec !=nil {_abfbbc .SetAction (_ecagec );};if _gdaaf ,_fbfcg :=_egfgf .Dest .(*_bf .PdfObjectArray );_fbfcg {_abfbbc .Dest =_bf .MakeArray (_gdaaf .Elements ()...);};return _abfbbc ;};func _cagc (_gfbaf int64 ,_feebe ,_fafdb ,_dgecg float64 )*_bbd .PdfAnnotation {_gbaga :=_bbd .NewPdfAnnotationLink ();
_aabfg :=_bbd .NewBorderStyle ();_aabfg .SetBorderWidth (0);_gbaga .BS =_aabfg .ToPdfObject ();if _gfbaf < 0{_gfbaf =0;};_gbaga .Dest =_bf .MakeArray (_bf .MakeInteger (_gfbaf ),_bf .MakeName ("\u0058\u0059\u005a"),_bf .MakeFloat (_feebe ),_bf .MakeFloat (_fafdb ),_bf .MakeFloat (_dgecg ));
return _gbaga .PdfAnnotation ;};

// SetSellerAddress sets the seller address of the invoice.
func (_aege *Invoice )SetSellerAddress (address *InvoiceAddress ){_aege ._bege =address };

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_cgfcf Color ;_cgccf _gad .LineStyle ;_adac CellBorderStyle ;_baecc Color ;_caec float64 ;_ggdb CellBorderStyle ;_cfcd Color ;_adcb float64 ;_ggag CellBorderStyle ;_bgbe Color ;_gbad float64 ;_adebbb CellBorderStyle ;_acaa Color ;
_accd float64 ;_cddg ,_aeec int ;_fcabc int ;_cfbea int ;_ffed VectorDrawable ;_fegaf CellHorizontalAlignment ;_ffedg CellVerticalAlignment ;_bfef float64 ;_bdcge *Table ;};func (_gdf *Block )drawToPage (_gcg *_bbd .PdfPage )error {_adg :=&_da .ContentStreamOperations {};
if _gcg .Resources ==nil {_gcg .Resources =_bbd .NewPdfPageResources ();};_dee :=_dec (_adg ,_gcg .Resources ,_gdf ._ec ,_gdf ._ce );if _dee !=nil {return _dee ;};if _dee =_gff (_gdf ._ce ,_gcg .Resources );_dee !=nil {return _dee ;};if _dee =_gcg .AppendContentBytes (_adg .Bytes (),true );
_dee !=nil {return _dee ;};for _ ,_dcd :=range _gdf ._cb {_gcg .AddAnnotation (_dcd );};return nil ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_bfbb *Invoice )TitleStyle ()TextStyle {return _bfbb ._dccef };

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_edeff *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ebfc ,_egec :=_dbce .setOpacity (_edeff ._eedg ,_edeff ._dggg );if _egec !=nil {return nil ,ctx ,_egec ;
};_ddaf :=_edeff ._cba ;_ddaf .FillEnabled =_ddaf .FillColor !=nil ;_ddaf .BorderEnabled =_ddaf .BorderColor !=nil &&_ddaf .BorderWidth > 0;var (_efe =ctx .PageHeight ;_gaa =_ddaf .Rings ;_bfcb =make ([][]_gad .CubicBezierCurve ,0,len (_ddaf .Rings ));
);_cfbb :=_bbd .PdfRectangle {};if len (_gaa )> 0&&len (_gaa [0])> 0{_fffg :=_gaa [0][0];_fffg .P0 .Y =_efe -_fffg .P0 .Y ;_fffg .P1 .Y =_efe -_fffg .P1 .Y ;_fffg .P2 .Y =_efe -_fffg .P2 .Y ;_fffg .P3 .Y =_efe -_fffg .P3 .Y ;_cfbb =_fffg .GetBounds ();
};for _ ,_bgegg :=range _gaa {_gab :=make ([]_gad .CubicBezierCurve ,0,len (_bgegg ));for _ ,_ecge :=range _bgegg {_gfee :=_ecge ;_gfee .P0 .Y =_efe -_gfee .P0 .Y ;_gfee .P1 .Y =_efe -_gfee .P1 .Y ;_gfee .P2 .Y =_efe -_gfee .P2 .Y ;_gfee .P3 .Y =_efe -_gfee .P3 .Y ;
_gab =append (_gab ,_gfee );_afbbg :=_gfee .GetBounds ();_cfbb .Llx =_bbg .Min (_cfbb .Llx ,_afbbg .Llx );_cfbb .Lly =_bbg .Min (_cfbb .Lly ,_afbbg .Lly );_cfbb .Urx =_bbg .Max (_cfbb .Urx ,_afbbg .Urx );_cfbb .Ury =_bbg .Max (_cfbb .Ury ,_afbbg .Ury );
};_bfcb =append (_bfcb ,_gab );};_ddaf .Rings =_bfcb ;defer func (){_ddaf .Rings =_gaa }();if _ddaf .FillEnabled {_edba :=_agab (_dbce ,_edeff ._cba .FillColor ,_edeff ._fgcaa ,func ()Rectangle {return Rectangle {_bgcbe :_cfbb .Llx ,_aagb :_cfbb .Lly ,_cdagc :_cfbb .Width (),_ddbcg :_cfbb .Height ()};
});if _edba !=nil {return nil ,ctx ,_edba ;};};_ccb ,_ ,_egec :=_ddaf .Draw (_ebfc );if _egec !=nil {return nil ,ctx ,_egec ;};if _egec =_dbce .addContentsByString (string (_ccb ));_egec !=nil {return nil ,ctx ,_egec ;};return []*Block {_dbce },ctx ,nil ;
};func (_dgad *Invoice )generateInformationBlocks (_dcfff DrawContext )([]*Block ,DrawContext ,error ){_ffaeg :=_ggcdc (_dgad ._faeg );_ffaeg .SetMargins (0,0,0,20);_adebb :=_dgad .drawAddress (_dgad ._bege );_adebb =append (_adebb ,_ffaeg );_adebb =append (_adebb ,_dgad .drawAddress (_dgad ._ecff )...);
_bgea :=_cebc ();for _ ,_fdeeb :=range _adebb {_bgea .Add (_fdeeb );};_acbca :=_dgad .drawInformation ();_dggdd :=_bfdec (2);_dggdd .SetMargins (0,0,25,0);_ceda :=_dggdd .NewCell ();_ceda .SetIndent (0);_ceda .SetContent (_bgea );_ceda =_dggdd .NewCell ();
_ceda .SetContent (_acbca );return _dggdd .GeneratePageBlocks (_dcfff );};

// SetBorderOpacity sets the border opacity.
func (_dbdg *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_dbdg ._bbga =opacity };

// NewPolyline creates a new polyline.
func (_ced *Creator )NewPolyline (points []_gad .Point )*Polyline {return _aged (points )};func _ggba (_bcdabgb ...interface{})(map[string ]interface{},error ){_fccfa :=len (_bcdabgb );if _fccfa %2!=0{_ee .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_fccfa );
return nil ,_bf .ErrRangeError ;};_ecdcf :=map[string ]interface{}{};for _caebf :=0;_caebf < _fccfa ;_caebf +=2{_fccae ,_afeeb :=_bcdabgb [_caebf ].(string );if !_afeeb {_ee .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_bcdabgb [_caebf ]);
return nil ,_bf .ErrTypeError ;};_ecdcf [_fccae ]=_bcdabgb [_caebf +1];};return _ecdcf ,nil ;};func (_cfcf *templateProcessor )parseLine (_edbgc *templateNode )(interface{},error ){_gbcea :=_cfcf .creator .NewLine (0,0,0,0);for _ ,_dgaef :=range _edbgc ._ebeg .Attr {_cfag :=_dgaef .Value ;
switch _ddcdd :=_dgaef .Name .Local ;_ddcdd {case "\u0078\u0031":_gbcea ._fcgb =_cfcf .parseFloatAttr (_ddcdd ,_cfag );case "\u0079\u0031":_gbcea ._aeea =_cfcf .parseFloatAttr (_ddcdd ,_cfag );case "\u0078\u0032":_gbcea ._eefg =_cfcf .parseFloatAttr (_ddcdd ,_cfag );
case "\u0079\u0032":_gbcea ._bfbgf =_cfcf .parseFloatAttr (_ddcdd ,_cfag );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_gbcea .SetLineWidth (_cfcf .parseFloatAttr (_ddcdd ,_cfag ));case "\u0063\u006f\u006co\u0072":_gbcea .SetColor (_cfcf .parseColorAttr (_ddcdd ,_cfag ));
case "\u0073\u0074\u0079l\u0065":_gbcea .SetStyle (_cfcf .parseLineStyleAttr (_ddcdd ,_cfag ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_gbcea .SetDashPattern (_cfcf .parseInt64Array (_ddcdd ,_cfag ),_gbcea ._edae );case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_gbcea .SetDashPattern (_gbcea ._daab ,_cfcf .parseInt64Attr (_ddcdd ,_cfag ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_gbcea .SetOpacity (_cfcf .parseFloatAttr (_ddcdd ,_cfag ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_gbcea .SetPositioning (_cfcf .parsePositioningAttr (_ddcdd ,_cfag ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_gbcea .SetFitMode (_cfcf .parseFitModeAttr (_ddcdd ,_cfag ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_egafe :=_cfcf .parseMarginAttr (_ddcdd ,_cfag );_gbcea .SetMargins (_egafe .Left ,_egafe .Right ,_egafe .Top ,_egafe .Bottom );default:_cfcf .nodeLogDebug (_edbgc ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ddcdd );
};};return _gbcea ,nil ;};func (_eagb *Invoice )generateHeaderBlocks (_eeaff DrawContext )([]*Block ,DrawContext ,error ){_ecdf :=_ggcdc (_eagb ._dccef );_ecdf .SetEnableWrap (true );_ecdf .Append (_eagb ._aabb );_adff :=_bfdec (2);if _eagb ._dcbc !=nil {_bfgc :=_adff .NewCell ();
_bfgc .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_bfgc .SetVerticalAlignment (CellVerticalAlignmentMiddle );_bfgc .SetIndent (0);_bfgc .SetContent (_eagb ._dcbc );_eagb ._dcbc .ScaleToHeight (_ecdf .Height ()+20);}else {_adff .SkipCells (1);
};_bada :=_adff .NewCell ();_bada .SetHorizontalAlignment (CellHorizontalAlignmentRight );_bada .SetVerticalAlignment (CellVerticalAlignmentMiddle );_bada .SetContent (_ecdf );return _adff .GeneratePageBlocks (_eeaff );};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_eggf *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_geeeb :=&_eggf ._eada ;_geeeb .Left =left ;_geeeb .Right =right ;_geeeb .Top =top ;_geeeb .Bottom =bottom ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_daaaa *Invoice )BuyerAddress ()*InvoiceAddress {return _daaaa ._ecff };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_dacf *shading )SetBackgroundColor (backgroundColor Color ){_dacf ._cfgfd =backgroundColor };func (_eagff *templateProcessor )parseAttrPropList (_bbfbb string )map[string ]string {_fabba :=_dd .Fields (_bbfbb );if len (_fabba )==0{return nil ;};_edcaf :=map[string ]string {};
for _ ,_bagga :=range _fabba {_caafa :=_cgce .FindStringSubmatch (_bagga );if len (_caafa )< 3{continue ;};_edgb ,_cadec :=_dd .TrimSpace (_caafa [1]),_caafa [2];if _edgb ==""{continue ;};_edcaf [_edgb ]=_cadec ;};return _edcaf ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_dgca *Creator )SetPageLabels (pageLabels _bf .PdfObject ){_dgca ._fdga =pageLabels };

// Append adds a new text chunk to the paragraph.
func (_acge *StyledParagraph )Append (text string )*TextChunk {_aafdc :=NewTextChunk (text ,_acge ._abeaf );return _acge .appendChunk (_aafdc );};var (_cgce =_bc .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");
_eeaffa =_ge .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");_gcgf =_ge .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");
_fbdf =_ge .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");_ecfd =_ge .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e");
);

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_bfeg *Image )SetMargins (left ,right ,top ,bottom float64 ){_bfeg ._ecd .Left =left ;_bfeg ._ecd .Right =right ;_bfeg ._ecd .Top =top ;_bfeg ._ecd .Bottom =bottom ;};

// NewFilledCurve returns a instance of filled curve.
func (_eaafe *Creator )NewFilledCurve ()*FilledCurve {return _egbg ()};

// Height returns the height of the ellipse.
func (_acbd *Ellipse )Height ()float64 {return _acbd ._dgdg };func _eced (_fdca string ,_abeag TextStyle )*Paragraph {_cggf :=&Paragraph {_bcecc :_fdca ,_bebf :_abeag .Font ,_gfddf :_abeag .FontSize ,_degf :1.0,_bacce :true ,_gecd :true ,_dacg :TextAlignmentLeft ,_eagec :0,_bcee :1,_agbad :1,_geee :PositionRelative };
_cggf .SetColor (_abeag .Color );return _cggf ;};func (_ddebc *templateProcessor )parseRectangle (_geda *templateNode )(interface{},error ){_agaa :=_ddebc .creator .NewRectangle (0,0,0,0);for _ ,_bcgba :=range _geda ._ebeg .Attr {_baeccg :=_bcgba .Value ;
switch _fafge :=_bcgba .Name .Local ;_fafge {case "\u0078":_agaa ._bgcbe =_ddebc .parseFloatAttr (_fafge ,_baeccg );case "\u0079":_agaa ._aagb =_ddebc .parseFloatAttr (_fafge ,_baeccg );case "\u0077\u0069\u0064t\u0068":_agaa .SetWidth (_ddebc .parseFloatAttr (_fafge ,_baeccg ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_agaa .SetHeight (_ddebc .parseFloatAttr (_fafge ,_baeccg ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_agaa .SetFillColor (_ddebc .parseColorAttr (_fafge ,_baeccg ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_agaa .SetFillOpacity (_ddebc .parseFloatAttr (_fafge ,_baeccg ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_agaa .SetBorderColor (_ddebc .parseColorAttr (_fafge ,_baeccg ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_agaa .SetBorderOpacity (_ddebc .parseFloatAttr (_fafge ,_baeccg ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_agaa .SetBorderWidth (_ddebc .parseFloatAttr (_fafge ,_baeccg ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_edbd ,_efdbe ,_dccbe ,_egda :=_ddebc .parseBorderRadiusAttr (_fafge ,_baeccg );
_agaa .SetBorderRadius (_edbd ,_efdbe ,_egda ,_dccbe );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_agaa ._bfbf =_ddebc .parseFloatAttr (_fafge ,_baeccg );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_agaa ._gefff =_ddebc .parseFloatAttr (_fafge ,_baeccg );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_agaa ._fgegb =_ddebc .parseFloatAttr (_fafge ,_baeccg );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_agaa ._bcfag =_ddebc .parseFloatAttr (_fafge ,_baeccg );
case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_agaa .SetPositioning (_ddebc .parsePositioningAttr (_fafge ,_baeccg ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_agaa .SetFitMode (_ddebc .parseFitModeAttr (_fafge ,_baeccg ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cdcd :=_ddebc .parseMarginAttr (_fafge ,_baeccg );
_agaa .SetMargins (_cdcd .Left ,_cdcd .Right ,_cdcd .Top ,_cdcd .Bottom );default:_ddebc .nodeLogDebug (_geda ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020re\u0063\u0074\u0061\u006e\u0067\u006ce\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_fafge );
};};return _agaa ,nil ;};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_fga *Chart )Width ()float64 {return float64 (_fga ._eebf .Width ())};

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_gfed *Rectangle )ScaleToHeight (h float64 ){_ddeg :=_gfed ._cdagc /_gfed ._ddbcg ;_gfed ._ddbcg =h ;_gfed ._cdagc =h *_ddeg ;};

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_gbgd *Rectangle )SetPositioning (position Positioning ){_gbgd ._efee =position };

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_cdfa *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_gbfe []*Block ;_eadef =NewBlock (ctx .PageWidth ,ctx .PageHeight );_gege =ctx ;_egde =_cdfa ._egdc /2;);_egcg :=_cdfa ._efee .IsRelative ();if _egcg {_cdfa .applyFitMode (ctx .Width );
ctx .X +=_cdfa ._caegfd .Left +_egde ;ctx .Y +=_cdfa ._caegfd .Top +_egde ;ctx .Width -=_cdfa ._caegfd .Left +_cdfa ._caegfd .Right ;ctx .Height -=_cdfa ._caegfd .Top +_cdfa ._caegfd .Bottom ;if _cdfa ._ddbcg > ctx .Height {_gbfe =append (_gbfe ,_eadef );
_eadef =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gbge :=ctx ;_gbge .Y =ctx .Margins .Top +_cdfa ._caegfd .Top +_egde ;_gbge .X =ctx .Margins .Left +_cdfa ._caegfd .Left +_egde ;_gbge .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_cdfa ._caegfd .Top -_cdfa ._caegfd .Bottom ;
_gbge .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cdfa ._caegfd .Left -_cdfa ._caegfd .Right ;ctx =_gbge ;};}else {ctx .X =_cdfa ._bgcbe ;ctx .Y =_cdfa ._aagb ;};_gdee :=_gad .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_cdfa ._ddbcg ,Width :_cdfa ._cdagc ,Height :_cdfa ._ddbcg ,BorderRadiusTopLeft :_cdfa ._bfbf ,BorderRadiusTopRight :_cdfa ._gefff ,BorderRadiusBottomLeft :_cdfa ._fgegb ,BorderRadiusBottomRight :_cdfa ._bcfag ,Opacity :1.0};
if _cdfa ._eade !=nil {_gdee .FillEnabled =true ;_cfgb :=_dcgf (_cdfa ._eade );_aggbg :=_agab (_eadef ,_cfgb ,_cdfa ._eade ,func ()Rectangle {return Rectangle {_bgcbe :_gdee .X ,_aagb :_gdee .Y ,_cdagc :_gdee .Width ,_ddbcg :_gdee .Height };});if _aggbg !=nil {return nil ,ctx ,_aggbg ;
};_gdee .FillColor =_cfgb ;};if _cdfa ._acbae !=nil &&_cdfa ._egdc > 0{_gdee .BorderEnabled =true ;_gdee .BorderColor =_dcgf (_cdfa ._acbae );_gdee .BorderWidth =_cdfa ._egdc ;};_cabe ,_ffgd :=_eadef .setOpacity (_cdfa ._fbcfb ,_cdfa ._cegge );if _ffgd !=nil {return nil ,ctx ,_ffgd ;
};_dbdef ,_ ,_ffgd :=_gdee .Draw (_cabe );if _ffgd !=nil {return nil ,ctx ,_ffgd ;};if _ffgd =_eadef .addContentsByString (string (_dbdef ));_ffgd !=nil {return nil ,ctx ,_ffgd ;};if _egcg {ctx .X =_gege .X ;ctx .Width =_gege .Width ;_dfcd :=_cdfa ._ddbcg +_egde ;
ctx .Y +=_dfcd +_cdfa ._caegfd .Bottom ;ctx .Height -=_dfcd ;}else {ctx =_gege ;};_gbfe =append (_gbfe ,_eadef );return _gbfe ,ctx ,nil ;};func _fdd (_bdba [][]_gad .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_cba :&_gad .CurvePolygon {Rings :_bdba },_eedg :1.0,_dggg :1.0};
};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetStyleRight sets border style for right side.
func (_cdcb *border )SetStyleRight (style CellBorderStyle ){_cdcb ._aadc =style };

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_cgcc *Paragraph )Height ()float64 {_cgcc .wrapText ();return float64 (len (_cgcc ._fffef ))*_cgcc ._degf *_cgcc ._gfddf ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fffa *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _fffa ._cadc [0],_fffa ._cadc [1]};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_cdea *LinearShading )SetExtends (start bool ,end bool ){_cdea ._ebade .SetExtends (start ,end )};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);
ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_fbbd *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fbbd ._ggfad .Left ,_fbbd ._ggfad .Right ,_fbbd ._ggfad .Top ,_fbbd ._ggfad .Bottom ;};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_fbfg *Line )SetColor (color Color ){_fbfg ._baefg =color };

// Height returns the height of the list.
func (_ggbgb *List )Height ()float64 {var _gafba float64 ;for _ ,_ggcd :=range _ggbgb ._gebg {_gafba +=_ggcd .ctxHeight (_ggbgb .Width ());};return _gafba ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_aaab *Paragraph )SetTextAlignment (align TextAlignment ){_aaab ._dacg =align };func (_afce *templateProcessor )parseChapter (_debg *templateNode )(interface{},error ){_ecgef :=_afce .creator .NewChapter ;if _debg ._afbge !=nil {if _fgag ,_ebac :=_debg ._afbge ._dceb .(*Chapter );
_ebac {_ecgef =_fgag .NewSubchapter ;};};_agcd :=_ecgef ("");for _ ,_efcfd :=range _debg ._ebeg .Attr {_abfc :=_efcfd .Value ;switch _cade :=_efcfd .Name .Local ;_cade {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_agcd .SetShowNumbering (_afce .parseBoolAttr (_cade ,_abfc ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_agcd .SetIncludeInTOC (_afce .parseBoolAttr (_cade ,_abfc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_egfg :=_afce .parseMarginAttr (_cade ,_abfc );_agcd .SetMargins (_egfg .Left ,_egfg .Right ,_egfg .Top ,_egfg .Bottom );
default:_afce .nodeLogDebug (_debg ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cade );
};};return _agcd ,nil ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_cadg *LinearShading )SetAntiAlias (enable bool ){_cadg ._ebade .SetAntiAlias (enable )};func (_bdb *pageTransformations )transformPage (_dea *_bbd .PdfPage )error {if _bfbeg :=_bdb .applyFlip (_dea );_bfbeg !=nil {return _bfbeg ;};return nil ;};


// CreateTableOfContents sets a function to generate table of contents.
func (_cgff *Creator )CreateTableOfContents (genTOCFunc func (_ccda *TOC )error ){_cgff ._bef =genTOCFunc ;};

// SkipOver skips over a specified number of rows and cols.
func (_baaa *Table )SkipOver (rows ,cols int ){_cfde :=rows *_baaa ._efbf +cols -1;if _cfde < 0{_ee .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _ccfg :=0;_ccfg < _cfde ;_ccfg ++{_baaa .NewCell ();};};

// SetWidthTop sets border width for top.
func (_bcf *border )SetWidthTop (bw float64 ){_bcf ._eeb =bw };

// SetBorderColor sets the border color.
func (_fdda *Polygon )SetBorderColor (color Color ){_fdda ._bbbe .BorderColor =_dcgf (color )};func (_gbecd *templateProcessor )run ()error {_bfagb :=_f .NewDecoder (_fg .NewReader (_gbecd ._fgeb ));var _geeab *templateNode ;for {_acbeg ,_bedge :=_bfagb .Token ();
if _bedge !=nil {if _bedge ==_ga .EOF {return nil ;};return _bedge ;};if _acbeg ==nil {break ;};_cfdfe ,_bgeba :=_febfd (_bfagb );_adfg :=_bfagb .InputOffset ();switch _ecbgb :=_acbeg .(type ){case _f .StartElement :_ee .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_ecbgb .Name .Local );
_daec ,_faabg :=_bcfge [_ecbgb .Name .Local ];if !_faabg {if _gbecd ._dedc ==""{if _cfdfe !=0{_ee .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0064\u003a\u0025\u0064\u005d",_ecbgb .Name .Local ,_cfdfe ,_bgeba );
}else {_ee .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070i\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u002e\u0020\u005b%\u0064\u005d",_ecbgb .Name .Local ,_adfg );
};}else {if _cfdfe !=0{_ee .Log .Debug ("\u0055\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0074e\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u003a\u0025d\u005d",_ecbgb .Name .Local ,_gbecd ._dedc ,_cfdfe ,_bgeba );
}else {_ee .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006dp\u006c\u0061\u0074\u0065 \u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e\u0020\u005b%\u0073\u003a\u0025\u0064\u005d",_ecbgb .Name .Local ,_gbecd ._dedc ,_adfg );
};};continue ;};_geeab =&templateNode {_ebeg :_ecbgb ,_afbge :_geeab ,_dfcc :_cfdfe ,_efaa :_bgeba ,_bcbaa :_adfg };if _baac :=_daec ._eecgd ;_baac !=nil {_geeab ._dceb ,_bedge =_baac (_gbecd ,_geeab );if _bedge !=nil {return _bedge ;};};case _f .EndElement :_ee .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_ecbgb .Name .Local );
if _geeab !=nil {if _geeab ._dceb !=nil {if _cbbae :=_gbecd .renderNode (_geeab );_cbbae !=nil {return _cbbae ;};};_geeab =_geeab ._afbge ;};case _f .CharData :if _geeab !=nil &&_geeab ._dceb !=nil {if _facag :=_gbecd .addNodeText (_geeab ,string (_ecbgb ));
_facag !=nil {return _facag ;};};case _f .Comment :_ee .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_ecbgb ));
};};return nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_eaeb *Paragraph )SetLineHeight (lineheight float64 ){_eaeb ._degf =lineheight };func (_dbgbe *StyledParagraph )getTextWidth ()float64 {var _cdgdd float64 ;_bcae :=len (_dbgbe ._gacc );for _agdg ,_beee :=range _dbgbe ._gacc {_afgea :=&_beee .Style ;
_fbfgc :=len (_beee .Text );for _ebgf ,_aagce :=range _beee .Text {if _aagce =='\u000A'{continue ;};_bdac ,_cgbg :=_afgea .Font .GetRuneMetrics (_aagce );if !_cgbg {_ee .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_aagce );
return -1;};_cdgdd +=_afgea .FontSize *_bdac .Wx *_afgea .horizontalScale ();if _aagce !=' '&&(_agdg !=_bcae -1||_ebgf !=_fbfgc -1){_cdgdd +=_afgea .CharSpacing *1000.0;};};};return _cdgdd ;};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_cebcg *TOC )SetLineLevelOffset (levelOffset float64 ){_cebcg ._addd =levelOffset };

// FitMode returns the fit mode of the ellipse.
func (_aaaa *Ellipse )FitMode ()FitMode {return _aaaa ._aacb };func (_becg *templateProcessor )parseTable (_ccdg *templateNode )(interface{},error ){var _fgbac int64 ;for _ ,_gbdg :=range _ccdg ._ebeg .Attr {_face :=_gbdg .Value ;switch _ccgc :=_gbdg .Name .Local ;
_ccgc {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_fgbac =_becg .parseInt64Attr (_ccgc ,_face );};};if _fgbac <=0{_becg .nodeLogDebug (_ccdg ,"\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_fgbac );
_fgbac =1;};_bcafeg :=_becg .creator .NewTable (int (_fgbac ));for _ ,_fdde :=range _ccdg ._ebeg .Attr {_cegf :=_fdde .Value ;switch _fgbfb :=_fdde .Name .Local ;_fgbfb {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_bcafeg .SetColumnWidths (_becg .parseFloatArray (_fgbfb ,_cegf )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_bbgac :=_becg .parseMarginAttr (_fgbfb ,_cegf );_bcafeg .SetMargins (_bbgac .Left ,_bbgac .Right ,_bbgac .Top ,_bbgac .Bottom );case "\u0078":_bcafeg .SetPos (_becg .parseFloatAttr (_fgbfb ,_cegf ),_bcafeg ._fdacc );
case "\u0079":_bcafeg .SetPos (_bcafeg ._dcfa ,_becg .parseFloatAttr (_fgbfb ,_cegf ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_bcafeg ._gdae =int (_becg .parseInt64Attr (_fgbfb ,_cegf ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_bcafeg ._fefce =int (_becg .parseInt64Attr (_fgbfb ,_cegf ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_bcafeg .EnableRowWrap (_becg .parseBoolAttr (_fgbfb ,_cegf ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_bcafeg .EnablePageWrap (_becg .parseBoolAttr (_fgbfb ,_cegf ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_becg .nodeLogDebug (_ccdg ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_fgbfb );
};};if _bcafeg ._gdae !=0&&_bcafeg ._fefce !=0{_ccae :=_bcafeg .SetHeaderRows (_bcafeg ._gdae ,_bcafeg ._fefce );if _ccae !=nil {_becg .nodeLogDebug (_ccdg ,"\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_ccae );
};}else {_bcafeg ._gdae =0;_bcafeg ._fefce =0;};return _bcafeg ,nil ;};

// AddColorStop add color stop info for rendering gradient color.
func (_dcdcd *LinearShading )AddColorStop (color Color ,point float64 ){_dcdcd ._ebade .AddColorStop (color ,point );};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_aadf *TOC )SetLineStyle (style TextStyle ){_aadf .SetLineNumberStyle (style );_aadf .SetLineTitleStyle (style );_aadf .SetLineSeparatorStyle (style );_aadf .SetLinePageStyle (style );};

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_acgb *Rectangle )GetCoords ()(float64 ,float64 ){return _acgb ._bgcbe ,_acgb ._aagb };func _dfea (_dfc *Chapter ,_dfbf *TOC ,_dbed *_bbd .Outline ,_aec string ,_fgb int ,_bcag TextStyle )*Chapter {var _cgc uint =1;if _dfc !=nil {_cgc =_dfc ._ddf +1;
};_adde :=&Chapter {_eca :_fgb ,_feb :_aec ,_ffef :true ,_efb :true ,_bcd :_dfc ,_abc :_dfbf ,_babb :_dbed ,_gba :[]Drawable {},_ddf :_cgc };_bag :=_eced (_adde .headingText (),_bcag );_bag .SetFont (_bcag .Font );_bag .SetFontSize (_bcag .FontSize );_adde ._fgef =_bag ;
return _adde ;};

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_bfaed *GraphicSVG )SetPos (x ,y float64 ){_bfaed ._aedcf =PositionAbsolute ;_bfaed ._ddfe =x ;_bfaed ._bgbba =y ;};

// Write output of creator to io.Writer interface.
func (_cadf *Creator )Write (ws _ga .Writer )error {if _fedd :=_cadf .Finalize ();_fedd !=nil {return _fedd ;};_bcde :=_bbd .NewPdfWriter ();_bcde .SetOptimizer (_cadf ._eadg );if _cadf ._bagc !=nil {_bfdd :=_bcde .SetForms (_cadf ._bagc );if _bfdd !=nil {_ee .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bfdd );
return _bfdd ;};};if _cadf ._bagg !=nil {_bcde .AddOutlineTree (_cadf ._bagg );}else if _cadf ._cda !=nil &&_cadf .AddOutlines {_bcde .AddOutlineTree (&_cadf ._cda .ToPdfOutline ().PdfOutlineTreeNode );};if _cadf ._fdga !=nil {if _adad :=_bcde .SetPageLabels (_cadf ._fdga );
_adad !=nil {_ee .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_adad );return _adad ;};};if _cadf ._bbca !=nil {for _ ,_bdfb :=range _cadf ._bbca {_adag :=_bdfb .SubsetRegistered ();
if _adag !=nil {_ee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_adag );return _adag ;};};};if _cadf ._cfdb !=nil {_aedaa :=_cadf ._cfdb (&_bcde );
if _aedaa !=nil {_ee .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_aedaa );return _aedaa ;};};for _ ,_ecbd :=range _cadf ._afbe {_bcbd :=_bcde .AddPage (_ecbd );if _bcbd !=nil {_ee .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_bcbd );
return _bcbd ;};};_ffefd :=_bcde .Write (ws );if _ffefd !=nil {return _ffefd ;};return nil ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_ggc *Creator )MoveRight (dx float64 ){_ggc ._ffdd .X +=dx };

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_eabg *shading )SetExtends (start bool ,end bool ){_eabg ._aeaa =[]bool {start ,end }};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_cbef *Creator )PageFinalize (pageFinalizeFunc func (_cfdg PageFinalizeFunctionArgs )error ){_cbef ._efd =pageFinalizeFunc ;};func _dec (_ggd *_da .ContentStreamOperations ,_dg *_bbd .PdfPageResources ,_ccg *_da .ContentStreamOperations ,_aegg *_bbd .PdfPageResources )error {_gcgb :=map[_bf .PdfObjectName ]_bf .PdfObjectName {};
_ded :=map[_bf .PdfObjectName ]_bf .PdfObjectName {};_eac :=map[_bf .PdfObjectName ]_bf .PdfObjectName {};_cfg :=map[_bf .PdfObjectName ]_bf .PdfObjectName {};_gef :=map[_bf .PdfObjectName ]_bf .PdfObjectName {};_aad :=map[_bf .PdfObjectName ]_bf .PdfObjectName {};
for _ ,_bbe :=range *_ccg {switch _bbe .Operand {case "\u0044\u006f":if len (_bbe .Params )==1{if _gaed ,_gegf :=_bbe .Params [0].(*_bf .PdfObjectName );_gegf {if _ ,_ecf :=_gcgb [*_gaed ];!_ecf {var _ef _bf .PdfObjectName ;_dfa ,_ :=_aegg .GetXObjectByName (*_gaed );
if _dfa !=nil {_ef =*_gaed ;for {_gafd ,_ :=_dg .GetXObjectByName (_ef );if _gafd ==nil ||_gafd ==_dfa {break ;};_ef =*_bf .MakeName (_baa (_ef .String ()));};};_dg .SetXObjectByName (_ef ,_dfa );_gcgb [*_gaed ]=_ef ;};_edee :=_gcgb [*_gaed ];_bbe .Params [0]=&_edee ;
};};case "\u0054\u0066":if len (_bbe .Params )==2{if _ffg ,_fec :=_bbe .Params [0].(*_bf .PdfObjectName );_fec {if _ ,_cae :=_ded [*_ffg ];!_cae {_fgf ,_decc :=_aegg .GetFontByName (*_ffg );_caef :=*_ffg ;if _decc &&_fgf !=nil {_caef =_ffge (_ffg .String (),_fgf ,_dg );
};_dg .SetFontByName (_caef ,_fgf );_ded [*_ffg ]=_caef ;};_dfb :=_ded [*_ffg ];_bbe .Params [0]=&_dfb ;};};case "\u0043\u0053","\u0063\u0073":if len (_bbe .Params )==1{if _ddg ,_cff :=_bbe .Params [0].(*_bf .PdfObjectName );_cff {if _ ,_bad :=_eac [*_ddg ];
!_bad {var _cca _bf .PdfObjectName ;_acg ,_ffd :=_aegg .GetColorspaceByName (*_ddg );if _ffd {_cca =*_ddg ;for {_fgfd ,_gcc :=_dg .GetColorspaceByName (_cca );if !_gcc ||_acg ==_fgfd {break ;};_cca =*_bf .MakeName (_baa (_cca .String ()));};_dg .SetColorspaceByName (_cca ,_acg );
_eac [*_ddg ]=_cca ;}else {_ee .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _adgd ,_cefd :=_eac [*_ddg ];_cefd {_bbe .Params [0]=&_adgd ;}else {_ee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_ddg );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_bbe .Params )==1{if _cfe ,_cce :=_bbe .Params [0].(*_bf .PdfObjectName );_cce {if _ ,_caag :=_cfg [*_cfe ];!_caag {var _abb _bf .PdfObjectName ;_acb ,_gcb :=_aegg .GetPatternByName (*_cfe );
if _gcb {_abb =*_cfe ;for {_bfg ,_eba :=_dg .GetPatternByName (_abb );if !_eba ||_bfg ==_acb {break ;};_abb =*_bf .MakeName (_baa (_abb .String ()));};_eeg :=_dg .SetPatternByName (_abb ,_acb .ToPdfObject ());if _eeg !=nil {return _eeg ;};_cfg [*_cfe ]=_abb ;
};};if _eacg ,_agc :=_cfg [*_cfe ];_agc {_bbe .Params [0]=&_eacg ;};};};case "\u0073\u0068":if len (_bbe .Params )==1{if _fbb ,_ceg :=_bbe .Params [0].(*_bf .PdfObjectName );_ceg {if _ ,_ffc :=_gef [*_fbb ];!_ffc {var _bbc _bf .PdfObjectName ;_ggb ,_dgd :=_aegg .GetShadingByName (*_fbb );
if _dgd {_bbc =*_fbb ;for {_dce ,_bea :=_dg .GetShadingByName (_bbc );if !_bea ||_ggb ==_dce {break ;};_bbc =*_bf .MakeName (_baa (_bbc .String ()));};_ecb :=_dg .SetShadingByName (_bbc ,_ggb .ToPdfObject ());if _ecb !=nil {_ee .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_ecb );
return _ecb ;};_gef [*_fbb ]=_bbc ;}else {_ee .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _agd ,_geb :=_gef [*_fbb ];_geb {_bbe .Params [0]=&_agd ;}else {_ee .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_fbb );
};};};case "\u0067\u0073":if len (_bbe .Params )==1{if _afb ,_gea :=_bbe .Params [0].(*_bf .PdfObjectName );_gea {if _ ,_fab :=_aad [*_afb ];!_fab {var _aega _bf .PdfObjectName ;_fgfe ,_bge :=_aegg .GetExtGState (*_afb );if _bge {_aega =*_afb ;for {_dbc ,_bgeg :=_dg .GetExtGState (_aega );
if !_bgeg ||_fgfe ==_dbc {break ;};_aega =*_bf .MakeName (_baa (_aega .String ()));};};_dg .AddExtGState (_aega ,_fgfe );_aad [*_afb ]=_aega ;};_fgc :=_aad [*_afb ];_bbe .Params [0]=&_fgc ;};};};*_ggd =append (*_ggd ,_bbe );};return nil ;};

// SetBorderColor sets the border color of the ellipse.
func (_cgeaa *Ellipse )SetBorderColor (col Color ){_cgeaa ._dgdf =col };

// AddTotalLine adds a new line in the invoice totals table.
func (_dfbbd *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_eccdc :=&InvoiceCell {_dfbbd ._aefg ,desc };_acbe :=&InvoiceCell {_dfbbd ._aefg ,value };_dfbbd ._bgebb =append (_dfbbd ._bgebb ,[2]*InvoiceCell {_eccdc ,_acbe });return _eccdc ,_acbe ;
};

// String implements error interface.
func (_bbdd UnsupportedRuneError )Error ()string {return _bbdd .Message };

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ec *_da .ContentStreamOperations ;_ce *_bbd .PdfPageResources ;_daf Positioning ;_ea ,_fd float64 ;_eg float64 ;_gg float64 ;_fc float64 ;_cf Margins ;_cb []*_bbd .PdfAnnotation ;};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };
PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);func _efbee (_bggb string )(*GraphicSVG ,error ){_cfcg ,_gead :=_bd .ParseFromString (_bggb );if _gead !=nil {return nil ,_gead ;
};return _adfd (_cfcg );};

// GetCoords returns coordinates of border.
func (_fcef *border )GetCoords ()(float64 ,float64 ){return _fcef ._dgf ,_fcef ._fcb };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_gbege *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_aebga :=&_gbege ._ebca ._dadf ;return _gbege ._ggcac ,_aebga .Right ,_aebga .Top ,_aebga .Bottom ;};

// Columns returns all the columns in the invoice line items table.
func (_fbcgb *Invoice )Columns ()[]*InvoiceCell {return _fbcgb ._agbb };

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_dfdce *RadialShading )AddPatternResource (block *Block )(_dgdc _bf .PdfObjectName ,_eadgc error ){_edege :=1;_defa :=_bf .PdfObjectName ("\u0050"+_bb .Itoa (_edege ));for block ._ce .HasPatternByName (_defa ){_edege ++;_defa =_bf .PdfObjectName ("\u0050"+_bb .Itoa (_edege ));
};if _geeaa :=block ._ce .SetPatternByName (_defa ,_dfdce .ToPdfShadingPattern ().ToPdfObject ());_geeaa !=nil {return "",_geeaa ;};return _defa ,nil ;};func _dabef (_eaaec float64 ,_gaace int )float64 {_cedb :=_bbg .Pow10 (_gaace );return _bbg .Round (_cedb *_eaaec )/_cedb ;
};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_egfa *Invoice )Terms ()(string ,string ){return _egfa ._caeed [0],_egfa ._caeed [1]};

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_ebgb *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ebgb ._fdcb .Left ,_ebgb ._fdcb .Right ,_ebgb ._fdcb .Top ,_ebgb ._fdcb .Bottom ;};

// SetNumber sets the number of the invoice.
func (_bedd *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_bedd ._aca [1].Value =number ;return _bedd ._aca [0],_bedd ._aca [1];};

// SetBorderRadius sets the radius of the rectangle corners.
func (_bcbe *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_bcbe ._bfbf =topLeft ;_bcbe ._gefff =topRight ;_bcbe ._fgegb =bottomLeft ;_bcbe ._bcfag =bottomRight ;};func (_eaac *Division )split (_ggca DrawContext )(_feee ,_fdge *Division ){var (_eebb float64 ;
_gaaf ,_ccee []VectorDrawable ;);_fgg :=_ggca .Width -_eaac ._ggea .Left -_eaac ._ggea .Right -_eaac ._eabe .Left -_eaac ._eabe .Right ;for _afgb ,_ecabd :=range _eaac ._befg {_eebb +=_gcgga (_ecabd ,_fgg );if _eebb < _ggca .Height {_gaaf =append (_gaaf ,_ecabd );
}else {_ccee =_eaac ._befg [_afgb :];break ;};};if len (_gaaf )> 0{_feee =_cebc ();*_feee =*_eaac ;_feee ._befg =_gaaf ;if _eaac ._cacc !=nil {_feee ._cacc =&Background {};*_feee ._cacc =*_eaac ._cacc ;};};if len (_ccee )> 0{_fdge =_cebc ();*_fdge =*_eaac ;
_fdge ._befg =_ccee ;if _eaac ._cacc !=nil {_fdge ._cacc =&Background {};*_fdge ._cacc =*_eaac ._cacc ;};};return _feee ,_fdge ;};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_edbfe *TOCLine )SetStyle (style TextStyle ){_edbfe .Number .Style =style ;_edbfe .Title .Style =style ;_edbfe .Separator .Style =style ;_edbfe .Page .Style =style ;};

// Length calculates and returns the length of the line.
func (_fecge *Line )Length ()float64 {return _bbg .Sqrt (_bbg .Pow (_fecge ._eefg -_fecge ._fcgb ,2.0)+_bbg .Pow (_fecge ._bfbgf -_fecge ._aeea ,2.0));};

// SetWidthLeft sets border width for left.
func (_eaa *border )SetWidthLeft (bw float64 ){_eaa ._dafd =bw };func _gaegg (_ffbcb *Creator ,_gdbfd string ,_eaec []byte ,_ecbcd *TemplateOptions ,_abgfc componentRenderer )*templateProcessor {if _ecbcd ==nil {_ecbcd =&TemplateOptions {};};_ecbcd .init ();
if _abgfc ==nil {_abgfc =_ffbcb ;};return &templateProcessor {creator :_ffbcb ,_fgeb :_eaec ,_afgef :_ecbcd ,_gdeg :_abgfc ,_dedc :_gdbfd };};

// NewPageBreak create a new page break.
func (_abeg *Creator )NewPageBreak ()*PageBreak {return _gaebg ()};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_dgaeag *Paragraph )SetWidth (width float64 ){_dgaeag ._cfedb =width ;_dgaeag .wrapText ()};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_cafdg *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cafdg ._ecd .Left ,_cafdg ._ecd .Right ,_cafdg ._ecd .Top ,_cafdg ._ecd .Bottom ;};

// AddColorStop add color stop info for rendering gradient color.
func (_ceae *RadialShading )AddColorStop (color Color ,point float64 ){_ceae ._daacc .AddColorStop (color ,point );};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_cgcf *Ellipse )BorderOpacity ()float64 {return _cgcf ._eaf };

// SetFillOpacity sets the fill opacity.
func (_fgcab *Polygon )SetFillOpacity (opacity float64 ){_fgcab ._cfeea =opacity };func _bfdec (_afdf int )*Table {_acbdb :=&Table {_efbf :_afdf ,_bcgeag :10.0,_ecgg :[]float64 {},_abaa :[]float64 {},_gggdf :[]*TableCell {},_ecaf :make ([]int ,_afdf ),_gdaa :true };
_acbdb .resetColumnWidths ();return _acbdb ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_dgfbc *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dgfbc ._afcg .Left ,_dgfbc ._afcg .Right ,_dgfbc ._afcg .Top ,_dgfbc ._afcg .Bottom ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_ebca *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_ggcac float64 ;_fffag uint ;_ebadg float64 ;_cgcba Positioning ;_fggb float64 ;_bdeg float64 ;_bgge int64 ;};

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_fgce Color ;_gabg float64 ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_ad *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eee :=_eb .IdentityMatrix ();_ede ,_afg :=_ad .Width (),_ad .Height ();if _ad ._daf .IsRelative (){_eee =_eee .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_afg );}else {_eee =_eee .Translate (_ad ._ea ,ctx .PageHeight -_ad ._fd -_afg );
};_de :=_afg ;if _ad ._fc !=0{_eee =_eee .Translate (_ede /2,_afg /2).Rotate (_ad ._fc *_bbg .Pi /180.0).Translate (-_ede /2,-_afg /2);_ ,_de =_ad .RotatedSize ();};if _ad ._daf .IsRelative (){ctx .Y +=_de ;};_cd :=_da .NewContentCreator ();_cd .Add_cm (_eee [0],_eee [1],_eee [3],_eee [4],_eee [6],_eee [7]);
_gee :=_ad .duplicate ();_fge :=append (*_cd .Operations (),*_gee ._ec ...);_fge .WrapIfNeeded ();_gee ._ec =&_fge ;for _ ,_bdf :=range _ad ._cb {_fcd ,_bdc :=_bf .GetArray (_bdf .Rect );if !_bdc ||_fcd .Len ()!=4{_ee .Log .Debug ("\u0057\u0041\u0052\u004e\u003a \u0069\u006e\u0076\u0061\u006ci\u0064 \u0061\u006e\u006e\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065l\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e",_bdf .Rect );
continue ;};_bbdb ,_dcb :=_bbd .NewPdfRectangle (*_fcd );if _dcb !=nil {_ee .Log .Debug ("\u0057A\u0052N\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074 \u0070\u0061\u0072\u0073e\u0020\u0061\u006e\u006e\u006ft\u0061\u0074\u0069\u006f\u006e\u0020\u0052\u0065\u0063\u0074\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0076\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u002e",_dcb );
continue ;};_bbdb .Transform (_eee );_bdf .Rect =_bbdb .ToPdfObject ();};return []*Block {_gee },ctx ,nil ;};func (_dceg *Image )applyFitMode (_fbfc float64 ){_fbfc -=_dceg ._ecd .Left +_dceg ._ecd .Right ;switch _dceg ._gfeea {case FitModeFillWidth :_dceg .ScaleToWidth (_fbfc );
};};

// TextAlignment options for paragraph.
type TextAlignment int ;

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_gacc []*TextChunk ;_abeaf TextStyle ;_fbcb TextStyle ;_eceb TextAlignment ;_adbg TextVerticalAlignment ;_dedbc float64 ;_abbea bool ;_ccac float64 ;_cgdf bool ;_ccddf bool ;_ggfg TextOverflow ;_fabd float64 ;_dadf Margins ;
_dageg Positioning ;_bebdg float64 ;_egfdb float64 ;_fbefe float64 ;_bcac float64 ;_gegeg [][]*TextChunk ;_cbee func (_fgaf *StyledParagraph ,_ggbcf DrawContext );};func _cdgbb (_eafeg string ,_gabf ,_bdgcc TextStyle )*TOC {_dddfgf :=_bdgcc ;_dddfgf .FontSize =14;
_gbfacg :=_ggcdc (_dddfgf );_gbfacg .SetEnableWrap (true );_gbfacg .SetTextAlignment (TextAlignmentLeft );_gbfacg .SetMargins (0,0,0,5);_cfgae :=_gbfacg .Append (_eafeg );_cfgae .Style =_dddfgf ;return &TOC {_efaae :_gbfacg ,_dcbb :[]*TOCLine {},_febc :_gabf ,_abgfe :_gabf ,_dbfaf :_gabf ,_gfgag :_gabf ,_abdbb :"\u002e",_addd :10,_eada :Margins {0,0,2,2},_cgcad :PositionRelative ,_gecg :_gabf ,_fbfca :true };
};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_cafcc *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cccg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fbcff ,_cfcga :=_cccg .setOpacity (_cafcc ._faba ,_cafcc ._bbga );if _cfcga !=nil {return nil ,ctx ,_cfcga ;
};_cegg :=_cafcc ._cgbc ;_cegg .FillEnabled =_cegg .FillColor !=nil ;var (_afaa =ctx .PageHeight ;_dcbf =_cegg .Curves ;_feda =make ([]_gad .CubicBezierCurve ,0,len (_cegg .Curves )););_bdfc :=_bbd .PdfRectangle {};for _ceea :=range _cegg .Curves {_eff :=_dcbf [_ceea ];
_eff .P0 .Y =_afaa -_eff .P0 .Y ;_eff .P1 .Y =_afaa -_eff .P1 .Y ;_eff .P2 .Y =_afaa -_eff .P2 .Y ;_eff .P3 .Y =_afaa -_eff .P3 .Y ;_feda =append (_feda ,_eff );_dgdd :=_eff .GetBounds ();if _ceea ==0{_bdfc =_dgdd ;}else {_bdfc .Llx =_bbg .Min (_bdfc .Llx ,_dgdd .Llx );
_bdfc .Lly =_bbg .Min (_bdfc .Lly ,_dgdd .Lly );_bdfc .Urx =_bbg .Max (_bdfc .Urx ,_dgdd .Urx );_bdfc .Ury =_bbg .Max (_bdfc .Ury ,_dgdd .Ury );};};_cegg .Curves =_feda ;defer func (){_cegg .Curves =_dcbf }();if _cegg .FillEnabled {_ffbce :=_agab (_cccg ,_cafcc ._cgbc .FillColor ,_cafcc ._fddb ,func ()Rectangle {return Rectangle {_bgcbe :_bdfc .Llx ,_aagb :_bdfc .Lly ,_cdagc :_bdfc .Width (),_ddbcg :_bdfc .Height ()};
});if _ffbce !=nil {return nil ,ctx ,_ffbce ;};};_ceaf ,_ ,_cfcga :=_cegg .Draw (_fbcff );if _cfcga !=nil {return nil ,ctx ,_cfcga ;};if _cfcga =_cccg .addContentsByString (string (_ceaf ));_cfcga !=nil {return nil ,ctx ,_cfcga ;};return []*Block {_cccg },ctx ,nil ;
};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// HelperFuncMap is used to define functions which can be accessed
// inside the rendered templates by their assigned names.
HelperFuncMap _ed .FuncMap ;

// SubtemplateMap contains templates which can be rendered alongside
// the main template. They can be accessed using their assigned names
// in the main template or in the other subtemplates.
// Subtemplates defined inside the subtemplates specified in the map
// can be accessed directly.
// All resources available to the main template are also available
// to the subtemplates.
SubtemplateMap map[string ]_ga .Reader ;

// FontMap contains pre-loaded fonts which can be accessed
// inside the rendered templates by their assigned names.
FontMap map[string ]*_bbd .PdfFont ;

// ImageMap contains pre-loaded images which can be accessed
// inside the rendered templates by their assigned names.
ImageMap map[string ]*_bbd .Image ;

// ColorMap contains colors which can be accessed
// inside the rendered templates by their assigned names.
ColorMap map[string ]Color ;

// ChartMap contains charts which can be accessed
// inside the rendered templates by their assigned names.
ChartMap map[string ]_ba .ChartRenderable ;};func (_aegd *TextChunk )clone ()*TextChunk {_bcefa :=*_aegd ;_bcefa ._gdege =_geafg (_aegd ._gdege );return &_bcefa ;};func (_aea *Creator )setActivePage (_ccd *_bbd .PdfPage ){_aea ._faee =_ccd };

// Cols returns the total number of columns the table has.
func (_bfgcf *Table )Cols ()int {return _bfgcf ._efbf };func (_gbgbg *Table )resetColumnWidths (){_gbgbg ._ecgg =[]float64 {};_befc :=float64 (1.0)/float64 (_gbgbg ._efbf );for _dfgf :=0;_dfgf < _gbgbg ._efbf ;_dfgf ++{_gbgbg ._ecgg =append (_gbgbg ._ecgg ,_befc );
};};type templateNode struct{_dceb interface{};_ebeg _f .StartElement ;_afbge *templateNode ;_dfcc int ;_efaa int ;_bcbaa int64 ;};type shading struct{_cfgfd Color ;_gdfd bool ;_aeaa []bool ;_eeee []*ColorPoint ;};

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_gccbb *GraphicSVG )ScaleToWidth (w float64 ){_fefb :=_gccbb ._gdbd .Height /_gccbb ._gdbd .Width ;_gccbb ._gdbd .Width =w ;_gccbb ._gdbd .Height =w *_fefb ;_gccbb ._gdbd .SetScaling (_fefb ,_fefb );};func (_efc *Chapter )headingText ()string {_bdef :=_efc ._feb ;
if _bdcd :=_efc .headingNumber ();_bdcd !=""{_bdef =_b .Sprintf ("\u0025\u0073\u0020%\u0073",_bdcd ,_bdef );};return _bdef ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);func (_dffcc *templateProcessor )parseFontAttr (_defcg ,_bcbbb string )*_bbd .PdfFont {_ee .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_defcg ,_bcbbb );
_fefca :=_dffcc .creator ._aaaf ;if _bcbbb ==""{return _fefca ;};_ggfgf :=_dd .Split (_bcbbb ,"\u002c");for _ ,_afbae :=range _ggfgf {_afbae =_dd .TrimSpace (_afbae );if _afbae ==""{continue ;};_efge ,_edcac :=_dffcc ._afgef .FontMap [_bcbbb ];if _edcac {return _efge ;
};_egfac ,_edcac :=map[string ]_bbd .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_bbd .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_bbd .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_bbd .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_bbd .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_bbd .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_bbd .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_bbd .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_bbd .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_bbd .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_bbd .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_bbd .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_bbd .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_bbd .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_bbd .TimesBoldItalicName }[_bcbbb ];
if _edcac {if _gbfa ,_aegc :=_bbd .NewStandard14Font (_egfac );_aegc ==nil {return _gbfa ;};};if _adceg :=_dffcc .parseAttrPropList (_afbae );len (_adceg )> 0{if _cegfc ,_abecb :=_adceg ["\u0070\u0061\u0074\u0068"];_abecb {_dgaa :=_bbd .NewPdfFontFromTTFFile ;
if _ggfaf ,_beece :=_adceg ["\u0074\u0079\u0070\u0065"];_beece &&_ggfaf =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_dgaa =_bbd .NewCompositePdfFontFromTTFFile ;};if _cgfdg ,_degc :=_dgaa (_cegfc );_degc !=nil {_ee .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_cegfc ,_degc );
}else {return _cgfdg ;};};};};return _fefca ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bcdab *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _faega float64 ;var _gdcf []*StyledParagraph ;for _ ,_acdab :=range _bcdab ._gebg {_aebd :=_ggcdc (_bcdab ._ddbae );_aebd .SetEnableWrap (false );_aebd .SetTextAlignment (TextAlignmentRight );
_aebd .Append (_acdab ._badgf .Text ).Style =_acdab ._badgf .Style ;_bfca :=_aebd .getTextWidth ()/1000.0/ctx .Width ;if _faega < _bfca {_faega =_bfca ;};_gdcf =append (_gdcf ,_aebd );};_acee :=_bfdec (2);_acee .SetColumnWidths (_faega ,1-_faega );_acee .SetMargins (_bcdab ._ddba .Left +_bcdab ._eaef ,_bcdab ._ddba .Right ,_bcdab ._ddba .Top ,_bcdab ._ddba .Bottom );
_acee .EnableRowWrap (true );for _agbbb ,_dafcc :=range _bcdab ._gebg {_fcada :=_acee .NewCell ();_fcada .SetIndent (0);_fcada .SetContent (_gdcf [_agbbb ]);_fcada =_acee .NewCell ();_fcada .SetIndent (0);_fcada .SetContent (_dafcc ._dgfd );};return _acee .GeneratePageBlocks (ctx );
};func (_acaf *templateProcessor )parseCellBorderStyleAttr (_gdegg ,_acea string )CellBorderStyle {_ee .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_gdegg ,_acea );
_fddeb :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_acea ];return _fddeb ;};

// GeneratePageBlocks draws the chart onto a block.
func (_egbe *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbd :=ctx ;_cceg :=_egbe ._ecce .IsRelative ();var _fega []*Block ;if _cceg {_fbef :=1.0;_cceb :=_egbe ._ceac .Top ;if float64 (_egbe ._eebf .Height ())> ctx .Height -_egbe ._ceac .Top {_fega =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _gebe error ;if _ ,ctx ,_gebe =_gaebg ().GeneratePageBlocks (ctx );_gebe !=nil {return nil ,ctx ,_gebe ;};_cceb =0;};ctx .X +=_egbe ._ceac .Left +_fbef ;ctx .Y +=_cceb ;ctx .Width -=_egbe ._ceac .Left +_egbe ._ceac .Right +2*_fbef ;ctx .Height -=_cceb ;
_egbe ._eebf .SetWidth (int (ctx .Width ));}else {ctx .X =_egbe ._bdaf ;ctx .Y =_egbe ._ecfb ;};_ebdde :=_da .NewContentCreator ();_ebdde .Translate (0,ctx .PageHeight );_ebdde .Scale (1,-1);_ebdde .Translate (ctx .X ,ctx .Y );_cgaf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
_egbe ._eebf .Render (_edb .NewRenderer (_ebdde ,_cgaf ._ce ),nil );if _ebbe :=_cgaf .addContentsByString (_ebdde .String ());_ebbe !=nil {return nil ,ctx ,_ebbe ;};if _cceg {_gebc :=_egbe .Height ()+_egbe ._ceac .Bottom ;ctx .Y +=_gebc ;ctx .Height -=_gebc ;
}else {ctx =_cbd ;};_fega =append (_fega ,_cgaf );return _fega ,ctx ,nil ;};

// Positioning returns the type of positioning the rectangle is set to use.
func (_dcaab *Rectangle )Positioning ()Positioning {return _dcaab ._efee };

// SetStyleTop sets border style for top side.
func (_bcg *border )SetStyleTop (style CellBorderStyle ){_bcg ._ggg =style };

// SetStyleLeft sets border style for left side.
func (_gcac *border )SetStyleLeft (style CellBorderStyle ){_gcac ._ccf =style };func (_ffcg *templateProcessor )parseInt64Array (_gccf ,_dfdg string )[]int64 {_ee .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gccf ,_dfdg );
_dabac :=_dd .Fields (_dfdg );_gbdc :=make ([]int64 ,0,len (_dabac ));for _ ,_eaabf :=range _dabac {_cegfa ,_ :=_bb .ParseInt (_eaabf ,10,64);_gbdc =append (_gbdc ,_cegfa );};return _gbdc ;};func (_ceacg *TextStyle )horizontalScale ()float64 {return _ceacg .HorizontalScaling /100};


// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_befg []VectorDrawable ;_gdcc Positioning ;_ggea Margins ;_eabe Margins ;_abgc bool ;_acd bool ;_cacc *Background ;};func _edggd (_cgacb *templateProcessor ,_ebfac *templateNode )(interface{},error ){return _cgacb .parseBackground (_ebfac );
};

// Indent returns the left offset of the list when nested into another list.
func (_ccfbd *List )Indent ()float64 {return _ccfbd ._eaef };

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_eaea *List )Width ()float64 {return 0};func _eeeec (_gggg float64 ,_eefgb float64 ,_bgeae float64 ,_bcgee float64 ,_afdcc []*ColorPoint )*RadialShading {return &RadialShading {_daacc :&shading {_cfgfd :ColorWhite ,_gdfd :false ,_aeaa :[]bool {false ,false },_eeee :_afdcc },_eecda :_gggg ,_dfagd :_eefgb ,_bbac :_bgeae ,_accge :_bcgee ,_ceafc :AnchorCenter };
};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_dbgb *Invoice )AddressHeadingStyle ()TextStyle {return _dbgb ._bdag };

// NewSubchapter creates a new child chapter with the specified title.
func (_geea *Chapter )NewSubchapter (title string )*Chapter {_daa :=_afbde (_geea ._fgef ._bebf );_daa .FontSize =14;_geea ._gfg ++;_edd :=_dfea (_geea ,_geea ._abc ,_geea ._babb ,title ,_geea ._gfg ,_daa );_geea .Add (_edd );return _edd ;};

// CreateFrontPage sets a function to generate a front Page.
func (_cdgd *Creator )CreateFrontPage (genFrontPageFunc func (_cdca FrontpageFunctionArgs )){_cdgd ._bdcb =genFrontPageFunc ;};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_ggade *Table )MultiCell (rowspan ,colspan int )*TableCell {_ggade ._dace ++;_bgdg :=(_ggade .moveToNextAvailableCell ()-1)%(_ggade ._efbf )+1;_ddab :=(_ggade ._dace -1)/_ggade ._efbf +1;for _ddab > _ggade ._gcgba {_ggade ._gcgba ++;_ggade ._abaa =append (_ggade ._abaa ,_ggade ._bcgeag );
};_cbdd :=&TableCell {};_cbdd ._cddg =_ddab ;_cbdd ._aeec =_bgdg ;_cbdd ._bfef =5;_cbdd ._adac =CellBorderStyleNone ;_cbdd ._cgccf =_gad .LineStyleSolid ;_cbdd ._fegaf =CellHorizontalAlignmentLeft ;_cbdd ._ffedg =CellVerticalAlignmentTop ;_cbdd ._caec =0;
_cbdd ._adcb =0;_cbdd ._gbad =0;_cbdd ._accd =0;_egede :=ColorBlack ;_cbdd ._baecc =_egede ;_cbdd ._cfcd =_egede ;_cbdd ._bgbe =_egede ;_cbdd ._acaa =_egede ;if rowspan < 1{_ee .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_dfefa :=_ggade ._gcgba -(_cbdd ._cddg -1);if rowspan > _dfefa {_ee .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_dfefa );
_ggade ._gcgba +=rowspan -1;for _ddad :=0;_ddad <=rowspan -_dfefa ;_ddad ++{_ggade ._abaa =append (_ggade ._abaa ,_ggade ._bcgeag );};};for _gede :=0;_gede < colspan &&_bgdg +_gede -1< len (_ggade ._ecaf );_gede ++{_ggade ._ecaf [_bgdg +_gede -1]=rowspan -1;
};_cbdd ._fcabc =rowspan ;if colspan < 1{_ee .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_cfcdg :=_ggade ._efbf -(_cbdd ._aeec -1);if colspan > _cfcdg {_ee .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_cfcdg );
colspan =_cfcdg ;};_cbdd ._cfbea =colspan ;_ggade ._dace +=colspan -1;_ggade ._gggdf =append (_ggade ._gggdf ,_cbdd );_cbdd ._bdcge =_ggade ;return _cbdd ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_edge *Creator )NewPage ()*_bbd .PdfPage {_aegga :=_edge .newPage ();_edge ._afbe =append (_edge ._afbe ,_aegga );_edge ._ffdd .Page ++;return _aegga ;};

// GetRowHeight returns the height of the specified row.
func (_edadg *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_edadg ._abaa ){return 0,_ge .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _edadg ._abaa [row -1],nil ;
};

// SetBorderColor sets the cell's border color.
func (_abdb *TableCell )SetBorderColor (col Color ){_abdb ._baecc =col ;_abdb ._cfcd =col ;_abdb ._bgbe =col ;_abdb ._acaa =col ;};

// NewTable create a new Table with a specified number of columns.
func (_cde *Creator )NewTable (cols int )*Table {return _bfdec (cols )};func (_ggcef *templateProcessor )loadImageFromSrc (_fede string )(*Image ,error ){if _fede ==""{_ee .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_ecfd ;};_dfdbf :=_dd .Split (_fede ,"\u002c");for _ ,_fdfag :=range _dfdbf {_fdfag =_dd .TrimSpace (_fdfag );if _fdfag ==""{continue ;};_gdgce ,_ageb :=_ggcef ._afgef .ImageMap [_fdfag ];if _ageb {return _eggc (_gdgce );};if _fddd :=_ggcef .parseAttrPropList (_fdfag );
len (_fddd )> 0{if _gafdf ,_eddcb :=_fddd ["\u0070\u0061\u0074\u0068"];_eddcb {if _ecgde ,_ggfd :=_ddfb (_gafdf );_ggfd !=nil {_ee .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_gafdf ,_ggfd );
}else {return _ecgde ,nil ;};};};};_ee .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_fede );return nil ,_ecfd ;};

// SetPos sets absolute positioning with specified coordinates.
func (_ddea *StyledParagraph )SetPos (x ,y float64 ){_ddea ._dageg =PositionAbsolute ;_ddea ._bebdg =x ;_ddea ._egfdb =y ;};

// Rows returns the total number of rows the table has.
func (_febb *Table )Rows ()int {return _febb ._gcgba };func _cgbbe (_efab *templateProcessor ,_agdac *templateNode )(interface{},error ){return _efab .parseEllipse (_agdac );};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_aggeb *Table )EnablePageWrap (enable bool ){_aggeb ._gdaa =enable };

// IsAbsolute checks if the positioning is absolute.
func (_fbce Positioning )IsAbsolute ()bool {return _fbce ==PositionAbsolute };

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dagg *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _dagg ._ffda [0],_dagg ._ffda [1]};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_gcgbb *Image )SetPos (x ,y float64 ){_gcgbb ._fgcd =PositionAbsolute ;_gcgbb ._agcca =x ;_gcgbb ._fgba =y ;};func (_ffbe *TableCell )width (_dbfg []float64 ,_bdagb float64 )float64 {_faag :=float64 (0.0);for _gbadb :=0;_gbadb < _ffbe ._cfbea ;_gbadb ++{_faag +=_dbfg [_ffbe ._aeec +_gbadb -1];
};return _faag *_bdagb ;};

// SetNotes sets the notes section of the invoice.
func (_fgbc *Invoice )SetNotes (title ,content string ){_fgbc ._eccg =[2]string {title ,content }};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_eafe *RadialShading )SetBackgroundColor (backgroundColor Color ){_eafe ._daacc .SetBackgroundColor (backgroundColor );};func _aabcf (_fcbe *templateProcessor ,_fabbg *templateNode )(interface{},error ){return _fcbe .parseChart (_fabbg );};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_dcdd *Block )Draw (d Drawable )error {_fad :=DrawContext {};_fad .Width =_dcdd ._eg ;_fad .Height =_dcdd ._gg ;_fad .PageWidth =_dcdd ._eg ;_fad .PageHeight =_dcdd ._gg ;_fad .X =0;_fad .Y =0;_eea ,_ ,_bfbe :=d .GeneratePageBlocks (_fad );if _bfbe !=nil {return _bfbe ;
};if len (_eea )!=1{return ErrContentNotFit ;};for _ ,_fdg :=range _eea {if _eef :=_dcdd .mergeBlocks (_fdg );_eef !=nil {return _eef ;};};return nil ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_cafe *Creator )NewParagraph (text string )*Paragraph {return _eced (text ,_cafe .NewTextStyle ())};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_caa *Block )ScaleToWidth (w float64 ){_ebd :=w /_caa ._eg ;_caa .Scale (_ebd ,_ebd )};

// Reset removes all the text chunks the paragraph contains.
func (_ebbb *StyledParagraph )Reset (){_ebbb ._gacc =[]*TextChunk {}};func _ebadef (_eaddf *templateProcessor ,_gfba *templateNode )(interface{},error ){return _eaddf .parseTextChunk (_gfba ,nil );};

// Inline returns whether the inline mode of the division is active.
func (_ccc *Division )Inline ()bool {return _ccc ._abgc };

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_fabae *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _ge .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _ge .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _ge .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_fabae ._gabb =true ;_fabae ._gdae =startRow ;_fabae ._fefce =endRow ;return nil ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_abcf *Creator )NewImageFromGoImage (goimg _ab .Image )(*Image ,error ){return _ddfd (goimg )};func (_cggb *FilledCurve )draw (_bdde *Block ,_eccee string )([]byte ,*_bbd .PdfRectangle ,error ){_egff :=_gad .NewCubicBezierPath ();for _ ,_edff :=range _cggb ._dbca {_egff =_egff .AppendCurve (_edff );
};creator :=_da .NewContentCreator ();creator .Add_q ();if _cggb .FillEnabled &&_cggb ._dcabf !=nil {_caabf :=_dcgf (_cggb ._dcabf );_cffc :=_agab (_bdde ,_caabf ,_cggb ._dcabf ,func ()Rectangle {_eaeg :=_gad .NewCubicBezierPath ();for _ ,_cdgb :=range _cggb ._dbca {_eaeg =_eaeg .AppendCurve (_cdgb );
};_defb :=_eaeg .GetBoundingBox ();if _cggb .BorderEnabled {_defb .Height +=_cggb .BorderWidth ;_defb .Width +=_cggb .BorderWidth ;_defb .X -=_cggb .BorderWidth /2;_defb .Y -=_cggb .BorderWidth /2;};return Rectangle {_bgcbe :_defb .X ,_aagb :_defb .Y ,_cdagc :_defb .Width ,_ddbcg :_defb .Height };
});if _cffc !=nil {return nil ,nil ,_cffc ;};creator .SetNonStrokingColor (_caabf );};if _cggb .BorderEnabled {if _cggb ._badb !=nil {creator .SetStrokingColor (_dcgf (_cggb ._badb ));};creator .Add_w (_cggb .BorderWidth );};if len (_eccee )> 1{creator .Add_gs (_bf .PdfObjectName (_eccee ));
};_gad .DrawBezierPathWithCreator (_egff ,creator );creator .Add_h ();if _cggb .FillEnabled &&_cggb .BorderEnabled {creator .Add_B ();}else if _cggb .FillEnabled {creator .Add_f ();}else if _cggb .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_dgee :=_egff .GetBoundingBox ();
if _cggb .BorderEnabled {_dgee .Height +=_cggb .BorderWidth ;_dgee .Width +=_cggb .BorderWidth ;_dgee .X -=_cggb .BorderWidth /2;_dgee .Y -=_cggb .BorderWidth /2;};_dfbd :=&_bbd .PdfRectangle {};_dfbd .Llx =_dgee .X ;_dfbd .Lly =_dgee .Y ;_dfbd .Urx =_dgee .X +_dgee .Width ;
_dfbd .Ury =_dgee .Y +_dgee .Height ;return creator .Bytes (),_dfbd ,nil ;};func _daecc (_dcbg *_bbd .PdfRectangle ,_gcccd _eb .Matrix )*_bbd .PdfRectangle {var _egad _bbd .PdfRectangle ;_egad .Llx ,_egad .Lly =_gcccd .Transform (_dcbg .Llx ,_dcbg .Lly );
_egad .Urx ,_egad .Ury =_gcccd .Transform (_dcbg .Urx ,_dcbg .Ury );_egad .Normalize ();return &_egad ;};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SetColorTop sets border color for top.
func (_ceb *border )SetColorTop (col Color ){_ceb ._cdc =col };func _ggced (_cafgd string )([]string ,error ){var (_fegeb []string ;_bfgeg []rune ;);for _ ,_eggd :=range _cafgd {if _eggd =='\u000A'{if len (_bfgeg )> 0{_fegeb =append (_fegeb ,string (_bfgeg ));
};_fegeb =append (_fegeb ,string (_eggd ));_bfgeg =nil ;continue ;};_bfgeg =append (_bfgeg ,_eggd );};if len (_bfgeg )> 0{_fegeb =append (_fegeb ,string (_bfgeg ));};var _cafgf []string ;for _ ,_dcdbf :=range _fegeb {_cadd :=[]rune (_dcdbf );_cdadca :=_geg .NewScanner (_cadd );
var _caffb []rune ;for _ddcgd :=0;_ddcgd < len (_cadd );_ddcgd ++{_ ,_dgbcg ,_fbde :=_cdadca .Next ();if _fbde !=nil {return nil ,_fbde ;};if _dgbcg ==_geg .BreakProhibited ||_fa .IsSpace (_cadd [_ddcgd ]){_caffb =append (_caffb ,_cadd [_ddcgd ]);if _fa .IsSpace (_cadd [_ddcgd ]){_cafgf =append (_cafgf ,string (_caffb ));
_caffb =[]rune {};};continue ;}else {if len (_caffb )> 0{_cafgf =append (_cafgf ,string (_caffb ));};_caffb =[]rune {_cadd [_ddcgd ]};};};if len (_caffb )> 0{_cafgf =append (_cafgf ,string (_caffb ));};};return _cafgf ,nil ;};

// SetColorLeft sets border color for left.
func (_acc *border )SetColorLeft (col Color ){_acc ._fcc =col };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_dfdcb *Table )NewCell ()*TableCell {return _dfdcb .MultiCell (1,1)};func (_cdcf *templateProcessor )parseMarginAttr (_acbdf ,_fgfeb string )Margins {_ee .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_acbdf ,_fgfeb );
_cggff :=Margins {};switch _dadc :=_dd .Fields (_fgfeb );len (_dadc ){case 1:_cggff .Top ,_ =_bb .ParseFloat (_dadc [0],64);_cggff .Bottom =_cggff .Top ;_cggff .Left =_cggff .Top ;_cggff .Right =_cggff .Top ;case 2:_cggff .Top ,_ =_bb .ParseFloat (_dadc [0],64);
_cggff .Bottom =_cggff .Top ;_cggff .Left ,_ =_bb .ParseFloat (_dadc [1],64);_cggff .Right =_cggff .Left ;case 3:_cggff .Top ,_ =_bb .ParseFloat (_dadc [0],64);_cggff .Left ,_ =_bb .ParseFloat (_dadc [1],64);_cggff .Right =_cggff .Left ;_cggff .Bottom ,_ =_bb .ParseFloat (_dadc [2],64);
case 4:_cggff .Top ,_ =_bb .ParseFloat (_dadc [0],64);_cggff .Right ,_ =_bb .ParseFloat (_dadc [1],64);_cggff .Bottom ,_ =_bb .ParseFloat (_dadc [2],64);_cggff .Left ,_ =_bb .ParseFloat (_dadc [3],64);};return _cggff ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_gdfg *Creator )NewTextStyle ()TextStyle {return _afbde (_gdfg ._aaaf )};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_gbda *Table )SetMargins (left ,right ,top ,bottom float64 ){_gbda ._afcg .Left =left ;_gbda ._afcg .Right =right ;_gbda ._afcg .Top =top ;_gbda ._afcg .Bottom =bottom ;};

// SetColPosition sets cell column position.
func (_bbbd *TableCell )SetColPosition (col int ){_bbbd ._aeec =col };

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_ggdg *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_gaee []*Block ;_deccd =NewBlock (ctx .PageWidth ,ctx .PageHeight );_gfgc =ctx ;_fgfa ,_fbdac =_ggdg ._fcgb ,ctx .PageHeight -_ggdg ._aeea ;_fdcc ,_cdfbd =_ggdg ._eefg ,ctx .PageHeight -_ggdg ._bfbgf ;
);_dfba :=_ggdg ._dabg .IsRelative ();if _dfba {ctx .X +=_ggdg ._babe .Left ;ctx .Y +=_ggdg ._babe .Top ;ctx .Width -=_ggdg ._babe .Left +_ggdg ._babe .Right ;ctx .Height -=_ggdg ._babe .Top +_ggdg ._babe .Bottom ;_fgfa ,_fbdac ,_fdcc ,_cdfbd =_ggdg .computeCoords (ctx );
if _ggdg .Height ()> ctx .Height {_gaee =append (_gaee ,_deccd );_deccd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_edfff :=ctx ;_edfff .Y =ctx .Margins .Top +_ggdg ._babe .Top ;_edfff .X =ctx .Margins .Left +_ggdg ._babe .Left ;_edfff .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_ggdg ._babe .Top -_ggdg ._babe .Bottom ;
_edfff .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ggdg ._babe .Left -_ggdg ._babe .Right ;ctx =_edfff ;_fgfa ,_fbdac ,_fdcc ,_cdfbd =_ggdg .computeCoords (ctx );};};_dcafa :=_gad .BasicLine {X1 :_fgfa ,Y1 :_fbdac ,X2 :_fdcc ,Y2 :_cdfbd ,LineColor :_dcgf (_ggdg ._baefg ),Opacity :_ggdg ._ffbdb ,LineWidth :_ggdg ._fffb ,LineStyle :_ggdg ._dedd ,DashArray :_ggdg ._daab ,DashPhase :_ggdg ._edae };
_cbgf ,_bgfg :=_deccd .setOpacity (1.0,_ggdg ._ffbdb );if _bgfg !=nil {return nil ,ctx ,_bgfg ;};_bfdeg ,_ ,_bgfg :=_dcafa .Draw (_cbgf );if _bgfg !=nil {return nil ,ctx ,_bgfg ;};if _bgfg =_deccd .addContentsByString (string (_bfdeg ));_bgfg !=nil {return nil ,ctx ,_bgfg ;
};if _dfba {ctx .X =_gfgc .X ;ctx .Width =_gfgc .Width ;_edaf :=_ggdg .Height ();ctx .Y +=_edaf +_ggdg ._babe .Bottom ;ctx .Height -=_edaf ;}else {ctx =_gfgc ;};_gaee =append (_gaee ,_deccd );return _gaee ,ctx ,nil ;};func _dffgd (_efgf *Table ,_aabf DrawContext )([]*Block ,DrawContext ,error ){var _eaae []*Block ;
_eedgg :=NewBlock (_aabf .PageWidth ,_aabf .PageHeight );_efgf .updateRowHeights (_aabf .Width -_efgf ._afcg .Left -_efgf ._afcg .Right );_acgbb :=_efgf ._afcg .Top ;if _efgf ._ffdf .IsRelative ()&&!_efgf ._gdaa {_cfad :=_efgf .Height ();if _cfad > _aabf .Height -_efgf ._afcg .Top &&_cfad <=_aabf .PageHeight -_aabf .Margins .Top -_aabf .Margins .Bottom {_eaae =[]*Block {NewBlock (_aabf .PageWidth ,_aabf .PageHeight -_aabf .Y )};
var _cadfe error ;if _ ,_aabf ,_cadfe =_gaebg ().GeneratePageBlocks (_aabf );_cadfe !=nil {return nil ,_aabf ,_cadfe ;};_acgbb =0;};};_ffcd :=_aabf ;if _efgf ._ffdf .IsAbsolute (){_aabf .X =_efgf ._dcfa ;_aabf .Y =_efgf ._fdacc ;}else {_aabf .X +=_efgf ._afcg .Left ;
_aabf .Y +=_acgbb ;_aabf .Width -=_efgf ._afcg .Left +_efgf ._afcg .Right ;_aabf .Height -=_acgbb ;};_gefgbd :=_aabf .Width ;_adgaa :=_aabf .X ;_feag :=_aabf .Y ;_bdgd :=_aabf .Height ;_aeeea :=0;_ggeae ,_cecd :=-1,-1;if _efgf ._gabb {for _edcdf ,_cgfea :=range _efgf ._gggdf {if _cgfea ._cddg < _efgf ._gdae {continue ;
};if _cgfea ._cddg > _efgf ._fefce {break ;};if _ggeae < 0{_ggeae =_edcdf ;};_cecd =_edcdf ;};};if _aeccg :=_efgf .wrapContent (_aabf );_aeccg !=nil {return nil ,_aabf ,_aeccg ;};_efgf .updateRowHeights (_aabf .Width -_efgf ._afcg .Left -_efgf ._afcg .Right );
var (_ffcb bool ;_gfbf int ;_cbeef int ;_gabga bool ;_geaed int ;_bagff error ;);for _daeb :=0;_daeb < len (_efgf ._gggdf );_daeb ++{_gbabg :=_efgf ._gggdf [_daeb ];if _dgdfg ,_bgde :=_efgf .getLastCellFromCol (_gbabg ._aeec );_dgdfg ==_daeb {if (_bgde ._cddg +_bgde ._fcabc -1)< _efgf ._gcgba {for _eggce :=_gbabg ._cddg ;
_eggce < _efgf ._gcgba ;_eggce ++{_bbfa :=&TableCell {};_bbfa ._cddg =_eggce +1;_bbfa ._fcabc =1;_bbfa ._aeec =_gbabg ._aeec ;_efgf ._gggdf =append (_efgf ._gggdf ,_bbfa );};};};_bcbdfb :=_gbabg .width (_efgf ._ecgg ,_gefgbd );_fgggd :=float64 (0.0);for _caae :=0;
_caae < _gbabg ._aeec -1;_caae ++{_fgggd +=_efgf ._ecgg [_caae ]*_gefgbd ;};_dbcba :=float64 (0.0);for _gabed :=_aeeea ;_gabed < _gbabg ._cddg -1;_gabed ++{_dbcba +=_efgf ._abaa [_gabed ];};_aabf .Height =_bdgd -_dbcba ;_bfcd :=float64 (0.0);for _ecfee :=0;
_ecfee < _gbabg ._fcabc ;_ecfee ++{_bfcd +=_efgf ._abaa [_gbabg ._cddg +_ecfee -1];};_dbfcf :=_gabga &&_gbabg ._cddg !=_geaed ;_geaed =_gbabg ._cddg ;if _dbfcf ||_bfcd > _aabf .Height {if _efgf ._bcfad &&!_gabga {_gabga ,_bagff =_efgf .wrapRow (_daeb ,_aabf ,_gefgbd );
if _bagff !=nil {return nil ,_aabf ,_bagff ;};if _gabga {_daeb --;continue ;};};_eaae =append (_eaae ,_eedgg );_eedgg =NewBlock (_aabf .PageWidth ,_aabf .PageHeight );_adgaa =_aabf .Margins .Left +_efgf ._afcg .Left ;_feag =_aabf .Margins .Top ;_aabf .Height =_aabf .PageHeight -_aabf .Margins .Top -_aabf .Margins .Bottom ;
_aabf .Page ++;_bdgd =_aabf .Height ;_aeeea =_gbabg ._cddg -1;_dbcba =0;_gabga =false ;if _efgf ._gabb &&_ggeae >=0{_gfbf =_daeb ;_daeb =_ggeae -1;_cbeef =_aeeea ;_aeeea =_efgf ._gdae -1;_ffcb =true ;if _gbabg ._fcabc > (_efgf ._gcgba -_geaed )||(_gbabg ._fcabc > 1&&_daeb < 0){_ee .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_ffcb =false ;_ggeae ,_cecd =-1,-1;};continue ;};if _dbfcf {_daeb --;continue ;};};_aabf .Width =_bcbdfb ;_aabf .X =_adgaa +_fgggd ;_aabf .Y =_feag +_dbcba ;if _bfcd > _aabf .PageHeight -_aabf .Margins .Top -_aabf .Margins .Bottom {_bfcd =_aabf .PageHeight -_aabf .Margins .Top -_aabf .Margins .Bottom ;
};_ecfae :=_dbcb (_aabf .X ,_aabf .Y ,_bcbdfb ,_bfcd );if _gbabg ._cgfcf !=nil {_ecfae .SetFillColor (_gbabg ._cgfcf );};_ecfae .LineStyle =_gbabg ._cgccf ;_ecfae ._ccf =_gbabg ._adac ;_ecfae ._aadc =_gbabg ._ggag ;_ecfae ._ggg =_gbabg ._adebbb ;_ecfae ._gec =_gbabg ._ggdb ;
if _gbabg ._baecc !=nil {_ecfae .SetColorLeft (_gbabg ._baecc );};if _gbabg ._cfcd !=nil {_ecfae .SetColorBottom (_gbabg ._cfcd );};if _gbabg ._bgbe !=nil {_ecfae .SetColorRight (_gbabg ._bgbe );};if _gbabg ._acaa !=nil {_ecfae .SetColorTop (_gbabg ._acaa );
};_ecfae .SetWidthBottom (_gbabg ._adcb );_ecfae .SetWidthLeft (_gbabg ._caec );_ecfae .SetWidthRight (_gbabg ._gbad );_ecfae .SetWidthTop (_gbabg ._accd );_ddcg :=NewBlock (_eedgg ._eg ,_eedgg ._gg );_gggde :=_eedgg .Draw (_ecfae );if _gggde !=nil {_ee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gggde );
};if _gbabg ._ffed !=nil {_gbdb :=_gbabg ._ffed .Width ();_agcfe :=_gbabg ._ffed .Height ();_dedg :=0.0;switch _fefga :=_gbabg ._ffed .(type ){case *Paragraph :if _fefga ._bacce {_gbdb =_fefga .getMaxLineWidth ()/1000.0;};_bfga ,_acceb ,_ :=_fefga .getTextMetrics ();
_cfcb ,_fgcfa :=_bfga *_fefga ._degf ,_acceb *_fefga ._degf ;_agcfe =_agcfe -_fgcfa +_cfcb ;_dedg +=_cfcb -_fgcfa ;_dbaa :=0.5;if _efgf ._eedb {_dbaa =0.3;};switch _gbabg ._ffedg {case CellVerticalAlignmentTop :_dedg +=_cfcb *_dbaa ;case CellVerticalAlignmentBottom :_dedg -=_cfcb *_dbaa ;
};_gbdb +=_fefga ._ggfad .Left +_fefga ._ggfad .Right ;_agcfe +=_fefga ._ggfad .Top +_fefga ._ggfad .Bottom ;case *StyledParagraph :if _fefga ._abbea {_gbdb =_fefga .getMaxLineWidth ()/1000.0;};_cefbc ,_bcddg ,_gaccc :=_fefga .getLineMetrics (0);_adaa ,_ecafa :=_cefbc *_fefga ._dedbc ,_bcddg *_fefga ._dedbc ;
if _fefga ._adbg ==TextVerticalAlignmentCenter {_dedg =_ecafa -(_bcddg +(_cefbc +_gaccc -_bcddg )/2+(_ecafa -_bcddg )/2);};if len (_fefga ._gegeg )==1{_agcfe =_adaa ;}else {_agcfe =_agcfe -_ecafa +_adaa ;};_dedg +=_adaa -_ecafa ;switch _gbabg ._ffedg {case CellVerticalAlignmentTop :_dedg +=_adaa *0.5;
case CellVerticalAlignmentBottom :_dedg -=_adaa *0.5;};_gbdb +=_fefga ._dadf .Left +_fefga ._dadf .Right ;_agcfe +=_fefga ._dadf .Top +_fefga ._dadf .Bottom ;case *Table :_gbdb =_bcbdfb ;case *List :_gbdb =_bcbdfb ;case *Division :_gbdb =_bcbdfb ;case *Chart :_gbdb =_bcbdfb ;
case *Line :_agcfe +=_fefga ._babe .Top +_fefga ._babe .Bottom ;_dedg -=_fefga .Height ()/2;case *Image :_gbdb +=_fefga ._ecd .Left +_fefga ._ecd .Right ;_agcfe +=_fefga ._ecd .Top +_fefga ._ecd .Bottom ;};switch _gbabg ._fegaf {case CellHorizontalAlignmentLeft :_aabf .X +=_gbabg ._bfef ;
_aabf .Width -=_gbabg ._bfef ;case CellHorizontalAlignmentCenter :if _eccdf :=_bcbdfb -_gbdb ;_eccdf > 0{_aabf .X +=_eccdf /2;_aabf .Width -=_eccdf /2;};case CellHorizontalAlignmentRight :if _bcbdfb > _gbdb {_aabf .X =_aabf .X +_bcbdfb -_gbdb -_gbabg ._bfef ;
_aabf .Width -=_gbabg ._bfef ;};};_dcfgf :=_aabf .Y ;_ccga :=_aabf .Height ;_aabf .Y +=_dedg ;switch _gbabg ._ffedg {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _ffbdg :=_bfcd -_agcfe ;_ffbdg > 0{_aabf .Y +=_ffbdg /2;_aabf .Height -=_ffbdg /2;
};case CellVerticalAlignmentBottom :if _bfcd > _agcfe {_aabf .Y =_aabf .Y +_bfcd -_agcfe ;_aabf .Height =_bfcd ;};};_bccg :=_eedgg .DrawWithContext (_gbabg ._ffed ,_aabf );if _bccg !=nil {if _ge .Is (_bccg ,ErrContentNotFit )&&!_dbfcf {_eedgg =_ddcg ;_dbfcf =true ;
_daeb --;continue ;};_ee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bccg );};_aabf .Y =_dcfgf ;_aabf .Height =_ccga ;};_aabf .Y +=_bfcd ;_aabf .Height -=_bfcd ;if _ffcb &&_daeb +1> _cecd {_feag +=_dbcba +_bfcd ;_bdgd -=_bfcd +_dbcba ;
_aeeea =_cbeef ;_daeb =_gfbf -1;_ffcb =false ;};};_eaae =append (_eaae ,_eedgg );if _efgf ._ffdf .IsAbsolute (){return _eaae ,_ffcd ,nil ;};_aabf .X =_ffcd .X ;_aabf .Width =_ffcd .Width ;_aabf .Y +=_efgf ._afcg .Bottom ;_aabf .Height -=_efgf ._afcg .Bottom ;
return _eaae ,_aabf ,nil ;};func (_bagb *templateProcessor )parseTableCell (_bacga *templateNode )(interface{},error ){if _bacga ._afbge ==nil {_bagb .nodeLogError (_bacga ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_gcgf ;};_abafe ,_gcee :=_bacga ._afbge ._dceb .(*Table );if !_gcee {_bagb .nodeLogError (_bacga ,"\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_bacga ._afbge ._dceb );
return nil ,_gcgf ;};var _bbeb ,_gfbe int64 ;for _ ,_dgfe :=range _bacga ._ebeg .Attr {_gdgc :=_dgfe .Value ;switch _cbdeg :=_dgfe .Name .Local ;_cbdeg {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_bbeb =_bagb .parseInt64Attr (_cbdeg ,_gdgc );case "\u0072o\u0077\u0073\u0070\u0061\u006e":_gfbe =_bagb .parseInt64Attr (_cbdeg ,_gdgc );
};};if _bbeb <=0{_bbeb =1;};if _gfbe <=0{_gfbe =1;};_cbdb :=_abafe .MultiCell (int (_gfbe ),int (_bbeb ));for _ ,_ecdc :=range _bacga ._ebeg .Attr {_eaafc :=_ecdc .Value ;switch _cgbb :=_ecdc .Name .Local ;_cgbb {case "\u0069\u006e\u0064\u0065\u006e\u0074":_cbdb .SetIndent (_bagb .parseFloatAttr (_cgbb ,_eaafc ));
case "\u0061\u006c\u0069g\u006e":_cbdb .SetHorizontalAlignment (_bagb .parseCellAlignmentAttr (_cgbb ,_eaafc ));case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_cbdb .SetVerticalAlignment (_bagb .parseCellVerticalAlignmentAttr (_cgbb ,_eaafc ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_cbdb .SetSideBorderStyle (CellBorderSideAll ,_bagb .parseCellBorderStyleAttr (_cgbb ,_eaafc ));case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_cbdb .SetSideBorderStyle (CellBorderSideTop ,_bagb .parseCellBorderStyleAttr (_cgbb ,_eaafc ));
case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_cbdb .SetSideBorderStyle (CellBorderSideBottom ,_bagb .parseCellBorderStyleAttr (_cgbb ,_eaafc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_cbdb .SetSideBorderStyle (CellBorderSideLeft ,_bagb .parseCellBorderStyleAttr (_cgbb ,_eaafc ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_cbdb .SetSideBorderStyle (CellBorderSideRight ,_bagb .parseCellBorderStyleAttr (_cgbb ,_eaafc ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_cbdb .SetSideBorderWidth (CellBorderSideAll ,_bagb .parseFloatAttr (_cgbb ,_eaafc ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_cbdb .SetSideBorderWidth (CellBorderSideTop ,_bagb .parseFloatAttr (_cgbb ,_eaafc ));case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_cbdb .SetSideBorderWidth (CellBorderSideBottom ,_bagb .parseFloatAttr (_cgbb ,_eaafc ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_cbdb .SetSideBorderWidth (CellBorderSideLeft ,_bagb .parseFloatAttr (_cgbb ,_eaafc ));case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_cbdb .SetSideBorderWidth (CellBorderSideRight ,_bagb .parseFloatAttr (_cgbb ,_eaafc ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_cbdb .SetSideBorderColor (CellBorderSideAll ,_bagb .parseColorAttr (_cgbb ,_eaafc ));case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_cbdb .SetSideBorderColor (CellBorderSideTop ,_bagb .parseColorAttr (_cgbb ,_eaafc ));
case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_cbdb .SetSideBorderColor (CellBorderSideBottom ,_bagb .parseColorAttr (_cgbb ,_eaafc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_cbdb .SetSideBorderColor (CellBorderSideLeft ,_bagb .parseColorAttr (_cgbb ,_eaafc ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_cbdb .SetSideBorderColor (CellBorderSideRight ,_bagb .parseColorAttr (_cgbb ,_eaafc ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_cbdb .SetBorderLineStyle (_bagb .parseLineStyleAttr (_cgbb ,_eaafc ));
case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_cbdb .SetBackgroundColor (_bagb .parseColorAttr (_cgbb ,_eaafc ));case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;
default:_bagb .nodeLogDebug (_bacga ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_cgbb );
};};return _cbdb ,nil ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_faf *Invoice )SetBuyerAddress (address *InvoiceAddress ){_faf ._ecff =address };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_ebe *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_ebe ._cee .Left =left ;_ebe ._cee .Right =right ;_ebe ._cee .Top =top ;_ebe ._cee .Bottom =bottom ;};

// Style returns the style of the line.
func (_bbea *Line )Style ()_gad .LineStyle {return _bbea ._dedd };

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_gefd *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_gefd ._ggab =toc ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_cac *Block )ScaleToHeight (h float64 ){_dac :=h /_cac ._gg ;_cac .Scale (_dac ,_dac )};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_aggdf *Creator )RotateDeg (angleDeg int64 )error {_gged :=_aggdf .getActivePage ();if _gged ==nil {_ee .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _ge .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_ee .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _ge .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _gdc int64 ;if _gged .Rotate !=nil {_gdc =*(_gged .Rotate );};_gdc +=angleDeg ;_gged .Rotate =&_gdc ;return nil ;};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_dbeg *Table )MultiRowCell (rowspan int )*TableCell {return _dbeg .MultiCell (rowspan ,1)};

// SetWidth sets line width.
func (_edda *Curve )SetWidth (width float64 ){_edda ._ffgc =width };func (_gae *Block )setOpacity (_egb float64 ,_ag float64 )(string ,error ){if (_egb < 0||_egb >=1.0)&&(_ag < 0||_ag >=1.0){return "",nil ;};_edc :=0;_ff :=_b .Sprintf ("\u0047\u0053\u0025\u0064",_edc );
for _gae ._ce .HasExtGState (_bf .PdfObjectName (_ff )){_edc ++;_ff =_b .Sprintf ("\u0047\u0053\u0025\u0064",_edc );};_edg :=_bf .MakeDict ();if _egb >=0&&_egb < 1.0{_edg .Set ("\u0063\u0061",_bf .MakeFloat (_egb ));};if _ag >=0&&_ag < 1.0{_edg .Set ("\u0043\u0041",_bf .MakeFloat (_ag ));
};_bg :=_gae ._ce .AddExtGState (_bf .PdfObjectName (_ff ),_edg );if _bg !=nil {return "",_bg ;};return _ff ,nil ;};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// SetTitle sets the title of the invoice.
func (_bgcf *Invoice )SetTitle (title string ){_bgcf ._aabb =title };func (_aeaeg *StyledParagraph )getMaxLineWidth ()float64 {if _aeaeg ._gegeg ==nil ||len (_aeaeg ._gegeg )==0{_aeaeg .wrapText ();};var _fgfaf float64 ;for _ ,_fagd :=range _aeaeg ._gegeg {_eaeee :=_aeaeg .getTextLineWidth (_fagd );
if _eaeee > _fgfaf {_fgfaf =_eaeee ;};};return _fgfaf ;};

// NewInvoice returns an instance of an empty invoice.
func (_ffac *Creator )NewInvoice ()*Invoice {_acgge :=_ffac .NewTextStyle ();_acgge .Font =_ffac ._dggc ;return _aecf (_ffac .NewTextStyle (),_acgge );};func (_gggag *templateProcessor )addNodeText (_ceaa *templateNode ,_fcfcc string )error {_ffab :=_ceaa ._dceb ;
if _ffab ==nil {return nil ;};switch _ecgae :=_ffab .(type ){case *TextChunk :_ecgae .Text =_fcfcc ;case *Paragraph :switch _ceaa ._ebeg .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _ceaa ._afbge !=nil {if _gfgce ,_gegc :=_ceaa ._afbge ._dceb .(*Chapter );
_gegc {_gfgce ._feb =_fcfcc ;_ecgae .SetText (_gfgce .headingText ());};};default:_ecgae .SetText (_fcfcc );};};return nil ;};

// SetBorderColor sets the border color.
func (_gbcb *CurvePolygon )SetBorderColor (color Color ){_gbcb ._cba .BorderColor =_dcgf (color )};func (_fgde *Creator )getActivePage ()*_bbd .PdfPage {if _fgde ._faee ==nil {if len (_fgde ._afbe )==0{return nil ;};return _fgde ._afbe [len (_fgde ._afbe )-1];
};return _fgde ._faee ;};

// SetOpacity sets the opacity of the line (0-1).
func (_affcd *Line )SetOpacity (opacity float64 ){_affcd ._ffbdb =opacity };func _bdfda (_caafb *templateProcessor ,_afbbe *templateNode )(interface{},error ){return _caafb .parseLine (_afbbe );};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_caefd *Creator )NewPolyBezierCurve (curves []_gad .CubicBezierCurve )*PolyBezierCurve {return _deed (curves );};func (_affcf *Table )wrapRow (_fbaf int ,_aeacb DrawContext ,_dcceb float64 )(bool ,error ){if !_affcf ._bcfad {return false ,nil ;};
var (_ecgad =_affcf ._gggdf [_fbaf ];_edgac =-1;_dfab []*TableCell ;_dfafg float64 ;_ebabba bool ;_dffgfe =make ([]float64 ,0,len (_affcf ._ecgg )););_dgcga :=func (_baff *TableCell ,_acdf VectorDrawable ,_dfad bool )*TableCell {_geeeda :=*_baff ;_geeeda ._ffed =_acdf ;
if _dfad {_geeeda ._cddg ++;};return &_geeeda ;};_aabc :=func (_ebbc int ,_fced VectorDrawable ){var _agbga float64 =-1;if _fced ==nil {if _gaff :=_dffgfe [_ebbc -_fbaf ];_gaff > _aeacb .Height {_fced =_affcf ._gggdf [_ebbc ]._ffed ;_affcf ._gggdf [_ebbc ]._ffed =nil ;
_dffgfe [_ebbc -_fbaf ]=0;_agbga =_gaff ;};};_efdc :=_dgcga (_affcf ._gggdf [_ebbc ],_fced ,true );_dfab =append (_dfab ,_efdc );if _agbga < 0{_agbga =_efdc .height (_aeacb .Width );};if _agbga > _dfafg {_dfafg =_agbga ;};};for _fabb :=_fbaf ;_fabb < len (_affcf ._gggdf );
_fabb ++{_gdcfff :=_affcf ._gggdf [_fabb ];if _ecgad ._cddg !=_gdcfff ._cddg {_edgac =_fabb ;break ;};_aeacb .Width =_gdcfff .width (_affcf ._ecgg ,_dcceb );_gaef :=_gdcfff .height (_aeacb .Width );var _ccde VectorDrawable ;switch _eagbg :=_gdcfff ._ffed .(type ){case *StyledParagraph :if _gaef > _aeacb .Height {_eafc :=_aeacb ;
_eafc .Height =_bbg .Floor (_aeacb .Height -_eagbg ._dadf .Top -_eagbg ._dadf .Bottom -0.5*_eagbg .getTextHeight ());_cdbe ,_fbbaf ,_eefgbb :=_eagbg .split (_eafc );if _eefgbb !=nil {return false ,_eefgbb ;};if _cdbe !=nil &&_fbbaf !=nil {_eagbg =_cdbe ;
_gdcfff =_dgcga (_gdcfff ,_cdbe ,false );_affcf ._gggdf [_fabb ]=_gdcfff ;_ccde =_fbbaf ;_ebabba =true ;};_gaef =_gdcfff .height (_aeacb .Width );};case *Division :if _gaef > _aeacb .Height {_efec :=_aeacb ;_efec .Height =_bbg .Floor (_aeacb .Height -_eagbg ._ggea .Top -_eagbg ._ggea .Bottom );
_cfdfd ,_gebf :=_eagbg .split (_efec );if _cfdfd !=nil &&_gebf !=nil {_eagbg =_cfdfd ;_gdcfff =_dgcga (_gdcfff ,_cfdfd ,false );_affcf ._gggdf [_fabb ]=_gdcfff ;_ccde =_gebf ;_ebabba =true ;if _cfdfd ._cacc !=nil {_cfdfd ._cacc .BorderRadiusBottomLeft =0;
_cfdfd ._cacc .BorderRadiusBottomRight =0;};if _gebf ._cacc !=nil {_gebf ._cacc .BorderRadiusTopLeft =0;_gebf ._cacc .BorderRadiusTopRight =0;};_gaef =_gdcfff .height (_aeacb .Width );};};case *List :if _gaef > _aeacb .Height {_faeb :=_aeacb ;_faeb .Height =_bbg .Floor (_aeacb .Height -_eagbg ._ddba .Vertical ());
_gdef ,_ffgda :=_eagbg .split (_faeb );if _gdef !=nil {_eagbg =_gdef ;_gdcfff =_dgcga (_gdcfff ,_gdef ,false );_affcf ._gggdf [_fabb ]=_gdcfff ;};if _ffgda !=nil {_ccde =_ffgda ;_ebabba =true ;};_gaef =_gdcfff .height (_aeacb .Width );};};_dffgfe =append (_dffgfe ,_gaef );
if _ebabba {if _dfab ==nil {_dfab =make ([]*TableCell ,0,len (_affcf ._ecgg ));for _afcgf :=_fbaf ;_afcgf < _fabb ;_afcgf ++{_aabc (_afcgf ,nil );};};_aabc (_fabb ,_ccde );};};var _bbgd float64 ;for _ ,_baeg :=range _dffgfe {if _baeg > _bbgd {_bbgd =_baeg ;
};};if _ebabba &&_bbgd < _aeacb .Height {if _edgac < 0{_edgac =len (_affcf ._gggdf );};_dcaga :=_affcf ._gggdf [_edgac -1]._cddg +_affcf ._gggdf [_edgac -1]._fcabc -1;for _egcd :=_edgac ;_egcd < len (_affcf ._gggdf );_egcd ++{_affcf ._gggdf [_egcd ]._cddg ++;
};_affcf ._gggdf =append (_affcf ._gggdf [:_edgac ],append (_dfab ,_affcf ._gggdf [_edgac :]...)...);_affcf ._abaa =append (_affcf ._abaa [:_dcaga ],append ([]float64 {_dfafg },_affcf ._abaa [_dcaga :]...)...);_affcf ._abaa [_ecgad ._cddg +_ecgad ._fcabc -2]=_bbgd ;
};return _ebabba ,nil ;};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_ecdg *Rectangle )ScaleToWidth (w float64 ){_fcab :=_ecdg ._ddbcg /_ecdg ._cdagc ;_ecdg ._cdagc =w ;_ecdg ._ddbcg =w *_fcab ;};func (_agdc *Creator )wrapPageIfNeeded (_abbf *_bbd .PdfPage )(*_bbd .PdfPage ,error ){_ebed ,_egge :=_abbf .GetAllContentStreams ();
if _egge !=nil {return nil ,_egge ;};_dggd :=_da .NewContentStreamParser (_ebed );_fbf ,_egge :=_dggd .Parse ();if _egge !=nil {return nil ,_egge ;};if !_fbf .HasUnclosedQ (){return nil ,nil ;};_fbf .WrapIfNeeded ();_aac ,_egge :=_bf .MakeStream (_fbf .Bytes (),_bf .NewFlateEncoder ());
if _egge !=nil {return nil ,_egge ;};_abbf .Contents =_bf .MakeArray (_aac );return _abbf ,nil ;};

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_bgce *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _bddgc (colorPoints );};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_aeac *Image )ConvertToBinary ()error {return _aeac ._dcce .ConvertToBinary ()};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_adbe *TOCLine )SetLevelOffset (levelOffset float64 ){_adbe ._ebadg =levelOffset ;_adbe ._ebca ._dadf .Left =_adbe ._ggcac +float64 (_adbe ._fffag -1)*_adbe ._ebadg ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gccc *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _gccc ._cdfc [0],_gccc ._cdfc [1]};func _ebdf (_cfafg *_a .File )([]*_bbd .PdfPage ,error ){_edffd ,_gggbb :=_bbd .NewPdfReader (_cfafg );if _gggbb !=nil {return nil ,_gggbb ;};_bgega ,_gggbb :=_edffd .GetNumPages ();
if _gggbb !=nil {return nil ,_gggbb ;};var _aabbb []*_bbd .PdfPage ;for _bffe :=0;_bffe < _bgega ;_bffe ++{_gaaec ,_gfbeb :=_edffd .GetPage (_bffe +1);if _gfbeb !=nil {return nil ,_gfbeb ;};_aabbb =append (_aabbb ,_gaaec );};return _aabbb ,nil ;};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_ecca *Line )SetFitMode (fitMode FitMode ){_ecca ._egfe =fitMode };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_gaege *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_adc []*Block ;_cecf bool ;_eefa error ;_gddb =_gaege ._gdcc .IsRelative ();_gag =_gaege ._ggea .Top ;);if _gddb &&!_gaege ._acd &&!_gaege ._abgc {_cdgg :=_gaege .ctxHeight (ctx .Width );
if _cdgg > ctx .Height -_gaege ._ggea .Top &&_cdgg <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _adc ,ctx ,_eefa =_gaebg ().GeneratePageBlocks (ctx );_eefa !=nil {return nil ,ctx ,_eefa ;};_cecf =true ;_gag =0;};};_ebebd :=ctx ;_efaf :=ctx ;
if _gddb {ctx .X +=_gaege ._ggea .Left ;ctx .Y +=_gag ;ctx .Width -=_gaege ._ggea .Left +_gaege ._ggea .Right ;ctx .Height -=_gag ;_efaf =ctx ;ctx .X +=_gaege ._eabe .Left ;ctx .Y +=_gaege ._eabe .Top ;ctx .Width -=_gaege ._eabe .Left +_gaege ._eabe .Right ;
ctx .Height -=_gaege ._eabe .Top ;ctx .Margins .Top +=_gaege ._eabe .Top ;ctx .Margins .Bottom +=_gaege ._eabe .Bottom ;ctx .Margins .Left +=_gaege ._ggea .Left +_gaege ._eabe .Left ;ctx .Margins .Right +=_gaege ._ggea .Right +_gaege ._eabe .Right ;};ctx .Inline =_gaege ._abgc ;
_abd :=ctx ;_eabf :=ctx ;var _bdge float64 ;for _ ,_abbfd :=range _gaege ._befg {if ctx .Inline {if (ctx .X -_abd .X )+_abbfd .Width ()<=ctx .Width {ctx .Y =_eabf .Y ;ctx .Height =_eabf .Height ;}else {ctx .X =_abd .X ;ctx .Width =_abd .Width ;_eabf .Y +=_bdge ;
_eabf .Height -=_bdge ;_bdge =0;};};_dfeb ,_dbfcg ,_bfff :=_abbfd .GeneratePageBlocks (ctx );if _bfff !=nil {_ee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_bfff );
return nil ,ctx ,_bfff ;};if len (_dfeb )< 1{continue ;};if len (_adc )> 0{_adc [len (_adc )-1].mergeBlocks (_dfeb [0]);_adc =append (_adc ,_dfeb [1:]...);}else {if _bcfe :=_dfeb [0]._ec ;_bcfe ==nil ||len (*_bcfe )==0{_cecf =true ;};_adc =append (_adc ,_dfeb [0:]...);
};if ctx .Inline {if ctx .Page !=_dbfcg .Page {_abd .Y =ctx .Margins .Top ;_abd .Height =ctx .PageHeight -ctx .Margins .Top ;_eabf .Y =_abd .Y ;_eabf .Height =_abd .Height ;_bdge =_dbfcg .Height -_abd .Height ;}else {if _eegc :=ctx .Height -_dbfcg .Height ;
_eegc > _bdge {_bdge =_eegc ;};};}else {_dbfcg .X =ctx .X ;};ctx =_dbfcg ;};ctx .Inline =_ebebd .Inline ;ctx .Margins =_ebebd .Margins ;if _gddb {ctx .X =_ebebd .X ;ctx .Width =_ebebd .Width ;ctx .Y +=_gaege ._eabe .Bottom ;ctx .Height -=_gaege ._eabe .Bottom ;
};if _gaege ._cacc !=nil {_adc ,_eefa =_gaege .drawBackground (_adc ,_efaf ,ctx ,_cecf );if _eefa !=nil {return nil ,ctx ,_eefa ;};};if _gaege ._gdcc .IsAbsolute (){return _adc ,_ebebd ,nil ;};ctx .Y +=_gaege ._ggea .Bottom ;ctx .Height -=_gaege ._ggea .Bottom ;
return _adc ,ctx ,nil ;};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_eecc *GraphicSVG )Scale (xFactor ,yFactor float64 ){_eecc ._gdbd .Width =xFactor *_eecc ._gdbd .Width ;_eecc ._gdbd .Height =yFactor *_eecc ._gdbd .Height ;_eecc ._gdbd .SetScaling (xFactor ,yFactor );};func _bgaf (_gfgbd *Creator ,_gecfa _ga .Reader ,_eecde interface{},_bgae *TemplateOptions ,_edccg componentRenderer )error {if _gfgbd ==nil {_ee .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _eeaffa ;};_gcfb :="";if _cgee ,_gbbcf :=_gecfa .(*_a .File );_gbbcf {_gcfb =_cgee .Name ();};_gcfa :=_fg .NewBuffer (nil );if _ ,_gaeda :=_ga .Copy (_gcfa ,_gecfa );_gaeda !=nil {return _gaeda ;};_eagf :=_ed .FuncMap {"\u0064\u0069\u0063\u0074":_ggba };
if _bgae !=nil &&_bgae .HelperFuncMap !=nil {for _gbcg ,_beba :=range _bgae .HelperFuncMap {if _ ,_fbbdd :=_eagf [_gbcg ];_fbbdd {_ee .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gbcg );
continue ;};_eagf [_gbcg ]=_beba ;};};_aead ,_fdgc :=_ed .New ("").Funcs (_eagf ).Parse (_gcfa .String ());if _fdgc !=nil {return _fdgc ;};if _bgae !=nil &&_bgae .SubtemplateMap !=nil {for _efdg ,_dgefc :=range _bgae .SubtemplateMap {if _efdg ==""{_ee .Log .Debug ("\u0053\u0075\u0062\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u006e\u0061\u006d\u0065\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006d\u0070\u0074\u0079\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067.\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006e\u0063o\u0072\u0072\u0065\u0063\u0074\u002e");
continue ;};if _dgefc ==nil {_ee .Log .Debug ("S\u0075\u0062t\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0063\u0061\u006e\u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063t\u002e");
continue ;};_gecdb :=_fg .NewBuffer (nil );if _ ,_bgfe :=_ga .Copy (_gecdb ,_dgefc );_bgfe !=nil {return _bgfe ;};if _ ,_abafd :=_aead .New (_efdg ).Parse (_gecdb .String ());_abafd !=nil {return _abafd ;};};};_gcfa .Reset ();if _ggeb :=_aead .Execute (_gcfa ,_eecde );
_ggeb !=nil {return _ggeb ;};return _gaegg (_gfgbd ,_gcfb ,_gcfa .Bytes (),_bgae ,_edccg ).run ();};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_gafe *Creator )SetOutlineTree (outlineTree *_bbd .PdfOutlineTreeNode ){_gafe ._bagg =outlineTree };func _dddg (_egbfc *Block ,_beeaa *Image ,_cccd DrawContext )(DrawContext ,error ){_edffb :=_cccd ;_bdcg :=1;_ddgec :=_bf .PdfObjectName (_b .Sprintf ("\u0049\u006d\u0067%\u0064",_bdcg ));
for _egbfc ._ce .HasXObjectByName (_ddgec ){_bdcg ++;_ddgec =_bf .PdfObjectName (_b .Sprintf ("\u0049\u006d\u0067%\u0064",_bdcg ));};_dggb :=_egbfc ._ce .SetXObjectImageByName (_ddgec ,_beeaa ._dgcf );if _dggb !=nil {return _cccd ,_dggb ;};_gbcbc :=0;_cdbc :=_bf .PdfObjectName (_b .Sprintf ("\u0047\u0053\u0025\u0064",_gbcbc ));
for _egbfc ._ce .HasExtGState (_cdbc ){_gbcbc ++;_cdbc =_bf .PdfObjectName (_b .Sprintf ("\u0047\u0053\u0025\u0064",_gbcbc ));};_bcfa :=_bf .MakeDict ();_bcfa .Set ("\u0042\u004d",_bf .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _beeaa ._gcce < 1.0{_bcfa .Set ("\u0043\u0041",_bf .MakeFloat (_beeaa ._gcce ));
_bcfa .Set ("\u0063\u0061",_bf .MakeFloat (_beeaa ._gcce ));};_dggb =_egbfc ._ce .AddExtGState (_cdbc ,_bf .MakeIndirectObject (_bcfa ));if _dggb !=nil {return _cccd ,_dggb ;};_gddd :=_beeaa .Width ();_agea :=_beeaa .Height ();_ ,_gefe :=_beeaa .rotatedSize ();
_bdgca :=_cccd .X ;_gbce :=_cccd .PageHeight -_cccd .Y -_agea ;if _beeaa ._fgcd .IsRelative (){_gbce -=(_gefe -_agea )/2;switch _beeaa ._gdbdg {case HorizontalAlignmentCenter :_bdgca +=(_cccd .Width -_gddd )/2;case HorizontalAlignmentRight :_bdgca =_cccd .PageWidth -_cccd .Margins .Right -_beeaa ._ecd .Right -_gddd ;
};};_ffae :=_beeaa ._bbed ;_gdbg :=_da .NewContentCreator ();_gdbg .Add_gs (_cdbc );_gdbg .Translate (_bdgca ,_gbce );if _ffae !=0{_gdbg .Translate (_gddd /2,_agea /2);_gdbg .RotateDeg (_ffae );_gdbg .Translate (-_gddd /2,-_agea /2);};_gdbg .Scale (_gddd ,_agea ).Add_Do (_ddgec );
_abcg :=_gdbg .Operations ();_abcg .WrapIfNeeded ();_egbfc .addContents (_abcg );if _beeaa ._fgcd .IsRelative (){_cccd .Y +=_gefe ;_cccd .Height -=_gefe ;return _cccd ,nil ;};return _edffb ,nil ;};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_cfee *Line )SetMargins (left ,right ,top ,bottom float64 ){_cfee ._babe .Left =left ;_cfee ._babe .Right =right ;_cfee ._babe .Top =top ;_cfee ._babe .Bottom =bottom ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetEnableWrap sets the line wrapping enabled flag.
func (_cafee *StyledParagraph )SetEnableWrap (enableWrap bool ){_cafee ._abbea =enableWrap ;_cafee ._ccddf =false ;};func (_bfce *templateProcessor )getNodeErrorLocation (_gfgee *templateNode ,_cebf string ,_ccec ...interface{})string {_begf :=_b .Sprintf (_cebf ,_ccec ...);
_aaaad :=_b .Sprintf ("\u0025\u0064",_gfgee ._bcbaa );if _gfgee ._dfcc !=0{_aaaad =_b .Sprintf ("\u0025\u0064\u003a%\u0064",_gfgee ._dfcc ,_gfgee ._efaa );};if _bfce ._dedc !=""{return _b .Sprintf ("\u0025\u0073\u0020\u005b\u0025\u0073\u003a\u0025\u0073\u005d",_begf ,_bfce ._dedc ,_aaaad );
};return _b .Sprintf ("\u0025s\u0020\u005b\u0025\u0073\u005d",_begf ,_aaaad );};

// SetLineOpacity sets the line opacity.
func (_acggeb *Polyline )SetLineOpacity (opacity float64 ){_acggeb ._cgfef =opacity };func (_ccad *templateProcessor )parseTextVerticalAlignmentAttr (_fbdca ,_dfgg string )TextVerticalAlignment {_ee .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_fbdca ,_dfgg );
_cecgb :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_dfgg ];return _cecgb ;};func _dcgf (_geae Color )_bbd .PdfColor {if _geae ==nil {_geae =ColorBlack ;
};switch _gddg :=_geae .(type ){case cmykColor :return _bbd .NewPdfColorDeviceCMYK (_gddg ._fegag ,_gddg ._acbg ,_gddg ._aggdc ,_gddg ._dfag );case *LinearShading :return _bbd .NewPdfColorPatternType2 ();case *RadialShading :return _bbd .NewPdfColorPatternType3 ();
};return _bbd .NewPdfColorDeviceRGB (_geae .ToRGB ());};func (_baaf *templateProcessor )parseRadialGradientAttr (creator *Creator ,_aafdd string )Color {_cgdg :=ColorBlack ;if _aafdd ==""{return _cgdg ;};var (_bcbae error ;_cbcg =0.0;_cfcge =0.0;_afee =-1.0;
_dgdfa =_dd .Split (_aafdd [16:len (_aafdd )-1],"\u002c"););_edbga :=_dd .Fields (_dgdfa [0]);if len (_edbga )==2&&_dd .TrimSpace (_edbga [0])[0]!='#'{_cbcg ,_bcbae =_bb .ParseFloat (_edbga [0],64);if _bcbae !=nil {_ee .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0058\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_bcbae );
};_cfcge ,_bcbae =_bb .ParseFloat (_edbga [1],64);if _bcbae !=nil {_ee .Log .Debug ("\u0046a\u0069\u006ce\u0064\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0072a\u0064\u0069\u0061\u006c\u0020\u0067r\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0059\u0020\u0070\u006fs\u0069\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076",_bcbae );
};_dgdfa =_dgdfa [1:];};_dgbea :=_dd .TrimSpace (_dgdfa [0]);if _dgbea [0]!='#'{_afee ,_bcbae =_bb .ParseFloat (_dgbea ,64);if _bcbae !=nil {_ee .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0070\u0061\u0072\u0073\u0069\u006eg\u0020\u0072\u0061\u0064\u0069\u0061l\u0020\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0020\u0073\u0069\u007ae\u003a\u0020\u0025\u0076",_bcbae );
};_dgdfa =_dgdfa [1:];};_ecced ,_cacg :=_baaf .processGradientColorPair (_dgdfa );if _ecced ==nil ||_cacg ==nil {return _cgdg ;};_gfag :=creator .NewRadialGradientColor (_cbcg ,_cfcge ,0,_afee ,[]*ColorPoint {});for _cebe :=0;_cebe < len (_ecced );_cebe ++{_gfag .AddColorStop (_ecced [_cebe ],_cacg [_cebe ]);
};return _gfag ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_egcdf *TableCell )SetContent (vd VectorDrawable )error {switch _cgac :=vd .(type ){case *Paragraph :if _cgac ._gecd {_cgac ._bacce =true ;};_egcdf ._ffed =vd ;case *StyledParagraph :if _cgac ._ccddf {_cgac ._abbea =true ;};_egcdf ._ffed =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_egcdf ._ffed =vd ;
default:_ee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _bf .ErrTypeError ;};return nil ;};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph, *Division, *Image, *Table, and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_bbab *List )Add (item VectorDrawable )(*TextChunk ,error ){_afdca :=&listItem {_dgfd :item ,_badgf :_bbab ._cafc };switch _cdfgg :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _cdfgg ._cbeab {_cdfgg ._eaef =15;};case *Division :case *Image :case *Table :default:return nil ,_ge .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_bbab ._gebg =append (_bbab ._gebg ,_afdca );return &_afdca ._badgf ,nil ;};func (_deccc *templateProcessor )parseParagraph (_daedd *templateNode ,_gcde *Paragraph )(interface{},error ){if _gcde ==nil {_gcde =_deccc .creator .NewParagraph ("");};for _ ,_defc :=range _daedd ._ebeg .Attr {_gcfad :=_defc .Value ;
switch _fdcgf :=_defc .Name .Local ;_fdcgf {case "\u0066\u006f\u006e\u0074":_gcde .SetFont (_deccc .parseFontAttr (_fdcgf ,_gcfad ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_gcde .SetFontSize (_deccc .parseFloatAttr (_fdcgf ,_gcfad ));case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_gcde .SetTextAlignment (_deccc .parseTextAlignmentAttr (_fdcgf ,_gcfad ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_gcde .SetLineHeight (_deccc .parseFloatAttr (_fdcgf ,_gcfad ));case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_gcde .SetEnableWrap (_deccc .parseBoolAttr (_fdcgf ,_gcfad ));
case "\u0063\u006f\u006co\u0072":_gcde .SetColor (_deccc .parseColorAttr (_fdcgf ,_gcfad ));case "\u0078":_gcde .SetPos (_deccc .parseFloatAttr (_fdcgf ,_gcfad ),_gcde ._egce );case "\u0079":_gcde .SetPos (_gcde ._bagf ,_deccc .parseFloatAttr (_fdcgf ,_gcfad ));
case "\u0061\u006e\u0067l\u0065":_gcde .SetAngle (_deccc .parseFloatAttr (_fdcgf ,_gcfad ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_dcabg :=_deccc .parseMarginAttr (_fdcgf ,_gcfad );_gcde .SetMargins (_dcabg .Left ,_dcabg .Right ,_dcabg .Top ,_dcabg .Bottom );
case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_gcde .SetMaxLines (int (_deccc .parseInt64Attr (_fdcgf ,_gcfad )));default:_deccc .nodeLogDebug (_daedd ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_fdcgf );
};};return _gcde ,nil ;};func (_addf *Chapter )headingNumber ()string {var _cea string ;if _addf ._ffef {if _addf ._eca !=0{_cea =_bb .Itoa (_addf ._eca )+"\u002e";};if _addf ._bcd !=nil {_ecfc :=_addf ._bcd .headingNumber ();if _ecfc !=""{_cea =_ecfc +_cea ;
};};};return _cea ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_ecged *TOC )SetLineTitleStyle (style TextStyle ){_ecged ._abgfe =style };

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_gd *Block )AddAnnotation (annotation *_bbd .PdfAnnotation ){for _ ,_cc :=range _gd ._cb {if _cc ==annotation {return ;};};_gd ._cb =append (_gd ._cb ,annotation );};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_dedb *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_faef ,_baefd :=_dgb .setOpacity (_dedb ._cfeea ,_dedb ._fbeb );if _baefd !=nil {return nil ,ctx ,_baefd ;};_gabde :=_dedb ._bbbe ;
_gabde .FillEnabled =_gabde .FillColor !=nil ;_gabde .BorderEnabled =_gabde .BorderColor !=nil &&_gabde .BorderWidth > 0;_gefa :=_gabde .Points ;_eeccb :=_bbd .PdfRectangle {};_fafc :=false ;for _fbab :=range _gefa {for _ecee :=range _gefa [_fbab ]{_aebgg :=&_gefa [_fbab ][_ecee ];
_aebgg .Y =ctx .PageHeight -_aebgg .Y ;if !_fafc {_eeccb .Llx =_aebgg .X ;_eeccb .Lly =_aebgg .Y ;_eeccb .Urx =_aebgg .X ;_eeccb .Ury =_aebgg .Y ;_fafc =true ;}else {_eeccb .Llx =_bbg .Min (_eeccb .Llx ,_aebgg .X );_eeccb .Lly =_bbg .Min (_eeccb .Lly ,_aebgg .Y );
_eeccb .Urx =_bbg .Max (_eeccb .Urx ,_aebgg .X );_eeccb .Ury =_bbg .Max (_eeccb .Ury ,_aebgg .Y );};};};if _gabde .FillEnabled {_ggga :=_agab (_dgb ,_dedb ._bbbe .FillColor ,_dedb ._fbceb ,func ()Rectangle {return Rectangle {_bgcbe :_eeccb .Llx ,_aagb :_eeccb .Lly ,_cdagc :_eeccb .Width (),_ddbcg :_eeccb .Height ()};
});if _ggga !=nil {return nil ,ctx ,_ggga ;};};_aaafg ,_ ,_baefd :=_gabde .Draw (_faef );if _baefd !=nil {return nil ,ctx ,_baefd ;};if _baefd =_dgb .addContentsByString (string (_aaafg ));_baefd !=nil {return nil ,ctx ,_baefd ;};return []*Block {_dgb },ctx ,nil ;
};func _bfbdb (_fffce *templateProcessor ,_efgb *templateNode )(interface{},error ){return _fffce .parseChapter (_efgb );};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_bbd .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_bdbe *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_bdbe ._ggfg =textOverflow };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_ebf *Creator )EnableFontSubsetting (font *_bbd .PdfFont ){_ebf ._bbca =append (_ebf ._bbca ,font )};

// GeneratePageBlocks implements drawable interface.
func (_feeg *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gga :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gcad :=_feeg ._dgf ;_gb :=ctx .PageHeight -_feeg ._fcb ;if _feeg ._cfd !=nil {_ebc :=_gad .Rectangle {Opacity :1.0,X :_feeg ._dgf ,Y :ctx .PageHeight -_feeg ._fcb -_feeg ._cg ,Height :_feeg ._cg ,Width :_feeg ._fce };
_ebc .FillEnabled =true ;_efa :=_dcgf (_feeg ._cfd );_eda :=_agab (_gga ,_efa ,_feeg ._cfd ,func ()Rectangle {return Rectangle {_bgcbe :_ebc .X ,_aagb :_ebc .Y ,_cdagc :_ebc .Width ,_ddbcg :_ebc .Height };});if _eda !=nil {return nil ,ctx ,_eda ;};_ebc .FillColor =_efa ;
_ebc .BorderEnabled =false ;_deec ,_ ,_eda :=_ebc .Draw ("");if _eda !=nil {return nil ,ctx ,_eda ;};_eda =_gga .addContentsByString (string (_deec ));if _eda !=nil {return nil ,ctx ,_eda ;};};_gafg :=_feeg ._eeb ;_gda :=_feeg ._bca ;_aebg :=_feeg ._dafd ;
_eag :=_feeg ._dbf ;_abee :=_feeg ._eeb ;if _feeg ._ggg ==CellBorderStyleDouble {_abee +=2*_gafg ;};_bab :=_feeg ._bca ;if _feeg ._gec ==CellBorderStyleDouble {_bab +=2*_gda ;};_ggbb :=_feeg ._dafd ;if _feeg ._ccf ==CellBorderStyleDouble {_ggbb +=2*_aebg ;
};_cdbg :=_feeg ._dbf ;if _feeg ._aadc ==CellBorderStyleDouble {_cdbg +=2*_eag ;};_aag :=(_abee -_ggbb )/2;_fae :=(_abee -_cdbg )/2;_fgd :=(_bab -_ggbb )/2;_bdad :=(_bab -_cdbg )/2;if _feeg ._eeb !=0{_cfgf :=_gcad ;_dged :=_gb ;if _feeg ._ggg ==CellBorderStyleDouble {_dged -=_gafg ;
_cga :=_gad .BasicLine {LineColor :_dcgf (_feeg ._cdc ),Opacity :1.0,LineWidth :_feeg ._eeb ,LineStyle :_feeg .LineStyle ,X1 :_cfgf -_abee /2+_aag ,Y1 :_dged +2*_gafg ,X2 :_cfgf +_abee /2-_fae +_feeg ._fce ,Y2 :_dged +2*_gafg };_cge ,_ ,_eagd :=_cga .Draw ("");
if _eagd !=nil {return nil ,ctx ,_eagd ;};_eagd =_gga .addContentsByString (string (_cge ));if _eagd !=nil {return nil ,ctx ,_eagd ;};};_ade :=_gad .BasicLine {LineWidth :_feeg ._eeb ,Opacity :1.0,LineColor :_dcgf (_feeg ._cdc ),LineStyle :_feeg .LineStyle ,X1 :_cfgf -_abee /2+_aag +(_ggbb -_feeg ._dafd ),Y1 :_dged ,X2 :_cfgf +_abee /2-_fae +_feeg ._fce -(_cdbg -_feeg ._dbf ),Y2 :_dged };
_acbc ,_ ,_ddgg :=_ade .Draw ("");if _ddgg !=nil {return nil ,ctx ,_ddgg ;};_ddgg =_gga .addContentsByString (string (_acbc ));if _ddgg !=nil {return nil ,ctx ,_ddgg ;};};if _feeg ._bca !=0{_bacf :=_gcad ;_cfae :=_gb -_feeg ._cg ;if _feeg ._gec ==CellBorderStyleDouble {_cfae +=_gda ;
_fcbb :=_gad .BasicLine {LineWidth :_feeg ._bca ,Opacity :1.0,LineColor :_dcgf (_feeg ._ege ),LineStyle :_feeg .LineStyle ,X1 :_bacf -_bab /2+_fgd ,Y1 :_cfae -2*_gda ,X2 :_bacf +_bab /2-_bdad +_feeg ._fce ,Y2 :_cfae -2*_gda };_afdc ,_ ,_cebb :=_fcbb .Draw ("");
if _cebb !=nil {return nil ,ctx ,_cebb ;};_cebb =_gga .addContentsByString (string (_afdc ));if _cebb !=nil {return nil ,ctx ,_cebb ;};};_fabc :=_gad .BasicLine {LineWidth :_feeg ._bca ,Opacity :1.0,LineColor :_dcgf (_feeg ._ege ),LineStyle :_feeg .LineStyle ,X1 :_bacf -_bab /2+_fgd +(_ggbb -_feeg ._dafd ),Y1 :_cfae ,X2 :_bacf +_bab /2-_bdad +_feeg ._fce -(_cdbg -_feeg ._dbf ),Y2 :_cfae };
_edea ,_ ,_fbe :=_fabc .Draw ("");if _fbe !=nil {return nil ,ctx ,_fbe ;};_fbe =_gga .addContentsByString (string (_edea ));if _fbe !=nil {return nil ,ctx ,_fbe ;};};if _feeg ._dafd !=0{_fgfg :=_gcad ;_gbc :=_gb ;if _feeg ._ccf ==CellBorderStyleDouble {_fgfg +=_aebg ;
_egg :=_gad .BasicLine {LineWidth :_feeg ._dafd ,Opacity :1.0,LineColor :_dcgf (_feeg ._fcc ),LineStyle :_feeg .LineStyle ,X1 :_fgfg -2*_aebg ,Y1 :_gbc +_ggbb /2+_aag ,X2 :_fgfg -2*_aebg ,Y2 :_gbc -_ggbb /2-_fgd -_feeg ._cg };_caf ,_ ,_cdf :=_egg .Draw ("");
if _cdf !=nil {return nil ,ctx ,_cdf ;};_cdf =_gga .addContentsByString (string (_caf ));if _cdf !=nil {return nil ,ctx ,_cdf ;};};_cacf :=_gad .BasicLine {LineWidth :_feeg ._dafd ,Opacity :1.0,LineColor :_dcgf (_feeg ._fcc ),LineStyle :_feeg .LineStyle ,X1 :_fgfg ,Y1 :_gbc +_ggbb /2+_aag -(_abee -_feeg ._eeb ),X2 :_fgfg ,Y2 :_gbc -_ggbb /2-_fgd -_feeg ._cg +(_bab -_feeg ._bca )};
_fde ,_ ,_eed :=_cacf .Draw ("");if _eed !=nil {return nil ,ctx ,_eed ;};_eed =_gga .addContentsByString (string (_fde ));if _eed !=nil {return nil ,ctx ,_eed ;};};if _feeg ._dbf !=0{_dfdd :=_gcad +_feeg ._fce ;_aced :=_gb ;if _feeg ._aadc ==CellBorderStyleDouble {_dfdd -=_eag ;
_ebdd :=_gad .BasicLine {LineWidth :_feeg ._dbf ,Opacity :1.0,LineColor :_dcgf (_feeg ._dfe ),LineStyle :_feeg .LineStyle ,X1 :_dfdd +2*_eag ,Y1 :_aced +_cdbg /2+_fae ,X2 :_dfdd +2*_eag ,Y2 :_aced -_cdbg /2-_bdad -_feeg ._cg };_cace ,_ ,_beac :=_ebdd .Draw ("");
if _beac !=nil {return nil ,ctx ,_beac ;};_beac =_gga .addContentsByString (string (_cace ));if _beac !=nil {return nil ,ctx ,_beac ;};};_gaeb :=_gad .BasicLine {LineWidth :_feeg ._dbf ,Opacity :1.0,LineColor :_dcgf (_feeg ._dfe ),LineStyle :_feeg .LineStyle ,X1 :_dfdd ,Y1 :_aced +_cdbg /2+_fae -(_abee -_feeg ._eeb ),X2 :_dfdd ,Y2 :_aced -_cdbg /2-_bdad -_feeg ._cg +(_bab -_feeg ._bca )};
_dag ,_ ,_dga :=_gaeb .Draw ("");if _dga !=nil {return nil ,ctx ,_dga ;};_dga =_gga .addContentsByString (string (_dag ));if _dga !=nil {return nil ,ctx ,_dga ;};};return []*Block {_gga },ctx ,nil ;};

// Scale scales the rectangle dimensions by the specified factors.
func (_cfgcg *Rectangle )Scale (xFactor ,yFactor float64 ){_cfgcg ._cdagc =xFactor *_cfgcg ._cdagc ;_cfgcg ._ddbcg =yFactor *_cfgcg ._ddbcg ;};func (_cdeg *templateProcessor )parseTextRenderingModeAttr (_dedca ,_gagba string )TextRenderingMode {_ee .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dedca ,_gagba );
_ggcg :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_gagba ];
return _ggcg ;};func _febfd (_cfdc *_f .Decoder )(int ,int ){return 0,0};

// SetIndent sets the cell's left indent.
func (_dabe *TableCell )SetIndent (indent float64 ){_dabe ._bfef =indent };

// Add adds a new line with the default style to the table of contents.
func (_efce *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_degcb :=_efce .AddLine (_defde (TextChunk {Text :number ,Style :_efce ._febc },TextChunk {Text :title ,Style :_efce ._abgfe },TextChunk {Text :page ,Style :_efce ._gfgag },level ,_efce ._gecg ));
if _degcb ==nil {return nil ;};_cbagb :=&_efce ._eada ;_degcb .SetMargins (_cbagb .Left ,_cbagb .Right ,_cbagb .Top ,_cbagb .Bottom );_degcb .SetLevelOffset (_efce ._addd );_degcb .Separator .Text =_efce ._abdbb ;_degcb .Separator .Style =_efce ._dbfaf ;
return _degcb ;};

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _fag (color ,point )};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_gcgba int ;_efbf int ;_dace int ;_ecgg []float64 ;_abaa []float64 ;_bcgeag float64 ;_gggdf []*TableCell ;_ecaf []int ;_ffdf Positioning ;_dcfa ,_fdacc float64 ;_afcg Margins ;_gabb bool ;_gdae int ;_fefce int ;_bcfad bool ;_gdaa bool ;
_eedb bool ;};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ba .ChartRenderable )*Chart {return _agca (chart )};

// SetWidthBottom sets border width for bottom.
func (_edf *border )SetWidthBottom (bw float64 ){_edf ._bca =bw };

// BorderWidth returns the border width of the rectangle.
func (_edbf *Rectangle )BorderWidth ()float64 {return _edbf ._egdc };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style ,VerticalAlignment :TextVerticalAlignmentBaseline };};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_ebddb *RadialShading )SetAntiAlias (enable bool ){_ebddb ._daacc .SetAntiAlias (enable )};func (_fccaf *Table )moveToNextAvailableCell ()int {_cfeb :=(_fccaf ._dace -1)%(_fccaf ._efbf )+1;for {if _cfeb -1>=len (_fccaf ._ecaf ){if _fccaf ._ecaf [0]==0{return _cfeb ;
};_cfeb =1;}else if _fccaf ._ecaf [_cfeb -1]==0{return _cfeb ;};_fccaf ._dace ++;_fccaf ._ecaf [_cfeb -1]--;_cfeb ++;};};

// FitMode returns the fit mode of the line.
func (_dbea *Line )FitMode ()FitMode {return _dbea ._egfe };

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_ebfcd *LinearShading )SetAngle (angle float64 ){_ebfcd ._gegea =angle };

// AddLine appends a new line to the invoice line items table.
func (_dfcg *Invoice )AddLine (values ...string )[]*InvoiceCell {_daeeg :=len (_dfcg ._agbb );var _fffeb []*InvoiceCell ;for _gcede ,_cbcf :=range values {_aggac :=_dfcg .newCell (_cbcf ,_dfcg ._ecaa );if _gcede < _daeeg {_aggac .Alignment =_dfcg ._agbb [_gcede ].Alignment ;
};_fffeb =append (_fffeb ,_aggac );};_dfcg ._gddbf =append (_dfcg ._gddbf ,_fffeb );return _fffeb ;};

// SetFillOpacity sets the fill opacity of the ellipse.
func (_aagf *Ellipse )SetFillOpacity (opacity float64 ){_aagf ._bcgab =opacity };func (_cdfbg *TableCell )cloneProps (_ffacg VectorDrawable )*TableCell {_gbdff :=*_cdfbg ;_gbdff ._ffed =_ffacg ;return &_gbdff ;};

// GetIndent get the cell's left indent.
func (_agcg *TableCell )GetIndent ()float64 {return _agcg ._bfef };func _bbaf (_eegd *Block ,_fcfc *StyledParagraph ,_bdagf [][]*TextChunk ,_cdaa DrawContext )(DrawContext ,[][]*TextChunk ,error ){_ccfd :=1;_dffcd :=_bf .PdfObjectName (_b .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ccfd ));
for _eegd ._ce .HasFontByName (_dffcd ){_ccfd ++;_dffcd =_bf .PdfObjectName (_b .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ccfd ));};_eeebg :=_eegd ._ce .SetFontByName (_dffcd ,_fcfc ._abeaf .Font .ToPdfObject ());if _eeebg !=nil {return _cdaa ,nil ,_eeebg ;
};_ccfd ++;_ccgge :=_dffcd ;_gbfc :=_fcfc ._abeaf .FontSize ;_cbbd :=_fcfc ._dageg .IsRelative ();var _cdac [][]_bf .PdfObjectName ;var _abcff [][]*TextChunk ;var _gaecb float64 ;for _ffec ,_cfgbb :=range _bdagf {var _cbgd []_bf .PdfObjectName ;var _gggdg float64 ;
if len (_cfgbb )> 0{_gggdg =_cfgbb [0].Style .FontSize ;};for _ ,_febf :=range _cfgbb {_eefgc :=_febf .Style ;if _febf .Text !=""&&_eefgc .FontSize > _gggdg {_gggdg =_eefgc .FontSize ;};if _gggdg > _cdaa .PageHeight {return _cdaa ,nil ,_ge .New ("\u0050\u0061\u0072\u0061\u0067\u0072a\u0070\u0068\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020\u006ca\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0070\u0061\u0067\u0065 \u0068e\u0069\u0067\u0068\u0074");
};_dffcd =_bf .PdfObjectName (_b .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ccfd ));_gebgf :=_eegd ._ce .SetFontByName (_dffcd ,_eefgc .Font .ToPdfObject ());if _gebgf !=nil {return _cdaa ,nil ,_gebgf ;};_cbgd =append (_cbgd ,_dffcd );_ccfd ++;};
_gggdg *=_fcfc ._dedbc ;if _cbbd &&_gaecb +_gggdg > _cdaa .Height {_abcff =_bdagf [_ffec :];_bdagf =_bdagf [:_ffec ];break ;};_gaecb +=_gggdg ;_cdac =append (_cdac ,_cbgd );};_cdef ,_faeca ,_gdfed :=_fcfc .getLineMetrics (0);_gfb ,_dbdf :=_cdef *_fcfc ._dedbc ,_faeca *_fcfc ._dedbc ;
if len (_bdagf )==0{return _cdaa ,_abcff ,nil ;};_gaac :=_da .NewContentCreator ();_gaac .Add_q ();_cedg :=_dbdf ;if _fcfc ._adbg ==TextVerticalAlignmentCenter {_cedg =_faeca +(_cdef +_gdfed -_faeca )/2+(_dbdf -_faeca )/2;};_daca :=_cdaa .PageHeight -_cdaa .Y -_cedg ;
_gaac .Translate (_cdaa .X ,_daca );_eefaf :=_daca ;if _fcfc ._fabd !=0{_gaac .RotateDeg (_fcfc ._fabd );};if _fcfc ._ggfg ==TextOverflowHidden {_gaac .Add_re (0,-_gaecb +_gfb +1,_fcfc ._ccac ,_gaecb ).Add_W ().Add_n ();};_gaac .Add_BT ();var _gagaf []*_gad .BasicLine ;
for _acddd ,_cbce :=range _bdagf {_ddec :=_cdaa .X ;var _ebgg float64 ;if len (_cbce )> 0{_ebgg =_cbce [0].Style .FontSize ;};_cdef ,_ ,_gdfed =_fcfc .getLineMetrics (_acddd );_dbdf =(_cdef +_gdfed );for _ ,_cegb :=range _cbce {_ecfe :=&_cegb .Style ;if _cegb .Text !=""&&_ecfe .FontSize > _ebgg {_ebgg =_ecfe .FontSize ;
};if _dbdf > _ebgg {_ebgg =_dbdf ;};};if _acddd !=0{_gaac .Add_TD (0,-_ebgg *_fcfc ._dedbc );_eefaf -=_ebgg *_fcfc ._dedbc ;};_eadba :=_acddd ==len (_bdagf )-1;var (_fcgfa float64 ;_egaae float64 ;_aecfg *fontMetrics ;_abfbe float64 ;_deabc uint ;);var _dffcg []float64 ;
for _ ,_cbba :=range _cbce {_faab :=&_cbba .Style ;if _faab .FontSize > _egaae {_egaae =_faab .FontSize ;_aecfg =_dfcfd (_cbba .Style .Font ,_faab .FontSize );};if _dbdf > _egaae {_egaae =_dbdf ;};_daead ,_cdcc :=_faab .Font .GetRuneMetrics (' ');if !_cdcc {return _cdaa ,nil ,_ge .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _fadbd uint ;var _ccdce float64 ;_cdec :=len (_cbba .Text );for _fdcaf ,_ebcfg :=range _cbba .Text {if _ebcfg ==' '{_fadbd ++;continue ;};if _ebcfg =='\u000A'{continue ;};_dgcgg ,_ceffg :=_faab .Font .GetRuneMetrics (_ebcfg );if !_ceffg {_ee .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_ebcfg );
return _cdaa ,nil ,_ge .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_ccdce +=_faab .FontSize *_dgcgg .Wx *_faab .horizontalScale ();if _fdcaf !=_cdec -1{_ccdce +=_faab .CharSpacing *1000.0;
};};_dffcg =append (_dffcg ,_ccdce );_fcgfa +=_ccdce ;_abfbe +=float64 (_fadbd )*_daead .Wx *_faab .FontSize *_faab .horizontalScale ();_deabc +=_fadbd ;};_egaae *=_fcfc ._dedbc ;var _bcgeab []_bf .PdfObject ;_bfec :=_fcfc ._ccac *1000.0;if _fcfc ._eceb ==TextAlignmentJustify {if _deabc > 0&&!_eadba {_abfbe =(_bfec -_fcgfa )/float64 (_deabc )/_gbfc ;
};}else if _fcfc ._eceb ==TextAlignmentCenter {_dfaa :=(_bfec -_fcgfa -_abfbe )/2;_gcafa :=_dfaa /_gbfc ;_bcgeab =append (_bcgeab ,_bf .MakeFloat (-_gcafa ));_ddec +=_dfaa /1000.0;}else if _fcfc ._eceb ==TextAlignmentRight {_cfdf :=(_bfec -_fcgfa -_abfbe );
_cfgfg :=_cfdf /_gbfc ;_bcgeab =append (_bcgeab ,_bf .MakeFloat (-_cfgfg ));_ddec +=_cfdf /1000.0;};if len (_bcgeab )> 0{_gaac .Add_Tf (_ccgge ,_gbfc ).Add_TL (_gbfc *_fcfc ._dedbc ).Add_TJ (_bcgeab ...);};_gcggf :=0.0;for _abeca ,_abeac :=range _cbce {_daacb :=&_abeac .Style ;
_bdbcc :=_ccgge ;_cgdb :=_gbfc ;_fabg :=_daacb .OutlineColor !=nil ;_bdaaf :=_daacb .HorizontalScaling !=DefaultHorizontalScaling ;_cbfg :=_daacb .OutlineSize !=1;if _cbfg {_gaac .Add_w (_daacb .OutlineSize );};_egabb :=_daacb .RenderingMode !=TextRenderingModeFill ;
if _egabb {_gaac .Add_Tr (int64 (_daacb .RenderingMode ));};_cbdcd :=_daacb .CharSpacing !=0;if _cbdcd {_gaac .Add_Tc (_daacb .CharSpacing );};_fbcbg :=_daacb .TextRise !=0;if _fbcbg {_gaac .Add_Ts (_daacb .TextRise );};if _abeac .VerticalAlignment !=TextVerticalAlignmentBaseline {_fbcfg :=_dfcfd (_abeac .Style .Font ,_daacb .FontSize );
switch _abeac .VerticalAlignment {case TextVerticalAlignmentCenter :_gcggf =_aecfg ._ffaf /2-_fbcfg ._ffaf /2;case TextVerticalAlignmentBottom :_gcggf =_aecfg ._fbbdb -_fbcfg ._fbbdb ;case TextVerticalAlignmentTop :_gcggf =_faeca -_daacb .FontSize ;};if _gcggf !=0.0{_gaac .Translate (0,_gcggf );
};};if _fcfc ._eceb !=TextAlignmentJustify ||_eadba {_bbbb ,_bcbb :=_daacb .Font .GetRuneMetrics (' ');if !_bcbb {return _cdaa ,nil ,_ge .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};_bdbcc =_cdac [_acddd ][_abeca ];_cgdb =_daacb .FontSize ;_abfbe =_bbbb .Wx *_daacb .horizontalScale ();};_bedb :=_daacb .Font .Encoder ();var _gaaa []byte ;for _ ,_aafgd :=range _abeac .Text {if _aafgd =='\u000A'{continue ;};if _aafgd ==' '{if len (_gaaa )> 0{if _fabg {_gaac .SetStrokingColor (_dcgf (_daacb .OutlineColor ));
};if _bdaaf {_gaac .Add_Tz (_daacb .HorizontalScaling );};_gaac .SetNonStrokingColor (_dcgf (_daacb .Color )).Add_Tf (_cdac [_acddd ][_abeca ],_daacb .FontSize ).Add_TJ ([]_bf .PdfObject {_bf .MakeStringFromBytes (_gaaa )}...);_gaaa =nil ;};if _bdaaf {_gaac .Add_Tz (DefaultHorizontalScaling );
};_gaac .Add_Tf (_bdbcc ,_cgdb ).Add_TJ ([]_bf .PdfObject {_bf .MakeFloat (-_abfbe )}...);_dffcg [_abeca ]+=_abfbe *_cgdb ;}else {if _ ,_ggaea :=_bedb .RuneToCharcode (_aafgd );!_ggaea {_eeebg =UnsupportedRuneError {Message :_b .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_aafgd ,_aafgd ),Rune :_aafgd };
_cdaa ._eccc =append (_cdaa ._eccc ,_eeebg );_ee .Log .Debug (_eeebg .Error ());if _cdaa ._bdbc <=0{continue ;};_aafgd =_cdaa ._bdbc ;};_gaaa =append (_gaaa ,_bedb .Encode (string (_aafgd ))...);};};if len (_gaaa )> 0{if _fabg {_gaac .SetStrokingColor (_dcgf (_daacb .OutlineColor ));
};if _bdaaf {_gaac .Add_Tz (_daacb .HorizontalScaling );};_gaac .SetNonStrokingColor (_dcgf (_daacb .Color )).Add_Tf (_cdac [_acddd ][_abeca ],_daacb .FontSize ).Add_TJ ([]_bf .PdfObject {_bf .MakeStringFromBytes (_gaaa )}...);};_aagfc :=_dffcg [_abeca ]/1000.0;
if _daacb .Underline {_cfdd :=_daacb .UnderlineStyle .Color ;if _cfdd ==nil {_cfdd =_abeac .Style .Color ;};_gfff ,_gefc ,_affaf :=_cfdd .ToRGB ();_gdba :=_ddec -_cdaa .X ;_daagd :=_eefaf -_daca +_daacb .TextRise -_daacb .UnderlineStyle .Offset ;_gagaf =append (_gagaf ,&_gad .BasicLine {X1 :_gdba ,Y1 :_daagd ,X2 :_gdba +_aagfc ,Y2 :_daagd ,LineWidth :_abeac .Style .UnderlineStyle .Thickness ,LineColor :_bbd .NewPdfColorDeviceRGB (_gfff ,_gefc ,_affaf )});
};if _abeac ._gdege !=nil {var _decbd *_bf .PdfObjectArray ;if !_abeac ._daadb {switch _bdgbe :=_abeac ._gdege .GetContext ().(type ){case *_bbd .PdfAnnotationLink :_decbd =_bf .MakeArray ();_bdgbe .Rect =_decbd ;_eeaad ,_fegead :=_bdgbe .Dest .(*_bf .PdfObjectArray );
if _fegead &&_eeaad .Len ()==5{_fbcce ,_cdgf :=_eeaad .Get (1).(*_bf .PdfObjectName );if _cdgf &&_fbcce .String ()=="\u0058\u0059\u005a"{_bdfcf ,_fdfe :=_bf .GetNumberAsFloat (_eeaad .Get (3));if _fdfe ==nil {_eeaad .Set (3,_bf .MakeFloat (_cdaa .PageHeight -_bdfcf ));
};};};};_abeac ._daadb =true ;};if _decbd !=nil {_bbccc :=_gad .NewPoint (_ddec -_cdaa .X ,_eefaf +_daacb .TextRise -_daca ).Rotate (_fcfc ._fabd );_bbccc .X +=_cdaa .X ;_bbccc .Y +=_daca ;_cdfe ,_afcc ,_bbec ,_ggaedc :=_deef (_aagfc ,_egaae ,_fcfc ._fabd );
_bbccc .X +=_cdfe ;_bbccc .Y +=_afcc ;_decbd .Clear ();_decbd .Append (_bf .MakeFloat (_bbccc .X ));_decbd .Append (_bf .MakeFloat (_bbccc .Y ));_decbd .Append (_bf .MakeFloat (_bbccc .X +_bbec ));_decbd .Append (_bf .MakeFloat (_bbccc .Y +_ggaedc ));};
_eegd .AddAnnotation (_abeac ._gdege );};_ddec +=_aagfc ;if _cbfg {_gaac .Add_w (1.0);};if _fabg {_gaac .Add_RG (0.0,0.0,0.0);};if _egabb {_gaac .Add_Tr (int64 (TextRenderingModeFill ));};if _cbdcd {_gaac .Add_Tc (0);};if _fbcbg {_gaac .Add_Ts (0);};if _bdaaf {_gaac .Add_Tz (DefaultHorizontalScaling );
};if _gcggf !=0.0{_gaac .Translate (0,-_gcggf );_gcggf =0.0;};};};_gaac .Add_ET ();for _ ,_fdba :=range _gagaf {_gaac .SetStrokingColor (_fdba .LineColor ).Add_w (_fdba .LineWidth ).Add_m (_fdba .X1 ,_fdba .Y1 ).Add_l (_fdba .X2 ,_fdba .Y2 ).Add_s ();};
_gaac .Add_Q ();_gaaeg :=_gaac .Operations ();_gaaeg .WrapIfNeeded ();_eegd .addContents (_gaaeg );if _cbbd {_ggef :=_gaecb ;_cdaa .Y +=_ggef ;_cdaa .Height -=_ggef ;if _cdaa .Inline {_cdaa .X +=_fcfc .Width ()+_fcfc ._dadf .Right ;};};return _cdaa ,_abcff ,nil ;
};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_bdbc rune ;_eccc []error ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_febe *Invoice )AddressStyle ()TextStyle {return _febe ._dbbe };func _gaebg ()*PageBreak {return &PageBreak {}};

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;func (_cafda *templateProcessor )nodeLogError (_gcbee *templateNode ,_bcafe string ,_eegg ...interface{}){_ee .Log .Error (_cafda .getNodeErrorLocation (_gcbee ,_bcafe ,_eegg ...));};

// SetFillOpacity sets the fill opacity.
func (_eacb *PolyBezierCurve )SetFillOpacity (opacity float64 ){_eacb ._faba =opacity };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_dbag *StyledParagraph )SetWidth (width float64 ){_dbag ._ccac =width ;_dbag .wrapText ()};

// Width returns the width of the specified text chunk.
func (_ebfcc *TextChunk )Width ()float64 {var (_accaf float64 ;_gccgb =_ebfcc .Style ;);for _ ,_beef :=range _ebfcc .Text {_ddabc ,_ecgf :=_gccgb .Font .GetRuneMetrics (_beef );if !_ecgf {_ee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_beef ,_beef ,_gccgb .Font .BaseFont (),_gccgb .Font .Subtype ());
_ee .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_gccgb .Font );_ee .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_gccgb .Font .Encoder ());};_dbbcga :=_gccgb .FontSize *_ddabc .Wx ;_bcdfe :=_dbbcga ;
if _beef !=' '{_bcdfe =_dbbcga +_gccgb .CharSpacing *1000.0;};_accaf +=_bcdfe ;};return _accaf /1000.0;};func (_cdfce *List )markerWidth ()float64 {var _fbgb float64 ;for _ ,_cadce :=range _cdfce ._gebg {_ecga :=_ggcdc (_cdfce ._ddbae );_ecga .SetEnableWrap (false );
_ecga .SetTextAlignment (TextAlignmentRight );_ecga .Append (_cadce ._badgf .Text ).Style =_cadce ._badgf .Style ;_gdde :=_ecga .getTextWidth ()/1000.0;if _fbgb < _gdde {_fbgb =_gdde ;};};return _fbgb ;};

// SetBorder sets the cell's border style.
func (_aaacb *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_aaacb ._adac =CellBorderStyleSingle ;_aaacb ._caec =width ;_aaacb ._ggdb =CellBorderStyleSingle ;
_aaacb ._adcb =width ;_aaacb ._ggag =CellBorderStyleSingle ;_aaacb ._gbad =width ;_aaacb ._adebbb =CellBorderStyleSingle ;_aaacb ._accd =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_aaacb ._adac =CellBorderStyleDouble ;_aaacb ._caec =width ;
_aaacb ._ggdb =CellBorderStyleDouble ;_aaacb ._adcb =width ;_aaacb ._ggag =CellBorderStyleDouble ;_aaacb ._gbad =width ;_aaacb ._adebbb =CellBorderStyleDouble ;_aaacb ._accd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_aaacb ._adac =style ;
_aaacb ._caec =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_aaacb ._ggdb =style ;_aaacb ._adcb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_aaacb ._ggag =style ;
_aaacb ._gbad =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_aaacb ._adebbb =style ;_aaacb ._accd =width ;};};

// SetAngle sets the rotation angle of the text.
func (_dgaea *Paragraph )SetAngle (angle float64 ){_dgaea ._eagec =angle };func _ffag (_efcf ,_cfbe ,_aggg ,_faeef float64 )*Ellipse {return &Ellipse {_cfga :_efcf ,_adcc :_cfbe ,_dgga :_aggg ,_dgdg :_faeef ,_cafbc :PositionAbsolute ,_bcgab :1.0,_dgdf :ColorBlack ,_cbab :1.0,_eaf :1.0};
};func (_aede *Invoice )generateNoteBlocks (_gbbge DrawContext )([]*Block ,DrawContext ,error ){_dagb :=_cebc ();_gcaae :=append ([][2]string {_aede ._eccg ,_aede ._caeed },_aede ._gbae ...);for _ ,_geca :=range _gcaae {if _geca [1]!=""{_eaaba :=_aede .drawSection (_geca [0],_geca [1]);
for _ ,_bfdaf :=range _eaaba {_dagb .Add (_bfdaf );};_ccdc :=_ggcdc (_aede ._faeg );_ccdc .SetMargins (0,0,10,0);_dagb .Add (_ccdc );};};return _dagb .GeneratePageBlocks (_gbbge );};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//
//	green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_eage :_bbg .Max (_bbg .Min (r ,1.0),0.0),_eaee :_bbg .Max (_bbg .Min (g ,1.0),0.0),_gfe :_bbg .Max (_bbg .Min (b ,1.0),0.0)};};

// Level returns the indentation level of the TOC line.
func (_fdbd *TOCLine )Level ()uint {return _fdbd ._fffag };func (_fedb *Paragraph )getTextWidth ()float64 {_bbgb :=0.0;for _ ,_fdag :=range _fedb ._bcecc {if _fdag =='\u000A'{continue ;};_eace ,_gabef :=_fedb ._bebf .GetRuneMetrics (_fdag );if !_gabef {_ee .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_fdag ,_fdag );
return -1;};_bbgb +=_fedb ._gfddf *_eace .Wx ;};return _bbgb ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;TextVerticalAlignmentBottom ;TextVerticalAlignmentTop ;);func _agca (_caac _ba .ChartRenderable )*Chart {return &Chart {_eebf :_caac ,_ecce :PositionRelative ,_ceac :Margins {Top :10,Bottom :10}};
};func (_ebff *templateProcessor )parseStyledParagraph (_gcbb *templateNode )(interface{},error ){_ecgdb :=_ebff .creator .NewStyledParagraph ();for _ ,_gcab :=range _gcbb ._ebeg .Attr {_ddfg :=_gcab .Value ;switch _gdcfg :=_gcab .Name .Local ;_gdcfg {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_ecgdb .SetTextAlignment (_ebff .parseTextAlignmentAttr (_gdcfg ,_ddfg ));
case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_ecgdb .SetTextVerticalAlignment (_ebff .parseTextVerticalAlignmentAttr (_gdcfg ,_ddfg ));case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_ecgdb .SetLineHeight (_ebff .parseFloatAttr (_gdcfg ,_ddfg ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_gagfg :=_ebff .parseMarginAttr (_gdcfg ,_ddfg );_ecgdb .SetMargins (_gagfg .Left ,_gagfg .Right ,_gagfg .Top ,_gagfg .Bottom );case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_ecgdb .SetEnableWrap (_ebff .parseBoolAttr (_gdcfg ,_ddfg ));
case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_ecgdb .EnableWordWrap (_ebff .parseBoolAttr (_gdcfg ,_ddfg ));case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_ecgdb .SetTextOverflow (_ebff .parseTextOverflowAttr (_gdcfg ,_ddfg ));
case "\u0078":_ecgdb .SetPos (_ebff .parseFloatAttr (_gdcfg ,_ddfg ),_ecgdb ._egfdb );case "\u0079":_ecgdb .SetPos (_ecgdb ._bebdg ,_ebff .parseFloatAttr (_gdcfg ,_ddfg ));case "\u0061\u006e\u0067l\u0065":_ecgdb .SetAngle (_ebff .parseFloatAttr (_gdcfg ,_ddfg ));
default:_ebff .nodeLogDebug (_gcbb ,"\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0073\u0074\u0079l\u0065\u0064\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0060\u0025\u0073`.\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gdcfg );
};};return _ecgdb ,nil ;};

// SetHeight sets the height of the rectangle.
func (_cfgcb *Rectangle )SetHeight (height float64 ){_cfgcb ._ddbcg =height };func (_daed *Rectangle )applyFitMode (_fffed float64 ){_fffed -=_daed ._caegfd .Left +_daed ._caegfd .Right +_daed ._egdc ;switch _daed ._dgba {case FitModeFillWidth :_daed .ScaleToWidth (_fffed );
};};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_gcd *Chapter )SetIncludeInTOC (includeInTOC bool ){_gcd ._efb =includeInTOC };

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_bcdb *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_bcdb ._gbf .Left =left ;_bcdb ._gbf .Right =right ;_bcdb ._gbf .Top =top ;_bcdb ._gbf .Bottom =bottom ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_dfbadc *TOC )SetLineNumberStyle (style TextStyle ){_dfbadc ._febc =style };func _eeae (_dcdcf ,_dbbb ,_cbcdg ,_gbd float64 )*Line {return &Line {_fcgb :_dcdcf ,_aeea :_dbbb ,_eefg :_cbcdg ,_bfbgf :_gbd ,_baefg :ColorBlack ,_ffbdb :1.0,_fffb :1.0,_daab :[]int64 {1,1},_dabg :PositionAbsolute };
};

// Context returns the current drawing context.
func (_fbbe *Creator )Context ()DrawContext {return _fbbe ._ffdd };type listItem struct{_dgfd VectorDrawable ;_badgf TextChunk ;};var (ErrContentNotFit =_ge .New ("\u0043\u0061\u006e\u006e\u006ft\u0020\u0066\u0069\u0074\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020i\u006e\u0074\u006f\u0020\u0061\u006e\u0020\u0065\u0078\u0069\u0073\u0074\u0069\u006e\u0067\u0020\u0073\u0070\u0061\u0063\u0065");
);func (_gffcd *templateProcessor )parseLinearGradientAttr (creator *Creator ,_dddd string )Color {_deff :=ColorBlack ;if _dddd ==""{return _deff ;};_eede :=creator .NewLinearGradientColor ([]*ColorPoint {});_eede .SetExtends (true ,true );var (_cdddb =_dd .Split (_dddd [16:len (_dddd )-1],"\u002c");
_fgefb =_dd .TrimSpace (_cdddb [0]););if _dd .HasSuffix (_fgefb ,"\u0064\u0065\u0067"){_fdccf ,_edbe :=_bb .ParseFloat (_fgefb [:len (_fgefb )-3],64);if _edbe !=nil {_ee .Log .Debug ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0067\u0072\u0061\u0064\u0069e\u006e\u0074\u0020\u0061\u006e\u0067\u006ce\u003a\u0020\u0025\u0076",_edbe );
}else {_eede .SetAngle (_fdccf );};_cdddb =_cdddb [1:];};_abge ,_edcad :=_gffcd .processGradientColorPair (_cdddb );if _abge ==nil ||_edcad ==nil {return _deff ;};for _acfec :=0;_acfec < len (_abge );_acfec ++{_eede .AddColorStop (_abge [_acfec ],_edcad [_acfec ]);
};return _eede ;};func (_acebde *templateProcessor )parseEllipse (_beeeg *templateNode )(interface{},error ){_eaefdc :=_acebde .creator .NewEllipse (0,0,0,0);for _ ,_fgga :=range _beeeg ._ebeg .Attr {_cfgcf :=_fgga .Value ;switch _cgbf :=_fgga .Name .Local ;
_cgbf {case "\u0063\u0078":_eaefdc ._cfga =_acebde .parseFloatAttr (_cgbf ,_cfgcf );case "\u0063\u0079":_eaefdc ._adcc =_acebde .parseFloatAttr (_cgbf ,_cfgcf );case "\u0077\u0069\u0064t\u0068":_eaefdc .SetWidth (_acebde .parseFloatAttr (_cgbf ,_cfgcf ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_eaefdc .SetHeight (_acebde .parseFloatAttr (_cgbf ,_cfgcf ));case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_eaefdc .SetFillColor (_acebde .parseColorAttr (_cgbf ,_cfgcf ));case "\u0066\u0069\u006cl\u002d\u006f\u0070\u0061\u0063\u0069\u0074\u0079":_eaefdc .SetFillOpacity (_acebde .parseFloatAttr (_cgbf ,_cfgcf ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_eaefdc .SetBorderColor (_acebde .parseColorAttr (_cgbf ,_cfgcf ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006f\u0070a\u0063\u0069\u0074\u0079":_eaefdc .SetBorderOpacity (_acebde .parseFloatAttr (_cgbf ,_cfgcf ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_eaefdc .SetBorderWidth (_acebde .parseFloatAttr (_cgbf ,_cfgcf ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_eaefdc .SetPositioning (_acebde .parsePositioningAttr (_cgbf ,_cfgcf ));
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_eaefdc .SetFitMode (_acebde .parseFitModeAttr (_cgbf ,_cfgcf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_afgbc :=_acebde .parseMarginAttr (_cgbf ,_cfgcf );_eaefdc .SetMargins (_afgbc .Left ,_afgbc .Right ,_afgbc .Top ,_afgbc .Bottom );
default:_acebde .nodeLogDebug (_beeeg ,"\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u006c\u0069\u0070\u0073\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cgbf );
};};return _eaefdc ,nil ;};

// Width returns the current page width.
func (_cfc *Creator )Width ()float64 {return _cfc ._afgc };

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_gafb *Creator )Draw (d Drawable )error {if _gafb .getActivePage ()==nil {_gafb .NewPage ();};_eaga ,_agga ,_afdg :=d .GeneratePageBlocks (_gafb ._ffdd );if _afdg !=nil {return _afdg ;};if len (_agga ._eccc )> 0{_gafb .Errors =append (_gafb .Errors ,_agga ._eccc ...);
};for _bedf ,_eadd :=range _eaga {if _bedf > 0{_gafb .NewPage ();};_aggae :=_gafb .getActivePage ();if _adgg ,_egef :=_gafb ._acba [_aggae ];_egef {if _caeg :=_adgg .mergeBlocks (_eadd );_caeg !=nil {return _caeg ;};if _egaf :=_gff (_eadd ._ce ,_adgg ._ce );
_egaf !=nil {return _egaf ;};}else {_gafb ._acba [_aggae ]=_eadd ;};};_gafb ._ffdd .X =_agga .X ;_gafb ._ffdd .Y =_agga .Y ;_gafb ._ffdd .Height =_agga .PageHeight -_agga .Y -_agga .Margins .Bottom ;return nil ;};

// SetColorBottom sets border color for bottom.
func (_dbd *border )SetColorBottom (col Color ){_dbd ._ege =col };func _bcff (_aeee []byte )(*Image ,error ){_bgcb :=_fg .NewReader (_aeee );_bacg ,_bdeff :=_bbd .ImageHandling .Read (_bgcb );if _bdeff !=nil {_ee .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bdeff );
return nil ,_bdeff ;};return _eggc (_bacg );};func (_bdgf *templateProcessor )parseListItem (_gdca *templateNode )(interface{},error ){if _gdca ._afbge ==nil {_bdgf .nodeLogError (_gdca ,"\u004c\u0069\u0073t\u0020\u0069\u0074\u0065m\u0020\u0070\u0061\u0072\u0065\u006e\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_gcgf ;};_ffefg ,_ggbbeg :=_gdca ._afbge ._dceb .(*List );if !_ggbbeg {_bdgf .nodeLogError (_gdca ,"\u004c\u0069s\u0074\u0020\u0069\u0074\u0065\u006d\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u004cis\u0074\u002e");
return nil ,_gcgf ;};_edffa :=_afc ();_edffa ._badgf =_ffefg ._cafc ;return _edffa ,nil ;};func _fcdfc (_cdbd *templateProcessor ,_dgcc *templateNode )(interface{},error ){return _cdbd .parseRectangle (_dgcc );};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_bcecc string ;_bebf *_bbd .PdfFont ;_gfddf float64 ;_degf float64 ;_bbbf Color ;_dacg TextAlignment ;_bacce bool ;_cfedb float64 ;_gbdf int ;_gecd bool ;_eagec float64 ;_ggfad Margins ;_geee Positioning ;_bagf float64 ;_egce float64 ;
_bcee ,_agbad float64 ;_fffef []string ;};func (_ecbg *TemplateOptions )init (){if _ecbg .SubtemplateMap ==nil {_ecbg .SubtemplateMap =map[string ]_ga .Reader {};};if _ecbg .FontMap ==nil {_ecbg .FontMap =map[string ]*_bbd .PdfFont {};};if _ecbg .ImageMap ==nil {_ecbg .ImageMap =map[string ]*_bbd .Image {};
};if _ecbg .ColorMap ==nil {_ecbg .ColorMap =map[string ]Color {};};if _ecbg .ChartMap ==nil {_ecbg .ChartMap =map[string ]_ba .ChartRenderable {};};};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_aaag *Creator )MoveDown (dy float64 ){_aaag ._ffdd .Y +=dy };

// SetBorderOpacity sets the border opacity.
func (_bbf *CurvePolygon )SetBorderOpacity (opacity float64 ){_bbf ._dggg =opacity };

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_ccea *Rectangle )FillOpacity ()float64 {return _ccea ._fbcfb };

// SetColorRight sets border color for right.
func (_ddda *border )SetColorRight (col Color ){_ddda ._dfe =col };

// Height returns Image's document height.
func (_fefbg *Image )Height ()float64 {return _fefbg ._bcec };

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_dgab *Chart )SetPos (x ,y float64 ){_dgab ._ecce =PositionAbsolute ;_dgab ._bdaf =x ;_dgab ._ecfb =y ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fecce *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ebda :=ctx ;_cddf ,ctx ,_dgbag :=_fecce ._ebca .GeneratePageBlocks (ctx );if _dgbag !=nil {return _cddf ,ctx ,_dgbag ;};if _fecce ._cgcba .IsRelative (){ctx .X =_ebda .X ;
};if _fecce ._cgcba .IsAbsolute (){return _cddf ,_ebda ,nil ;};return _cddf ,ctx ,nil ;};

// SetCoords sets the center coordinates of the ellipse.
func (_aebb *Ellipse )SetCoords (xc ,yc float64 ){_aebb ._cfga =xc ;_aebb ._adcc =yc };func (_abdf *TOCLine )prepareParagraph (_afde *StyledParagraph ,_agbgb DrawContext ){_aaddf :=_abdf .Title .Text ;if _abdf .Number .Text !=""{_aaddf ="\u0020"+_aaddf ;
};_aaddf +="\u0020";_gcfgf :=_abdf .Page .Text ;if _gcfgf !=""{_gcfgf ="\u0020"+_gcfgf ;};_afde ._gacc =[]*TextChunk {{Text :_abdf .Number .Text ,Style :_abdf .Number .Style ,_gdege :_abdf .getLineLink ()},{Text :_aaddf ,Style :_abdf .Title .Style ,_gdege :_abdf .getLineLink ()},{Text :_gcfgf ,Style :_abdf .Page .Style ,_gdege :_abdf .getLineLink ()}};
_afde .wrapText ();_debd :=len (_afde ._gegeg );if _debd ==0{return ;};_dddda :=_agbgb .Width *1000-_afde .getTextLineWidth (_afde ._gegeg [_debd -1]);_fdead :=_afde .getTextLineWidth ([]*TextChunk {&_abdf .Separator });_dgcefa :=int (_dddda /_fdead );
_eeffc :=_dd .Repeat (_abdf .Separator .Text ,_dgcefa );_fbbgf :=_abdf .Separator .Style ;_gebee :=_afde .Insert (2,_eeffc );_gebee .Style =_fbbgf ;_gebee ._gdege =_abdf .getLineLink ();_dddda =_dddda -float64 (_dgcefa )*_fdead ;if _dddda > 500{_gecgf ,_gbaabb :=_fbbgf .Font .GetRuneMetrics (' ');
if _gbaabb &&_dddda > _gecgf .Wx {_gdgb :=int (_dddda /_gecgf .Wx );if _gdgb > 0{_aaafe :=_fbbgf ;_aaafe .FontSize =1;_gebee =_afde .Insert (2,_dd .Repeat ("\u0020",_gdgb ));_gebee .Style =_aaafe ;_gebee ._gdege =_abdf .getLineLink ();};};};};const (DefaultHorizontalScaling =100;
);func (_dbcgg *Invoice )newCell (_bba string ,_bgdc InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_bgdc ,_bba };};func (_aeebb *Paragraph )wrapText ()error {if !_aeebb ._bacce ||int (_aeebb ._cfedb )<=0{_aeebb ._fffef =[]string {_aeebb ._bcecc };
return nil ;};_dcbcb :=NewTextChunk (_aeebb ._bcecc ,TextStyle {Font :_aeebb ._bebf ,FontSize :_aeebb ._gfddf });_cfaf ,_dbad :=_dcbcb .Wrap (_aeebb ._cfedb );if _dbad !=nil {return _dbad ;};if _aeebb ._gbdf > 0&&len (_cfaf )> _aeebb ._gbdf {_cfaf =_cfaf [:_aeebb ._gbdf ];
};_aeebb ._fffef =_cfaf ;return nil ;};func _dbcb (_dbcc ,_fadd ,_dgcd ,_aef float64 )*border {_add :=&border {};_add ._dgf =_dbcc ;_add ._fcb =_fadd ;_add ._fce =_dgcd ;_add ._cg =_aef ;_add ._cdc =ColorBlack ;_add ._ege =ColorBlack ;_add ._fcc =ColorBlack ;
_add ._dfe =ColorBlack ;_add ._eeb =0;_add ._bca =0;_add ._dafd =0;_add ._dbf =0;_add .LineStyle =_gad .LineStyleSolid ;return _add ;};func (_cbfdc *templateProcessor )nodeLogDebug (_ddcc *templateNode ,_afca string ,_cefg ...interface{}){_ee .Log .Debug (_cbfdc .getNodeErrorLocation (_ddcc ,_afca ,_cefg ...));
};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_bgdcf *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cafba :=ctx ;var _afggg []*Block ;_bbgg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _bgdcf ._dageg .IsRelative (){ctx .X +=_bgdcf ._dadf .Left ;ctx .Y +=_bgdcf ._dadf .Top ;
ctx .Width -=_bgdcf ._dadf .Left +_bgdcf ._dadf .Right ;ctx .Height -=_bgdcf ._dadf .Top ;_bgdcf .SetWidth (ctx .Width );}else {if int (_bgdcf ._ccac )<=0{_bgdcf .SetWidth (_bgdcf .getTextWidth ()/1000.0);};ctx .X =_bgdcf ._bebdg ;ctx .Y =_bgdcf ._egfdb ;
};if _bgdcf ._cbee !=nil {_bgdcf ._cbee (_bgdcf ,ctx );};if _ggad :=_bgdcf .wrapText ();_ggad !=nil {return nil ,ctx ,_ggad ;};_fbac :=_bgdcf ._gegeg ;_cdadcc :=0;for {_bgbc ,_cbccf ,_dddef :=_bbaf (_bbgg ,_bgdcf ,_fbac ,ctx );if _dddef !=nil {_ee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dddef );
return nil ,ctx ,_dddef ;};ctx =_bgbc ;_afggg =append (_afggg ,_bbgg );if _fbac =_cbccf ;len (_cbccf )==0{break ;};if len (_cbccf )==_cdadcc {return nil ,ctx ,_ge .New ("\u006e\u006f\u0074\u0020\u0065\u006e\u006f\u0075\u0067\u0068 \u0073\u0070\u0061\u0063\u0065\u0020\u0066o\u0072\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068");
};_bbgg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bgbc =ctx ;_bgbc .Y =ctx .Margins .Top ;_bgbc .X =ctx .Margins .Left +_bgdcf ._dadf .Left ;_bgbc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_bgbc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bgdcf ._dadf .Left -_bgdcf ._dadf .Right ;
ctx =_bgbc ;_cdadcc =len (_cbccf );};if _bgdcf ._dageg .IsRelative (){ctx .Y +=_bgdcf ._dadf .Bottom ;ctx .Height -=_bgdcf ._dadf .Bottom ;if !ctx .Inline {ctx .X =_cafba .X ;ctx .Width =_cafba .Width ;};return _afggg ,ctx ,nil ;};return _afggg ,_cafba ,nil ;
};func _aecf (_afdb ,_cafg TextStyle )*Invoice {_gfea :=&Invoice {_aabb :"\u0049N\u0056\u004f\u0049\u0043\u0045",_bbee :"\u002c\u0020",_faeg :_afdb ,_bdag :_cafg };_gfea ._bege =&InvoiceAddress {Separator :_gfea ._bbee };_gfea ._ecff =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_gfea ._bbee };
_cfed :=ColorRGBFrom8bit (245,245,245);_fefcc :=ColorRGBFrom8bit (155,155,155);_gfea ._dccef =_cafg ;_gfea ._dccef .Color =_fefcc ;_gfea ._dccef .FontSize =20;_gfea ._dbbe =_afdb ;_gfea ._abf =_cafg ;_gfea ._ddbe =_afdb ;_gfea ._ccfb =_cafg ;_gfea ._babf =_gfea .NewCellProps ();
_gfea ._babf .BackgroundColor =_cfed ;_gfea ._babf .TextStyle =_cafg ;_gfea ._edga =_gfea .NewCellProps ();_gfea ._edga .TextStyle =_cafg ;_gfea ._edga .BackgroundColor =_cfed ;_gfea ._edga .BorderColor =_cfed ;_gfea ._ecaa =_gfea .NewCellProps ();_gfea ._ecaa .BorderColor =_cfed ;
_gfea ._ecaa .BorderSides =[]CellBorderSide {CellBorderSideBottom };_gfea ._ecaa .Alignment =CellHorizontalAlignmentRight ;_gfea ._aefg =_gfea .NewCellProps ();_gfea ._aefg .Alignment =CellHorizontalAlignmentRight ;_gfea ._aca =[2]*InvoiceCell {_gfea .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_gfea ._babf ),_gfea .newCell ("",_gfea ._babf )};
_gfea ._cadc =[2]*InvoiceCell {_gfea .newCell ("\u0044\u0061\u0074\u0065",_gfea ._babf ),_gfea .newCell ("",_gfea ._babf )};_gfea ._cdfc =[2]*InvoiceCell {_gfea .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_gfea ._babf ),_gfea .newCell ("",_gfea ._babf )};
_gfea ._ffda =[2]*InvoiceCell {_gfea .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_gfea ._aefg ),_gfea .newCell ("",_gfea ._aefg )};_afgf :=_gfea ._aefg ;_afgf .TextStyle =_cafg ;_afgf .BackgroundColor =_cfed ;_afgf .BorderColor =_cfed ;
_gfea ._eegf =[2]*InvoiceCell {_gfea .newCell ("\u0054\u006f\u0074a\u006c",_afgf ),_gfea .newCell ("",_afgf )};_gfea ._eccg =[2]string {"\u004e\u006f\u0074e\u0073",""};_gfea ._caeed =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_gfea ._agbb =[]*InvoiceCell {_gfea .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_gfea .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_gfea .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_gfea .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _gfea ;};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};func _gbgaf (_afbff *templateProcessor ,_gbfac *templateNode )(interface{},error ){return _afbff .parseImage (_gbfac );};

// Width returns the width of the graphic svg.
func (_eeff *GraphicSVG )Width ()float64 {return _eeff ._gdbd .Width };

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_cgbc *_gad .PolyBezierCurve ;_faba float64 ;_bbga float64 ;_fddb Color ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_ecfa *Invoice )Sections ()[][2]string {return _ecfa ._gbae };

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_bcda *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _ffag (xc ,yc ,width ,height );};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_ccgf *Invoice )SetAddressHeadingStyle (style TextStyle ){_ccgf ._abf =style };

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};func (_bdee *Invoice )generateTotalBlocks (_eeab DrawContext )([]*Block ,DrawContext ,error ){_cefb :=_bfdec (4);
_cefb .SetMargins (0,0,10,10);_debe :=[][2]*InvoiceCell {_bdee ._ffda };_debe =append (_debe ,_bdee ._bgebb ...);_debe =append (_debe ,_bdee ._eegf );for _ ,_gaae :=range _debe {_fafg ,_fccaa :=_gaae [0],_gaae [1];if _fccaa .Value ==""{continue ;};_cefb .SkipCells (2);
_eafb :=_cefb .NewCell ();_eafb .SetBackgroundColor (_fafg .BackgroundColor );_eafb .SetHorizontalAlignment (_fccaa .Alignment );_bdee .setCellBorder (_eafb ,_fafg );_edcd :=_ggcdc (_fafg .TextStyle );_edcd .SetMargins (0,0,2,1);_edcd .Append (_fafg .Value );
_eafb .SetContent (_edcd );_eafb =_cefb .NewCell ();_eafb .SetBackgroundColor (_fccaa .BackgroundColor );_eafb .SetHorizontalAlignment (_fccaa .Alignment );_bdee .setCellBorder (_eafb ,_fafg );_edcd =_ggcdc (_fccaa .TextStyle );_edcd .SetMargins (0,0,2,1);
_edcd .Append (_fccaa .Value );_eafb .SetContent (_edcd );};return _cefb .GeneratePageBlocks (_eeab );};

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_aeba *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _geeed (x ,y ,width ,height );};func _deef (_dcge ,_bbef ,_ebbbd float64 )(_bbefa ,_bdeb ,_defbfg ,_cdaff float64 ){if _ebbbd ==0{return 0,0,_dcge ,_bbef ;};_bagdb :=_gad .Path {Points :[]_gad .Point {_gad .NewPoint (0,0).Rotate (_ebbbd ),_gad .NewPoint (_dcge ,0).Rotate (_ebbbd ),_gad .NewPoint (0,_bbef ).Rotate (_ebbbd ),_gad .NewPoint (_dcge ,_bbef ).Rotate (_ebbbd )}}.GetBoundingBox ();
return _bagdb .X ,_bagdb .Y ,_bagdb .Width ,_bagdb .Height ;};func (_fgdb *Invoice )generateLineBlocks (_bebg DrawContext )([]*Block ,DrawContext ,error ){_bbae :=_bfdec (len (_fgdb ._agbb ));_bbae .SetMargins (0,0,25,0);for _ ,_fggg :=range _fgdb ._agbb {_bfbg :=_ggcdc (_fggg .TextStyle );
_bfbg .SetMargins (0,0,1,0);_bfbg .Append (_fggg .Value );_gadf :=_bbae .NewCell ();_gadf .SetHorizontalAlignment (_fggg .Alignment );_gadf .SetBackgroundColor (_fggg .BackgroundColor );_fgdb .setCellBorder (_gadf ,_fggg );_gadf .SetContent (_bfbg );};
for _ ,_gbcd :=range _fgdb ._gddbf {for _ ,_adga :=range _gbcd {_gdge :=_ggcdc (_adga .TextStyle );_gdge .SetMargins (0,0,3,2);_gdge .Append (_adga .Value );_baca :=_bbae .NewCell ();_baca .SetHorizontalAlignment (_adga .Alignment );_baca .SetBackgroundColor (_adga .BackgroundColor );
_fgdb .setCellBorder (_baca ,_adga );_baca .SetContent (_gdge );};};return _bbae .GeneratePageBlocks (_bebg );};func (_agbgab *templateProcessor )parseBoolAttr (_abeeb ,_bcfdg string )bool {_ee .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_abeeb ,_bcfdg );
_bgbee ,_ :=_bb .ParseBool (_bcfdg );return _bcfdg ==""||_bgbee ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_gbeb *List )SetIndent (indent float64 ){_gbeb ._eaef =indent ;_gbeb ._cbeab =false };

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_fcgb float64 ;_aeea float64 ;_eefg float64 ;_bfbgf float64 ;_baefg Color ;_dedd _gad .LineStyle ;_ffbdb float64 ;_daab []int64 ;_edae int64 ;_fffb float64 ;_dabg Positioning ;_egfe FitMode ;_babe Margins ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_ccgfee *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_ccgfee .Text },nil ;};var _ggdff []string ;var _bgad []rune ;var _bdbb float64 ;var _gcdf []float64 ;_agbf :=_ccgfee .Style ;_bece :=_cbbcb (_ccgfee .Text );
for _ ,_cagd :=range _ccgfee .Text {if _cagd =='\u000A'{_deacb :=_eefe (string (_bgad ),_bece );_ggdff =append (_ggdff ,_dd .TrimRightFunc (_deacb ,_fa .IsSpace )+string (_cagd ));_bgad =nil ;_bdbb =0;_gcdf =nil ;continue ;};_begcb :=_cagd ==' ';_afbd ,_ggegf :=_agbf .Font .GetRuneMetrics (_cagd );
if !_ggegf {_ee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_cagd ,_cagd ,_agbf .Font .BaseFont (),_agbf .Font .Subtype ());
_ee .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_agbf .Font );_ee .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_agbf .Font .Encoder ());return nil ,_ge .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_facfc :=_agbf .FontSize *_afbd .Wx ;_gdce :=_facfc ;if !_begcb {_gdce =_facfc +_agbf .CharSpacing *1000.0;};if _bdbb +_facfc > width *1000.0{_feff :=-1;if !_begcb {for _cadea :=len (_bgad )-1;_cadea >=0;_cadea --{if _bgad [_cadea ]==' '{_feff =_cadea ;
break ;};};};_deeab :=string (_bgad );if _feff > 0{_deeab =string (_bgad [0:_feff +1]);_bgad =append (_bgad [_feff +1:],_cagd );_gcdf =append (_gcdf [_feff +1:],_gdce );_bdbb =0;for _ ,_dggec :=range _gcdf {_bdbb +=_dggec ;};}else {if _begcb {_bgad =[]rune {};
_gcdf =[]float64 {};_bdbb =0;}else {_bgad =[]rune {_cagd };_gcdf =[]float64 {_gdce };_bdbb =_gdce ;};};_deeab =_eefe (_deeab ,_bece );_ggdff =append (_ggdff ,_dd .TrimRightFunc (_deeab ,_fa .IsSpace ));}else {_bgad =append (_bgad ,_cagd );_bdbb +=_gdce ;
_gcdf =append (_gcdf ,_gdce );};};if len (_bgad )> 0{_faegab :=string (_bgad );_faegab =_eefe (_faegab ,_bece );_ggdff =append (_ggdff ,_faegab );};return _ggdff ,nil ;};

// RotatedSize returns the width and height of the rotated block.
func (_aba *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_bcc ,_age :=_deef (_aba ._eg ,_aba ._gg ,_aba ._fc );return _bcc ,_age ;};func (_accb *pageTransformations )transformBlock (_dgge *Block ){if _accb ._aeef !=nil {_dgge .transform (*_accb ._aeef );
};};func _dfcfd (_eggaf *_bbd .PdfFont ,_bgeaeg float64 )*fontMetrics {_cgcee :=&fontMetrics {};if _eggaf ==nil {_ee .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0066\u006f\u006e\u0074\u0020\u0069s\u0020\u006e\u0069\u006c");return _cgcee ;};_bcabc ,_feec :=_eggaf .GetFontDescriptor ();
if _feec !=nil {_ee .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063ri\u0070\u0074\u006fr\u003a \u0025\u0076",_feec );
return _cgcee ;};if _cgcee ._acdff ,_feec =_bcabc .GetCapHeight ();_feec !=nil {_ee .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0067\u0065\u0074\u0020f\u006f\u006e\u0074\u0020\u0063\u0061\u0070\u0020\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_feec );
};if int (_cgcee ._acdff )<=0{_ee .Log .Trace ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_cgcee ._acdff =1000;};_cgcee ._acdff *=_bgeaeg /1000.0;if _cgcee ._ffaf ,_feec =_bcabc .GetXHeight ();_feec !=nil {_ee .Log .Trace ("\u0057\u0041R\u004e\u003a\u0020\u0055n\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0078\u002d\u0068\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_feec );
};_cgcee ._ffaf *=_bgeaeg /1000.0;if _cgcee ._bcecg ,_feec =_bcabc .GetAscent ();_feec !=nil {_ee .Log .Trace ("W\u0041\u0052\u004e\u003a\u0020\u0055n\u0061\u0062\u006c\u0065\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0066\u006fn\u0074\u0020\u0061\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_feec );
};_cgcee ._bcecg *=_bgeaeg /1000.0;if _cgcee ._fbbdb ,_feec =_bcabc .GetDescent ();_feec !=nil {_ee .Log .Trace ("\u0057\u0041RN\u003a\u0020\u0055n\u0061\u0062\u006c\u0065 to\u0020ge\u0074\u0020\u0066\u006f\u006e\u0074\u0020de\u0073\u0063\u0065\u006e\u0074\u003a\u0020%\u0076",_feec );
};_cgcee ._fbbdb *=_bgeaeg /1000.0;return _cgcee ;};func _fddgf (_egccd *templateProcessor ,_caecf *templateNode )(interface{},error ){return _egccd .parseTableCell (_caecf );};

// DrawHeader sets a function to draw a header on created output pages.
func (_agba *Creator )DrawHeader (drawHeaderFunc func (_fcgd *Block ,_ffb HeaderFunctionArgs )){_agba ._aaa =drawHeaderFunc ;};func (_ffea *templateProcessor )parseColorAttr (_edgc ,_afaag string )Color {_ee .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_edgc ,_afaag );
_afaag =_dd .TrimSpace (_afaag );if _dd .HasPrefix (_afaag ,"\u006c\u0069n\u0065\u0061\u0072-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_dd .HasSuffix (_afaag ,"\u0029")&&len (_afaag )> 17{return _ffea .parseLinearGradientAttr (_ffea .creator ,_afaag );
};if _dd .HasPrefix (_afaag ,"\u0072\u0061d\u0069\u0061\u006c-\u0067\u0072\u0061\u0064\u0069\u0065\u006e\u0074\u0028")&&_dd .HasSuffix (_afaag ,"\u0029")&&len (_afaag )> 17{return _ffea .parseRadialGradientAttr (_ffea .creator ,_afaag );};if _aafcg :=_ffea .parseColor (_afaag );
_aafcg !=nil {return _aafcg ;};return ColorBlack ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_dfeaa *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ddb :=ctx ;if _dfeaa ._cfb .IsRelative (){ctx .X +=_dfeaa ._cee .Left ;ctx .Y +=_dfeaa ._cee .Top ;ctx .Width -=_dfeaa ._cee .Left +_dfeaa ._cee .Right ;ctx .Height -=_dfeaa ._cee .Top ;
};_gbb ,_gfd ,_fdec :=_dfeaa ._fgef .GeneratePageBlocks (ctx );if _fdec !=nil {return _gbb ,ctx ,_fdec ;};ctx =_gfd ;_dffc :=ctx .X ;_fca :=ctx .Y -_dfeaa ._fgef .Height ();_agbg :=int64 (ctx .Page );_bbcb :=_dfeaa .headingNumber ();_ada :=_dfeaa .headingText ();
if _dfeaa ._efb {_cdfb :=_dfeaa ._abc .Add (_bbcb ,_dfeaa ._feb ,_bb .FormatInt (_agbg ,10),_dfeaa ._ddf );if _dfeaa ._abc ._fbfca {_cdfb .SetLink (_agbg ,_dffc ,_fca );};};if _dfeaa ._gce ==nil {_dfeaa ._gce =_bbd .NewOutlineItem (_ada ,_bbd .NewOutlineDest (_agbg -1,_dffc ,_fca ));
if _dfeaa ._bcd !=nil {_dfeaa ._bcd ._gce .Add (_dfeaa ._gce );}else {_dfeaa ._babb .Add (_dfeaa ._gce );};}else {_cad :=&_dfeaa ._gce .Dest ;_cad .Page =_agbg -1;_cad .X =_dffc ;_cad .Y =_fca ;};for _ ,_dcaa :=range _dfeaa ._gba {_aadb ,_eab ,_bcb :=_dcaa .GeneratePageBlocks (ctx );
if _bcb !=nil {return _gbb ,ctx ,_bcb ;};if len (_aadb )< 1{continue ;};_gbb [len (_gbb )-1].mergeBlocks (_aadb [0]);_gbb =append (_gbb ,_aadb [1:]...);ctx =_eab ;};if _dfeaa ._cfb .IsRelative (){ctx .X =_ddb .X ;};if _dfeaa ._cfb .IsAbsolute (){return _gbb ,_ddb ,nil ;
};return _gbb ,ctx ,nil ;};func _eggc (_aafc *_bbd .Image )(*Image ,error ){_aecb :=float64 (_aafc .Width );_bdgc :=float64 (_aafc .Height );return &Image {_dcce :_aafc ,_accbf :_aecb ,_cdad :_bdgc ,_bfdf :_aecb ,_bcec :_bdgc ,_bbed :0,_gcce :1.0,_fgcd :PositionRelative },nil ;
};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_baec float64 ;_acfd float64 ;_eeaf float64 ;_eadc float64 ;_cefce float64 ;_eddf float64 ;_dgda Color ;_ffgc float64 ;};func (_caab *Block )transform (_afd _eb .Matrix ){_cef :=_da .NewContentCreator ().Add_cm (_afd [0],_afd [1],_afd [3],_afd [4],_afd [6],_afd [7]).Operations ();
*_caab ._ec =append (*_cef ,*_caab ._ec ...);_caab ._ec .WrapIfNeeded ();};func (_fgfb *Creator )newPage ()*_bbd .PdfPage {_decb :=_bbd .NewPdfPage ();_acfe :=_fgfb ._baba [0];_gcgd :=_fgfb ._baba [1];_fada :=_bbd .PdfRectangle {Llx :0,Lly :0,Urx :_acfe ,Ury :_gcgd };
_decb .MediaBox =&_fada ;_fgfb ._afgc =_acfe ;_fgfb ._ebeb =_gcgd ;_fgfb .initContext ();return _decb ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_fbfd *Invoice )NoteHeadingStyle ()TextStyle {return _fbfd ._ccfb };

// Width returns the Block's width.
func (_aab *Block )Width ()float64 {return _aab ._eg };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_fedc *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_fgdcc :=range subtable ._gggdf {_acggb :=&TableCell {};*_acggb =*_fgdcc ;_acggb ._bdcge =_fedc ;_acggb ._aeec +=col -1;if _dccb :=_fedc ._efbf -(_acggb ._aeec -1);_dccb < _acggb ._cfbea {_fedc ._efbf +=_acggb ._cfbea -_dccb ;
_fedc .resetColumnWidths ();_ee .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_fedc ._efbf );
};_acggb ._cddg +=row -1;_bccfa :=subtable ._abaa [_fgdcc ._cddg -1];if _acggb ._cddg > _fedc ._gcgba {for _acggb ._cddg > _fedc ._gcgba {_fedc ._gcgba ++;_fedc ._abaa =append (_fedc ._abaa ,_fedc ._bcgeag );};_fedc ._abaa [_acggb ._cddg -1]=_bccfa ;}else {_fedc ._abaa [_acggb ._cddg -1]=_bbg .Max (_fedc ._abaa [_acggb ._cddg -1],_bccfa );
};_fedc ._gggdf =append (_fedc ._gggdf ,_acggb );};_fedc .sortCells ();};

// CurRow returns the currently active cell's row number.
func (_bfagf *Table )CurRow ()int {_gbceg :=(_bfagf ._dace -1)/_bfagf ._efbf +1;return _gbceg };func (_bdec *InvoiceAddress )fmtLine (_beec ,_ggge string ,_edab bool )string {if _edab {_ggge ="";};return _b .Sprintf ("\u0025\u0073\u0025s\u000a",_ggge ,_beec );
};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_eaca *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_eaca ._efbf {_ee .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _ge .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eaca ._ecgg =widths ;return nil ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_befe *TOC )SetLineSeparatorStyle (style TextStyle ){_befe ._dbfaf =style };

// SetBorderWidth sets the border width of the rectangle.
func (_agcf *Rectangle )SetBorderWidth (bw float64 ){_agcf ._egdc =bw };

// SetWidthRight sets border width for right.
func (_dca *border )SetWidthRight (bw float64 ){_dca ._dbf =bw };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_abec :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_ee .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _abec ;
};var _bcfd ,_eaaf ,_agdf int ;if len (hexStr )==4{var _fbeg ,_geab ,_aed int ;_ffgg ,_cbge :=_b .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_fbeg ,&_geab ,&_aed );if _cbge !=nil {_ee .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_cbge );
return _abec ;};if _ffgg !=3{_ee .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _abec ;};_bcfd =_fbeg *16+_fbeg ;_eaaf =_geab *16+_geab ;_agdf =_aed *16+_aed ;}else {_dab ,_gggd :=_b .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_bcfd ,&_eaaf ,&_agdf );
if _gggd !=nil {_ee .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _abec ;};if _dab !=3{_ee .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_dab );
return _abec ;};};_edgg :=float64 (_bcfd )/255.0;_cbe :=float64 (_eaaf )/255.0;_fgbf :=float64 (_agdf )/255.0;_abec ._eage =_edgg ;_abec ._eaee =_cbe ;_abec ._gfe =_fgbf ;return _abec ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_gffb *Creator )DrawFooter (drawFooterFunc func (_edcb *Block ,_aeda FooterFunctionArgs )){_gffb ._bgg =drawFooterFunc ;};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_facc *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_facc ._fdcb .Left =left ;_facc ._fdcb .Right =right ;_facc ._fdcb .Top =top ;_facc ._fdcb .Bottom =bottom ;};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_aaafgd *Table )EnableRowWrap (enable bool ){_aaafgd ._bcfad =enable };

// SetLineWidth sets the line width.
func (_aggb *Polyline )SetLineWidth (lineWidth float64 ){_aggb ._efgc .LineWidth =lineWidth };

// Width returns the width of the Paragraph.
func (_fgade *StyledParagraph )Width ()float64 {if _fgade ._abbea &&int (_fgade ._ccac )> 0{return _fgade ._ccac ;};return _fgade .getTextWidth ()/1000.0;};

// SetMargins sets the margins TOC line.
func (_gbed *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_gbed ._ggcac =left ;_ebcbd :=&_gbed ._ebca ._dadf ;_ebcbd .Left =_gbed ._ggcac +float64 (_gbed ._fffag -1)*_gbed ._ebadg ;_ebcbd .Right =right ;_ebcbd .Top =top ;_ebcbd .Bottom =bottom ;
};

// SetAnchor set gradient position anchor.
// Default to center.
func (_dgged *RadialShading )SetAnchor (anchor AnchorPoint ){_dgged ._ceafc =anchor };func (_bcacb *Table )sortCells (){_g .Slice (_bcacb ._gggdf ,func (_dgfbce ,_gaecbg int )bool {_gdfbd :=_bcacb ._gggdf [_dgfbce ]._cddg ;_aeca :=_bcacb ._gggdf [_gaecbg ]._cddg ;
if _gdfbd < _aeca {return true ;};if _gdfbd > _aeca {return false ;};return _bcacb ._gggdf [_dgfbce ]._aeec < _bcacb ._gggdf [_gaecbg ]._aeec ;});};

// SkipRows skips over a specified number of rows in the table.
func (_bddec *Table )SkipRows (num int ){_adffb :=num *_bddec ._efbf -1;if _adffb < 0{_ee .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};for _cbfa :=0;_cbfa < _adffb ;_cbfa ++{_bddec .NewCell ();};};

// GeneratePageBlocks draws the curve onto page blocks.
func (_bfgf *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cgb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bfgg :=_da .NewContentCreator ();_bfgg .Add_q ().Add_w (_bfgf ._ffgc ).SetStrokingColor (_dcgf (_bfgf ._dgda )).Add_m (_bfgf ._baec ,ctx .PageHeight -_bfgf ._acfd ).Add_v (_bfgf ._eeaf ,ctx .PageHeight -_bfgf ._eadc ,_bfgf ._cefce ,ctx .PageHeight -_bfgf ._eddf ).Add_S ().Add_Q ();
_dfg :=_cgb .addContentsByString (_bfgg .String ());if _dfg !=nil {return nil ,ctx ,_dfg ;};return []*Block {_cgb },ctx ,nil ;};func (_baab *Invoice )setCellBorder (_geaf *TableCell ,_cdadc *InvoiceCell ){for _ ,_gfebb :=range _cdadc .BorderSides {_geaf .SetBorder (_gfebb ,CellBorderStyleSingle ,_cdadc .BorderWidth );
};_geaf .SetBorderColor (_cdadc .BorderColor );};

// InsertColumn inserts a column in the line items table at the specified index.
func (_ebfb *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_agf :=uint (len (_ebfb ._agbb ));if index > _agf {index =_agf ;};_agcb :=_ebfb .NewColumn (description );_ebfb ._agbb =append (_ebfb ._agbb [:index ],append ([]*InvoiceCell {_agcb },_ebfb ._agbb [index :]...)...);
return _agcb ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_faccc *Invoice )SetNoteHeadingStyle (style TextStyle ){_faccc ._ccfb =style };

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_bbd .PdfPage )(*Block ,error ){_fdf :=&Block {};_bce ,_cfa :=page .GetAllContentStreams ();if _cfa !=nil {return nil ,_cfa ;};_ac :=_da .NewContentStreamParser (_bce );_ae ,_cfa :=_ac .Parse ();if _cfa !=nil {return nil ,_cfa ;
};_ae .WrapIfNeeded ();_fdf ._ec =_ae ;if page .Resources !=nil {_fdf ._ce =page .Resources ;}else {_fdf ._ce =_bbd .NewPdfPageResources ();};_bde ,_cfa :=page .GetMediaBox ();if _cfa !=nil {return nil ,_cfa ;};if _bde .Llx !=0||_bde .Lly !=0{_fdf .translate (-_bde .Llx ,_bde .Lly );
};_fdf ._eg =_bde .Urx -_bde .Llx ;_fdf ._gg =_bde .Ury -_bde .Lly ;if page .Rotate !=nil {_fdf ._fc =-float64 (*page .Rotate );};return _fdf ,nil ;};func _gff (_dgg ,_badg *_bbd .PdfPageResources )error {_bdd ,_ :=_dgg .GetColorspaces ();if _bdd !=nil &&len (_bdd .Colorspaces )> 0{for _dfd ,_aeb :=range _bdd .Colorspaces {_ddgc :=*_bf .MakeName (_dfd );
if _badg .HasColorspaceByName (_ddgc ){continue ;};_dge :=_badg .SetColorspaceByName (_ddgc ,_aeb );if _dge !=nil {return _dge ;};};};return nil ;};

// Color returns the color of the line.
func (_caaf *Line )Color ()Color {return _caaf ._baefg };

// SetLineColor sets the line color.
func (_dbedd *Polyline )SetLineColor (color Color ){_dbedd ._efgc .LineColor =_dcgf (color )};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_daba *Ellipse )ScaleToHeight (h float64 ){_eedgd :=_daba ._dgga /_daba ._dgdg ;_daba ._dgdg =h ;_daba ._dgga =h *_eedgd ;};

// SetFillColor sets the fill color.
func (_badf *Polygon )SetFillColor (color Color ){_badf ._fbceb =color ;_badf ._bbbe .FillColor =_dcgf (color );};func _afc ()*listItem {return &listItem {}};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_gfgcc *RadialShading )ToPdfShadingPattern ()*_bbd .PdfShadingPatternType3 {_ecbcc ,_ged ,_ffee :=_gfgcc ._daacc ._cfgfd .ToRGB ();_cbabc :=_gfgcc .shadingModel ();_cbabc .PdfShading .Background =_bf .MakeArrayFromFloats ([]float64 {_ecbcc ,_ged ,_ffee });
_adfe :=_bbd .NewPdfShadingPatternType3 ();_adfe .Shading =_cbabc ;return _adfe ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_gcca *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _gdcd (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// SetAngle sets the rotation angle in degrees.
func (_fb *Block )SetAngle (angleDeg float64 ){_fb ._fc =angleDeg };func (_begcc *templateProcessor )parseColor (_ddggd string )Color {if _ddggd ==""{return nil ;};_fabec ,_addgg :=_begcc ._afgef .ColorMap [_ddggd ];if _addgg {return _fabec ;};if _ddggd [0]=='#'{return ColorRGBFromHex (_ddggd );
};return nil ;};func (_dgbcb *templateProcessor )renderNode (_gaecd *templateNode )error {_fgbe :=_gaecd ._dceb ;if _fgbe ==nil {return nil ;};_dcdda :=_gaecd ._ebeg .Name .Local ;_caaec ,_dgbe :=_bcfge [_dcdda ];if !_dgbe {_dgbcb .nodeLogDebug (_gaecd ,"I\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u002e \u0053\u006b\u0069p\u0070i\u006e\u0067\u002e",_dcdda );
return nil ;};var _bgcd interface{};if _gaecd ._afbge !=nil &&_gaecd ._afbge ._dceb !=nil {_gagfe :=_gaecd ._afbge ._ebeg .Name .Local ;if _ ,_dgbe =_caaec ._bfed [_gagfe ];!_dgbe {_dgbcb .nodeLogDebug (_gaecd ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_gagfe ,_dcdda );
return _gcgf ;};_bgcd =_gaecd ._afbge ._dceb ;}else {_bgbgb :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _dgbcb ._gdeg .(type ){case *Block :_bgbgb ="\u0062\u006c\u006fc\u006b";};if _ ,_dgbe =_caaec ._bfed [_bgbgb ];!_dgbe {_dgbcb .nodeLogDebug (_gaecd ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e \u0069\u0073\u0020no\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u003c\u0025\u0073\u003e\u0020\u0074a\u0067\u002e",_bgbgb ,_dcdda );
return _gcgf ;};_bgcd =_dgbcb ._gdeg ;};switch _ecage :=_bgcd .(type ){case componentRenderer :_fbbb ,_gcgbaa :=_fgbe .(Drawable );if !_gcgbaa {_dgbcb .nodeLogError (_gaecd ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u002e",_dcdda ,_fgbe );
return _fbdf ;};_faace :=_ecage .Draw (_fbbb );if _faace !=nil {return _dgbcb .nodeError (_gaecd ,"\u0043\u0061\u006en\u006f\u0074\u0020\u0064r\u0061\u0077\u0073\u0020\u0074\u0061\u0067 \u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u003a\u0020\u0025\u0073\u002e",_dcdda ,_fgbe ,_faace );
};case *Division :switch _cbdf :=_fgbe .(type ){case *Background :_ecage .SetBackground (_cbdf );case VectorDrawable :_dacad :=_ecage .Add (_cbdf );if _dacad !=nil {return _dgbcb .nodeError (_gaecd ,"\u0043a\u006e\u006eo\u0074\u0020\u0061d\u0064\u0020\u0074\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054)\u0020\u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0044\u0069\u0076i\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073\u002e",_dcdda ,_fgbe ,_dacad );
};};case *TableCell :_adeca ,_cgfcg :=_fgbe .(VectorDrawable );if !_cgfcg {_dgbcb .nodeLogError (_gaecd ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074 \u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_dcdda ,_fgbe );
return _fbdf ;};_geaea :=_ecage .SetContent (_adeca );if _geaea !=nil {return _dgbcb .nodeError (_gaecd ,"C\u0061\u006e\u006e\u006f\u0074\u0020\u0061\u0064\u0064 \u0074\u0061\u0067\u0020\u003c\u0025\u0073> \u0028\u0025\u0054\u0029 \u0069\u006e\u0074\u006f\u0020\u0061\u0020\u0074\u0061bl\u0065\u0020c\u0065\u006c\u006c\u003a\u0020\u0025\u0073\u002e",_dcdda ,_fgbe ,_geaea );
};case *StyledParagraph :_cfecc ,_gdfaa :=_fgbe .(*TextChunk );if !_gdfaa {_dgbcb .nodeLogError (_gaecd ,"\u0054\u0061\u0067 <\u0025\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020i\u0073 \u006eo\u0074 \u0061\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u002e",_dcdda ,_fgbe );
return _fbdf ;};_ecage .appendChunk (_cfecc );case *Chapter :switch _begdde :=_fgbe .(type ){case *Chapter :return nil ;case *Paragraph :if _gaecd ._ebeg .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};_gcba :=_ecage .Add (_begdde );if _gcba !=nil {return _dgbcb .nodeError (_gaecd ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_dcdda ,_fgbe ,_gcba );
};case Drawable :_dece :=_ecage .Add (_begdde );if _dece !=nil {return _dgbcb .nodeError (_gaecd ,"\u0043a\u006e\u006eo\u0074\u0020\u0061\u0064d\u0020\u0074\u0061g\u0020\u003c\u0025\u0073\u003e\u0020\u0028\u0025\u0054) \u0069\u006e\u0074o\u0020\u0061 \u0043\u0068\u0061\u0070\u0074\u0065r\u003a\u0020%\u0073\u002e",_dcdda ,_fgbe ,_dece );
};};case *List :switch _gcgdc :=_fgbe .(type ){case *TextChunk :case *listItem :_ecage ._gebg =append (_ecage ._gebg ,_gcgdc );default:_dgbcb .nodeLogError (_gaecd ,"\u0054\u0061\u0067\u0020\u003c\u0025\u0073>\u0020\u0028\u0025T\u0029\u0020\u0069\u0073 \u006e\u006f\u0074\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u0020\u0069\u0074\u0065\u006d\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dcdda ,_fgbe );
};case *listItem :switch _fgefc :=_fgbe .(type ){case *TextChunk :case *StyledParagraph :_ecage ._dgfd =_fgefc ;case *List :if _fgefc ._cbeab {_fgefc ._eaef =15;};_ecage ._dgfd =_fgefc ;case *Image :_ecage ._dgfd =_fgefc ;case *Division :_ecage ._dgfd =_fgefc ;
case *Table :_ecage ._dgfd =_fgefc ;default:_dgbcb .nodeLogError (_gaecd ,"\u0054\u0061\u0067\u0020\u003c%\u0073\u003e\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u0061\u0020\u006c\u0069\u0073\u0074\u002e",_dcdda ,_fgbe );
return _fbdf ;};};return nil ;};

// NewImageFromFile creates an Image from a file.
func (_agcc *Creator )NewImageFromFile (path string )(*Image ,error ){return _ddfb (path )};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_ceeg *Image )SetEncoder (encoder _bf .StreamEncoder ){_ceeg ._ccfa =encoder };

// Width returns the cell's width based on the input draw context.
func (_cdee *TableCell )Width (ctx DrawContext )float64 {_gfaa :=float64 (0.0);for _dedde :=0;_dedde < _cdee ._cfbea ;_dedde ++{_gfaa +=_cdee ._bdcge ._ecgg [_cdee ._aeec +_dedde -1];};_gbbf :=ctx .Width *_gfaa ;return _gbbf ;};

// SetFillColor sets background color for border.
func (_ggf *border )SetFillColor (col Color ){_ggf ._cfd =col };

// BorderColor returns the border color of the rectangle.
func (_fbfb *Rectangle )BorderColor ()Color {return _fbfb ._acbae };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// SetEnableWrap sets the line wrapping enabled flag.
func (_bggcg *Paragraph )SetEnableWrap (enableWrap bool ){_bggcg ._bacce =enableWrap ;_bggcg ._gecd =false ;};

// SetCompactMode sets the compact mode flag for this table.
//
// By enabling compact mode, table cell that contains Paragraph/StyleParagraph
// would not add extra height when calculating it's height.
//
// The default value is false.
func (_aacba *Table )SetCompactMode (enable bool ){_aacba ._eedb =enable };

// SetTerms sets the terms and conditions section of the invoice.
func (_bcab *Invoice )SetTerms (title ,content string ){_bcab ._caeed =[2]string {title ,content }};

// Lines returns all the lines the table of contents has.
func (_fcge *TOC )Lines ()[]*TOCLine {return _fcge ._dcbb };

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_gebea *Division )EnablePageWrap (enable bool ){_gebea ._acd =enable };func _egbg ()*FilledCurve {_aaad :=FilledCurve {};_aaad ._dbca =[]_gad .CubicBezierCurve {};return &_aaad ;};func (_ggff *Image )makeXObject ()error {_ecbf ,_bddea :=_bbd .NewXObjectImageFromImage (_ggff ._dcce ,nil ,_ggff ._ccfa );
if _bddea !=nil {_ee .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bddea );return _bddea ;};_ggff ._dgcf =_ecbf ;
return nil ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_dddfb *TextChunk )SetAnnotation (annotation *_bbd .PdfAnnotation ){_dddfb ._gdege =annotation };func (_abbad *templateProcessor )parseImage (_bafcf *templateNode )(interface{},error ){var _bcgfb string ;for _ ,_abgff :=range _bafcf ._ebeg .Attr {_cdfbc :=_abgff .Value ;
switch _cedf :=_abgff .Name .Local ;_cedf {case "\u0073\u0072\u0063":_bcgfb =_cdfbc ;};};_febdf ,_ggdag :=_abbad .loadImageFromSrc (_bcgfb );if _ggdag !=nil {return nil ,_ggdag ;};for _ ,_cbgde :=range _bafcf ._ebeg .Attr {_defeb :=_cbgde .Value ;switch _fcbae :=_cbgde .Name .Local ;
_fcbae {case "\u0061\u006c\u0069g\u006e":_febdf .SetHorizontalAlignment (_abbad .parseHorizontalAlignmentAttr (_fcbae ,_defeb ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_febdf .SetOpacity (_abbad .parseFloatAttr (_fcbae ,_defeb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_beaff :=_abbad .parseMarginAttr (_fcbae ,_defeb );
_febdf .SetMargins (_beaff .Left ,_beaff .Right ,_beaff .Top ,_beaff .Bottom );case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_febdf .SetFitMode (_abbad .parseFitModeAttr (_fcbae ,_defeb ));case "\u0078":_febdf .SetPos (_abbad .parseFloatAttr (_fcbae ,_defeb ),_febdf ._fgba );
case "\u0079":_febdf .SetPos (_febdf ._agcca ,_abbad .parseFloatAttr (_fcbae ,_defeb ));case "\u0077\u0069\u0064t\u0068":_febdf .SetWidth (_abbad .parseFloatAttr (_fcbae ,_defeb ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_febdf .SetHeight (_abbad .parseFloatAttr (_fcbae ,_defeb ));
case "\u0061\u006e\u0067l\u0065":_febdf .SetAngle (_abbad .parseFloatAttr (_fcbae ,_defeb ));case "\u0073\u0072\u0063":break ;default:_abbad .nodeLogDebug (_bafcf ,"\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_fcbae );
};};return _febdf ,nil ;};

// SetSideBorderColor sets the cell's side border color.
func (_gefec *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_gefec ._acaa =col ;_gefec ._cfcd =col ;_gefec ._baecc =col ;_gefec ._bgbe =col ;case CellBorderSideTop :_gefec ._acaa =col ;case CellBorderSideBottom :_gefec ._cfcd =col ;
case CellBorderSideLeft :_gefec ._baecc =col ;case CellBorderSideRight :_gefec ._bgbe =col ;};};

// BorderColor returns the border color of the ellipse.
func (_feca *Ellipse )BorderColor ()Color {return _feca ._dgdf };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_gbcee *StyledParagraph )Insert (index uint ,text string )*TextChunk {_gafga :=uint (len (_gbcee ._gacc ));if index > _gafga {index =_gafga ;};_eefb :=NewTextChunk (text ,_gbcee ._abeaf );_gbcee ._gacc =append (_gbcee ._gacc [:index ],append ([]*TextChunk {_eefb },_gbcee ._gacc [index :]...)...);
_gbcee .wrapText ();return _eefb ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_bbbfc *Table )MultiColCell (colspan int )*TableCell {return _bbbfc .MultiCell (1,colspan )};func _afbde (_cfbgc *_bbd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_cfbgc ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_fbd *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fbd ._cf .Left ,_fbd ._cf .Right ,_fbd ._cf .Top ,_fbd ._cf .Bottom ;};

// ToRGB implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_eaacf *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_eebf _ba .ChartRenderable ;_ecce Positioning ;_bdaf float64 ;_ecfb float64 ;_ceac Margins ;};

// SetFontSize sets the font size in document units (points).
func (_degg *Paragraph )SetFontSize (fontSize float64 ){_degg ._gfddf =fontSize };

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_bed *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_cdb ,_ ,_faa :=d .GeneratePageBlocks (ctx );if _faa !=nil {return _faa ;};if len (_cdb )!=1{return ErrContentNotFit ;};for _ ,_cag :=range _cdb {if _dde :=_bed .mergeBlocks (_cag );
_dde !=nil {return _dde ;};};return nil ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_cdcbb *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_cdcbb ._fegaf =halign ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_cfga float64 ;_adcc float64 ;_dgga float64 ;_dgdg float64 ;_cafbc Positioning ;_bfde Color ;_bcgab float64 ;_dgdf Color ;_cbab float64 ;_eaf float64 ;_fdcb Margins ;_aacb FitMode ;};

// SellerAddress returns the seller address used in the invoice template.
func (_ccdac *Invoice )SellerAddress ()*InvoiceAddress {return _ccdac ._bege };

// AddColorStop add color stop information for rendering gradient.
func (_dgef *shading )AddColorStop (color Color ,point float64 ){_dgef ._eeee =append (_dgef ._eeee ,_fag (color ,point ));};

// Angle returns the block rotation angle in degrees.
func (_db *Block )Angle ()float64 {return _db ._fc };

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_fdcf *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_fdcf ._daab =dashArray ;_fdcf ._edae =dashPhase ;};func (_gfacc *templateProcessor )parseTextAlignmentAttr (_dgea ,_dccbg string )TextAlignment {_ee .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dgea ,_dccbg );
_gefdb :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_dccbg ];
return _gefdb ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_bcbbf *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_bcbbf ._ffedg =valign };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_fff *Creator )Finalize ()error {if _fff ._dbg {return nil ;};_gcaa :=len (_fff ._afbe );_ggae :=0;if _fff ._bdcb !=nil {_fdaa :=*_fff ;_fff ._afbe =nil ;_fff ._faee =nil ;_fff .initContext ();_bega :=FrontpageFunctionArgs {PageNum :1,TotalPages :_gcaa };
_fff ._bdcb (_bega );_ggae +=len (_fff ._afbe );_fff ._afbe =_fdaa ._afbe ;_fff ._faee =_fdaa ._faee ;};if _fff .AddTOC {_fff .initContext ();_fff ._ffdd .Page =_ggae +1;if _fff .CustomTOC &&_fff ._bef !=nil {_ecg :=*_fff ;_fff ._afbe =nil ;_fff ._faee =nil ;
if _begb :=_fff ._bef (_fff ._ggab );_begb !=nil {return _begb ;};_ggae +=len (_fff ._afbe );_fff ._afbe =_ecg ._afbe ;_fff ._faee =_ecg ._faee ;}else {if _fff ._bef !=nil {if _ggaa :=_fff ._bef (_fff ._ggab );_ggaa !=nil {return _ggaa ;};};_bcgg ,_ ,_adgc :=_fff ._ggab .GeneratePageBlocks (_fff ._ffdd );
if _adgc !=nil {_ee .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_adgc );return _adgc ;};_ggae +=len (_bcgg );};_ggbc :=_fff ._ggab .Lines ();
for _ ,_gcbc :=range _ggbc {_fgca ,_afgd :=_bb .Atoi (_gcbc .Page .Text );if _afgd !=nil {continue ;};_gcbc .Page .Text =_bb .Itoa (_fgca +_ggae );_gcbc ._bgge +=int64 (_ggae );};};_gdfb :=false ;var _ccgd []*_bbd .PdfPage ;if _fff ._bdcb !=nil {_cab :=*_fff ;
_fff ._afbe =nil ;_fff ._faee =nil ;_bfbd :=FrontpageFunctionArgs {PageNum :1,TotalPages :_gcaa };_fff ._bdcb (_bfbd );_gcaa +=len (_fff ._afbe );_ccgd =_fff ._afbe ;_fff ._afbe =append (_fff ._afbe ,_cab ._afbe ...);_fff ._faee =_cab ._faee ;_gdfb =true ;
};var _bbb []*_bbd .PdfPage ;if _fff .AddTOC {_fff .initContext ();if _fff .CustomTOC &&_fff ._bef !=nil {_egbeg :=*_fff ;_fff ._afbe =nil ;_fff ._faee =nil ;if _dcba :=_fff ._bef (_fff ._ggab );_dcba !=nil {_ee .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_dcba );
return _dcba ;};_bbb =_fff ._afbe ;_gcaa +=len (_bbb );_fff ._afbe =_egbeg ._afbe ;_fff ._faee =_egbeg ._faee ;}else {if _fff ._bef !=nil {if _cefc :=_fff ._bef (_fff ._ggab );_cefc !=nil {_ee .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_cefc );
return _cefc ;};};_dfaf ,_ ,_ :=_fff ._ggab .GeneratePageBlocks (_fff ._ffdd );for _ ,_gaeg :=range _dfaf {_gaeg .SetPos (0,0);_gcaa ++;_gccb :=_fff .newPage ();_bbb =append (_bbb ,_gccb );_fff .setActivePage (_gccb );_fff .Draw (_gaeg );};};if _gdfb {_abbb :=_ccgd ;
_afeg :=_fff ._afbe [len (_ccgd ):];_fff ._afbe =append ([]*_bbd .PdfPage {},_abbb ...);_fff ._afbe =append (_fff ._afbe ,_bbb ...);_fff ._afbe =append (_fff ._afbe ,_afeg ...);}else {_fff ._afbe =append (_bbb ,_fff ._afbe ...);};};if _fff ._cda !=nil &&_fff .AddOutlines {var _fed func (_dafc *_bbd .OutlineItem );
_fed =func (_edeed *_bbd .OutlineItem ){_edeed .Dest .Page +=int64 (_ggae );if _bgcc :=int (_edeed .Dest .Page );_bgcc >=0&&_bgcc < len (_fff ._afbe ){_edeed .Dest .PageObj =_fff ._afbe [_bgcc ].GetPageAsIndirectObject ();}else {_ee .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_bgcc );
};_edeed .Dest .Y =_fff ._ebeb -_edeed .Dest .Y ;_baae :=_edeed .Items ();for _ ,_dbfc :=range _baae {_fed (_dbfc );};};_gebef :=_fff ._cda .Items ();for _ ,_bgfa :=range _gebef {_fed (_bgfa );};if _fff .AddTOC {var _fcea int ;if _gdfb {_fcea =len (_ccgd );
};_cafd :=_bbd .NewOutlineDest (int64 (_fcea ),0,_fff ._ebeb );if _fcea >=0&&_fcea < len (_fff ._afbe ){_cafd .PageObj =_fff ._afbe [_fcea ].GetPageAsIndirectObject ();}else {_ee .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_fcea );
};_fff ._cda .Insert (0,_bbd .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_cafd ));};};for _dae ,_dcaf :=range _fff ._afbe {_fff .setActivePage (_dcaf );if _fff ._efd !=nil {_bgee ,_dbfa ,_bcaf :=_dcaf .Size ();
if _bcaf !=nil {return _bcaf ;};_fbbec :=PageFinalizeFunctionArgs {PageNum :_dae +1,PageWidth :_bgee ,PageHeight :_dbfa ,TOCPages :len (_bbb ),TotalPages :_gcaa };if _cdag :=_fff ._efd (_fbbec );_cdag !=nil {_ee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_cdag );
return _cdag ;};};if _fff ._aaa !=nil {_fbec :=NewBlock (_fff ._afgc ,_fff ._gbf .Top );_efbd :=HeaderFunctionArgs {PageNum :_dae +1,TotalPages :_gcaa };_fff ._aaa (_fbec ,_efbd );_fbec .SetPos (0,0);if _fgad :=_fff .Draw (_fbec );_fgad !=nil {_ee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_fgad );
return _fgad ;};};if _fff ._bgg !=nil {_bfc :=NewBlock (_fff ._afgc ,_fff ._gbf .Bottom );_bga :=FooterFunctionArgs {PageNum :_dae +1,TotalPages :_gcaa };_fff ._bgg (_bfc ,_bga );_bfc .SetPos (0,_fff ._ebeb -_bfc ._gg );if _dad :=_fff .Draw (_bfc );_dad !=nil {_ee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_dad );
return _dad ;};};_fece ,_fcad :=_fff ._dacbc [_dcaf ];if _aga ,_baeb :=_fff ._acba [_dcaf ];_baeb {if _fcad {_fece .transformBlock (_aga );};if _bedg :=_aga .drawToPage (_dcaf );_bedg !=nil {_ee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_dae +1,_bedg );
return _bedg ;};};if _fcad {if _adge :=_fece .transformPage (_dcaf );_adge !=nil {_ee .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_adge );
return _adge ;};};};_fff ._dbg =true ;return nil ;};

// SetBorderColor sets the border color.
func (_fabe *PolyBezierCurve )SetBorderColor (color Color ){_fabe ._cgbc .BorderColor =_dcgf (color )};

// SetFillColor sets the fill color.
func (_deab *PolyBezierCurve )SetFillColor (color Color ){_deab ._fddb =color ;_deab ._cgbc .FillColor =_dcgf (color );};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_aggd *Chapter )SetShowNumbering (show bool ){_aggd ._ffef =show ;_aggd ._fgef .SetText (_aggd .headingText ());};

// SetHeight sets the Image's document height to specified h.
func (_febdb *Image )SetHeight (h float64 ){_febdb ._bcec =h };const (FitModeNone FitMode =iota ;FitModeFillWidth ;);func (_edec *Invoice )drawAddress (_adb *InvoiceAddress )[]*StyledParagraph {var _bgec []*StyledParagraph ;if _adb .Heading !=""{_ebadd :=_ggcdc (_edec ._abf );
_ebadd .SetMargins (0,0,0,7);_ebadd .Append (_adb .Heading );_bgec =append (_bgec ,_ebadd );};_bggf :=_ggcdc (_edec ._dbbe );_bggf .SetLineHeight (1.2);_dddfg :=_adb .Separator ;if _dddfg ==""{_dddfg =_edec ._bbee ;};_cfce :=_adb .City ;if _adb .State !=""{if _cfce !=""{_cfce +=_dddfg ;
};_cfce +=_adb .State ;};if _adb .Zip !=""{if _cfce !=""{_cfce +=_dddfg ;};_cfce +=_adb .Zip ;};if _adb .Name !=""{_bggf .Append (_adb .Name +"\u000a");};if _adb .Street !=""{_bggf .Append (_adb .Street +"\u000a");};if _adb .Street2 !=""{_bggf .Append (_adb .Street2 +"\u000a");
};if _cfce !=""{_bggf .Append (_cfce +"\u000a");};if _adb .Country !=""{_bggf .Append (_adb .Country +"\u000a");};_ece :=_ggcdc (_edec ._dbbe );_ece .SetLineHeight (1.2);_ece .SetMargins (0,0,7,0);if _adb .Phone !=""{_ece .Append (_adb .fmtLine (_adb .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_adb .HidePhoneLabel ));
};if _adb .Email !=""{_ece .Append (_adb .fmtLine (_adb .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_adb .HideEmailLabel ));};_bgec =append (_bgec ,_bggf ,_ece );return _bgec ;};

// SetLineHeight sets the line height (1.0 default).
func (_dbba *StyledParagraph )SetLineHeight (lineheight float64 ){_dbba ._dedbc =lineheight };var PPMM =float64 (72*1.0/25.4);

// SetBorderOpacity sets the border opacity of the rectangle.
func (_daea *Rectangle )SetBorderOpacity (opacity float64 ){_daea ._cegge =opacity };type templateProcessor struct{creator *Creator ;_fgeb []byte ;_afgef *TemplateOptions ;_gdeg componentRenderer ;_dedc string ;};

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_daee *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_dcdb []*Block ;_dcae =NewBlock (ctx .PageWidth ,ctx .PageHeight );_def =ctx ;);_dage :=_daee ._cafbc .IsRelative ();if _dage {_daee .applyFitMode (ctx .Width );
ctx .X +=_daee ._fdcb .Left ;ctx .Y +=_daee ._fdcb .Top ;ctx .Width -=_daee ._fdcb .Left +_daee ._fdcb .Right ;ctx .Height -=_daee ._fdcb .Top +_daee ._fdcb .Bottom ;if _daee ._dgdg > ctx .Height {_dcdb =append (_dcdb ,_dcae );_dcae =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_bbba :=ctx ;_bbba .Y =ctx .Margins .Top +_daee ._fdcb .Top ;_bbba .X =ctx .Margins .Left +_daee ._fdcb .Left ;_bbba .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_daee ._fdcb .Top -_daee ._fdcb .Bottom ;_bbba .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_daee ._fdcb .Left -_daee ._fdcb .Right ;
ctx =_bbba ;};}else {ctx .X =_daee ._cfga -_daee ._dgga /2;ctx .Y =_daee ._adcc -_daee ._dgdg /2;};_gecf :=_gad .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_daee ._dgdg ,Width :_daee ._dgga ,Height :_daee ._dgdg ,BorderWidth :_daee ._cbab ,Opacity :1.0};
if _daee ._bfde !=nil {_gecf .FillEnabled =true ;_ggde :=_dcgf (_daee ._bfde );_dbde :=_agab (_dcae ,_ggde ,_daee ._bfde ,func ()Rectangle {return Rectangle {_bgcbe :_gecf .X ,_aagb :_gecf .Y ,_cdagc :_gecf .Width ,_ddbcg :_gecf .Height };});if _dbde !=nil {return nil ,ctx ,_dbde ;
};_gecf .FillColor =_ggde ;};if _daee ._dgdf !=nil {_gecf .BorderEnabled =false ;if _daee ._cbab > 0{_gecf .BorderEnabled =true ;};_gecf .BorderColor =_dcgf (_daee ._dgdf );_gecf .BorderWidth =_daee ._cbab ;};_ffbd ,_bbcc :=_dcae .setOpacity (_daee ._bcgab ,_daee ._eaf );
if _bbcc !=nil {return nil ,ctx ,_bbcc ;};_gddba ,_ ,_bbcc :=_gecf .Draw (_ffbd );if _bbcc !=nil {return nil ,ctx ,_bbcc ;};_bbcc =_dcae .addContentsByString (string (_gddba ));if _bbcc !=nil {return nil ,ctx ,_bbcc ;};if _dage {ctx .X =_def .X ;ctx .Width =_def .Width ;
ctx .Y +=_daee ._dgdg +_daee ._fdcb .Bottom ;ctx .Height -=_daee ._dgdg ;}else {ctx =_def ;};_dcdb =append (_dcdb ,_dcae );return _dcdb ,ctx ,nil ;};func (_acbaa *templateProcessor )parseBackground (_aegag *templateNode )(interface{},error ){_cdfd :=&Background {};
for _ ,_eecb :=range _aegag ._ebeg .Attr {_gbaae :=_eecb .Value ;switch _eccab :=_eecb .Name .Local ;_eccab {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_cdfd .FillColor =_acbaa .parseColorAttr (_eccab ,_gbaae );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_cdfd .BorderColor =_acbaa .parseColorAttr (_eccab ,_gbaae );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_cdfd .BorderSize =_acbaa .parseFloatAttr (_eccab ,_gbaae );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_efag ,_faed ,_cbcfb ,_cdae :=_acbaa .parseBorderRadiusAttr (_eccab ,_gbaae );
_cdfd .SetBorderRadius (_efag ,_faed ,_cdae ,_cbcfb );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_cdfd .BorderRadiusTopLeft =_acbaa .parseFloatAttr (_eccab ,_gbaae );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_cdfd .BorderRadiusTopRight =_acbaa .parseFloatAttr (_eccab ,_gbaae );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_cdfd .BorderRadiusBottomLeft =_acbaa .parseFloatAttr (_eccab ,_gbaae );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_cdfd .BorderRadiusBottomRight =_acbaa .parseFloatAttr (_eccab ,_gbaae );
default:_acbaa .nodeLogDebug (_aegag ,"\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_eccab );
};};return _cdfd ,nil ;};func (_fegde *Table )clone ()*Table {_ffcef :=*_fegde ;_ffcef ._abaa =make ([]float64 ,len (_fegde ._abaa ));copy (_ffcef ._abaa ,_fegde ._abaa );_ffcef ._ecgg =make ([]float64 ,len (_fegde ._ecgg ));copy (_ffcef ._ecgg ,_fegde ._ecgg );
_ffcef ._gggdf =make ([]*TableCell ,0,len (_fegde ._gggdf ));for _ ,_fbag :=range _fegde ._gggdf {_ggcc :=*_fbag ;_ggcc ._bdcge =&_ffcef ;_ffcef ._gggdf =append (_ffcef ._gggdf ,&_ggcc );};return &_ffcef ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_cbg *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cbg ._cee .Left ,_cbg ._cee .Right ,_cbg ._cee .Top ,_cbg ._cee .Bottom ;};

// SetText sets the text content of the Paragraph.
func (_dddaf *Paragraph )SetText (text string ){_dddaf ._bcecc =text };func _adfd (_dagd *_bd .GraphicSVG )(*GraphicSVG ,error ){return &GraphicSVG {_gdbd :_dagd ,_aedcf :PositionRelative ,_gac :Margins {Top :10,Bottom :10}},nil ;};

// SetSubtotal sets the subtotal of the invoice.
func (_fbdaa *Invoice )SetSubtotal (value string ){_fbdaa ._ffda [1].Value =value };

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// FitMode returns the fit mode of the rectangle.
func (_gccca *Rectangle )FitMode ()FitMode {return _gccca ._dgba };func (_gefgb *Invoice )drawSection (_fgge ,_accbb string )[]*StyledParagraph {var _efea []*StyledParagraph ;if _fgge !=""{_baecf :=_ggcdc (_gefgb ._ccfb );_baecf .SetMargins (0,0,0,5);_baecf .Append (_fgge );
_efea =append (_efea ,_baecf );};if _accbb !=""{_cgfe :=_ggcdc (_gefgb ._ddbe );_cgfe .Append (_accbb );_efea =append (_efea ,_cgfe );};return _efea ;};