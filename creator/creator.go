//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_dd "bytes";_d "errors";_db "fmt";_dg "github.com/unidoc/unipdf/v3/common";_fb "github.com/unidoc/unipdf/v3/contentstream";_be "github.com/unidoc/unipdf/v3/contentstream/draw";_ef "github.com/unidoc/unipdf/v3/core";_dag "github.com/unidoc/unipdf/v3/internal/license";
_cf "github.com/unidoc/unipdf/v3/internal/transform";_dc "github.com/unidoc/unipdf/v3/model";_bg "image";_f "io";_da "math";_b "os";_c "sort";_ddd "strconv";_cec "strings";_ce "unicode";);type border struct{_cbd float64 ;_afc float64 ;_bae float64 ;_cdce float64 ;
_eegd Color ;_afb Color ;_fed float64 ;_cffe Color ;_dbc float64 ;_acc Color ;_fab float64 ;_adgaf Color ;_dfc float64 ;LineStyle _be .LineStyle ;_ddb CellBorderStyle ;_aebe CellBorderStyle ;_agc CellBorderStyle ;_cac CellBorderStyle ;};

// SetBorderColor sets the border color for the path.
func (_bdb *FilledCurve )SetBorderColor (color Color ){_bdb ._ccb =color };

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};const (PositionRelative Positioning =iota ;PositionAbsolute ;);func (_dfbe *Invoice )drawInformation ()*Table {_bfdec :=_eadg (2);
_dgdf :=append ([][2]*InvoiceCell {_dfbe ._bbee ,_dfbe ._adgb ,_dfbe ._gcfc },_dfbe ._gge ...);for _ ,_dbebe :=range _dgdf {_dbbg ,_gada :=_dbebe [0],_dbebe [1];if _gada .Value ==""{continue ;};_fefb :=_bfdec .NewCell ();_fefb .SetBackgroundColor (_dbbg .BackgroundColor );
_dfbe .setCellBorder (_fefb ,_dbbg );_bbg :=_dcgf (_dbbg .TextStyle );_bbg .Append (_dbbg .Value );_bbg .SetMargins (0,0,2,1);_fefb .SetContent (_bbg );_fefb =_bfdec .NewCell ();_fefb .SetBackgroundColor (_gada .BackgroundColor );_dfbe .setCellBorder (_fefb ,_gada );
_bbg =_dcgf (_gada .TextStyle );_bbg .Append (_gada .Value );_bbg .SetMargins (0,0,2,1);_fefb .SetContent (_bbg );};return _bfdec ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_fgec *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_bfbf :=_dcgf (_fgec ._dgg );_bfbf .Append (text );_fgbf ,_feegg :=_fgec .Add (_bfbf );return _bfbf ,_fgbf ,_feegg ;};

// SetIndent sets the cell's left indent.
func (_fdeb *TableCell )SetIndent (indent float64 ){_fdeb ._aefgf =indent };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_gacff float64 ;_eeag float64 ;_ddefa float64 ;_abeda float64 ;_dccd Color ;_gfgb float64 ;_ffgeb Color ;_afggg float64 ;_gagg float64 ;};

// SetText sets the text content of the Paragraph.
func (_fbbdf *Paragraph )SetText (text string ){_fbbdf ._aaaef =text };

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetBorderWidth sets the border width.
func (_bdd *CurvePolygon )SetBorderWidth (borderWidth float64 ){_bdd ._dgbg .BorderWidth =borderWidth };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_aeeeg *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_fcebg ,_bdcba :=_aeeeg .Wrap (width );if _bdcba !=nil {return nil ,_bdcba ;};_cdbb :=int (height /_aeeeg .Style .FontSize );if _cdbb >=len (_fcebg ){return nil ,nil ;};_gecdc :="\u000a";
_aeeeg .Text =_cec .Replace (_cec .Join (_fcebg [:_cdbb ],"\u0020"),_gecdc +"\u0020",_gecdc ,-1);_acafa :=_cec .Replace (_cec .Join (_fcebg [_cdbb :],"\u0020"),_gecdc +"\u0020",_gecdc ,-1);return NewTextChunk (_acafa ,_aeeeg .Style ),nil ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_dacdb *List )SetIndent (indent float64 ){_dacdb ._fdagb =indent ;_dacdb ._bagb =false };

// Height returns the current page height.
func (_afec *Creator )Height ()float64 {return _afec ._gbgd };func _ebb (_adb *_fb .ContentStreamOperations ,_cce *_dc .PdfPageResources ,_gfd *_fb .ContentStreamOperations ,_ccf *_dc .PdfPageResources )error {_ebd :=map[_ef .PdfObjectName ]_ef .PdfObjectName {};
_cgdf :=map[_ef .PdfObjectName ]_ef .PdfObjectName {};_ada :=map[_ef .PdfObjectName ]_ef .PdfObjectName {};_dad :=map[_ef .PdfObjectName ]_ef .PdfObjectName {};_fcd :=map[_ef .PdfObjectName ]_ef .PdfObjectName {};_cgda :=map[_ef .PdfObjectName ]_ef .PdfObjectName {};
for _ ,_cece :=range *_gfd {switch _cece .Operand {case "\u0044\u006f":if len (_cece .Params )==1{if _eedc ,_fbf :=_cece .Params [0].(*_ef .PdfObjectName );_fbf {if _ ,_daa :=_ebd [*_eedc ];!_daa {var _cgb _ef .PdfObjectName ;_eac ,_ :=_ccf .GetXObjectByName (*_eedc );
if _eac !=nil {_cgb =*_eedc ;for {_ege ,_ :=_cce .GetXObjectByName (_cgb );if _ege ==nil ||_ege ==_eac {break ;};_cgb =_cgb +"\u0030";};};_cce .SetXObjectByName (_cgb ,_eac );_ebd [*_eedc ]=_cgb ;};_ag :=_ebd [*_eedc ];_cece .Params [0]=&_ag ;};};case "\u0054\u0066":if len (_cece .Params )==2{if _de ,_ddc :=_cece .Params [0].(*_ef .PdfObjectName );
_ddc {if _ ,_bcb :=_cgdf [*_de ];!_bcb {_bec ,_fef :=_ccf .GetFontByName (*_de );_gfb :=*_de ;if _fef &&_bec !=nil {_gfb =_gddda (_de .String (),_bec ,_cce );};_cce .SetFontByName (_gfb ,_bec );_cgdf [*_de ]=_gfb ;};_efc :=_cgdf [*_de ];_cece .Params [0]=&_efc ;
};};case "\u0043\u0053","\u0063\u0073":if len (_cece .Params )==1{if _gfdc ,_bfab :=_cece .Params [0].(*_ef .PdfObjectName );_bfab {if _ ,_gdd :=_ada [*_gfdc ];!_gdd {var _ecb _ef .PdfObjectName ;_ca ,_ggg :=_ccf .GetColorspaceByName (*_gfdc );if _ggg {_ecb =*_gfdc ;
for {_fbe ,_gec :=_cce .GetColorspaceByName (_ecb );if !_gec ||_ca ==_fbe {break ;};_ecb =_ecb +"\u0030";};_cce .SetColorspaceByName (_ecb ,_ca );_ada [*_gfdc ]=_ecb ;}else {_dg .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");
};};if _gfg ,_bad :=_ada [*_gfdc ];_bad {_cece .Params [0]=&_gfg ;}else {_dg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_gfdc );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_cece .Params )==1{if _edbb ,_bcg :=_cece .Params [0].(*_ef .PdfObjectName );_bcg {if _ ,_gcf :=_dad [*_edbb ];!_gcf {var _dbe _ef .PdfObjectName ;_adc ,_aeb :=_ccf .GetPatternByName (*_edbb );
if _aeb {_dbe =*_edbb ;for {_fcc ,_dda :=_cce .GetPatternByName (_dbe );if !_dda ||_fcc ==_adc {break ;};_dbe =_dbe +"\u0030";};_adbf :=_cce .SetPatternByName (_dbe ,_adc .ToPdfObject ());if _adbf !=nil {return _adbf ;};_dad [*_edbb ]=_dbe ;};};if _faa ,_aea :=_dad [*_edbb ];
_aea {_cece .Params [0]=&_faa ;};};};case "\u0073\u0068":if len (_cece .Params )==1{if _egc ,_ebc :=_cece .Params [0].(*_ef .PdfObjectName );_ebc {if _ ,_cef :=_fcd [*_egc ];!_cef {var _ddge _ef .PdfObjectName ;_baf ,_bgc :=_ccf .GetShadingByName (*_egc );
if _bgc {_ddge =*_egc ;for {_age ,_gdgf :=_cce .GetShadingByName (_ddge );if !_gdgf ||_baf ==_age {break ;};_ddge =_ddge +"\u0030";};_ede :=_cce .SetShadingByName (_ddge ,_baf .ToPdfObject ());if _ede !=nil {_dg .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_ede );
return _ede ;};_fcd [*_egc ]=_ddge ;}else {_dg .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _dab ,_fg :=_fcd [*_egc ];_fg {_cece .Params [0]=&_dab ;}else {_dg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_egc );
};};};case "\u0067\u0073":if len (_cece .Params )==1{if _edf ,_fga :=_cece .Params [0].(*_ef .PdfObjectName );_fga {if _ ,_dabc :=_cgda [*_edf ];!_dabc {var _bbb _ef .PdfObjectName ;_bde ,_fcg :=_ccf .GetExtGState (*_edf );if _fcg {_bbb =*_edf ;_ffbf :=1;
for {_afd ,_gddd :=_cce .GetExtGState (_bbb );if !_gddd ||_bde ==_afd {break ;};_bbb =_ef .PdfObjectName (_db .Sprintf ("\u0047\u0053\u0025\u0064",_ffbf ));_ffbf ++;};};_cce .AddExtGState (_bbb ,_bde );_cgda [*_edf ]=_bbb ;};_gdb :=_cgda [*_edf ];_cece .Params [0]=&_gdb ;
};};};*_adb =append (*_adb ,_cece );};return nil ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// SetFillColor sets background color for border.
func (_eca *border )SetFillColor (col Color ){_eca ._eegd =col };

// SetColorLeft sets border color for left.
func (_edc *border )SetColorLeft (col Color ){_edc ._afb =col };func (_gcd *Block )drawToPage (_dbdb *_dc .PdfPage )error {_ddfc :=&_fb .ContentStreamOperations {};if _dbdb .Resources ==nil {_dbdb .Resources =_dc .NewPdfPageResources ();};_gb :=_ebb (_ddfc ,_dbdb .Resources ,_gcd ._g ,_gcd ._a );
if _gb !=nil {return _gb ;};if _gb =_cde (_gcd ._a ,_dbdb .Resources );_gb !=nil {return _gb ;};if _gb =_dbdb .AppendContentBytes (_ddfc .Bytes (),true );_gb !=nil {return _gb ;};for _ ,_bfd :=range _gcd ._dbd {_dbdb .AddAnnotation (_bfd );};return nil ;
};func (_gf *Block )mergeBlocks (_bce *Block )error {_ffdb :=_ebb (_gf ._g ,_gf ._a ,_bce ._g ,_bce ._a );if _ffdb !=nil {return _ffdb ;};for _ ,_eeb :=range _bce ._dbd {_gf .AddAnnotation (_eeb );};return nil ;};func (_acdce *Table )newCell (_ddfa int )*TableCell {_acdce ._gecf ++;
_eeedf :=(_acdce ._gecf -1)/_acdce ._gaaa +1;for _eeedf > _acdce ._cbfc {_acdce ._cbfc ++;_acdce ._degd =append (_acdce ._degd ,_acdce ._bfeg );};_dbeff :=(_acdce ._gecf -1)%(_acdce ._gaaa )+1;_debb :=&TableCell {};_debb ._debc =_eeedf ;_debb ._agdfg =_dbeff ;
_debb ._feef =1;_debb ._aefgf =5;_debb ._eaeg =CellBorderStyleNone ;_debb ._egeb =_be .LineStyleSolid ;_debb ._bfbff =CellHorizontalAlignmentLeft ;_debb ._aegef =CellVerticalAlignmentTop ;_debb ._fbfd =0;_debb ._bfga =0;_debb ._dfba =0;_debb ._cgcbe =0;
_ffea :=ColorBlack ;_debb ._bbeg =_ffea ;_debb ._cegcg =_ffea ;_debb ._acfd =_ffea ;_debb ._gecdb =_ffea ;if _ddfa < 1{_dg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_ddfa );
_ddfa =1;};_eabbf :=_acdce ._gaaa -(_debb ._agdfg -1);if _ddfa > _eabbf {_dg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_ddfa ,_eabbf );
_ddfa =_eabbf ;};_debb ._acgf =_ddfa ;_acdce ._gecf +=_ddfa -1;_acdce ._fdbg =append (_acdce ._fdbg ,_debb );_debb ._abgd =_acdce ;return _debb ;};

// GetCoords returns coordinates of border.
func (_egf *border )GetCoords ()(float64 ,float64 ){return _egf ._cbd ,_egf ._afc };func (_gddc *StyledParagraph )getTextWidth ()float64 {var _gddfb float64 ;_cgga :=len (_gddc ._gfged );for _eeaga ,_dedb :=range _gddc ._gfged {_dgbb :=&_dedb .Style ;_cddc :=len (_dedb .Text );
for _efbc ,_fffd :=range _dedb .Text {if _fffd =='\u000A'{continue ;};_deec ,_ceafa :=_dgbb .Font .GetRuneMetrics (_fffd );if !_ceafa {_dg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fffd );
return -1;};_gddfb +=_dgbb .FontSize *_deec .Wx *_dgbb .horizontalScale ();if _fffd !=' '&&(_eeaga !=_cgga -1||_efbc !=_cddc -1){_gddfb +=_dgbb .CharSpacing *1000.0;};};};return _gddfb ;};func (_eadb *Invoice )setCellBorder (_aabd *TableCell ,_gfaf *InvoiceCell ){for _ ,_dbbfc :=range _gfaf .BorderSides {_aabd .SetBorder (_dbbfc ,CellBorderStyleSingle ,_gfaf .BorderWidth );
};_aabd .SetBorderColor (_gfaf .BorderColor );};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_aedf *Paragraph )SetWidth (width float64 ){_aedf ._cega =width ;_aedf .wrapText ()};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_agg float64 ;_ccee float64 ;_efea float64 ;_dfg float64 ;_edg float64 ;_fabf float64 ;_dfd Color ;_dcc float64 ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_ecec *TableCell )SetBorderLineStyle (style _be .LineStyle ){_ecec ._egeb =style };

// BuyerAddress returns the buyer address used in the invoice template.
func (_fecg *Invoice )BuyerAddress ()*InvoiceAddress {return _fecg ._gcaa };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_afbe :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_dg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _afbe ;
};var _agf ,_ffa ,_aad int ;if len (hexStr )==4{var _ccea ,_aade ,_afcb int ;_fbec ,_fabg :=_db .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_ccea ,&_aade ,&_afcb );if _fabg !=nil {_dg .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_fabg );
return _afbe ;};if _fbec !=3{_dg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _afbe ;};_agf =_ccea *16+_ccea ;_ffa =_aade *16+_aade ;_aad =_afcb *16+_afcb ;}else {_eaga ,_dead :=_db .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_agf ,&_ffa ,&_aad );
if _dead !=nil {_dg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _afbe ;};if _eaga !=3{_dg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_eaga );
return _afbe ;};};_ddae :=float64 (_agf )/255.0;_dac :=float64 (_ffa )/255.0;_edfe :=float64 (_aad )/255.0;_afbe ._acgc =_ddae ;_afbe ._cfe =_dac ;_afbe ._bgbb =_edfe ;return _afbe ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_ccef *_be .PolyBezierCurve ;_bffea float64 ;_ggga float64 ;};

// Reset removes all the text chunks the paragraph contains.
func (_dggd *StyledParagraph )Reset (){_dggd ._gfged =[]*TextChunk {}};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_dgbg *_be .CurvePolygon ;_bbae float64 ;_ccec float64 ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_adcgc *Table )MultiColCell (colspan int )*TableCell {return _adcgc .newCell (colspan )};

// GeneratePageBlocks implements drawable interface.
func (_abe *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fada :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_abef :=_abe ._cbd ;_aac :=ctx .PageHeight -_abe ._afc ;if _abe ._eegd !=nil {_fca :=_be .Rectangle {Opacity :1.0,X :_abe ._cbd ,Y :ctx .PageHeight -_abe ._afc -_abe ._cdce ,Height :_abe ._cdce ,Width :_abe ._bae };
_fca .FillEnabled =true ;_fca .FillColor =_eba (_abe ._eegd );_fca .BorderEnabled =false ;_bgca ,_ ,_daed :=_fca .Draw ("");if _daed !=nil {return nil ,ctx ,_daed ;};_daed =_fada .addContentsByString (string (_bgca ));if _daed !=nil {return nil ,ctx ,_daed ;
};};_gad :=_abe ._dfc ;_gfcf :=_abe ._dbc ;_dca :=_abe ._fed ;_aab :=_abe ._fab ;_fdaa :=_abe ._dfc ;if _abe ._agc ==CellBorderStyleDouble {_fdaa +=2*_gad ;};_ecc :=_abe ._dbc ;if _abe ._cac ==CellBorderStyleDouble {_ecc +=2*_gfcf ;};_efe :=_abe ._fed ;
if _abe ._ddb ==CellBorderStyleDouble {_efe +=2*_dca ;};_cdb :=_abe ._fab ;if _abe ._aebe ==CellBorderStyleDouble {_cdb +=2*_aab ;};if _abe ._dfc !=0{_cea :=_abef ;_fbfc :=_aac ;if _abe ._agc ==CellBorderStyleDouble {_fbfc -=_gad ;_afe :=_be .BasicLine {};
_afe .X1 =_cea -_fdaa /2;_afe .Y1 =_fbfc +2*_gad ;_afe .X2 =_cea +_abe ._bae +_fdaa /2;_afe .Y2 =_fbfc +2*_gad ;_afe .LineColor =_eba (_abe ._adgaf );_afe .LineWidth =_abe ._dfc ;_afe .LineStyle =_abe .LineStyle ;_dba ,_ ,_dgd :=_afe .Draw ("");if _dgd !=nil {return nil ,ctx ,_dgd ;
};_dgd =_fada .addContentsByString (string (_dba ));if _dgd !=nil {return nil ,ctx ,_dgd ;};};_acd :=_be .BasicLine {LineWidth :_abe ._dfc ,Opacity :1.0,LineColor :_eba (_abe ._adgaf ),X1 :_cea -_fdaa /2+(_efe -_abe ._fed ),Y1 :_fbfc ,X2 :_cea +_abe ._bae +_fdaa /2-(_cdb -_abe ._fab ),Y2 :_fbfc ,LineStyle :_abe .LineStyle };
_eab ,_ ,_adac :=_acd .Draw ("");if _adac !=nil {return nil ,ctx ,_adac ;};_adac =_fada .addContentsByString (string (_eab ));if _adac !=nil {return nil ,ctx ,_adac ;};};if _abe ._dbc !=0{_edce :=_abef ;_cbf :=_aac -_abe ._cdce ;if _abe ._cac ==CellBorderStyleDouble {_cbf +=_gfcf ;
_ecgb :=_be .BasicLine {LineWidth :_abe ._dbc ,Opacity :1.0,LineColor :_eba (_abe ._cffe ),X1 :_edce -_ecc /2,Y1 :_cbf -2*_gfcf ,X2 :_edce +_abe ._bae +_ecc /2,Y2 :_cbf -2*_gfcf ,LineStyle :_abe .LineStyle };_gdc ,_ ,_ffe :=_ecgb .Draw ("");if _ffe !=nil {return nil ,ctx ,_ffe ;
};_ffe =_fada .addContentsByString (string (_gdc ));if _ffe !=nil {return nil ,ctx ,_ffe ;};};_ddcb :=_be .BasicLine {LineWidth :_abe ._dbc ,Opacity :1.0,LineColor :_eba (_abe ._cffe ),X1 :_edce -_ecc /2+(_efe -_abe ._fed ),Y1 :_cbf ,X2 :_edce +_abe ._bae +_ecc /2-(_cdb -_abe ._fab ),Y2 :_cbf ,LineStyle :_abe .LineStyle };
_eag ,_ ,_gea :=_ddcb .Draw ("");if _gea !=nil {return nil ,ctx ,_gea ;};_gea =_fada .addContentsByString (string (_eag ));if _gea !=nil {return nil ,ctx ,_gea ;};};if _abe ._fed !=0{_agef :=_abef ;_cgf :=_aac ;if _abe ._ddb ==CellBorderStyleDouble {_agef +=_dca ;
_aag :=_be .BasicLine {LineWidth :_abe ._fed ,Opacity :1.0,LineColor :_eba (_abe ._afb ),X1 :_agef -2*_dca ,Y1 :_cgf +_efe /2,X2 :_agef -2*_dca ,Y2 :_cgf -_abe ._cdce -_efe /2,LineStyle :_abe .LineStyle };_fege ,_ ,_gba :=_aag .Draw ("");if _gba !=nil {return nil ,ctx ,_gba ;
};_gba =_fada .addContentsByString (string (_fege ));if _gba !=nil {return nil ,ctx ,_gba ;};};_baca :=_be .BasicLine {LineWidth :_abe ._fed ,Opacity :1.0,LineColor :_eba (_abe ._afb ),X1 :_agef ,Y1 :_cgf +_efe /2-(_fdaa -_abe ._dfc ),X2 :_agef ,Y2 :_cgf -_abe ._cdce -_efe /2+(_ecc -_abe ._dbc ),LineStyle :_abe .LineStyle };
_dde ,_ ,_gab :=_baca .Draw ("");if _gab !=nil {return nil ,ctx ,_gab ;};_gab =_fada .addContentsByString (string (_dde ));if _gab !=nil {return nil ,ctx ,_gab ;};};if _abe ._fab !=0{_egb :=_abef +_abe ._bae ;_cad :=_aac ;if _abe ._aebe ==CellBorderStyleDouble {_egb -=_aab ;
_gbg :=_be .BasicLine {LineWidth :_abe ._fab ,Opacity :1.0,LineColor :_eba (_abe ._acc ),X1 :_egb +2*_aab ,Y1 :_cad +_cdb /2,X2 :_egb +2*_aab ,Y2 :_cad -_abe ._cdce -_cdb /2,LineStyle :_abe .LineStyle };_gcc ,_ ,_dga :=_gbg .Draw ("");if _dga !=nil {return nil ,ctx ,_dga ;
};_dga =_fada .addContentsByString (string (_gcc ));if _dga !=nil {return nil ,ctx ,_dga ;};};_ebde :=_be .BasicLine {LineWidth :_abe ._fab ,Opacity :1.0,LineColor :_eba (_abe ._acc ),X1 :_egb ,Y1 :_cad +_cdb /2-(_fdaa -_abe ._dfc ),X2 :_egb ,Y2 :_cad -_abe ._cdce -_cdb /2+(_ecc -_abe ._dbc ),LineStyle :_abe .LineStyle };
_efaf ,_ ,_gdbf :=_ebde .Draw ("");if _gdbf !=nil {return nil ,ctx ,_gdbf ;};_gdbf =_fada .addContentsByString (string (_efaf ));if _gdbf !=nil {return nil ,ctx ,_gdbf ;};};return []*Block {_fada },ctx ,nil ;};func _dfgg (_efggc *_b .File )([]*_dc .PdfPage ,error ){_aadgb ,_dggf :=_dc .NewPdfReader (_efggc );
if _dggf !=nil {return nil ,_dggf ;};_cagba ,_dggf :=_aadgb .GetNumPages ();if _dggf !=nil {return nil ,_dggf ;};var _edgfd []*_dc .PdfPage ;for _dfcd :=0;_dfcd < _cagba ;_dfcd ++{_gbcef ,_dfcc :=_aadgb .GetPage (_dfcd +1);if _dfcc !=nil {return nil ,_dfcc ;
};_edgfd =append (_edgfd ,_gbcef );};return _edgfd ,nil ;};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ad :=&Block {};_ad ._g =&_fb .ContentStreamOperations {};_ad ._a =_dc .NewPdfPageResources ();_ad ._eg =width ;_ad ._ee =height ;return _ad ;};

// SetColorTop sets border color for top.
func (_ecdc *border )SetColorTop (col Color ){_ecdc ._adgaf =col };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_fgdc *StyledParagraph )SetTextAlignment (align TextAlignment ){_fgdc ._ddde =align };func _ccffd ()*FilledCurve {_fba :=FilledCurve {};_fba ._dcdg =[]_be .CubicBezierCurve {};return &_fba ;};

// SetBorderColor sets the border color.
func (_acaa *PolyBezierCurve )SetBorderColor (color Color ){_acaa ._ccef .BorderColor =_eba (color )};

// Add adds a new Drawable to the chapter.
func (_dgb *Chapter )Add (d Drawable )error {if Drawable (_dgb )==d {_dg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _bga :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_dgb ._gcea =append (_dgb ._gcea ,d );case containerDrawable :_ddeb ,_dcff :=_bga .ContainerComponent (_dgb );if _dcff !=nil {return _dcff ;};_dgb ._gcea =append (_dgb ._gcea ,_ddeb );
default:_dg .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_bbf *Creator )SetOptimizer (optimizer _dc .Optimizer ){_bbf ._becg =optimizer };

// SellerAddress returns the seller address used in the invoice template.
func (_afbcd *Invoice )SellerAddress ()*InvoiceAddress {return _afbcd ._aecb };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_cdddc *TOC )SetLineNumberStyle (style TextStyle ){_cdddc ._bbed =style };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_ddcba *TOC )SetLinePageStyle (style TextStyle ){_ddcba ._ggcd =style };

// SetLevel sets the indentation level of the TOC line.
func (_degdb *TOCLine )SetLevel (level uint ){_degdb ._ccbfd =level ;_degdb ._gfgedf ._afbed .Left =_degdb ._ccccf +float64 (_degdb ._ccbfd -1)*_degdb ._cfbad ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_cfbbb *Invoice )NoteHeadingStyle ()TextStyle {return _cfbbb ._eeae };func (_efeb *StyledParagraph )split (_becde DrawContext )(_ggf ,_ccgc *StyledParagraph ,_cbaa error ){if _cbaa =_efeb .wrapChunks (false );_cbaa !=nil {return nil ,nil ,_cbaa ;
};_gcad :=func (_bgdc []*TextChunk ,_abaf []*TextChunk )[]*TextChunk {if len (_abaf )==0{return _bgdc ;};_dbedg :=len (_bgdc );if _dbedg ==0{return append (_bgdc ,_abaf ...);};_bgdc [_dbedg -1].Text +=_abaf [0].Text ;return append (_bgdc ,_abaf [1:]...);
};_gdeag :=func (_acdc *StyledParagraph ,_dcdgb []*TextChunk )*StyledParagraph {if len (_dcdgb )==0{return nil ;};_gcfbcf :=*_acdc ;_gcfbcf ._gfged =_dcdgb ;return &_gcfbcf ;};var (_dbedb float64 ;_bfbd []*TextChunk ;_adbd []*TextChunk ;);for _ ,_dbcb :=range _efeb ._cfbc {var _fcceb float64 ;
_deacc :=make ([]*TextChunk ,0,len (_dbcb ));for _ ,_febgf :=range _dbcb {if _eeba :=_febgf .Style .FontSize ;_eeba > _fcceb {_fcceb =_eeba ;};_deacc =append (_deacc ,_febgf .clone ());};_fcceb *=_efeb ._bgfc ;if _efeb ._cfde .IsRelative (){if _dbedb +_fcceb > _becde .Height {_adbd =_gcad (_adbd ,_deacc );
}else {_bfbd =_gcad (_bfbd ,_deacc );};};_dbedb +=_fcceb ;};_efeb ._cfbc =nil ;if len (_adbd )==0{return _efeb ,nil ,nil ;};return _gdeag (_efeb ,_bfbd ),_gdeag (_efeb ,_adbd ),nil ;};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_aeaa *List )Add (item VectorDrawable )(*TextChunk ,error ){_bgde :=&listItem {_aeabb :item ,_dabg :_aeaa ._bed };switch _facc :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _facc ._bagb {_facc ._fdagb =15;};default:return nil ,_d .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_aeaa ._dddcf =append (_aeaa ._dddcf ,_bgde );return &_bgde ._dabg ,nil ;};func (_bff *Block )addContentsByString (_cb string )error {_df :=_fb .NewContentStreamParser (_cb );_dcb ,_bac :=_df .Parse ();if _bac !=nil {return _bac ;};_bff ._g .WrapIfNeeded ();
_dcb .WrapIfNeeded ();*_bff ._g =append (*_bff ._g ,*_dcb ...);return nil ;};func (_dbbd *Table )clone ()*Table {_cbcd :=*_dbbd ;_cbcd ._degd =make ([]float64 ,len (_dbbd ._degd ));copy (_cbcd ._degd ,_dbbd ._degd );_cbcd ._bbecd =make ([]float64 ,len (_dbbd ._bbecd ));
copy (_cbcd ._bbecd ,_dbbd ._bbecd );_cbcd ._fdbg =make ([]*TableCell ,0,len (_dbbd ._fdbg ));for _ ,_acaf :=range _dbbd ._fdbg {_cgbcb :=*_acaf ;_cgbcb ._abgd =&_cbcd ;_cbcd ._fdbg =append (_cbcd ._fdbg ,&_cgbcb );};return &_cbcd ;};func _gadc ()*Division {return &Division {_dbg :[]VectorDrawable {}}};


// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_dbeb *Division )Add (d VectorDrawable )error {switch _acb :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image :case containerDrawable :_ggbg ,_cfbfb :=_acb .ContainerComponent (_dbeb );if _cfbfb !=nil {return _cfbfb ;};_ccaf ,_aed :=_ggbg .(VectorDrawable );
if !_aed {return _db .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_ggbg );
};d =_ccaf ;default:return _d .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_dbeb ._dbg =append (_dbeb ._dbg ,d );return nil ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_deba *Invoice )SetColumns (cols []*InvoiceCell ){_deba ._dfdf =cols };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// SetOpacity sets opacity for Image.
func (_fbbb *Image )SetOpacity (opacity float64 ){_fbbb ._abcd =opacity };

// SkipRows skips over a specified number of rows in the table.
func (_eddbc *Table )SkipRows (num int ){_eacf :=num *_eddbc ._gaaa -1;if _eacf < 0{_dg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_eddbc ._gecf +=_eacf ;};

// SetStyleBottom sets border style for bottom side.
func (_aef *border )SetStyleBottom (style CellBorderStyle ){_aef ._cac =style };

// SetBorder sets the cell's border style.
func (_dccb *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_dccb ._eaeg =CellBorderStyleSingle ;_dccb ._fbfd =width ;_dccb ._bbaf =CellBorderStyleSingle ;_dccb ._bfga =width ;
_dccb ._gebae =CellBorderStyleSingle ;_dccb ._dfba =width ;_dccb ._edgf =CellBorderStyleSingle ;_dccb ._cgcbe =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_dccb ._eaeg =CellBorderStyleDouble ;_dccb ._fbfd =width ;_dccb ._bbaf =CellBorderStyleDouble ;
_dccb ._bfga =width ;_dccb ._gebae =CellBorderStyleDouble ;_dccb ._dfba =width ;_dccb ._edgf =CellBorderStyleDouble ;_dccb ._cgcbe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_dccb ._eaeg =style ;
_dccb ._fbfd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_dccb ._bbaf =style ;_dccb ._bfga =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_dccb ._gebae =style ;
_dccb ._dfba =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_dccb ._edgf =style ;_dccb ._cgcbe =width ;};};

// SetPos sets absolute positioning with specified coordinates.
func (_fecgg *StyledParagraph )SetPos (x ,y float64 ){_fecgg ._cfde =PositionAbsolute ;_fecgg ._ddbcd =x ;_fecgg ._dfeb =y ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_bfed DrawContext )([]*Block ,DrawContext ,error );};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_aa *Block )AddAnnotation (annotation *_dc .PdfAnnotation ){for _ ,_dce :=range _aa ._dbd {if _dce ==annotation {return ;};};_aa ._dbd =append (_aa ._dbd ,annotation );};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_cegfb *Chapter )SetShowNumbering (show bool ){_cegfb ._cdac =show ;_cegfb ._dbaf .SetText (_cegfb .headingText ());};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_dbcd *Image )ScaleToHeight (h float64 ){_feeg :=_dbcd ._ebe /_dbcd ._fedd ;_dbcd ._fedd =h ;_dbcd ._ebe =h *_feeg ;};func _bgfd (_edff []byte )(*Image ,error ){_abb :=_dd .NewReader (_edff );_acgg ,_agbgg :=_dc .ImageHandling .Read (_abb );if _agbgg !=nil {_dg .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_agbgg );
return nil ,_agbgg ;};return _cecg (_acgg );};

// AppendColumn appends a column to the line items table.
func (_afge *Invoice )AppendColumn (description string )*InvoiceCell {_cbacb :=_afge .NewColumn (description );_afge ._dfdf =append (_afge ._dfdf ,_cbacb );return _cbacb ;};var PPI float64 =72;

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_fgae *_be .Polyline ;_fadf float64 ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_fgf *Chapter )NewSubchapter (title string )*Chapter {_dgfa :=_cafg (_fgf ._dbaf ._ggeg );_dgfa .FontSize =14;_fgf ._dgfb ++;_beg :=_adacg (_fgf ,_fgf ._deg ,_fgf ._cegf ,title ,_fgf ._dgfb ,_dgfa );_fgf .Add (_beg );return _beg ;};

// SkipOver skips over a specified number of rows and cols.
func (_bgfcf *Table )SkipOver (rows ,cols int ){_gggeac :=rows *_bgfcf ._gaaa +cols -1;if _gggeac < 0{_dg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_bgfcf ._gecf +=_gggeac ;};func (_dffd *StyledParagraph )getLineMetrics (_bgef int )(_agba ,_gfgf ,_gcbe float64 ){if _dffd ._cfbc ==nil ||len (_dffd ._cfbc )==0{_dffd .wrapText ();};if _bgef < 0||_bgef > len (_dffd ._cfbc )-1{_dg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_bgef );
return 0,0,0;};_ceffg :=_dffd ._cfbc [_bgef ];for _ ,_ccecg :=range _ceffg {_ebda ,_afeea :=_ccecg .Style .Font .GetFontDescriptor ();if _afeea !=nil {_dg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _gggf ,_daca float64 ;if _ebda !=nil {if _gggf ,_afeea =_ebda .GetCapHeight ();_afeea !=nil {_dg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_afeea );
};if _daca ,_afeea =_ebda .GetDescent ();_afeea !=nil {_dg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0044\u0065\u0073\u0063\u0065\u006et\u003a\u0020\u0025\u0076",_afeea );
};};if int (_gggf )<=0{_dg .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");
_gggf =1000;};if _ffca :=_gggf /1000.0*_ccecg .Style .FontSize ;_ffca > _agba {_agba =_ffca ;};if _bbbca :=_ccecg .Style .FontSize ;_bbbca > _gfgf {_gfgf =_bbbca ;};if _eabcf :=_daca /1000.0*_ccecg .Style .FontSize ;_eabcf < _gcbe {_gcbe =_eabcf ;};};return _agba ,_gfgf ,_gcbe ;
};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_edge *Table )Width ()float64 {return 0};

// SetTerms sets the terms and conditions section of the invoice.
func (_deeg *Invoice )SetTerms (title ,content string ){_deeg ._eeda =[2]string {title ,content }};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_gaeab *Rectangle )GetCoords ()(float64 ,float64 ){return _gaeab ._gacff ,_gaeab ._eeag };

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_abgbf *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_bccf :=NewTextChunk (text ,_abgbf ._aega );_bccf ._cdfcd =_fceg (url );return _abgbf .appendChunk (_bccf );};func _fagfe (_eee string ,_dcffd TextStyle )*Paragraph {_fdgd :=&Paragraph {_aaaef :_eee ,_ggeg :_dcffd .Font ,_cfcd :_dcffd .FontSize ,_gagf :1.0,_gcfb :true ,_dbbaf :true ,_cdba :TextAlignmentLeft ,_gcaf :0,_efae :1,_debac :1,_cdfd :PositionRelative };
_fdgd .SetColor (_dcffd .Color );return _fdgd ;};

// AddTotalLine adds a new line in the invoice totals table.
func (_dafe *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_cgef :=&InvoiceCell {_dafe ._ded ,desc };_geae :=&InvoiceCell {_dafe ._ded ,value };_dafe ._gfcb =append (_dafe ._gfcb ,[2]*InvoiceCell {_cgef ,_geae });return _cgef ,_geae ;
};

// SetBuyerAddress sets the buyer address of the invoice.
func (_ggbb *Invoice )SetBuyerAddress (address *InvoiceAddress ){_ggbb ._gcaa =address };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cdga *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _becdad float64 ;var _egcd []*StyledParagraph ;for _ ,_dcgac :=range _cdga ._dddcf {_cedcb :=_dcgf (_cdga ._dgg );_cedcb .SetEnableWrap (false );_cedcb .SetTextAlignment (TextAlignmentRight );
_cedcb .Append (_dcgac ._dabg .Text ).Style =_dcgac ._dabg .Style ;_edfc :=_cedcb .getTextWidth ()/1000.0/ctx .Width ;if _becdad < _edfc {_becdad =_edfc ;};_egcd =append (_egcd ,_cedcb );};_acab :=_eadg (2);_acab .SetColumnWidths (_becdad ,1-_becdad );
_acab .SetMargins (_cdga ._fdagb ,0,0,0);for _gggee ,_fcdgg :=range _cdga ._dddcf {_edcf :=_acab .NewCell ();_edcf .SetIndent (0);_edcf .SetContent (_egcd [_gggee ]);_edcf =_acab .NewCell ();_edcf .SetIndent (0);_edcf .SetContent (_fcdgg ._aeabb );};return _acab .GeneratePageBlocks (ctx );
};func _eadg (_gggeg int )*Table {_aeabc :=&Table {_gaaa :_gggeg ,_bfeg :10.0,_bbecd :[]float64 {},_degd :[]float64 {},_fdbg :[]*TableCell {}};_aeabc .resetColumnWidths ();return _aeabc ;};func (_dfec *Invoice )generateHeaderBlocks (_gcee DrawContext )([]*Block ,DrawContext ,error ){_aacb :=_dcgf (_dfec ._ggac );
_aacb .SetEnableWrap (true );_aacb .Append (_dfec ._bddc );_fgef :=_eadg (2);if _dfec ._acba !=nil {_bffc :=_fgef .NewCell ();_bffc .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_bffc .SetVerticalAlignment (CellVerticalAlignmentMiddle );_bffc .SetIndent (0);
_bffc .SetContent (_dfec ._acba );_dfec ._acba .ScaleToHeight (_aacb .Height ()+20);}else {_fgef .SkipCells (1);};_fcdg :=_fgef .NewCell ();_fcdg .SetHorizontalAlignment (CellHorizontalAlignmentRight );_fcdg .SetVerticalAlignment (CellVerticalAlignmentMiddle );
_fcdg .SetContent (_aacb );return _fgef .GeneratePageBlocks (_gcee );};

// GeneratePageBlocks generates a page break block.
func (_cfaa *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dddb :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_geadd :=ctx ;_geadd .Y =ctx .Margins .Top ;
_geadd .X =ctx .Margins .Left ;_geadd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_geadd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_geadd ;return _dddb ,ctx ,nil ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_eec *Block )ScaleToHeight (h float64 ){_bgf :=h /_eec ._ee ;_eec .Scale (_bgf ,_bgf )};

// SetBorderOpacity sets the border opacity.
func (_dbbafc *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_dbbafc ._ggga =opacity };

// Cols returns the total number of columns the table has.
func (_dfdg *Table )Cols ()int {return _dfdg ._gaaa };func _afbg (_agbg ,_aga ,_dcca ,_bfdb float64 )*Ellipse {_beb :=&Ellipse {};_beb ._ggdbc =_agbg ;_beb ._gbfb =_aga ;_beb ._gfeb =_dcca ;_beb ._acfe =_bfdb ;_beb ._abae =ColorBlack ;_beb ._gfbcd =1.0;
return _beb ;};

// Title returns the title of the invoice.
func (_feag *Invoice )Title ()string {return _feag ._bddc };

// SetBorderWidth sets the border width.
func (_bdfg *Rectangle )SetBorderWidth (bw float64 ){_bdfg ._afggg =bw };

// SetBorderOpacity sets the border opacity.
func (_feba *Polygon )SetBorderOpacity (opacity float64 ){_feba ._efeab =opacity };

// NewInvoice returns an instance of an empty invoice.
func (_bab *Creator )NewInvoice ()*Invoice {_cfbg :=_bab .NewTextStyle ();_cfbg .Font =_bab ._gfe ;return _acbe (_bab .NewTextStyle (),_cfbg );};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_ddce *TOC )SetLineSeparator (separator string ){_ddce ._gecde =separator };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_bcc *Creator )NewPage ()*_dc .PdfPage {_ccc :=_bcc .newPage ();_bcc ._dec =append (_bcc ._dec ,_ccc );_bcc ._efab .Page ++;return _ccc ;};func (_dfdc *StyledParagraph )wrapText ()error {return _dfdc .wrapChunks (true )};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_ebg *Creator )SetPageSize (size PageSize ){_ebg ._ceag =size ;_ebg ._aaaf =size [0];_ebg ._gbgd =size [1];_dgde :=0.1*_ebg ._aaaf ;_ebg ._gggg .Left =_dgde ;_ebg ._gggg .Right =_dgde ;_ebg ._gggg .Top =_dgde ;_ebg ._gggg .Bottom =_dgde ;};

// SetSubtotal sets the subtotal of the invoice.
func (_gfbf *Invoice )SetSubtotal (value string ){_gfbf ._bbbf [1].Value =value };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_abfa *Creator )Finalize ()error {if _abfa ._bda {return nil ;};_edfeb :=len (_abfa ._dec );_cfga :=0;if _abfa ._bbbc !=nil {_cfga ++;};if _abfa .AddTOC {_abfa .initContext ();_abfa ._efab .Page =_cfga +1;if _abfa ._bcd !=nil {if _cbb :=_abfa ._bcd (_abfa ._dadc );
_cbb !=nil {return _cbb ;};};_bega ,_ ,_dade :=_abfa ._dadc .GeneratePageBlocks (_abfa ._efab );if _dade !=nil {_dg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_dade );
return _dade ;};_cfga +=len (_bega );_ceaf :=_abfa ._dadc .Lines ();for _ ,_becc :=range _ceaf {_eacg ,_cadg :=_ddd .Atoi (_becc .Page .Text );if _cadg !=nil {continue ;};_becc .Page .Text =_ddd .Itoa (_eacg +_cfga );};};_dagc :=false ;if _abfa ._bbbc !=nil {_edfeb ++;
_eedf :=_abfa .newPage ();_abfa ._dec =append ([]*_dc .PdfPage {_eedf },_abfa ._dec ...);_abfa .setActivePage (_eedf );_agb :=FrontpageFunctionArgs {PageNum :1,TotalPages :_edfeb };_abfa ._bbbc (_agb );_dagc =true ;};var _gfbd []*_dc .PdfPage ;if _abfa .AddTOC {_abfa .initContext ();
if _abfa ._bcd !=nil {if _acgaa :=_abfa ._bcd (_abfa ._dadc );_acgaa !=nil {_dg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_acgaa );return _acgaa ;
};};_cdfc :=_abfa ._dadc .Lines ();for _ ,_bacg :=range _cdfc {_bacg ._bdgb +=int64 (_cfga );};_bfda ,_ ,_ :=_abfa ._dadc .GeneratePageBlocks (_abfa ._efab );for _ ,_bada :=range _bfda {_bada .SetPos (0,0);_edfeb ++;_ddea :=_abfa .newPage ();_gfbd =append (_gfbd ,_ddea );
_abfa .setActivePage (_ddea );_abfa .Draw (_bada );};if _dagc {_gabg :=_abfa ._dec [0];_efgd :=_abfa ._dec [1:];_abfa ._dec =append ([]*_dc .PdfPage {_gabg },_gfbd ...);_abfa ._dec =append (_abfa ._dec ,_efgd ...);}else {_abfa ._dec =append (_gfbd ,_abfa ._dec ...);
};};if _abfa ._fage !=nil &&_abfa .AddOutlines {var _ggb func (_cgfb *_dc .OutlineItem );_ggb =func (_caea *_dc .OutlineItem ){_caea .Dest .Page +=int64 (_cfga );if _adcb :=int (_caea .Dest .Page );_adcb >=0&&_adcb < len (_abfa ._dec ){_caea .Dest .PageObj =_abfa ._dec [_adcb ].GetPageAsIndirectObject ();
}else {_dg .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_adcb );
};_caea .Dest .Y =_abfa ._gbgd -_caea .Dest .Y ;_bege :=_caea .Items ();for _ ,_cede :=range _bege {_ggb (_cede );};};_bgg :=_abfa ._fage .Items ();for _ ,_cdae :=range _bgg {_ggb (_cdae );};if _abfa .AddTOC {var _fagf int ;if _dagc {_fagf =1;};_efee :=_dc .NewOutlineDest (int64 (_fagf ),0,_abfa ._gbgd );
if _fagf >=0&&_fagf < len (_abfa ._dec ){_efee .PageObj =_abfa ._dec [_fagf ].GetPageAsIndirectObject ();}else {_dg .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_fagf );
};_abfa ._fage .Insert (0,_dc .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_efee ));};};for _fdb ,_gceg :=range _abfa ._dec {_abfa .setActivePage (_gceg );if _abfa ._gff !=nil {_bbc ,_cdbg ,_gfab :=_gceg .Size ();
if _gfab !=nil {return _gfab ;};_gbad :=PageFinalizeFunctionArgs {PageNum :_fdb +1,PageWidth :_bbc ,PageHeight :_cdbg ,TOCPages :len (_gfbd ),TotalPages :_edfeb };if _fbeb :=_abfa ._gff (_gbad );_fbeb !=nil {_dg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_fbeb );
return _fbeb ;};};if _abfa ._gcec !=nil {_ggc :=NewBlock (_abfa ._aaaf ,_abfa ._gggg .Top );_abac :=HeaderFunctionArgs {PageNum :_fdb +1,TotalPages :_edfeb };_abfa ._gcec (_ggc ,_abac );_ggc .SetPos (0,0);if _daf :=_abfa .Draw (_ggc );_daf !=nil {_dg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_daf );
return _daf ;};};if _abfa ._bfdd !=nil {_bffad :=NewBlock (_abfa ._aaaf ,_abfa ._gggg .Bottom );_dafa :=FooterFunctionArgs {PageNum :_fdb +1,TotalPages :_edfeb };_abfa ._bfdd (_bffad ,_dafa );_bffad .SetPos (0,_abfa ._gbgd -_bffad ._ee );if _ecgc :=_abfa .Draw (_bffad );
_ecgc !=nil {_dg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_ecgc );return _ecgc ;};};_cgg ,_abd :=_abfa ._adce [_gceg ];if !_abd {continue ;};if _begee ,_ggba :=_abfa ._ffc [_gceg ];
_ggba {_cgg .transform (_begee );};if _adfc :=_cgg .drawToPage (_gceg );_adfc !=nil {_dg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_fdb +1,_adfc );
return _adfc ;};};_abfa ._bda =true ;return nil ;};

// SetColorRight sets border color for right.
func (_acfg *border )SetColorRight (col Color ){_acfg ._acc =col };

// Lines returns all the rows of the invoice line items table.
func (_cbbf *Invoice )Lines ()[][]*InvoiceCell {return _cbbf ._ggdd };

// SetLineHeight sets the line height (1.0 default).
func (_daaa *StyledParagraph )SetLineHeight (lineheight float64 ){_daaa ._bgfc =lineheight };

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};const (DefaultHorizontalScaling =100;);

// AppendCurve appends a Bezier curve to the filled curve.
func (_cba *FilledCurve )AppendCurve (curve _be .CubicBezierCurve )*FilledCurve {_cba ._dcdg =append (_cba ._dcdg ,curve );return _cba ;};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_bgfa *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_eeaf *_dc .PdfWriter )error ){_bgfa ._feeb =pdfWriterAccessFunc ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_cdacde *Invoice )AddressStyle ()TextStyle {return _cdacde ._bcbb };

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eebf *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _eebf ._adgb [0],_eebf ._adgb [1]};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_bbe *Creator )NewStyledParagraph ()*StyledParagraph {return _dcgf (_bbe .NewTextStyle ())};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_acgc :float64 (r )/255.0,_cfe :float64 (g )/255.0,_bgbb :float64 (b )/255.0};};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_bcgc *TOC )SetLineLevelOffset (levelOffset float64 ){_bcgc ._ecda =levelOffset };

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_afba *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _afba ._ceca .Left ,_afba ._ceca .Right ,_afba ._ceca .Top ,_afba ._ceca .Bottom ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_dbgg *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fafe :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bdfb ,_bdee :=_fafe .setOpacity (_dbgg ._bffea ,_dbgg ._ggga );if _bdee !=nil {return nil ,ctx ,_bdee ;
};_dddf :=_dbgg ._ccef ;_dddf .FillEnabled =_dddf .FillColor !=nil ;var (_gedf =ctx .PageHeight ;_fffba =_dddf .Curves ;_eabc =make ([]_be .CubicBezierCurve ,0,len (_dddf .Curves )););for _fcgc :=range _dddf .Curves {_cgfbb :=_fffba [_fcgc ];_cgfbb .P0 .Y =_gedf -_cgfbb .P0 .Y ;
_cgfbb .P1 .Y =_gedf -_cgfbb .P1 .Y ;_cgfbb .P2 .Y =_gedf -_cgfbb .P2 .Y ;_cgfbb .P3 .Y =_gedf -_cgfbb .P3 .Y ;_eabc =append (_eabc ,_cgfbb );};_dddf .Curves =_eabc ;defer func (){_dddf .Curves =_fffba }();_cceeg ,_ ,_bdee :=_dddf .Draw (_bdfb );if _bdee !=nil {return nil ,ctx ,_bdee ;
};if _bdee =_fafe .addContentsByString (string (_cceeg ));_bdee !=nil {return nil ,ctx ,_bdee ;};return []*Block {_fafe },ctx ,nil ;};func _ggdae (_cfdf []_be .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_ccef :&_be .PolyBezierCurve {Curves :_cfdf ,BorderColor :_dc .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_bffea :1.0,_ggga :1.0};
};func (_gfcd *FilledCurve )draw (_cbaf string )([]byte ,*_dc .PdfRectangle ,error ){_gace :=_be .NewCubicBezierPath ();for _ ,_cdcb :=range _gfcd ._dcdg {_gace =_gace .AppendCurve (_cdcb );};creator :=_fb .NewContentCreator ();creator .Add_q ();if _gfcd .FillEnabled &&_gfcd ._afbc !=nil {creator .SetNonStrokingColor (_eba (_gfcd ._afbc ));
};if _gfcd .BorderEnabled {if _gfcd ._ccb !=nil {creator .SetStrokingColor (_eba (_gfcd ._ccb ));};creator .Add_w (_gfcd .BorderWidth );};if len (_cbaf )> 1{creator .Add_gs (_ef .PdfObjectName (_cbaf ));};_be .DrawBezierPathWithCreator (_gace ,creator );
creator .Add_h ();if _gfcd .FillEnabled &&_gfcd .BorderEnabled {creator .Add_B ();}else if _gfcd .FillEnabled {creator .Add_f ();}else if _gfcd .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_begaa :=_gace .GetBoundingBox ();if _gfcd .BorderEnabled {_begaa .Height +=_gfcd .BorderWidth ;
_begaa .Width +=_gfcd .BorderWidth ;_begaa .X -=_gfcd .BorderWidth /2;_begaa .Y -=_gfcd .BorderWidth /2;};_efeeb :=&_dc .PdfRectangle {};_efeeb .Llx =_begaa .X ;_efeeb .Lly =_begaa .Y ;_efeeb .Urx =_begaa .X +_begaa .Width ;_efeeb .Ury =_begaa .Y +_begaa .Height ;
return creator .Bytes (),_efeeb ,nil ;};

// SetWidthRight sets border width for right.
func (_bba *border )SetWidthRight (bw float64 ){_bba ._fab =bw };

// SetFillColor sets the fill color.
func (_cgea *Ellipse )SetFillColor (col Color ){_cgea ._fgcd =col };

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_faccd *Paragraph )SetColor (col Color ){_faccd ._gdbg =col };

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fdca *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _fdca ._fgab [0],_fdca ._fgab [1]};

// GetRowHeight returns the height of the specified row.
func (_fddgc *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_fddgc ._degd ){return 0,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _fddgc ._degd [row -1],nil ;
};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_ceafab *Table )SetPos (x ,y float64 ){_ceafab ._debec =PositionAbsolute ;_ceafab ._cgaa =x ;_ceafab ._gadae =y ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_fd *Block )SetPos (x ,y float64 ){_fd ._bc =PositionAbsolute ;_fd ._bcf =x ;_fd ._ba =y };

// Inline returns whether the inline mode of the division is active.
func (_fbebb *Division )Inline ()bool {return _fbebb ._gbc };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_fefbg *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_gffc :=NewTextChunk (text ,_fefbg ._aega );_gffc ._cdfcd =_dbcg (page -1,x ,y ,zoom );return _fefbg .appendChunk (_gffc );};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_bcaeb *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_bcaeb .Text },nil ;};var _gcdge []string ;var _cdfdb []rune ;var _eddec float64 ;var _cdge []float64 ;_dfgc :=_bcaeb .Style ;for _ ,_ddfb :=range _bcaeb .Text {if _ddfb =='\u000A'{_gcdge =append (_gcdge ,_cec .TrimRightFunc (string (_cdfdb ),_ce .IsSpace )+string (_ddfb ));
_cdfdb =nil ;_eddec =0;_cdge =nil ;continue ;};_fggef :=_ddfb ==' ';_gfafg ,_acff :=_dfgc .Font .GetRuneMetrics (_ddfb );if !_acff {_dg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_ddfb ,_ddfb ,_dfgc .Font .BaseFont (),_dfgc .Font .Subtype ());
_dg .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_dfgc .Font );_dg .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_dfgc .Font .Encoder ());return nil ,_d .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_fcef :=_dfgc .FontSize *_gfafg .Wx ;_eagag :=_fcef ;if !_fggef {_eagag =_fcef +_dfgc .CharSpacing *1000.0;};if _eddec +_fcef > width *1000.0{_egff :=-1;if !_fggef {for _ddgd :=len (_cdfdb )-1;_ddgd >=0;_ddgd --{if _cdfdb [_ddgd ]==' '{_egff =_ddgd ;
break ;};};};_bbafe :=string (_cdfdb );if _egff > 0{_bbafe =string (_cdfdb [0:_egff +1]);_cdfdb =append (_cdfdb [_egff +1:],_ddfb );_cdge =append (_cdge [_egff +1:],_eagag );_eddec =0;for _ ,_bdeec :=range _cdge {_eddec +=_bdeec ;};}else {if _fggef {_cdfdb =[]rune {};
_cdge =[]float64 {};_eddec =0;}else {_cdfdb =[]rune {_ddfb };_cdge =[]float64 {_eagag };_eddec =_eagag ;};};_gcdge =append (_gcdge ,_cec .TrimRightFunc (_bbafe ,_ce .IsSpace ));}else {_cdfdb =append (_cdfdb ,_ddfb );_eddec +=_eagag ;_cdge =append (_cdge ,_eagag );
};};if len (_cdfdb )> 0{_gcdge =append (_gcdge ,string (_cdfdb ));};return _gcdge ,nil ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_ggdbc float64 ;_gbfb float64 ;_gfeb float64 ;_acfe float64 ;_fgcd Color ;_abae Color ;_gfbcd float64 ;};func _dcadc (_bbcc ,_bgbaa ,_gaded string ,_ebfcc uint ,_egec TextStyle )*TOCLine {return _cdgb (TextChunk {Text :_bbcc ,Style :_egec },TextChunk {Text :_bgbaa ,Style :_egec },TextChunk {Text :_gaded ,Style :_egec },_ebfcc ,_egec );
};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_gfgedf *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_ccccf float64 ;_ccbfd uint ;_cfbad float64 ;_ecef Positioning ;_bdcbg float64 ;_ecgd float64 ;_bdgb int64 ;};func (_dadac *List )tableHeight (_gafc float64 )float64 {var _degc float64 ;for _ ,_egfgc :=range _dadac ._dddcf {switch _faf :=_egfgc ._aeabb .(type ){case *Paragraph :_fdgf :=_faf ;
if _fdgf ._gcfb {_fdgf .SetWidth (_gafc );};_degc +=_fdgf .Height ()+_fdgf ._agdb .Bottom +_fdgf ._agdb .Bottom ;_degc +=0.5*_fdgf ._cfcd *_fdgf ._gagf ;case *StyledParagraph :_afgf :=_faf ;if _afgf ._cead {_afgf .SetWidth (_gafc );};_degc +=_afgf .Height ()+_afgf ._afbed .Top +_afgf ._afbed .Bottom ;
_degc +=0.5*_afgf .getTextHeight ();default:_degc +=_egfgc ._aeabb .Height ();};};return _degc ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_cgbc *Creator )Draw (d Drawable )error {if _cgbc .getActivePage ()==nil {_cgbc .NewPage ();};_dgcg ,_acdg ,_eebd :=d .GeneratePageBlocks (_cgbc ._efab );if _eebd !=nil {return _eebd ;};for _caed ,_fcdb :=range _dgcg {if _caed > 0{_cgbc .NewPage ();
};_becda :=_cgbc .getActivePage ();if _ebdc ,_dgeg :=_cgbc ._adce [_becda ];_dgeg {if _fbfg :=_ebdc .mergeBlocks (_fcdb );_fbfg !=nil {return _fbfg ;};if _gbgf :=_cde (_fcdb ._a ,_ebdc ._a );_gbgf !=nil {return _gbgf ;};}else {_cgbc ._adce [_becda ]=_fcdb ;
};};_cgbc ._efab .X =_acdg .X ;_cgbc ._efab .Y =_acdg .Y ;_cgbc ._efab .Height =_acdg .PageHeight -_acdg .Y -_acdg .Margins .Bottom ;return nil ;};

// SetLineOpacity sets the line opacity.
func (_eacge *Polyline )SetLineOpacity (opacity float64 ){_eacge ._fadf =opacity };func (_eddc *Paragraph )getTextLineWidth (_bace string )float64 {var _efb float64 ;for _ ,_dbacd :=range _bace {if _dbacd =='\u000A'{continue ;};_egad ,_efdc :=_eddc ._ggeg .GetRuneMetrics (_dbacd );
if !_efdc {_dg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dbacd ,_dbacd );
return -1;};_efb +=_eddc ._cfcd *_egad .Wx ;};return _efb ;};

// TOC returns the table of contents component of the creator.
func (_gbb *Creator )TOC ()*TOC {return _gbb ._dadc };

// SetStyleRight sets border style for right side.
func (_gfdcc *border )SetStyleRight (style CellBorderStyle ){_gfdcc ._aebe =style };func (_bdcc *Invoice )newCell (_fffa string ,_adcbd InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_adcbd ,_fffa };};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_egfg :_da .Min (float64 (c ),100)/100.0,_dcd :_da .Min (float64 (m ),100)/100.0,_fdc :_da .Min (float64 (y ),100)/100.0,_dgfc :_da .Min (float64 (k ),100)/100.0};};

// SetBorderWidth sets the border width.
func (_gaea *Polygon )SetBorderWidth (borderWidth float64 ){_gaea ._aaac .BorderWidth =borderWidth };

// SetNotes sets the notes section of the invoice.
func (_gdea *Invoice )SetNotes (title ,content string ){_gdea ._aaae =[2]string {title ,content }};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_ggda *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gabb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gfce :=_be .Line {LineWidth :_ggda ._ged ,Opacity :1.0,LineColor :_eba (_ggda ._eeafe ),LineEndingStyle1 :_be .LineEndingStyleNone ,LineEndingStyle2 :_be .LineEndingStyleNone ,X1 :_ggda ._gda ,Y1 :ctx .PageHeight -_ggda ._afea ,X2 :_ggda ._fbbd ,Y2 :ctx .PageHeight -_ggda ._faae };
_edea ,_ ,_agbe :=_gfce .Draw ("");if _agbe !=nil {return nil ,ctx ,_agbe ;};_agbe =_gabb .addContentsByString (string (_edea ));if _agbe !=nil {return nil ,ctx ,_agbe ;};return []*Block {_gabb },ctx ,nil ;};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_dbg []VectorDrawable ;_gaf Positioning ;_bafe Margins ;_gbc bool ;};

// CreateFrontPage sets a function to generate a front Page.
func (_ffg *Creator )CreateFrontPage (genFrontPageFunc func (_aba FrontpageFunctionArgs )){_ffg ._bbbc =genFrontPageFunc ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);func (_caecf *Invoice )newColumn (_fdcaf string ,_fgce CellHorizontalAlignment )*InvoiceCell {_efd :=&InvoiceCell {_caecf ._agdd ,_fdcaf };
_efd .Alignment =_fgce ;return _efd ;};

// Write output of creator to io.Writer interface.
func (_cca *Creator )Write (ws _f .Writer )error {if _cfdc :=_cca .Finalize ();_cfdc !=nil {return _cfdc ;};_eef :=_dc .NewPdfWriter ();_eef .SetOptimizer (_cca ._becg );if _cca ._ffef !=nil {_cgee :=_eef .SetForms (_cca ._ffef );if _cgee !=nil {_dg .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cgee );
return _cgee ;};};if _cca ._fcgad !=nil {_eef .AddOutlineTree (_cca ._fcgad );}else if _cca ._fage !=nil &&_cca .AddOutlines {_eef .AddOutlineTree (&_cca ._fage .ToPdfOutline ().PdfOutlineTreeNode );};if _cca ._bdedg !=nil {if _fgc :=_eef .SetPageLabels (_cca ._bdedg );
_fgc !=nil {_dg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_fgc );return _fgc ;};};if _cca ._cefb !=nil {for _ ,_dcbf :=range _cca ._cefb {_faea :=_dcbf .SubsetRegistered ();
if _faea !=nil {_dg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_faea );return _faea ;};};};if _cca ._feeb !=nil {_acde :=_cca ._feeb (&_eef );
if _acde !=nil {_dg .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_acde );return _acde ;};};for _ ,_eea :=range _cca ._dec {_dcffb :=_eef .AddPage (_eea );if _dcffb !=nil {_dg .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_dcffb );
return _dcffb ;};};_deb :=_eef .Write (ws );if _deb !=nil {return _deb ;};return nil ;};

// SetBorderWidth sets the border width.
func (_bbec *Ellipse )SetBorderWidth (bw float64 ){_bbec ._gfbcd =bw };

// SetSellerAddress sets the seller address of the invoice.
func (_ceb *Invoice )SetSellerAddress (address *InvoiceAddress ){_ceb ._aecb =address };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_eebc *TOC )SetLineSeparatorStyle (style TextStyle ){_eebc ._eaab =style };

// SetInline sets the inline mode of the division.
func (_bafd *Division )SetInline (inline bool ){_bafd ._gbc =inline };

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_dcdg []_be .CubicBezierCurve ;FillEnabled bool ;_afbc Color ;BorderEnabled bool ;BorderWidth float64 ;_ccb Color ;};

// SetBorderColor sets the cell's border color.
func (_egccg *TableCell )SetBorderColor (col Color ){_egccg ._bbeg =col ;_egccg ._cegcg =col ;_egccg ._acfd =col ;_egccg ._gecdb =col ;};

// SetColorBottom sets border color for bottom.
func (_fffe *border )SetColorBottom (col Color ){_fffe ._cffe =col };

// SetDate sets the date of the invoice.
func (_dcbd *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_dcbd ._adgb [1].Value =date ;return _dcbd ._adgb [0],_dcbd ._adgb [1];};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_abgf *List )Marker ()*TextChunk {return &_abgf ._bed };

// Height returns the total height of all rows.
func (_eege *Table )Height ()float64 {_cadd :=float64 (0.0);for _ ,_bcdd :=range _eege ._degd {_cadd +=_bcdd ;};return _cadd ;};type listItem struct{_aeabb VectorDrawable ;_dabg TextChunk ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);
ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););func (_ge *Block )transform (_bd _cf .Matrix ){_dcf :=_fb .NewContentCreator ().Add_cm (_bd [0],_bd [1],_bd [3],_bd [4],_bd [6],_bd [7]).Operations ();
*_ge ._g =append (*_dcf ,*_ge ._g ...);_ge ._g .WrapIfNeeded ();};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_cded *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_cded ._bfbff =halign };func _egdf (_eage [][]_be .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_dgbg :&_be .CurvePolygon {Rings :_eage },_bbae :1.0,_ccec :1.0};
};

// The Image type is used to draw an image onto PDF.
type Image struct{_ecde *_dc .XObjectImage ;_gaac *_dc .Image ;_gdce float64 ;_ebe ,_fedd float64 ;_cbac ,_bffg float64 ;_beeb Positioning ;_bbff HorizontalAlignment ;_adba float64 ;_agfb float64 ;_abcd float64 ;_ceca Margins ;_fffb ,_afgg float64 ;_gdeb _ef .StreamEncoder ;
};

// SetPos sets absolute positioning with specified coordinates.
func (_aeac *Paragraph )SetPos (x ,y float64 ){_aeac ._cdfd =PositionAbsolute ;_aeac ._cbdb =x ;_aeac ._ecdcb =y ;};

// SetWidthBottom sets border width for bottom.
func (_ccg *border )SetWidthBottom (bw float64 ){_ccg ._dbc =bw };func _cdceb ()*PageBreak {return &PageBreak {}};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_gda float64 ;_afea float64 ;_fbbd float64 ;_faae float64 ;_eeafe Color ;_ged float64 ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_eaaa *Image )SetPos (x ,y float64 ){_eaaa ._beeb =PositionAbsolute ;_eaaa ._adba =x ;_eaaa ._agfb =y ;};

// CurRow returns the currently active cell's row number.
func (_egef *Table )CurRow ()int {_fcaa :=(_egef ._gecf -1)/_egef ._gaaa +1;return _fcaa };

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_badd *Chapter )SetIncludeInTOC (includeInTOC bool ){_badd ._afgd =includeInTOC };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_acdd *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_aafe :=range subtable ._fdbg {_acdaa :=&TableCell {};*_acdaa =*_aafe ;_acdaa ._abgd =_acdd ;_acdaa ._agdfg +=col -1;if _cgbdb :=_acdd ._gaaa -(_acdaa ._agdfg -1);_cgbdb < _acdaa ._acgf {_acdd ._gaaa +=_acdaa ._acgf -_cgbdb ;
_acdd .resetColumnWidths ();_dg .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_acdd ._gaaa );
};_acdaa ._debc +=row -1;_adefe :=subtable ._degd [_aafe ._debc -1];if _acdaa ._debc > _acdd ._cbfc {for _acdaa ._debc > _acdd ._cbfc {_acdd ._cbfc ++;_acdd ._degd =append (_acdd ._degd ,_acdd ._bfeg );};_acdd ._degd [_acdaa ._debc -1]=_adefe ;}else {_acdd ._degd [_acdaa ._debc -1]=_da .Max (_acdd ._degd [_acdaa ._debc -1],_adefe );
};_acdd ._fdbg =append (_acdd ._fdbg ,_acdaa );};_c .Slice (_acdd ._fdbg ,func (_aecc ,_efcca int )bool {_aeed :=_acdd ._fdbg [_aecc ]._debc ;_cged :=_acdd ._fdbg [_efcca ]._debc ;if _aeed < _cged {return true ;};if _aeed > _cged {return false ;};return _acdd ._fdbg [_aecc ]._agdfg < _acdd ._fdbg [_efcca ]._agdfg ;
});};func (_geg cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_dcag :=_geg ._dgfc ;return 1-(_geg ._egfg *(1-_dcag )+_dcag ),1-(_geg ._dcd *(1-_dcag )+_dcag ),1-(_geg ._fdc *(1-_dcag )+_dcag );};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_dbce *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _bacf (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_gadf *Invoice )SetAddressStyle (style TextStyle ){_gadf ._bcbb =style };

// Heading returns the heading component of the table of contents.
func (_cdde *TOC )Heading ()*StyledParagraph {return _cdde ._eaeb };func (_gbaa *TextStyle )horizontalScale ()float64 {return _gbaa .HorizontalScaling /100};

// AddLine appends a new line to the invoice line items table.
func (_dfbf *Invoice )AddLine (values ...string )[]*InvoiceCell {_gbag :=len (_dfbf ._dfdf );var _efeg []*InvoiceCell ;for _eff ,_cbcc :=range values {_bgbd :=_dfbf .newCell (_cbcc ,_dfbf ._ggec );if _eff < _gbag {_bgbd .Alignment =_dfbf ._dfdf [_eff ].Alignment ;
};_efeg =append (_efeg ,_bgbd );};_dfbf ._ggdd =append (_dfbf ._ggdd ,_efeg );return _efeg ;};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_cgbg *Image )ScaleToWidth (w float64 ){_ccd :=_cgbg ._fedd /_cgbg ._ebe ;_cgbg ._ebe =w ;_cgbg ._fedd =w *_ccd ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_gcg *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _aece []*Block ;_ebdb :=ctx ;if _gcg ._gaf .IsRelative (){ctx .X +=_gcg ._bafe .Left ;ctx .Y +=_gcg ._bafe .Top ;ctx .Width -=_gcg ._bafe .Left +_gcg ._bafe .Right ;
ctx .Height -=_gcg ._bafe .Top +_gcg ._bafe .Bottom ;};ctx .Inline =_gcg ._gbc ;_bcda :=ctx ;_ffge :=ctx ;var _cbeb float64 ;for _ ,_dcec :=range _gcg ._dbg {if ctx .Inline {if (ctx .X -_bcda .X )+_dcec .Width ()<=ctx .Width {ctx .Y =_ffge .Y ;ctx .Height =_ffge .Height ;
}else {ctx .X =_bcda .X ;ctx .Width =_bcda .Width ;_ffge .Y +=_cbeb ;_ffge .Height -=_cbeb ;_cbeb =0;};};_bdf ,_add ,_cadc :=_dcec .GeneratePageBlocks (ctx );if _cadc !=nil {_dg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_cadc );
return nil ,ctx ,_cadc ;};if len (_bdf )< 1{continue ;};if len (_aece )> 0{_aece [len (_aece )-1].mergeBlocks (_bdf [0]);_aece =append (_aece ,_bdf [1:]...);}else {_aece =append (_aece ,_bdf [0:]...);};if ctx .Inline {if ctx .Page !=_add .Page {_bcda .Y =ctx .Margins .Top ;
_bcda .Height =ctx .PageHeight -ctx .Margins .Top ;_ffge .Y =_bcda .Y ;_ffge .Height =_bcda .Height ;_cbeb =_add .Height -_bcda .Height ;}else {if _aggb :=ctx .Height -_add .Height ;_aggb > _cbeb {_cbeb =_aggb ;};};}else {_add .X =ctx .X ;};ctx =_add ;
};ctx .Inline =_ebdb .Inline ;if _gcg ._gaf .IsRelative (){ctx .X =_ebdb .X ;};if _gcg ._gaf .IsAbsolute (){return _aece ,_ebdb ,nil ;};return _aece ,ctx ,nil ;};func (_gffe *TOCLine )prepareParagraph (_dcgdg *StyledParagraph ,_abcf DrawContext ){_gcge :=_gffe .Title .Text ;
if _gffe .Number .Text !=""{_gcge ="\u0020"+_gcge ;};_gcge +="\u0020";_eggf :=_gffe .Page .Text ;if _eggf !=""{_eggf ="\u0020"+_eggf ;};_dcgdg ._gfged =[]*TextChunk {{Text :_gffe .Number .Text ,Style :_gffe .Number .Style ,_cdfcd :_gffe .getLineLink ()},{Text :_gcge ,Style :_gffe .Title .Style ,_cdfcd :_gffe .getLineLink ()},{Text :_eggf ,Style :_gffe .Page .Style ,_cdfcd :_gffe .getLineLink ()}};
_dcgdg .wrapText ();_affc :=len (_dcgdg ._cfbc );if _affc ==0{return ;};_dbbbd :=_abcf .Width *1000-_dcgdg .getTextLineWidth (_dcgdg ._cfbc [_affc -1]);_cdbbc :=_dcgdg .getTextLineWidth ([]*TextChunk {&_gffe .Separator });_bagd :=int (_dbbbd /_cdbbc );
_caba :=_cec .Repeat (_gffe .Separator .Text ,_bagd );_fgda :=_gffe .Separator .Style ;_cdaf :=_dcgdg .Insert (2,_caba );_cdaf .Style =_fgda ;_cdaf ._cdfcd =_gffe .getLineLink ();_dbbbd =_dbbbd -float64 (_bagd )*_cdbbc ;if _dbbbd > 500{_edcb ,_fcgaf :=_fgda .Font .GetRuneMetrics (' ');
if _fcgaf &&_dbbbd > _edcb .Wx {_egffb :=int (_dbbbd /_edcb .Wx );if _egffb > 0{_bddf :=_fgda ;_bddf .FontSize =1;_cdaf =_dcgdg .Insert (2,_cec .Repeat ("\u0020",_egffb ));_cdaf .Style =_bddf ;_cdaf ._cdfcd =_gffe .getLineLink ();};};};};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_af *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _af ._ed .Left ,_af ._ed .Right ,_af ._ed .Top ,_af ._ed .Bottom ;};func _ccbc (_fcbag *_dc .PdfAnnotation )*_dc .PdfAnnotation {if _fcbag ==nil {return nil ;};var _agdfb *_dc .PdfAnnotation ;
switch _ccefb :=_fcbag .GetContext ().(type ){case *_dc .PdfAnnotationLink :if _afeg :=_fegee (_ccefb );_afeg !=nil {_agdfb =_afeg .PdfAnnotation ;};};return _agdfb ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_cagb *Image )SetWidth (w float64 ){_cagb ._ebe =w };func _fegee (_gefed *_dc .PdfAnnotationLink )*_dc .PdfAnnotationLink {if _gefed ==nil {return nil ;};_cfcb :=_dc .NewPdfAnnotationLink ();_cfcb .BS =_gefed .BS ;_cfcb .A =_gefed .A ;if _gfea ,_ecbda :=_gefed .GetAction ();
_ecbda ==nil &&_gfea !=nil {_cfcb .SetAction (_gfea );};if _bbcd ,_ccbdd :=_gefed .Dest .(*_ef .PdfObjectArray );_ccbdd {_cfcb .Dest =_ef .MakeArray (_bbcd .Elements ()...);};return _cfcb ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_afca *Creator )NewImageFromGoImage (goimg _bg .Image )(*Image ,error ){return _deac (goimg )};

// Width returns Image's document width.
func (_ead *Image )Width ()float64 {return _ead ._ebe };const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);func _acbe (_face ,_bdcf TextStyle )*Invoice {_dagg :=&Invoice {_bddc :"\u0049N\u0056\u004f\u0049\u0043\u0045",_dff :"\u002c\u0020",_deab :_face ,_bccc :_bdcf };
_dagg ._aecb =&InvoiceAddress {Separator :_dagg ._dff };_dagg ._gcaa =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_dagg ._dff };_agee :=ColorRGBFrom8bit (245,245,245);_aede :=ColorRGBFrom8bit (155,155,155);_dagg ._ggac =_bdcf ;
_dagg ._ggac .Color =_aede ;_dagg ._ggac .FontSize =20;_dagg ._bcbb =_face ;_dagg ._dcbg =_bdcf ;_dagg ._cbab =_face ;_dagg ._eeae =_bdcf ;_dagg ._ebga =_dagg .NewCellProps ();_dagg ._ebga .BackgroundColor =_agee ;_dagg ._ebga .TextStyle =_bdcf ;_dagg ._agdd =_dagg .NewCellProps ();
_dagg ._agdd .TextStyle =_bdcf ;_dagg ._agdd .BackgroundColor =_agee ;_dagg ._agdd .BorderColor =_agee ;_dagg ._ggec =_dagg .NewCellProps ();_dagg ._ggec .BorderColor =_agee ;_dagg ._ggec .BorderSides =[]CellBorderSide {CellBorderSideBottom };_dagg ._ggec .Alignment =CellHorizontalAlignmentRight ;
_dagg ._ded =_dagg .NewCellProps ();_dagg ._ded .Alignment =CellHorizontalAlignmentRight ;_dagg ._bbee =[2]*InvoiceCell {_dagg .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_dagg ._ebga ),_dagg .newCell ("",_dagg ._ebga )};
_dagg ._adgb =[2]*InvoiceCell {_dagg .newCell ("\u0044\u0061\u0074\u0065",_dagg ._ebga ),_dagg .newCell ("",_dagg ._ebga )};_dagg ._gcfc =[2]*InvoiceCell {_dagg .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_dagg ._ebga ),_dagg .newCell ("",_dagg ._ebga )};
_dagg ._bbbf =[2]*InvoiceCell {_dagg .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_dagg ._ded ),_dagg .newCell ("",_dagg ._ded )};_cefac :=_dagg ._ded ;_cefac .TextStyle =_bdcf ;_cefac .BackgroundColor =_agee ;_cefac .BorderColor =_agee ;
_dagg ._fgab =[2]*InvoiceCell {_dagg .newCell ("\u0054\u006f\u0074a\u006c",_cefac ),_dagg .newCell ("",_cefac )};_dagg ._aaae =[2]string {"\u004e\u006f\u0074e\u0073",""};_dagg ._eeda =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_dagg ._dfdf =[]*InvoiceCell {_dagg .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_dagg .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_dagg .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_dagg .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _dagg ;};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_gfge *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bdab ,_dbba :=_cfc .setOpacity (_gfge ._bbae ,_gfge ._ccec );if _dbba !=nil {return nil ,ctx ,_dbba ;};_daee :=_gfge ._dgbg ;
_daee .FillEnabled =_daee .FillColor !=nil ;_daee .BorderEnabled =_daee .BorderColor !=nil &&_daee .BorderWidth > 0;var (_cdca =ctx .PageHeight ;_fadc =_daee .Rings ;_bgfae =make ([][]_be .CubicBezierCurve ,0,len (_daee .Rings )););for _ ,_edccg :=range _fadc {_fbga :=make ([]_be .CubicBezierCurve ,0,len (_edccg ));
for _ ,_def :=range _edccg {_fddb :=_def ;_fddb .P0 .Y =_cdca -_fddb .P0 .Y ;_fddb .P1 .Y =_cdca -_fddb .P1 .Y ;_fddb .P2 .Y =_cdca -_fddb .P2 .Y ;_fddb .P3 .Y =_cdca -_fddb .P3 .Y ;_fbga =append (_fbga ,_fddb );};_bgfae =append (_bgfae ,_fbga );};_daee .Rings =_bgfae ;
defer func (){_daee .Rings =_fadc }();_babd ,_ ,_dbba :=_daee .Draw (_bdab );if _dbba !=nil {return nil ,ctx ,_dbba ;};if _dbba =_cfc .addContentsByString (string (_babd ));_dbba !=nil {return nil ,ctx ,_dbba ;};return []*Block {_cfc },ctx ,nil ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_cggf *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_fdaae :=&_cggf ._gfgedf ._afbed ;return _cggf ._ccccf ,_fdaae .Right ,_fdaae .Top ,_fdaae .Bottom ;};func (_dcfd *Creator )initContext (){_dcfd ._efab .X =_dcfd ._gggg .Left ;_dcfd ._efab .Y =_dcfd ._gggg .Top ;
_dcfd ._efab .Width =_dcfd ._aaaf -_dcfd ._gggg .Right -_dcfd ._gggg .Left ;_dcfd ._efab .Height =_dcfd ._gbgd -_dcfd ._gggg .Bottom -_dcfd ._gggg .Top ;_dcfd ._efab .PageHeight =_dcfd ._gbgd ;_dcfd ._efab .PageWidth =_dcfd ._aaaf ;_dcfd ._efab .Margins =_dcfd ._gggg ;
};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};type rgbColor struct{_acgc ,_cfe ,_bgbb float64 };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_eead *StyledParagraph )Insert (index uint ,text string )*TextChunk {_bgbdf :=uint (len (_eead ._gfged ));if index > _bgbdf {index =_bgbdf ;};_agad :=NewTextChunk (text ,_eead ._beeea );_eead ._gfged =append (_eead ._gfged [:index ],append ([]*TextChunk {_agad },_eead ._gfged [index :]...)...);
_eead .wrapText ();return _agad ;};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// MoveX moves the drawing context to absolute position x.
func (_bcdb *Creator )MoveX (x float64 ){_bcdb ._efab .X =x };func (_bdabc *StyledParagraph )getTextHeight ()float64 {var _fdfd float64 ;for _ ,_ggdac :=range _bdabc ._gfged {_babf :=_ggdac .Style .FontSize *_bdabc ._bgfc ;if _babf > _fdfd {_fdfd =_babf ;
};};return _fdfd ;};

// SetFillColor sets the fill color.
func (_baag *Polygon )SetFillColor (color Color ){_baag ._aaac .FillColor =_eba (color )};func _edfg (_fae ,_egg ,_aeab ,_faed float64 )*border {_fff :=&border {};_fff ._cbd =_fae ;_fff ._afc =_egg ;_fff ._bae =_aeab ;_fff ._cdce =_faed ;_fff ._adgaf =ColorBlack ;
_fff ._cffe =ColorBlack ;_fff ._afb =ColorBlack ;_fff ._acc =ColorBlack ;_fff ._dfc =0;_fff ._dbc =0;_fff ._fed =0;_fff ._fab =0;_fff .LineStyle =_be .LineStyleSolid ;return _fff ;};func (_adcg *Invoice )drawAddress (_eecg *InvoiceAddress )[]*StyledParagraph {var _faeb []*StyledParagraph ;
if _eecg .Heading !=""{_gade :=_dcgf (_adcg ._dcbg );_gade .SetMargins (0,0,0,7);_gade .Append (_eecg .Heading );_faeb =append (_faeb ,_gade );};_cgba :=_dcgf (_adcg ._bcbb );_cgba .SetLineHeight (1.2);_adbaf :=_eecg .Separator ;if _adbaf ==""{_adbaf =_adcg ._dff ;
};_efff :=_eecg .City ;if _eecg .State !=""{if _efff !=""{_efff +=_adbaf ;};_efff +=_eecg .State ;};if _eecg .Zip !=""{if _efff !=""{_efff +=_adbaf ;};_efff +=_eecg .Zip ;};if _eecg .Name !=""{_cgba .Append (_eecg .Name +"\u000a");};if _eecg .Street !=""{_cgba .Append (_eecg .Street +"\u000a");
};if _eecg .Street2 !=""{_cgba .Append (_eecg .Street2 +"\u000a");};if _efff !=""{_cgba .Append (_efff +"\u000a");};if _eecg .Country !=""{_cgba .Append (_eecg .Country +"\u000a");};_fagag :=_dcgf (_adcg ._bcbb );_fagag .SetLineHeight (1.2);_fagag .SetMargins (0,0,7,0);
if _eecg .Phone !=""{_fagag .Append (_eecg .fmtLine (_eecg .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_eecg .HidePhoneLabel ));};if _eecg .Email !=""{_fagag .Append (_eecg .fmtLine (_eecg .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_eecg .HideEmailLabel ));
};_faeb =append (_faeb ,_cgba ,_fagag );return _faeb ;};func _dbcg (_cgddf int64 ,_edgc ,_ggdaf ,_aeag float64 )*_dc .PdfAnnotation {_ffecf :=_dc .NewPdfAnnotationLink ();_aaec :=_dc .NewBorderStyle ();_aaec .SetBorderWidth (0);_ffecf .BS =_aaec .ToPdfObject ();
if _cgddf < 0{_cgddf =0;};_ffecf .Dest =_ef .MakeArray (_ef .MakeInteger (_cgddf ),_ef .MakeName ("\u0058\u0059\u005a"),_ef .MakeFloat (_edgc ),_ef .MakeFloat (_ggdaf ),_ef .MakeFloat (_aeag ));return _ffecf .PdfAnnotation ;};

// SetFontSize sets the font size in document units (points).
func (_gfaa *Paragraph )SetFontSize (fontSize float64 ){_gfaa ._cfcd =fontSize };

// Height returns the height of the list.
func (_ccbdc *List )Height ()float64 {var _cbba float64 ;for _ ,_beedc :=range _ccbdc ._dddcf {_cbba +=_beedc ._aeabb .Height ();};return _cbba ;};

// SetTotal sets the total of the invoice.
func (_fgb *Invoice )SetTotal (value string ){_fgb ._fgab [1].Value =value };

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_bbffc *Image )ConvertToBinary ()error {return _bbffc ._gaac .ConvertToBinary ()};

// SetBorderWidth sets the border width.
func (_gadcg *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_gadcg ._ccef .BorderWidth =borderWidth ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_bafagf *TOCLine )SetLink (page int64 ,x ,y float64 ){_bafagf ._bdcbg =x ;_bafagf ._ecgd =y ;_bafagf ._bdgb =page ;_ebcd :=_bafagf ._gfgedf ._aega .Color ;_bafagf .Number .Style .Color =_ebcd ;_bafagf .Title .Style .Color =_ebcd ;_bafagf .Separator .Style .Color =_ebcd ;
_bafagf .Page .Style .Color =_ebcd ;};

// NewFilledCurve returns a instance of filled curve.
func (_efgg *Creator )NewFilledCurve ()*FilledCurve {return _ccffd ()};

// Add adds a new line with the default style to the table of contents.
func (_agca *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_dcgdd :=_agca .AddLine (_cdgb (TextChunk {Text :number ,Style :_agca ._bbed },TextChunk {Text :title ,Style :_agca ._ebdac },TextChunk {Text :page ,Style :_agca ._ggcd },level ,_agca ._aegc ));
if _dcgdd ==nil {return nil ;};_cgfc :=&_agca ._daddd ;_dcgdd .SetMargins (_cgfc .Left ,_cgfc .Right ,_cgfc .Top ,_cgfc .Bottom );_dcgdd .SetLevelOffset (_agca ._ecda );_dcgdd .Separator .Text =_agca ._gecde ;_dcgdd .Separator .Style =_agca ._eaab ;return _dcgdd ;
};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_fce *Creator )MoveTo (x ,y float64 ){_fce ._efab .X =x ;_fce ._efab .Y =y };

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_bafa *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_bafa ._gggg .Left =left ;_bafa ._gggg .Right =right ;_bafa ._gggg .Top =top ;_bafa ._gggg .Bottom =bottom ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_cdacdg Color ;_egeb _be .LineStyle ;_eaeg CellBorderStyle ;_bbeg Color ;_fbfd float64 ;_bbaf CellBorderStyle ;_cegcg Color ;_bfga float64 ;_gebae CellBorderStyle ;_acfd Color ;_dfba float64 ;_edgf CellBorderStyle ;_gecdb Color ;_cgcbe float64 ;
_debc ,_agdfg int ;_feef int ;_acgf int ;_fagfbd VectorDrawable ;_bfbff CellHorizontalAlignment ;_aegef CellVerticalAlignment ;_aefgf float64 ;_abgd *Table ;};func _ageb (_dcdb *Block ,_gegc *Image ,_ddcd DrawContext )(DrawContext ,error ){_edbbb :=_ddcd ;
_dacg :=1;_bgcba :=_ef .PdfObjectName (_db .Sprintf ("\u0049\u006d\u0067%\u0064",_dacg ));for _dcdb ._a .HasXObjectByName (_bgcba ){_dacg ++;_bgcba =_ef .PdfObjectName (_db .Sprintf ("\u0049\u006d\u0067%\u0064",_dacg ));};_fdaac :=_dcdb ._a .SetXObjectImageByName (_bgcba ,_gegc ._ecde );
if _fdaac !=nil {return _ddcd ,_fdaac ;};_bef :=0;_egbc :=_ef .PdfObjectName (_db .Sprintf ("\u0047\u0053\u0025\u0064",_bef ));for _dcdb ._a .HasExtGState (_egbc ){_bef ++;_egbc =_ef .PdfObjectName (_db .Sprintf ("\u0047\u0053\u0025\u0064",_bef ));};_ebgb :=_ef .MakeDict ();
_ebgb .Set ("\u0042\u004d",_ef .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _gegc ._abcd < 1.0{_ebgb .Set ("\u0043\u0041",_ef .MakeFloat (_gegc ._abcd ));_ebgb .Set ("\u0063\u0061",_ef .MakeFloat (_gegc ._abcd ));};_fdaac =_dcdb ._a .AddExtGState (_egbc ,_ef .MakeIndirectObject (_ebgb ));
if _fdaac !=nil {return _ddcd ,_fdaac ;};_adgda :=_gegc .Width ();_baa :=_gegc .Height ();_ ,_bgad :=_gegc .rotatedSize ();_ceac :=_ddcd .X ;_bdae :=_ddcd .PageHeight -_ddcd .Y -_baa ;if _gegc ._beeb .IsRelative (){_bdae -=(_bgad -_baa )/2;switch _gegc ._bbff {case HorizontalAlignmentCenter :_ceac +=(_ddcd .Width -_adgda )/2;
case HorizontalAlignmentRight :_ceac =_ddcd .PageWidth -_ddcd .Margins .Right -_gegc ._ceca .Right -_adgda ;};};_efac :=_gegc ._gdce ;_fedc :=_fb .NewContentCreator ();_fedc .Add_gs (_egbc );_fedc .Translate (_ceac ,_bdae );if _efac !=0{_fedc .Translate (_adgda /2,_baa /2);
_fedc .RotateDeg (_efac );_fedc .Translate (-_adgda /2,-_baa /2);};_fedc .Scale (_adgda ,_baa ).Add_Do (_bgcba );_bfdg :=_fedc .Operations ();_bfdg .WrapIfNeeded ();_dcdb .addContents (_bfdg );if _gegc ._beeb .IsRelative (){_ddcd .Y +=_bgad ;_ddcd .Height -=_bgad ;
return _ddcd ,nil ;};return _edbbb ,nil ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_bddc string ;_acba *Image ;_gcaa *InvoiceAddress ;_aecb *InvoiceAddress ;_dff string ;_bbee [2]*InvoiceCell ;_adgb [2]*InvoiceCell ;_gcfc [2]*InvoiceCell ;_gge [][2]*InvoiceCell ;_dfdf []*InvoiceCell ;_ggdd [][]*InvoiceCell ;_bbbf [2]*InvoiceCell ;
_fgab [2]*InvoiceCell ;_gfcb [][2]*InvoiceCell ;_aaae [2]string ;_eeda [2]string ;_eaac [][2]string ;_deab TextStyle ;_bccc TextStyle ;_ggac TextStyle ;_bcbb TextStyle ;_dcbg TextStyle ;_cbab TextStyle ;_eeae TextStyle ;_ebga InvoiceCellProps ;_agdd InvoiceCellProps ;
_ggec InvoiceCellProps ;_ded InvoiceCellProps ;_cceg Positioning ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_cfbdb *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cfbdb ._agdb .Left ,_cfbdb ._agdb .Right ,_cfbdb ._agdb .Top ,_cfbdb ._agdb .Bottom ;};func (_gcfgf *Table )resetColumnWidths (){_gcfgf ._bbecd =[]float64 {};_ccfg :=float64 (1.0)/float64 (_gcfgf ._gaaa );
for _dcecc :=0;_dcecc < _gcfgf ._gaaa ;_dcecc ++{_gcfgf ._bbecd =append (_gcfgf ._bbecd ,_ccfg );};};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_ffb *Block )Draw (d Drawable )error {_dgfd :=DrawContext {};_dgfd .Width =_ffb ._eg ;_dgfd .Height =_ffb ._ee ;_dgfd .PageWidth =_ffb ._eg ;_dgfd .PageHeight =_ffb ._ee ;_dgfd .X =0;_dgfd .Y =0;_fbb ,_ ,_gcdg :=d .GeneratePageBlocks (_dgfd );if _gcdg !=nil {return _gcdg ;
};if len (_fbb )!=1{return _d .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_acga :=range _fbb {if _fda :=_ffb .mergeBlocks (_acga );_fda !=nil {return _fda ;};};
return nil ;};

// SetAngle sets the rotation angle in degrees.
func (_cg *Block )SetAngle (angleDeg float64 ){_cg ._gd =angleDeg };

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_daac *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_cecf :=&_daac ._daddd ;_cecf .Left =left ;_cecf .Right =right ;_cecf .Top =top ;_cecf .Bottom =bottom ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_eddb *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aefe :=ctx ;var _bcef []*Block ;_feda :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _eddb ._cfde .IsRelative (){ctx .X +=_eddb ._afbed .Left ;ctx .Y +=_eddb ._afbed .Top ;
ctx .Width -=_eddb ._afbed .Left +_eddb ._afbed .Right ;ctx .Height -=_eddb ._afbed .Top +_eddb ._afbed .Bottom ;_eddb .SetWidth (ctx .Width );}else {if int (_eddb ._aegf )<=0{_eddb .SetWidth (_eddb .getTextWidth ()/1000.0);};ctx .X =_eddb ._ddbcd ;ctx .Y =_eddb ._dfeb ;
};if _eddb ._gacb !=nil {_eddb ._gacb (_eddb ,ctx );};if _dfdfc :=_eddb .wrapText ();_dfdfc !=nil {return nil ,ctx ,_dfdfc ;};_gfgfa :=_eddb ._cfbc ;for {_bbbfd ,_egfga ,_bgdd :=_ceadd (_feda ,_eddb ,_gfgfa ,ctx );if _bgdd !=nil {_dg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bgdd );
return nil ,ctx ,_bgdd ;};ctx =_bbbfd ;_bcef =append (_bcef ,_feda );if _gfgfa =_egfga ;len (_egfga )==0{break ;};_feda =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bbbfd =ctx ;_bbbfd .Y =ctx .Margins .Top ;_bbbfd .X =ctx .Margins .Left +_eddb ._afbed .Left ;
_bbbfd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_eddb ._afbed .Bottom ;_bbbfd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_eddb ._afbed .Left -_eddb ._afbed .Right ;ctx =_bbbfd ;};if _eddb ._cfde .IsRelative (){ctx .X -=_eddb ._afbed .Left ;
ctx .Width =_aefe .Width ;return _bcef ,ctx ,nil ;};return _bcef ,_aefe ,nil ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_bbbg *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abcgg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gbbe :=_be .Rectangle {Opacity :1.0,X :_bbbg ._gacff ,Y :ctx .PageHeight -_bbbg ._eeag -_bbbg ._abeda ,Height :_bbbg ._abeda ,Width :_bbbg ._ddefa };
if _bbbg ._dccd !=nil {_gbbe .FillEnabled =true ;_gbbe .FillColor =_eba (_bbbg ._dccd );};if _bbbg ._ffgeb !=nil &&_bbbg ._afggg > 0{_gbbe .BorderEnabled =true ;_gbbe .BorderColor =_eba (_bbbg ._ffgeb );_gbbe .BorderWidth =_bbbg ._afggg ;};_bafg ,_bgfe :=_abcgg .setOpacity (_bbbg ._gfgb ,_bbbg ._gagg );
if _bgfe !=nil {return nil ,ctx ,_bgfe ;};_cgfg ,_ ,_bgfe :=_gbbe .Draw (_bafg );if _bgfe !=nil {return nil ,ctx ,_bgfe ;};if _bgfe =_abcgg .addContentsByString (string (_cgfg ));_bgfe !=nil {return nil ,ctx ,_bgfe ;};return []*Block {_abcgg },ctx ,nil ;
};

// NewImage create a new image from a unidoc image (model.Image).
func (_gdfc *Creator )NewImage (img *_dc .Image )(*Image ,error ){return _cecg (img )};

// Rows returns the total number of rows the table has.
func (_cfbfc *Table )Rows ()int {return _cfbfc ._cbfc };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_cabd *Paragraph )SetMaxLines (maxLines int ){_cabd ._faad =maxLines ;_cabd .wrapText ()};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_bebg *Paragraph )Height ()float64 {_bebg .wrapText ();return float64 (len (_bebg ._babg ))*_bebg ._gagf *_bebg ._cfcd ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;);func _gabc (_bgcg [][]_be .Point )*Polygon {return &Polygon {_aaac :&_be .Polygon {Points :_bgcg },_bgbf :1.0,_efeab :1.0};
};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_dcfc *Invoice )SetNoteStyle (style TextStyle ){_dcfc ._cbab =style };

// SetFillColor sets the fill color.
func (_abcg *Rectangle )SetFillColor (col Color ){_abcg ._dccd =col };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_dafc *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_caeaa :=ctx ;_eefd :=[]func (_eddf DrawContext )([]*Block ,DrawContext ,error ){_dafc .generateHeaderBlocks ,_dafc .generateInformationBlocks ,_dafc .generateLineBlocks ,_dafc .generateTotalBlocks ,_dafc .generateNoteBlocks };
var _fefcd []*Block ;for _ ,_edfb :=range _eefd {_cefgd ,_fdag ,_aedg :=_edfb (ctx );if _aedg !=nil {return _fefcd ,ctx ,_aedg ;};if len (_fefcd )==0{_fefcd =_cefgd ;}else if len (_cefgd )> 0{_fefcd [len (_fefcd )-1].mergeBlocks (_cefgd [0]);_fefcd =append (_fefcd ,_cefgd [1:]...);
};ctx =_fdag ;};if _dafc ._cceg .IsRelative (){ctx .X =_caeaa .X ;};if _dafc ._cceg .IsAbsolute (){return _fefcd ,_caeaa ,nil ;};return _fefcd ,ctx ,nil ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_egfg :_da .Max (_da .Min (c ,1.0),0.0),_dcd :_da .Max (_da .Min (m ,1.0),0.0),_fdc :_da .Max (_da .Min (y ,1.0),0.0),_dgfc :_da .Max (_da .Min (k ,1.0),0.0)};};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_edbcc *TOCLine )SetLevelOffset (levelOffset float64 ){_edbcc ._cfbad =levelOffset ;_edbcc ._gfgedf ._afbed .Left =_edbcc ._ccccf +float64 (_edbcc ._ccbfd -1)*_edbcc ._cfbad ;};func (_bbaa *StyledParagraph )getMaxLineWidth ()float64 {if _bbaa ._cfbc ==nil ||len (_bbaa ._cfbc )==0{_bbaa .wrapText ();
};var _abaeg float64 ;for _ ,_ecccg :=range _bbaa ._cfbc {_fgbd :=_bbaa .getTextLineWidth (_ecccg );if _fgbd > _abaeg {_abaeg =_fgbd ;};};return _abaeg ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_gddb *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ecce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dcea ,_ ,_gcgd :=_gddb .draw ("");if _gcgd !=nil {return nil ,ctx ,_gcgd ;};_gcgd =_ecce .addContentsByString (string (_dcea ));
if _gcgd !=nil {return nil ,ctx ,_gcgd ;};return []*Block {_ecce },ctx ,nil ;};func (_aggbb *StyledParagraph )appendChunk (_bfae *TextChunk )*TextChunk {_aggbb ._gfged =append (_aggbb ._gfged ,_bfae );_aggbb .wrapText ();return _bfae ;};

// RotatedSize returns the width and height of the rotated block.
func (_adg *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_acg ,_cdc :=_adegb (_adg ._eg ,_adg ._ee ,_adg ._gd );return _acg ,_cdc ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_afddd *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_afddd ._gaaa {_dg .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_afddd ._bbecd =widths ;return nil ;};func (_gca *Creator )newPage ()*_dc .PdfPage {_fbg :=_dc .NewPdfPage ();_aacg :=_gca ._ceag [0];
_bfg :=_gca ._ceag [1];_bge :=_dc .PdfRectangle {Llx :0,Lly :0,Urx :_aacg ,Ury :_bfg };_fbg .MediaBox =&_bge ;_gca ._aaaf =_aacg ;_gca ._gbgd =_bfg ;_gca .initContext ();return _fbg ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_aaac *_be .Polygon ;_bgbf float64 ;_efeab float64 ;};func (_ecca *Chapter )headingText ()string {_fge :=_ecca ._cefc ;if _dbfg :=_ecca .headingNumber ();_dbfg !=""{_fge =_db .Sprintf ("\u0025\u0073\u0020%\u0073",_dbfg ,_fge );};return _fge ;
};func (_dbbb *Paragraph )wrapText ()error {if !_dbbb ._gcfb ||int (_dbbb ._cega )<=0{_dbbb ._babg =[]string {_dbbb ._aaaef };return nil ;};_fgeaf :=NewTextChunk (_dbbb ._aaaef ,TextStyle {Font :_dbbb ._ggeg ,FontSize :_dbbb ._cfcd });_ddga ,_deea :=_fgeaf .Wrap (_dbbb ._cega );
if _deea !=nil {return _deea ;};if _dbbb ._faad > 0&&len (_ddga )> _dbbb ._faad {_ddga =_ddga [:_dbbb ._faad ];};_dbbb ._babg =_ddga ;return nil ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_adcd *StyledParagraph )SetText (text string )*TextChunk {_adcd .Reset ();return _adcd .Append (text );};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_aaaef string ;_ggeg *_dc .PdfFont ;_cfcd float64 ;_gagf float64 ;_gdbg Color ;_cdba TextAlignment ;_gcfb bool ;_cega float64 ;_faad int ;_dbbaf bool ;_gcaf float64 ;_agdb Margins ;_cdfd Positioning ;_cbdb float64 ;_ecdcb float64 ;
_efae ,_debac float64 ;_babg []string ;};

// Width returns the current page width.
func (_fddg *Creator )Width ()float64 {return _fddg ._aaaf };

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_adgg *List )Width ()float64 {return 0};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// Width returns the cell's width based on the input draw context.
func (_dcgbd *TableCell )Width (ctx DrawContext )float64 {_degcb :=float64 (0.0);for _cfgd :=0;_cfgd < _dcgbd ._acgf ;_cfgd ++{_degcb +=_dcgbd ._abgd ._bbecd [_dcgbd ._agdfg +_cfgd -1];};_afad :=ctx .Width *_degcb ;return _afad ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_g *_fb .ContentStreamOperations ;_a *_dc .PdfPageResources ;_bc Positioning ;_bcf ,_ba float64 ;_eg float64 ;_ee float64 ;_gd float64 ;_ed Margins ;_dbd []*_dc .PdfAnnotation ;};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_gfdcf *StyledParagraph )Height ()float64 {_gfdcf .wrapText ();var _gaeg float64 ;for _ ,_fceb :=range _gfdcf ._cfbc {var _aada float64 ;for _ ,_gbga :=range _fceb {_bfcb :=_gfdcf ._bgfc *_gbga .Style .FontSize ;if _bfcb > _aada {_aada =_bfcb ;};
};_gaeg +=_aada ;};return _gaeg ;};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetBorderOpacity sets the border opacity.
func (_gcfe *CurvePolygon )SetBorderOpacity (opacity float64 ){_gcfe ._ccec =opacity };

// SetLineColor sets the line color.
func (_gbec *Polyline )SetLineColor (color Color ){_gbec ._fgae .LineColor =_eba (color )};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_fdd *Creator )SetOutlineTree (outlineTree *_dc .PdfOutlineTreeNode ){_fdd ._fcgad =outlineTree };

// SetFillOpacity sets the fill opacity.
func (_afbga *Rectangle )SetFillOpacity (opacity float64 ){_afbga ._gfgb =opacity };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);func _dcgf (_cefe TextStyle )*StyledParagraph {return &StyledParagraph {_gfged :[]*TextChunk {},_beeea :_cefe ,_aega :_ccac (_cefe .Font ),_bgfc :1.0,_ddde :TextAlignmentLeft ,_cead :true ,_dagcf :true ,_febg :0,_cafc :1,_gfgec :1,_cfde :PositionRelative };
};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_edde *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _edde ._gda ,_edde ._afea ,_edde ._fbbd ,_edde ._faae ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// NewPolyline creates a new polyline.
func (_bggd *Creator )NewPolyline (points []_be .Point )*Polyline {return _cee (points )};func (_fcgdg *Invoice )generateNoteBlocks (_cbcca DrawContext )([]*Block ,DrawContext ,error ){_dcge :=_gadc ();_gceed :=append ([][2]string {_fcgdg ._aaae ,_fcgdg ._eeda },_fcgdg ._eaac ...);
for _ ,_gged :=range _gceed {if _gged [1]!=""{_beeg :=_fcgdg .drawSection (_gged [0],_gged [1]);for _ ,_cdaccb :=range _beeg {_dcge .Add (_cdaccb );};_dfga :=_dcgf (_fcgdg ._deab );_dfga .SetMargins (0,0,10,0);_dcge .Add (_dfga );};};return _dcge .GeneratePageBlocks (_cbcca );
};

// SetFillOpacity sets the fill opacity.
func (_ccag *Polygon )SetFillOpacity (opacity float64 ){_ccag ._bgbf =opacity };func (_ffee rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _ffee ._acgc ,_ffee ._cfe ,_ffee ._bgbb ;};

// NewImageFromData creates an Image from image data.
func (_bgff *Creator )NewImageFromData (data []byte )(*Image ,error ){return _bgfd (data )};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_dddcf []*listItem ;_fede Margins ;_bed TextChunk ;_fdagb float64 ;_bagb bool ;_bbcg Positioning ;_dgg TextStyle ;};

// Indent returns the left offset of the list when nested into another list.
func (_gcac *List )Indent ()float64 {return _gcac ._fdagb };

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_egdag *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_dcda :=[2]*InvoiceCell {_egdag .newCell (description ,_egdag ._ebga ),_egdag .newCell (value ,_egdag ._ebga )};_egdag ._gge =append (_egdag ._gge ,_dcda );return _dcda [0],_dcda [1];
};

// Columns returns all the columns in the invoice line items table.
func (_aacgg *Invoice )Columns ()[]*InvoiceCell {return _aacgg ._dfdf };

// SetStyleLeft sets border style for left side.
func (_bbd *border )SetStyleLeft (style CellBorderStyle ){_bbd ._ddb =style };

// SetFillOpacity sets the fill opacity.
func (_cgbb *PolyBezierCurve )SetFillOpacity (opacity float64 ){_cgbb ._bffea =opacity };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_cfa *Creator )EnableFontSubsetting (font *_dc .PdfFont ){_cfa ._cefb =append (_cfa ._cefb ,font )};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_dbbf *Image )GetHorizontalAlignment ()HorizontalAlignment {return _dbbf ._bbff };

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_gceac *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _d .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _d .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _d .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_gceac ._deaf =true ;_gceac ._febb =startRow ;_gceac ._dgaa =endRow ;return nil ;};

// Width returns the Block's width.
func (_fad *Block )Width ()float64 {return _fad ._eg };

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_afcc *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _aaff (x ,y ,width ,height );};func (_cfd *Block )addContents (_dgc *_fb .ContentStreamOperations ){_cfd ._g .WrapIfNeeded ();_dgc .WrapIfNeeded ();*_cfd ._g =append (*_cfd ._g ,*_dgc ...);
};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// CreateTableOfContents sets a function to generate table of contents.
func (_fgdg *Creator )CreateTableOfContents (genTOCFunc func (_dfb *TOC )error ){_fgdg ._bcd =genTOCFunc ;};

// NewDivision returns a new Division container component.
func (_fac *Creator )NewDivision ()*Division {return _gadc ()};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_ced *Creator )SetForms (form *_dc .PdfAcroForm )error {_ced ._ffef =form ;return nil };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_cdfcd *_dc .PdfAnnotation ;_ecdg bool ;};

// SetWidthTop sets border width for top.
func (_gdf *border )SetWidthTop (bw float64 ){_gdf ._dfc =bw };func (_fcgd *Invoice )generateTotalBlocks (_dcagg DrawContext )([]*Block ,DrawContext ,error ){_babad :=_eadg (4);_babad .SetMargins (0,0,10,10);_adgfc :=[][2]*InvoiceCell {_fcgd ._bbbf };_adgfc =append (_adgfc ,_fcgd ._gfcb ...);
_adgfc =append (_adgfc ,_fcgd ._fgab );for _ ,_gbff :=range _adgfc {_ffbfb ,_ffaa :=_gbff [0],_gbff [1];if _ffaa .Value ==""{continue ;};_babad .SkipCells (2);_gcefa :=_babad .NewCell ();_gcefa .SetBackgroundColor (_ffbfb .BackgroundColor );_gcefa .SetHorizontalAlignment (_ffaa .Alignment );
_fcgd .setCellBorder (_gcefa ,_ffbfb );_cdfe :=_dcgf (_ffbfb .TextStyle );_cdfe .SetMargins (0,0,2,1);_cdfe .Append (_ffbfb .Value );_gcefa .SetContent (_cdfe );_gcefa =_babad .NewCell ();_gcefa .SetBackgroundColor (_ffaa .BackgroundColor );_gcefa .SetHorizontalAlignment (_ffaa .Alignment );
_fcgd .setCellBorder (_gcefa ,_ffbfb );_cdfe =_dcgf (_ffaa .TextStyle );_cdfe .SetMargins (0,0,2,1);_cdfe .Append (_ffaa .Value );_gcefa .SetContent (_cdfe );};return _babad .GeneratePageBlocks (_dcagg );};func _aefb (_agab *Block ,_fddf *Paragraph ,_cegb DrawContext )(DrawContext ,error ){_fgg :=1;
_gcfd :=_ef .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ddd .Itoa (_fgg ));for _agab ._a .HasFontByName (_gcfd ){_fgg ++;_gcfd =_ef .PdfObjectName ("\u0046\u006f\u006e\u0074"+_ddd .Itoa (_fgg ));};_aeee :=_agab ._a .SetFontByName (_gcfd ,_fddf ._ggeg .ToPdfObject ());
if _aeee !=nil {return _cegb ,_aeee ;};_fddf .wrapText ();_caca :=_fb .NewContentCreator ();_caca .Add_q ();_egcdg :=_cegb .PageHeight -_cegb .Y -_fddf ._cfcd *_fddf ._gagf ;_caca .Translate (_cegb .X ,_egcdg );if _fddf ._gcaf !=0{_caca .RotateDeg (_fddf ._gcaf );
};_caca .Add_BT ().SetNonStrokingColor (_eba (_fddf ._gdbg )).Add_Tf (_gcfd ,_fddf ._cfcd ).Add_TL (_fddf ._cfcd *_fddf ._gagf );for _dbdf ,_aege :=range _fddf ._babg {if _dbdf !=0{_caca .Add_Tstar ();};_edbaf :=[]rune (_aege );_effd :=0.0;_cfccb :=0;for _faeac ,_cfag :=range _edbaf {if _cfag ==' '{_cfccb ++;
continue ;};if _cfag =='\u000A'{continue ;};_feeggb ,_debd :=_fddf ._ggeg .GetRuneMetrics (_cfag );if !_debd {_dg .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_faeac ,_cfag ,_cfag ,_fddf ._ggeg .BaseFont (),_fddf ._ggeg .Subtype ());
return _cegb ,_d .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_effd +=_fddf ._cfcd *_feeggb .Wx ;};var _ccdg []_ef .PdfObject ;_fgge ,_bgcf :=_fddf ._ggeg .GetRuneMetrics (' ');
if !_bgcf {return _cegb ,_d .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_ddbg :=_fgge .Wx ;switch _fddf ._cdba {case TextAlignmentJustify :if _cfccb > 0&&_dbdf < len (_fddf ._babg )-1{_ddbg =(_fddf ._cega *1000.0-_effd )/float64 (_cfccb )/_fddf ._cfcd ;
};case TextAlignmentCenter :_gcfg :=_effd +float64 (_cfccb )*_ddbg *_fddf ._cfcd ;_cceec :=(_fddf ._cega *1000.0-_gcfg )/2/_fddf ._cfcd ;_ccdg =append (_ccdg ,_ef .MakeFloat (-_cceec ));case TextAlignmentRight :_gffd :=_effd +float64 (_cfccb )*_ddbg *_fddf ._cfcd ;
_afefd :=(_fddf ._cega *1000.0-_gffd )/_fddf ._cfcd ;_ccdg =append (_ccdg ,_ef .MakeFloat (-_afefd ));};_gdbc :=_fddf ._ggeg .Encoder ();var _afbcg []byte ;for _ ,_bdcb :=range _edbaf {if _bdcb =='\u000A'{continue ;};if _bdcb ==' '{if len (_afbcg )> 0{_ccdg =append (_ccdg ,_ef .MakeStringFromBytes (_afbcg ));
_afbcg =nil ;};_ccdg =append (_ccdg ,_ef .MakeFloat (-_ddbg ));}else {if _ ,_debe :=_gdbc .RuneToCharcode (_bdcb );!_debe {_dg .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_bdcb ,_bdcb );
continue ;};_afbcg =append (_afbcg ,_gdbc .Encode (string (_bdcb ))...);};};if len (_afbcg )> 0{_ccdg =append (_ccdg ,_ef .MakeStringFromBytes (_afbcg ));};_caca .Add_TJ (_ccdg ...);};_caca .Add_ET ();_caca .Add_Q ();_adgbf :=_caca .Operations ();_adgbf .WrapIfNeeded ();
_agab .addContents (_adgbf );if _fddf ._cdfd .IsRelative (){_bgab :=_fddf .Height ()+_fddf ._agdb .Bottom ;_cegb .Y +=_bgab ;_cegb .Height -=_bgab ;if _cegb .Inline {_cegb .X +=_fddf .Width ()+_fddf ._agdb .Right ;};};return _cegb ,nil ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_aecbc *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _aecbc ._bbbf [0],_aecbc ._bbbf [1];};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SetLineHeight sets the line height (1.0 default).
func (_degf *Paragraph )SetLineHeight (lineheight float64 ){_degf ._gagf =lineheight };

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_eaf *Block )ScaleToWidth (w float64 ){_ddg :=w /_eaf ._eg ;_eaf .Scale (_ddg ,_ddg )};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};func (_cbc *Creator )setActivePage (_cdf *_dc .PdfPage ){_cbc ._cbec =_cdf };func (_acag *Invoice )generateLineBlocks (_bcde DrawContext )([]*Block ,DrawContext ,error ){_edba :=_eadg (len (_acag ._dfdf ));
_edba .SetMargins (0,0,25,0);for _ ,_egba :=range _acag ._dfdf {_cfcc :=_dcgf (_egba .TextStyle );_cfcc .SetMargins (0,0,1,0);_cfcc .Append (_egba .Value );_cccc :=_edba .NewCell ();_cccc .SetHorizontalAlignment (_egba .Alignment );_cccc .SetBackgroundColor (_egba .BackgroundColor );
_acag .setCellBorder (_cccc ,_egba );_cccc .SetContent (_cfcc );};for _ ,_efeaa :=range _acag ._ggdd {for _ ,_bdfc :=range _efeaa {_gead :=_dcgf (_bdfc .TextStyle );_gead .SetMargins (0,0,3,2);_gead .Append (_bdfc .Value );_dfef :=_edba .NewCell ();_dfef .SetHorizontalAlignment (_bdfc .Alignment );
_dfef .SetBackgroundColor (_bdfc .BackgroundColor );_acag .setCellBorder (_dfef ,_bdfc );_dfef .SetContent (_gead );};};return _edba .GeneratePageBlocks (_bcde );};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_gc *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcg :=_fb .NewContentCreator ();_bfe ,_cgd :=_gc .Width (),_gc .Height ();if _gc ._bc .IsRelative (){_dcg .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_cgd );}else {_dcg .Translate (_gc ._bcf ,ctx .PageHeight -_gc ._ba -_cgd );
};_ac :=_cgd ;if _gc ._gd !=0{_dcg .Translate (_bfe /2,_cgd /2);_dcg .RotateDeg (_gc ._gd );_dcg .Translate (-_bfe /2,-_cgd /2);_ ,_ac =_gc .RotatedSize ();};if _gc ._bc .IsRelative (){ctx .Y +=_ac ;};_ab :=_gc .duplicate ();_ega :=append (*_dcg .Operations (),*_ab ._g ...);
_ega .WrapIfNeeded ();_ab ._g =&_ega ;return []*Block {_ab },ctx ,nil ;};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// SetAnnotation sets a annotation on a TextChunk.
func (_ffgg *TextChunk )SetAnnotation (annotation *_dc .PdfAnnotation ){_ffgg ._cdfcd =annotation };

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_fcb *Invoice )Sections ()[][2]string {return _fcb ._eaac };

// SetEnableWrap sets the line wrapping enabled flag.
func (_abgb *Paragraph )SetEnableWrap (enableWrap bool ){_abgb ._gcfb =enableWrap ;_abgb ._dbbaf =false ;};func (_gdfe *TableCell )width (_ebdcc []float64 ,_gdgc float64 )float64 {_aafb :=float64 (0.0);for _dagcb :=0;_dagcb < _gdfe ._acgf ;_dagcb ++{_aafb +=_ebdcc [_gdfe ._agdfg +_dagcb -1];
};return _aafb *_gdgc ;};

// SetFont sets the Paragraph's font.
func (_aaag *Paragraph )SetFont (font *_dc .PdfFont ){_aaag ._ggeg =font };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_fced *Creator )NewTextStyle ()TextStyle {return _cafg (_fced ._gac )};func _cdgb (_eacfe ,_afcgf ,_cbda TextChunk ,_cdacb uint ,_cgeb TextStyle )*TOCLine {_afgfg :=_dcgf (_cgeb );_afgfg .SetEnableWrap (true );_afgfg .SetTextAlignment (TextAlignmentLeft );
_afgfg .SetMargins (0,0,2,2);_degdg :=&TOCLine {_gfgedf :_afgfg ,Number :_eacfe ,Title :_afcgf ,Page :_cbda ,Separator :TextChunk {Text :"\u002e",Style :_cgeb },_ccccf :0,_ccbfd :_cdacb ,_cfbad :10,_ecef :PositionRelative };_afgfg ._afbed .Left =_degdg ._ccccf +float64 (_degdg ._ccbfd -1)*_degdg ._cfbad ;
_afgfg ._gacb =_degdg .prepareParagraph ;return _degdg ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_cecge *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_cecge ._dccf =append (_cecge ._dccf ,line );return line ;};

// SetMargins sets the margins TOC line.
func (_cegbf *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_cegbf ._ccccf =left ;_edab :=&_cegbf ._gfgedf ._afbed ;_edab .Left =_cegbf ._ccccf +float64 (_cegbf ._ccbfd -1)*_cegbf ._cfbad ;_edab .Right =right ;_edab .Top =top ;_edab .Bottom =bottom ;
};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_gdgg *Invoice )SetAddressHeadingStyle (style TextStyle ){_gdgg ._dcbg =style };func _afcgc (_aagac string ,_fddcd ,_eagb TextStyle )*TOC {_gfbg :=_eagb ;_gfbg .FontSize =14;_dagff :=_dcgf (_gfbg );_dagff .SetEnableWrap (true );_dagff .SetTextAlignment (TextAlignmentLeft );
_dagff .SetMargins (0,0,0,5);_fgca :=_dagff .Append (_aagac );_fgca .Style =_gfbg ;return &TOC {_eaeb :_dagff ,_dccf :[]*TOCLine {},_bbed :_fddcd ,_ebdac :_fddcd ,_eaab :_fddcd ,_ggcd :_fddcd ,_gecde :"\u002e",_ecda :10,_daddd :Margins {0,0,2,2},_acbf :PositionRelative ,_aegc :_fddcd ,_ggfd :true };
};func _cee (_aeae []_be .Point )*Polyline {return &Polyline {_fgae :&_be .Polyline {Points :_aeae ,LineColor :_dc .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_fadf :1.0};};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// GeneratePageBlocks draws the curve onto page blocks.
func (_caec *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gfad :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bged :=_fb .NewContentCreator ();_bged .Add_q ().Add_w (_caec ._dcc ).SetStrokingColor (_eba (_caec ._dfd )).Add_m (_caec ._agg ,ctx .PageHeight -_caec ._ccee ).Add_v (_caec ._efea ,ctx .PageHeight -_caec ._dfg ,_caec ._edg ,ctx .PageHeight -_caec ._fabf ).Add_S ().Add_Q ();
_dace :=_gfad .addContentsByString (_bged .String ());if _dace !=nil {return nil ,ctx ,_dace ;};return []*Block {_gfad },ctx ,nil ;};func _cecg (_gagc *_dc .Image )(*Image ,error ){_fbd :=float64 (_gagc .Width );_bebe :=float64 (_gagc .Height );return &Image {_gaac :_gagc ,_cbac :_fbd ,_bffg :_bebe ,_ebe :_fbd ,_fedd :_bebe ,_gdce :0,_abcd :1.0,_beeb :PositionRelative },nil ;
};

// SetHeight sets the Image's document height to specified h.
func (_geab *Image )SetHeight (h float64 ){_geab ._fedd =h };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_abbd *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bdg :=ctx ;var _dega []*Block ;_faca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _abbd ._cdfd .IsRelative (){ctx .X +=_abbd ._agdb .Left ;ctx .Y +=_abbd ._agdb .Top ;
ctx .Width -=_abbd ._agdb .Left +_abbd ._agdb .Right ;ctx .Height -=_abbd ._agdb .Top +_abbd ._agdb .Bottom ;_abbd .SetWidth (ctx .Width );if _abbd .Height ()> ctx .Height {_dega =append (_dega ,_faca );_faca =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_affb :=ctx ;_affb .Y =ctx .Margins .Top ;_affb .X =ctx .Margins .Left +_abbd ._agdb .Left ;_affb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_abbd ._agdb .Bottom ;_affb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_abbd ._agdb .Left -_abbd ._agdb .Right ;
ctx =_affb ;};}else {if int (_abbd ._cega )<=0{_abbd .SetWidth (_abbd .getTextWidth ());};ctx .X =_abbd ._cbdb ;ctx .Y =_abbd ._ecdcb ;};ctx ,_gdaag :=_aefb (_faca ,_abbd ,ctx );if _gdaag !=nil {_dg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gdaag );
return nil ,ctx ,_gdaag ;};_dega =append (_dega ,_faca );if _abbd ._cdfd .IsRelative (){ctx .X -=_abbd ._agdb .Left ;ctx .Width =_bdg .Width ;return _dega ,ctx ,nil ;};return _dega ,_bdg ,nil ;};

// NewImageFromFile creates an Image from a file.
func (_cdd *Creator )NewImageFromFile (path string )(*Image ,error ){return _fcdc (path )};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_ga *Block )SetMargins (left ,right ,top ,bottom float64 ){_ga ._ed .Left =left ;_ga ._ed .Right =right ;_ga ._ed .Top =top ;_ga ._ed .Bottom =bottom ;};func (_aebeg *Paragraph )getMaxLineWidth ()float64 {if _aebeg ._babg ==nil ||len (_aebeg ._babg )==0{_aebeg .wrapText ();
};var _efba float64 ;for _ ,_bfaf :=range _aebeg ._babg {_ecff :=_aebeg .getTextLineWidth (_bfaf );if _ecff > _efba {_efba =_ecff ;};};return _efba ;};

// NewTOC creates a new table of contents.
func (_bdag *Creator )NewTOC (title string )*TOC {_gcfa :=_bdag .NewTextStyle ();_gcfa .Font =_bdag ._gfe ;return _afcgc (title ,_bdag .NewTextStyle (),_gcfa );};

// SetDueDate sets the due date of the invoice.
func (_cebc *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_cebc ._gcfc [1].Value =dueDate ;return _cebc ._gcfc [0],_cebc ._gcfc [1];};

// SetBorderColor sets border color.
func (_ebcf *Rectangle )SetBorderColor (col Color ){_ebcf ._ffgeb =col };

// SetBorderColor sets the border color.
func (_gbe *Polygon )SetBorderColor (color Color ){_gbe ._aaac .BorderColor =_eba (color )};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_acgc :_da .Max (_da .Min (r ,1.0),0.0),_cfe :_da .Max (_da .Min (g ,1.0),0.0),_bgbb :_da .Max (_da .Min (b ,1.0),0.0)};};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_ffad *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _afbg (xc ,yc ,width ,height );};func (_bbcga *Paragraph )getTextWidth ()float64 {_adef :=0.0;for _ ,_cgc :=range _bbcga ._aaaef {if _cgc =='\u000A'{continue ;};_cffd ,_daaf :=_bbcga ._ggeg .GetRuneMetrics (_cgc );
if !_daaf {_dg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_cgc ,_cgc );
return -1;};_adef +=_bbcga ._cfcd *_cffd .Wx ;};return _adef ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_gcbf *TableCell )SetContent (vd VectorDrawable )error {switch _cefdf :=vd .(type ){case *Paragraph :if _cefdf ._dbbaf {_cefdf ._gcfb =true ;};_gcbf ._fagfbd =vd ;case *StyledParagraph :if _cefdf ._dagcf {_cefdf ._cead =true ;};_gcbf ._fagfbd =vd ;
case *Image :_gcbf ._fagfbd =vd ;case *Table :_gcbf ._fagfbd =vd ;case *List :_gcbf ._fagfbd =vd ;case *Division :_gcbf ._fagfbd =vd ;default:_dg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _ef .ErrTypeError ;};return nil ;};

// MoveY moves the drawing context to absolute position y.
func (_dcga *Creator )MoveY (y float64 ){_dcga ._efab .Y =y };

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_eeab *Invoice )AddressHeadingStyle ()TextStyle {return _eeab ._bccc };

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _ebbd ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_eccc :=&Creator {};_eccc ._dec =[]*_dc .PdfPage {};_eccc ._adce =map[*_dc .PdfPage ]*Block {};_eccc .SetPageSize (PageSizeLetter );_eaff :=0.1*_eccc ._aaaf ;
_eccc ._gggg .Left =_eaff ;_eccc ._gggg .Right =_eaff ;_eccc ._gggg .Top =_eaff ;_eccc ._gggg .Bottom =_eaff ;var _adeb error ;_eccc ._gac ,_adeb =_dc .NewStandard14Font (_dc .HelveticaName );if _adeb !=nil {_eccc ._gac =_dc .DefaultFont ();};_eccc ._gfe ,_adeb =_dc .NewStandard14Font (_dc .HelveticaBoldName );
if _adeb !=nil {_eccc ._gac =_dc .DefaultFont ();};_eccc ._dadc =_eccc .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_eccc .AddOutlines =true ;_eccc ._fage =_dc .NewOutline ();_dag .TrackUse (_ebbd );
return _eccc ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_fec *Chapter )GetHeading ()*Paragraph {return _fec ._dbaf };func (_bfb *Image )makeXObject ()error {_dfe :=_bfb ._gdeb ;if _dfe ==nil {_dfe =_ef .NewFlateEncoder ();};_gfaed ,_gafb :=_dc .NewXObjectImageFromImage (_bfb ._gaac ,nil ,_dfe );if _gafb !=nil {_dg .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gafb );
return _gafb ;};_bfb ._ecde =_gfaed ;return nil ;};

// SetNumber sets the number of the invoice.
func (_fdg *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_fdg ._bbee [1].Value =number ;return _fdg ._bbee [0],_fdg ._bbee [1];};

// SetBorderOpacity sets the border opacity.
func (_ecge *Rectangle )SetBorderOpacity (opacity float64 ){_ecge ._gagg =opacity };

// Level returns the indentation level of the TOC line.
func (_cbdba *TOCLine )Level ()uint {return _cbdba ._ccbfd };

// LevelOffset returns the amount of space an indentation level occupies.
func (_cade *TOCLine )LevelOffset ()float64 {return _cade ._cfbad };

// SetWidth sets line width.
func (_geca *Curve )SetWidth (width float64 ){_geca ._dcc =width };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_bbga *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_bbga ._fdf =textOverflow };

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_gfbc *Division )Width ()float64 {return 0};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_dcbe *Invoice )InfoLines ()[][2]*InvoiceCell {_gfgc :=[][2]*InvoiceCell {_dcbe ._bbee ,_dcbe ._adgb ,_dcbe ._gcfc };return append (_gfgc ,_dcbe ._gge ...);};type cmykColor struct{_egfg ,_dcd ,_fdc ,_dgfc float64 };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_egfa int ;_cefc string ;_dbaf *Paragraph ;_gcea []Drawable ;_dgfb int ;_cdac bool ;_afgd bool ;_cae Positioning ;_daab ,_dcaf float64 ;_beed Margins ;_fbfb *Chapter ;_deg *TOC ;_cegf *_dc .Outline ;_efad *_dc .OutlineItem ;_cefg uint ;
};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// NewCellProps returns the default properties of an invoice cell.
func (_aca *Invoice )NewCellProps ()InvoiceCellProps {_gcga :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_aca ._deab ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_gcga ,BorderColor :_gcga ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_bbfc *TOC )SetLineTitleStyle (style TextStyle ){_bbfc ._ebdac =style };

// SetWidthLeft sets border width for left.
func (_dee *border )SetWidthLeft (bw float64 ){_dee ._fed =bw };

// SetFillColor sets the fill color.
func (_agbc *PolyBezierCurve )SetFillColor (color Color ){_agbc ._ccef .FillColor =_eba (color )};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_bdbd *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_afga :=_bdbd ;if _bdbd ._dgdd {_afga =_bdbd .clone ();};return _fddc (_afga ,ctx );};func (_acfga *StyledParagraph )getTextLineWidth (_cccb []*TextChunk )float64 {var _acdea float64 ;
_gecc :=len (_cccb );for _afbd ,_gffaf :=range _cccb {_eeafb :=&_gffaf .Style ;_bggf :=len (_gffaf .Text );for _cfab ,_gbgc :=range _gffaf .Text {if _gbgc =='\u000A'{continue ;};_cffed ,_fbce :=_eeafb .Font .GetRuneMetrics (_gbgc );if !_fbce {_dg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_gbgc );
return -1;};_acdea +=_eeafb .FontSize *_cffed .Wx *_eeafb .horizontalScale ();if _gbgc !=' '&&(_afbd !=_gecc -1||_cfab !=_bggf -1){_acdea +=_eeafb .CharSpacing *1000.0;};};};return _acdea ;};func (_gg *Block )translate (_bgb ,_gdg float64 ){_bfa :=_fb .NewContentCreator ().Translate (_bgb ,-_gdg ).Operations ();
*_gg ._g =append (*_bfa ,*_gg ._g ...);_gg ._g .WrapIfNeeded ();};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_bgbfa *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_bgbfa ._aegef =valign };

// GetOptimizer returns current PDF optimizer.
func (_gfdd *Creator )GetOptimizer ()_dc .Optimizer {return _gfdd ._becg };func (_eadd *TextChunk )clone ()*TextChunk {_addf :=*_eadd ;_addf ._cdfcd =_ccbc (_eadd ._cdfcd );return &_addf ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_ecfc *Table )NewCell ()*TableCell {return _ecfc .newCell (1)};

// SkipCells skips over a specified number of cells in the table.
func (_ebeb *Table )SkipCells (num int ){if num < 0{_dg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_ebeb ._gecf +=num ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// SetFillColor sets the fill color for the path.
func (_dgab *FilledCurve )SetFillColor (color Color ){_dgab ._afbc =color };

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_bebc *TOC )SetHeading (text string ,style TextStyle ){_feff :=_bebc .Heading ();_feff .Reset ();_gbbd :=_feff .Append (text );_gbbd .Style =style ;};func (_ggce *Table )wrapRow (_bdfa int ,_bece DrawContext ,_dgceg float64 )(bool ,error ){if !_ggce ._dgdd {return false ,nil ;
};var (_ddbge =_ggce ._fdbg [_bdfa ];_dcfg =-1;_bbbb []*TableCell ;_afead float64 ;_bgbaf bool ;_fbfca =make ([]float64 ,0,len (_ggce ._bbecd )););_efdge :=func (_ffcf *TableCell ,_dadcc VectorDrawable ,_bffb bool )*TableCell {_agcd :=*_ffcf ;_agcd ._fagfbd =_dadcc ;
if _bffb {_agcd ._debc ++;};return &_agcd ;};_ebae :=func (_defc int ,_cgdc VectorDrawable ){var _gefe float64 =-1;if _cgdc ==nil {if _ceagf :=_fbfca [_defc -_bdfa ];_ceagf > _bece .Height {_cgdc =_ggce ._fdbg [_defc ]._fagfbd ;_ggce ._fdbg [_defc ]._fagfbd =nil ;
_fbfca [_defc -_bdfa ]=0;_gefe =_ceagf ;};};_bafc :=_efdge (_ggce ._fdbg [_defc ],_cgdc ,true );_bbbb =append (_bbbb ,_bafc );if _gefe < 0{_gefe =_bafc .height (_bece .Width );};if _gefe > _afead {_afead =_gefe ;};};for _bfbfg :=_bdfa ;_bfbfg < len (_ggce ._fdbg );
_bfbfg ++{_efaca :=_ggce ._fdbg [_bfbfg ];if _ddbge ._debc !=_efaca ._debc {_dcfg =_bfbfg ;break ;};_bece .Width =_efaca .width (_ggce ._bbecd ,_dgceg );var _cccg VectorDrawable ;switch _deef :=_efaca ._fagfbd .(type ){case *StyledParagraph :if _eggec :=_efaca .height (_bece .Width );
_eggec > _bece .Height {_geccf :=_bece ;_geccf .Height =_da .Floor (_bece .Height -_deef ._afbed .Top -_deef ._afbed .Bottom -0.5*_deef .getTextHeight ());_bede ,_eedb ,_fgfe :=_deef .split (_geccf );if _fgfe !=nil {return false ,_fgfe ;};if _bede !=nil &&_eedb !=nil {_deef =_bede ;
_efaca =_efdge (_efaca ,_bede ,false );_ggce ._fdbg [_bfbfg ]=_efaca ;_cccg =_eedb ;_bgbaf =true ;};};};_fbfca =append (_fbfca ,_efaca .height (_bece .Width ));if _bgbaf {if _bbbb ==nil {_bbbb =make ([]*TableCell ,0,len (_ggce ._bbecd ));for _cddd :=_bdfa ;
_cddd < _bfbfg ;_cddd ++{_ebae (_cddd ,nil );};};_ebae (_bfbfg ,_cccg );};};var _bfee float64 ;for _ ,_gee :=range _fbfca {if _gee > _bfee {_bfee =_gee ;};};if _bgbaf &&_bfee < _bece .Height {if _dcfg < 0{_dcfg =len (_ggce ._fdbg );};_cgcb :=_ggce ._fdbg [_dcfg -1]._debc +_ggce ._fdbg [_dcfg -1]._feef -1;
for _fbde :=_dcfg ;_fbde < len (_ggce ._fdbg );_fbde ++{_ggce ._fdbg [_fbde ]._debc ++;};_ggce ._fdbg =append (_ggce ._fdbg [:_dcfg ],append (_bbbb ,_ggce ._fdbg [_dcfg :]...)...);_ggce ._degd =append (_ggce ._degd [:_cgcb ],append ([]float64 {_afead },_ggce ._degd [_cgcb :]...)...);
_ggce ._degd [_ddbge ._debc +_ddbge ._feef -2]=_bfee ;};return _bgbaf ,nil ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_bdc *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _dcadc (number ,title ,page ,level ,_bdc .NewTextStyle ());};

// SetShowLinks sets visibility of links for the TOC lines.
func (_dbcc *TOC )SetShowLinks (showLinks bool ){_dbcc ._ggfd =showLinks };

// TitleStyle returns the style properties used to render the invoice title.
func (_dedf *Invoice )TitleStyle ()TextStyle {return _dedf ._ggac };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_ddfg *Image )SetEncoder (encoder _ef .StreamEncoder ){_ddfg ._gdeb =encoder };var PPMM =float64 (72*1.0/25.4);func _adegb (_cfbdba ,_cfccc ,_fdeg float64 )(_gdeac ,_abab ,_eeafee ,_dgga float64 ){if _fdeg ==0{return 0,0,_cfbdba ,_cfccc ;};_fbdc :=_be .Path {Points :[]_be .Point {_be .NewPoint (0,0).Rotate (_fdeg ),_be .NewPoint (_cfbdba ,0).Rotate (_fdeg ),_be .NewPoint (0,_cfccc ).Rotate (_fdeg ),_be .NewPoint (_cfbdba ,_cfccc ).Rotate (_fdeg )}}.GetBoundingBox ();
return _fbdc .X ,_fbdc .Y ,_fbdc .Width ,_fbdc .Height ;};func (_eegdf *Invoice )generateInformationBlocks (_ceffb DrawContext )([]*Block ,DrawContext ,error ){_egdd :=_dcgf (_eegdf ._deab );_egdd .SetMargins (0,0,0,20);_afa :=_eegdf .drawAddress (_eegdf ._aecb );
_afa =append (_afa ,_egdd );_afa =append (_afa ,_eegdf .drawAddress (_eegdf ._gcaa )...);_dbgb :=_gadc ();for _ ,_gdcbe :=range _afa {_dbgb .Add (_gdcbe );};_ecacg :=_eegdf .drawInformation ();_egge :=_eadg (2);_egge .SetMargins (0,0,25,0);_gbcb :=_egge .NewCell ();
_gbcb .SetIndent (0);_gbcb .SetContent (_dbgb );_gbcb =_egge .NewCell ();_gbcb .SetContent (_ecacg );return _egge .GeneratePageBlocks (_ceffb );};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_ffcd *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_ffcd ._bbff =alignment };

// NewPageBreak create a new page break.
func (_gebg *Creator )NewPageBreak ()*PageBreak {return _cdceb ()};

// GetMargins returns the left, right, top, bottom Margins.
func (_afcg *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _afcg ._eeed .Left ,_afcg ._eeed .Right ,_afcg ._eeed .Top ,_afcg ._eeed .Bottom ;};

// NewColumn returns a new column for the line items invoice table.
func (_afcbc *Invoice )NewColumn (description string )*InvoiceCell {return _afcbc .newColumn (description ,CellHorizontalAlignmentLeft );};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_ebfa *TOCLine )SetStyle (style TextStyle ){_ebfa .Number .Style =style ;_ebfa .Title .Style =style ;_ebfa .Separator .Style =style ;_ebfa .Page .Style =style ;};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_bag *Division )Height ()float64 {var _fcaf float64 ;for _ ,_acbb :=range _bag ._dbg {switch _eegc :=_acbb .(type ){case *Paragraph :_fcaf +=_eegc .Height ()+_eegc ._agdb .Top +_eegc ._agdb .Bottom ;case *StyledParagraph :_fcaf +=_eegc .Height ()+_eegc ._afbed .Top +_eegc ._afbed .Bottom ;
default:_fcaf +=_eegc .Height ();};};return _fcaf ;};

// SetColor sets the line color.
func (_dacd *Curve )SetColor (col Color ){_dacd ._dfd =col };

// Scale block by specified factors in the x and y directions.
func (_eda *Block )Scale (sx ,sy float64 ){_feg :=_fb .NewContentCreator ().Scale (sx ,sy ).Operations ();*_eda ._g =append (*_feg ,*_eda ._g ...);_eda ._g .WrapIfNeeded ();_eda ._eg *=sx ;_eda ._ee *=sy ;};

// Text sets the text content of the Paragraph.
func (_ecfd *Paragraph )Text ()string {return _ecfd ._aaaef };func (_dgcgf *Invoice )drawSection (_ebaf ,_dcac string )[]*StyledParagraph {var _gddff []*StyledParagraph ;if _ebaf !=""{_eaca :=_dcgf (_dgcgf ._eeae );_eaca .SetMargins (0,0,0,5);_eaca .Append (_ebaf );
_gddff =append (_gddff ,_eaca );};if _dcac !=""{_acfc :=_dcgf (_dgcgf ._cbab );_acfc .Append (_dcac );_gddff =append (_gddff ,_acfc );};return _gddff ;};

// SetAngle sets the rotation angle of the text.
func (_gcgg *Paragraph )SetAngle (angle float64 ){_gcgg ._gcaf =angle };

// SetRowHeight sets the height for a specified row.
func (_edag *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_edag ._degd ){return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_edag ._degd [row -1]=h ;return nil ;
};func _gebc (_gacf ,_badf ,_gdaa ,_eafd float64 )*Line {_cfgf :=&Line {};_cfgf ._gda =_gacf ;_cfgf ._afea =_badf ;_cfgf ._fbbd =_gdaa ;_cfgf ._faae =_eafd ;_cfgf ._eeafe =ColorBlack ;_cfgf ._ged =1.0;return _cfgf ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_aaeb *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _aaeb ._ecde ==nil {if _gggea :=_aaeb .makeXObject ();_gggea !=nil {return nil ,ctx ,_gggea ;};};var _cag []*Block ;_cgdd :=ctx ;_fbebbc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _aaeb ._beeb .IsRelative (){ctx .X +=_aaeb ._ceca .Left ;ctx .Y +=_aaeb ._ceca .Top ;ctx .Width -=_aaeb ._ceca .Left +_aaeb ._ceca .Right ;ctx .Height -=_aaeb ._ceca .Top +_aaeb ._ceca .Bottom ;if _aaeb ._fedd > ctx .Height {_cag =append (_cag ,_fbebbc );
_fbebbc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gcae :=ctx ;_gcae .Y =ctx .Margins .Top +_aaeb ._ceca .Top ;_gcae .X =ctx .Margins .Left +_aaeb ._ceca .Left ;_gcae .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_aaeb ._ceca .Top -_aaeb ._ceca .Bottom ;
_gcae .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_aaeb ._ceca .Left -_aaeb ._ceca .Right ;ctx =_gcae ;_cgdd .X =ctx .Margins .Left ;_cgdd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;};}else {ctx .X =_aaeb ._adba ;
ctx .Y =_aaeb ._agfb ;};ctx ,_cgfe :=_ageb (_fbebbc ,_aaeb ,ctx );if _cgfe !=nil {return nil ,ctx ,_cgfe ;};_cag =append (_cag ,_fbebbc );if _aaeb ._beeb .IsAbsolute (){ctx =_cgdd ;}else {ctx .X =_cgdd .X ;ctx .Y +=_aaeb ._ceca .Bottom ;ctx .Width =_cgdd .Width ;
};return _cag ,ctx ,nil ;};

// Length calculates and returns the line length.
func (_ecdb *Line )Length ()float64 {return _da .Sqrt (_da .Pow (_ecdb ._fbbd -_ecdb ._gda ,2.0)+_da .Pow (_ecdb ._faae -_ecdb ._afea ,2.0));};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_beac *Ellipse )GetCoords ()(float64 ,float64 ){return _beac ._ggdbc ,_beac ._gbfb };func _eba (_bded Color )_dc .PdfColor {if _bded ==nil {_bded =ColorBlack ;};switch _afee :=_bded .(type ){case cmykColor :return _dc .NewPdfColorDeviceCMYK (_afee ._egfg ,_afee ._dcd ,_afee ._fdc ,_afee ._dgfc );
};return _dc .NewPdfColorDeviceRGB (_bded .ToRGB ());};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_gage *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dbbfe :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dfa ,_fedcf :=_dbbfe .setOpacity (_gage ._fadf ,_gage ._fadf );if _fedcf !=nil {return nil ,ctx ,_fedcf ;};
_dgfag :=_gage ._fgae .Points ;for _dfgd :=range _dgfag {_cbdc :=&_dgfag [_dfgd ];_cbdc .Y =ctx .PageHeight -_cbdc .Y ;};_abag ,_ ,_fedcf :=_gage ._fgae .Draw (_dfa );if _fedcf !=nil {return nil ,ctx ,_fedcf ;};if _fedcf =_dbbfe .addContentsByString (string (_abag ));
_fedcf !=nil {return nil ,ctx ,_fedcf ;};return []*Block {_dbbfe },ctx ,nil ;};

// Height returns the Block's height.
func (_egac *Block )Height ()float64 {return _egac ._ee };

// NewTable create a new Table with a specified number of columns.
func (_fcac *Creator )NewTable (cols int )*Table {return _eadg (cols )};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_bgfg *Creator )MoveRight (dx float64 ){_bgfg ._efab .X +=dx };

// SetFillOpacity sets the fill opacity.
func (_cefa *CurvePolygon )SetFillOpacity (opacity float64 ){_cefa ._bbae =opacity };

// Angle returns the block rotation angle in degrees.
func (_ea *Block )Angle ()float64 {return _ea ._gd };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_fcafc *Invoice )NoteStyle ()TextStyle {return _fcafc ._cbab };

// SetMargins sets the Paragraph's margins.
func (_bcea *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_bcea ._agdb .Left =left ;_bcea ._agdb .Right =right ;_bcea ._agdb .Top =top ;_bcea ._agdb .Bottom =bottom ;};

// SetBorderColor sets the border color.
func (_ggdb *CurvePolygon )SetBorderColor (color Color ){_ggdb ._dgbg .BorderColor =_eba (color )};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_cbfc int ;_gaaa int ;_gecf int ;_bbecd []float64 ;_degd []float64 ;_bfeg float64 ;_fdbg []*TableCell ;_debec Positioning ;_cgaa ,_gadae float64 ;_eeed Margins ;_deaf bool ;_febb int ;_dgaa int ;_dgdd bool ;};

// WriteToFile writes the Creator output to file specified by path.
func (_edee *Creator )WriteToFile (outputPath string )error {_fdaf ,_egda :=_b .Create (outputPath );if _egda !=nil {return _egda ;};defer _fdaf .Close ();return _edee .Write (_fdaf );};

// InsertColumn inserts a column in the line items table at the specified index.
func (_ceff *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_gef :=uint (len (_ceff ._dfdf ));if index > _gef {index =_gef ;};_abba :=_ceff .NewColumn (description );_ceff ._dfdf =append (_ceff ._dfdf [:index ],append ([]*InvoiceCell {_abba },_ceff ._dfdf [index :]...)...);
return _abba ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_dc .PdfPage )(*Block ,error ){_ddf :=&Block {};_ceg ,_eeg :=page .GetAllContentStreams ();if _eeg !=nil {return nil ,_eeg ;};_eb :=_fb .NewContentStreamParser (_ceg );_fa ,_eeg :=_eb .Parse ();if _eeg !=nil {return nil ,_eeg ;
};_fa .WrapIfNeeded ();_ddf ._g =_fa ;if page .Resources !=nil {_ddf ._a =page .Resources ;}else {_ddf ._a =_dc .NewPdfPageResources ();};_ec ,_eeg :=page .GetMediaBox ();if _eeg !=nil {return nil ,_eeg ;};if _ec .Llx !=0||_ec .Lly !=0{_ddf .translate (-_ec .Llx ,_ec .Lly );
};_ddf ._eg =_ec .Urx -_ec .Llx ;_ddf ._ee =_ec .Ury -_ec .Lly ;if page .Rotate !=nil {_ddf ._gd =-float64 (*page .Rotate );};return _ddf ,nil ;};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_aaca *Invoice )TotalLines ()[][2]*InvoiceCell {_aee :=[][2]*InvoiceCell {_aaca ._bbbf };_aee =append (_aee ,_aaca ._gfcb ...);return append (_aee ,_aaca ._fgab );};

// SetBorderColor sets the border color.
func (_gdbd *Ellipse )SetBorderColor (col Color ){_gdbd ._abae =col };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_eaeb *StyledParagraph ;_dccf []*TOCLine ;_bbed TextStyle ;_ebdac TextStyle ;_eaab TextStyle ;_ggcd TextStyle ;_gecde string ;_ecda float64 ;_daddd Margins ;_acbf Positioning ;_aegc TextStyle ;_ggfd bool ;};

// Height returns Image's document height.
func (_adee *Image )Height ()float64 {return _adee ._fedd };

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_fcge *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adcc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cfba :=_be .Circle {X :_fcge ._ggdbc -_fcge ._gfeb /2,Y :ctx .PageHeight -_fcge ._gbfb -_fcge ._acfe /2,Width :_fcge ._gfeb ,Height :_fcge ._acfe ,Opacity :1.0,BorderWidth :_fcge ._gfbcd };
if _fcge ._fgcd !=nil {_cfba .FillEnabled =true ;_cfba .FillColor =_eba (_fcge ._fgcd );};if _fcge ._abae !=nil {_cfba .BorderEnabled =true ;_cfba .BorderColor =_eba (_fcge ._abae );_cfba .BorderWidth =_fcge ._gfbcd ;};_dgega ,_ ,_facf :=_cfba .Draw ("");
if _facf !=nil {return nil ,ctx ,_facf ;};_facf =_adcc .addContentsByString (string (_dgega ));if _facf !=nil {return nil ,ctx ,_facf ;};return []*Block {_adcc },ctx ,nil ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gbba *Paragraph )SetTextAlignment (align TextAlignment ){_gbba ._cdba =align };func (_bceg *Image )rotatedSize ()(float64 ,float64 ){_bffe :=_bceg ._ebe ;_gacg :=_bceg ._fedd ;_cdacd :=_bceg ._gdce ;if _cdacd ==0{return _bffe ,_gacg ;};_ffdba :=_be .Path {Points :[]_be .Point {_be .NewPoint (0,0).Rotate (_cdacd ),_be .NewPoint (_bffe ,0).Rotate (_cdacd ),_be .NewPoint (0,_gacg ).Rotate (_cdacd ),_be .NewPoint (_bffe ,_gacg ).Rotate (_cdacd )}}.GetBoundingBox ();
return _ffdba .Width ,_ffdba .Height ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ddgb *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aaaa :=ctx ;_eada ,ctx ,_gcbg :=_ddgb ._eaeb .GeneratePageBlocks (ctx );if _gcbg !=nil {return _eada ,ctx ,_gcbg ;};for _ ,_bebf :=range _ddgb ._dccf {_geac :=_bebf ._bdgb ;
if !_ddgb ._ggfd {_bebf ._bdgb =0;};_cbfg ,_gbcg ,_egag :=_bebf .GeneratePageBlocks (ctx );_bebf ._bdgb =_geac ;if _egag !=nil {return _eada ,ctx ,_egag ;};if len (_cbfg )< 1{continue ;};_eada [len (_eada )-1].mergeBlocks (_cbfg [0]);_eada =append (_eada ,_cbfg [1:]...);
ctx =_gbcg ;};if _ddgb ._acbf .IsRelative (){ctx .X =_aaaa .X ;};if _ddgb ._acbf .IsAbsolute (){return _eada ,_aaaa ,nil ;};return _eada ,ctx ,nil ;};func _bacf (_dbfgd ,_gceb ,_gbf ,_edd ,_aafa ,_bfde float64 )*Curve {_gcef :=&Curve {};_gcef ._agg =_dbfgd ;
_gcef ._ccee =_gceb ;_gcef ._efea =_gbf ;_gcef ._dfg =_edd ;_gcef ._edg =_aafa ;_gcef ._fabf =_bfde ;_gcef ._dfd =ColorBlack ;_gcef ._dcc =1.0;return _gcef ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_adf *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_adf ._dadc =toc ;};

// Logo returns the logo of the invoice.
func (_bgcd *Invoice )Logo ()*Image {return _bgcd ._acba };

// Scale scales Image by a constant factor, both width and height.
func (_cgdg *Image )Scale (xFactor ,yFactor float64 ){_cgdg ._ebe =xFactor *_cgdg ._ebe ;_cgdg ._fedd =yFactor *_cgdg ._fedd ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cdcbf *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _cdcbf ._bbee [0],_cdcbf ._bbee [1]};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_fdae *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_afef :=ctx ;if _fdae ._cae .IsRelative (){ctx .X +=_fdae ._beed .Left ;ctx .Y +=_fdae ._beed .Top ;ctx .Width -=_fdae ._beed .Left +_fdae ._beed .Right ;ctx .Height -=_fdae ._beed .Top ;
};_eceg ,_egd ,_feca :=_fdae ._dbaf .GeneratePageBlocks (ctx );if _feca !=nil {return _eceg ,ctx ,_feca ;};ctx =_egd ;_cfbb :=ctx .X ;_fccg :=ctx .Y -_fdae ._dbaf .Height ();_aae :=int64 (ctx .Page );_dada :=_fdae .headingNumber ();_gdgfb :=_fdae .headingText ();
if _fdae ._afgd {_cbe :=_fdae ._deg .Add (_dada ,_fdae ._cefc ,_ddd .FormatInt (_aae ,10),_fdae ._cefg );if _fdae ._deg ._ggfd {_cbe .SetLink (_aae ,_cfbb ,_fccg );};};if _fdae ._efad ==nil {_fdae ._efad =_dc .NewOutlineItem (_gdgfb ,_dc .NewOutlineDest (_aae -1,_cfbb ,_fccg ));
if _fdae ._fbfb !=nil {_fdae ._fbfb ._efad .Add (_fdae ._efad );}else {_fdae ._cegf .Add (_fdae ._efad );};}else {_gdcb :=&_fdae ._efad .Dest ;_gdcb .Page =_aae -1;_gdcb .X =_cfbb ;_gdcb .Y =_fccg ;};for _ ,_gecd :=range _fdae ._gcea {_edbd ,_ebcc ,_dea :=_gecd .GeneratePageBlocks (ctx );
if _dea !=nil {return _eceg ,ctx ,_dea ;};if len (_edbd )< 1{continue ;};_eceg [len (_eceg )-1].mergeBlocks (_edbd [0]);_eceg =append (_eceg ,_edbd [1:]...);ctx =_ebcc ;};if _fdae ._cae .IsRelative (){ctx .X =_afef .X ;};if _fdae ._cae .IsAbsolute (){return _eceg ,_afef ,nil ;
};return _eceg ,ctx ,nil ;};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
func (_ccga *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_ccga ._adfcb =align ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetEnableWrap sets the line wrapping enabled flag.
func (_bdfge *StyledParagraph )SetEnableWrap (enableWrap bool ){_bdfge ._cead =enableWrap ;_bdfge ._dagcf =false ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_gfged []*TextChunk ;_beeea TextStyle ;_aega TextStyle ;_ddde TextAlignment ;_adfcb TextVerticalAlignment ;_bgfc float64 ;_cead bool ;_aegf float64 ;_dagcf bool ;_fdf TextOverflow ;_febg float64 ;_afbed Margins ;_cfde Positioning ;
_ddbcd float64 ;_dfeb float64 ;_cafc float64 ;_gfgec float64 ;_cfbc [][]*TextChunk ;_gacb func (_gcfbc *StyledParagraph ,_ccda DrawContext );};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_dgca *Creator )PageFinalize (pageFinalizeFunc func (_fbc PageFinalizeFunctionArgs )error ){_dgca ._gff =pageFinalizeFunc ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_gddf *Image )SetMargins (left ,right ,top ,bottom float64 ){_gddf ._ceca .Left =left ;_gddf ._ceca .Right =right ;_gddf ._ceca .Top =top ;_gddf ._ceca .Bottom =bottom ;};

// SetLineWidth sets the line width.
func (_ddcda *Line )SetLineWidth (lw float64 ){_ddcda ._ged =lw };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_aecbe *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aecbe ._afbed .Left ,_aecbe ._afbed .Right ,_aecbe ._afbed .Top ,_aecbe ._afbed .Bottom ;};func _aaff (_cecdb ,_dgce ,_aaaff ,_afac float64 )*Rectangle {return &Rectangle {_gacff :_cecdb ,_eeag :_dgce ,_ddefa :_aaaff ,_abeda :_afac ,_ffgeb :ColorBlack ,_afggg :1.0,_gfgb :1.0,_gagg :1.0};
};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_agdf *Invoice )SetNoteHeadingStyle (style TextStyle ){_agdf ._eeae =style };

// SetSideBorderColor sets the cell's side border color.
func (_bcee *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideTop :_bcee ._gecdb =col ;case CellBorderSideBottom :_bcee ._cegcg =col ;case CellBorderSideLeft :_bcee ._bbeg =col ;case CellBorderSideRight :_bcee ._acfd =col ;
};};func (_fcgab *TableCell )height (_ddab float64 )float64 {var _ccbf float64 ;switch _edbg :=_fcgab ._fagfbd .(type ){case *Paragraph :if _edbg ._gcfb {_edbg .SetWidth (_ddab -_fcgab ._aefgf -_edbg ._agdb .Left -_edbg ._agdb .Right );};_ccbf =_edbg .Height ()+_edbg ._agdb .Top +_edbg ._agdb .Bottom +0.5*_edbg ._cfcd *_edbg ._gagf ;
case *StyledParagraph :if _edbg ._cead {_edbg .SetWidth (_ddab -_fcgab ._aefgf -_edbg ._afbed .Left -_edbg ._afbed .Right );};_ccbf =_edbg .Height ()+_edbg ._afbed .Top +_edbg ._afbed .Bottom +0.5*_edbg .getTextHeight ();case *Image :_ccbf =_edbg .Height ()+_edbg ._ceca .Top +_edbg ._ceca .Bottom ;
case *Table :_ccbf =_edbg .Height ()+_edbg ._eeed .Top +_edbg ._eeed .Bottom ;case *List :_ccbf =_edbg .tableHeight (_ddab -_fcgab ._aefgf )+_edbg ._fede .Top +_edbg ._fede .Bottom ;case *Division :_ccbf =_edbg .ctxHeight (_ddab -_fcgab ._aefgf )+_edbg ._bafe .Top +_edbg ._bafe .Bottom ;
};return _ccbf ;};

// TextAlignment options for paragraph.
type TextAlignment int ;

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_gfcfe *Creator )NewParagraph (text string )*Paragraph {return _fagfe (text ,_gfcfe .NewTextStyle ());};func _cafg (_aefgb *_dc .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_aefgb ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// DrawHeader sets a function to draw a header on created output pages.
func (_aadc *Creator )DrawHeader (drawHeaderFunc func (_dbef *Block ,_eceb HeaderFunctionArgs )){_aadc ._gcec =drawHeaderFunc ;};func _deac (_fea _bg .Image )(*Image ,error ){_aaga ,_edda :=_dc .ImageHandling .NewImageFromGoImage (_fea );if _edda !=nil {return nil ,_edda ;
};return _cecg (_aaga );};

// SetStyleTop sets border style for top side.
func (_adgf *border )SetStyleTop (style CellBorderStyle ){_adgf ._agc =style };

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_fagfb *Creator )MoveDown (dy float64 ){_fagfb ._efab .Y +=dy };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dfdb *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _dfdb ._gcfc [0],_dfdb ._gcfc [1]};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_fdad *StyledParagraph )SetWidth (width float64 ){_fdad ._aegf =width ;_fdad .wrapText ()};

// SetFillColor sets the fill color.
func (_fcee *CurvePolygon )SetFillColor (color Color ){_fcee ._dgbg .FillColor =_eba (color )};

// IsAbsolute checks if the positioning is absolute.
func (_agd Positioning )IsAbsolute ()bool {return _agd ==PositionAbsolute };

// DrawFooter sets a function to draw a footer on created output pages.
func (_ggd *Creator )DrawFooter (drawFooterFunc func (_gag *Block ,_ddef FooterFunctionArgs )){_ggd ._bfdd =drawFooterFunc ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_cecgg *TOC )SetLineStyle (style TextStyle ){_cecgg .SetLineNumberStyle (style );_cecgg .SetLineTitleStyle (style );_cecgg .SetLineSeparatorStyle (style );_cecgg .SetLinePageStyle (style );};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_dddc *Line )SetColor (col Color ){_dddc ._eeafe =col };func (_cada *InvoiceAddress )fmtLine (_gbbc ,_faba string ,_aefg bool )string {if _aefg {_faba ="";};return _db .Sprintf ("\u0025\u0073\u0025s\u000a",_faba ,_gbbc );};

// EnableRowWrap enables/disables row wrapping across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_fcfb *Table )EnableRowWrap (enable bool ){_fcfb ._dgdd =enable };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_aeg *Creator )RotateDeg (angleDeg int64 )error {_cffef :=_aeg .getActivePage ();if _cffef ==nil {_dg .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _d .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_dg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _daea int64 ;if _cffef .Rotate !=nil {_daea =*(_cffef .Rotate );};_daea +=angleDeg ;_cffef .Rotate =&_daea ;return nil ;};func _ccac (_dbggb *_dc .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_dbggb ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};func _fceg (_fbad string )*_dc .PdfAnnotation {_ceafaa :=_dc .NewPdfAnnotationLink ();_cbea :=_dc .NewBorderStyle ();_cbea .SetBorderWidth (0);_ceafaa .BS =_cbea .ToPdfObject ();_ggff :=_dc .NewPdfActionURI ();_ggff .URI =_ef .MakeString (_fbad );_ceafaa .SetAction (_ggff .PdfAction );
return _ceafaa .PdfAnnotation ;};func _cbgb (_ebed *_dc .PdfRectangle ,_gced _cf .Matrix )*_dc .PdfRectangle {var _abcgc _dc .PdfRectangle ;_abcgc .Llx ,_abcgc .Lly =_gced .Transform (_ebed .Llx ,_ebed .Lly );_abcgc .Urx ,_abcgc .Ury =_gced .Transform (_ebed .Urx ,_ebed .Ury );
_abcgc .Normalize ();return &_abcgc ;};func (_ebfe *TOCLine )getLineLink ()*_dc .PdfAnnotation {if _ebfe ._bdgb <=0{return nil ;};return _dbcg (_ebfe ._bdgb -1,_ebfe ._bdcbg ,_ebfe ._ecgd ,0);};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_caa *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _gebc (x1 ,y1 ,x2 ,y2 )};

// IsRelative checks if the positioning is relative.
func (_cdacc Positioning )IsRelative ()bool {return _cdacc ==PositionRelative };

// SetLogo sets the logo of the invoice.
func (_dbfgc *Invoice )SetLogo (logo *Image ){_dbfgc ._acba =logo };func (_ae *Block )duplicate ()*Block {_cd :=&Block {};*_cd =*_ae ;_ecg :=_fb .ContentStreamOperations {};_ecg =append (_ecg ,*_ae ._g ...);_cd ._g =&_ecg ;return _cd ;};

// NewPolygon creates a new polygon.
func (_dagf *Creator )NewPolygon (points [][]_be .Point )*Polygon {return _gabc (points )};

// Append adds a new text chunk to the paragraph.
func (_febab *StyledParagraph )Append (text string )*TextChunk {_bfafb :=NewTextChunk (text ,_febab ._beeea );return _febab .appendChunk (_bfafb );};func _adacg (_fbbe *Chapter ,_edcc *TOC ,_gfa *_dc .Outline ,_geaa string ,_dbab int ,_cdaa TextStyle )*Chapter {var _dbf uint =1;
if _fbbe !=nil {_dbf =_fbbe ._cefg +1;};_dbb :=&Chapter {_egfa :_dbab ,_cefc :_geaa ,_cdac :true ,_afgd :true ,_fbfb :_fbbe ,_deg :_edcc ,_cegf :_gfa ,_gcea :[]Drawable {},_cefg :_dbf };_fee :=_fagfe (_dbb .headingText (),_cdaa );_fee .SetFont (_cdaa .Font );
_fee .SetFontSize (_cdaa .FontSize );_dbb ._dbaf =_fee ;return _dbb ;};func _fcdc (_daeg string )(*Image ,error ){_abbf ,_bfeb :=_b .Open (_daeg );if _bfeb !=nil {return nil ,_bfeb ;};defer _abbf .Close ();_ceafc ,_bfeb :=_dc .ImageHandling .Read (_abbf );
if _bfeb !=nil {_dg .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bfeb );return nil ,_bfeb ;};return _cecg (_ceafc );};

// SetBackgroundColor sets the cell's background color.
func (_agfgf *TableCell )SetBackgroundColor (col Color ){_agfgf ._cdacdg =col };func (_ccbb *StyledParagraph )wrapChunks (_gcfbd bool )error {if !_ccbb ._cead ||int (_ccbb ._aegf )<=0{_ccbb ._cfbc =[][]*TextChunk {_ccbb ._gfged };return nil ;};_ccbb ._cfbc =[][]*TextChunk {};
var _ecffa []*TextChunk ;var _gfaac float64 ;_cffb :=_ce .IsSpace ;if !_gcfbd {_cffb =func (rune )bool {return false };};for _ ,_eaffc :=range _ccbb ._gfged {_eddef :=_eaffc .Style ;_bbgf :=_eaffc ._cdfcd ;var (_fcce []rune ;_gggeae []float64 ;);for _ ,_caee :=range _eaffc .Text {if _caee =='\u000A'{if !_gcfbd {_fcce =append (_fcce ,_caee );
};_ecffa =append (_ecffa ,&TextChunk {Text :_cec .TrimRightFunc (string (_fcce ),_cffb ),Style :_eddef ,_cdfcd :_ccbc (_bbgf )});_ccbb ._cfbc =append (_ccbb ._cfbc ,_ecffa );_ecffa =nil ;_gfaac =0;_fcce =nil ;_gggeae =nil ;continue ;};_eedcb :=_caee ==' ';
_gffad ,_dgegab :=_eddef .Font .GetRuneMetrics (_caee );if !_dgegab {_dg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_caee );
return _d .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_efdg :=_eddef .FontSize *_gffad .Wx *_eddef .horizontalScale ();_dcab :=_efdg ;if !_eedcb {_dcab =_efdg +_eddef .CharSpacing *1000.0;
};if _gfaac +_efdg > _ccbb ._aegf *1000.0{_befe :=-1;if !_eedcb {for _cebcc :=len (_fcce )-1;_cebcc >=0;_cebcc --{if _fcce [_cebcc ]==' '{_befe =_cebcc ;break ;};};};_bbac :=string (_fcce );if _befe >=0{_bbac =string (_fcce [0:_befe +1]);_fcce =_fcce [_befe +1:];
_fcce =append (_fcce ,_caee );_gggeae =_gggeae [_befe +1:];_gggeae =append (_gggeae ,_dcab );_gfaac =0;for _ ,_acda :=range _gggeae {_gfaac +=_acda ;};}else {if _eedcb {_gfaac =0;_fcce =[]rune {};_gggeae =[]float64 {};}else {_gfaac =_dcab ;_fcce =[]rune {_caee };
_gggeae =[]float64 {_dcab };};};if !_gcfbd &&_eedcb {_bbac +="\u0020";};_ecffa =append (_ecffa ,&TextChunk {Text :_cec .TrimRightFunc (_bbac ,_cffb ),Style :_eddef ,_cdfcd :_ccbc (_bbgf )});_ccbb ._cfbc =append (_ccbb ._cfbc ,_ecffa );_ecffa =[]*TextChunk {};
}else {_gfaac +=_dcab ;_fcce =append (_fcce ,_caee );_gggeae =append (_gggeae ,_dcab );};};if len (_fcce )> 0{_ecffa =append (_ecffa ,&TextChunk {Text :string (_fcce ),Style :_eddef ,_cdfcd :_ccbc (_bbgf )});};};if len (_ecffa )> 0{_ccbb ._cfbc =append (_ccbb ._cfbc ,_ecffa );
};return nil ;};

// Width returns the width of the Paragraph.
func (_fecc *Paragraph )Width ()float64 {if _fecc ._gcfb &&int (_fecc ._cega )> 0{return _fecc ._cega ;};return _fecc .getTextWidth ()/1000.0;};

// SetAngle sets the rotation angle of the text.
func (_cgcf *StyledParagraph )SetAngle (angle float64 ){_cgcf ._febg =angle };

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_ecf *Creator )AddPage (page *_dc .PdfPage )error {_aff ,_cfbf :=page .GetMediaBox ();if _cfbf !=nil {_dg .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_cfbf );
return _cfbf ;};_aff .Normalize ();_dgee ,_ccff :=_aff .Llx ,_aff .Lly ;_afbf :=_cf .IdentityMatrix ();_edcea :=page .Rotate ;_fefc :=_edcea !=nil &&*_edcea %360!=0&&*_edcea %90==0;if _fefc {_becd :=float64 ((360+*page .Rotate %360)%360);if _becd ==90{_afbf =_afbf .Translate (_aff .Width (),0);
}else if _becd ==180{_afbf =_afbf .Translate (_aff .Width (),_aff .Height ());}else if _becd ==270{_afbf =_afbf .Translate (0,_aff .Height ());};_afbf =_afbf .Mult (_cf .RotationMatrix (_becd *_da .Pi /180));_afbf =_afbf .Round (0.000001);_adgd :=_cbgb (_aff ,_afbf );
_aff =_adgd ;_aff .Normalize ();};if _dgee !=0||_ccff !=0{_afbf =_cf .TranslationMatrix (_dgee ,_ccff ).Mult (_afbf );};if !_afbf .Identity (){if _ecf ._ffc ==nil {_ecf ._ffc =map[*_dc .PdfPage ]_cf .Matrix {};};_afbf =_afbf .Round (0.000001);_ecf ._ffc [page ]=_afbf ;
};_ecf ._aaaf =_aff .Width ();_ecf ._gbgd =_aff .Height ();_ecf .initContext ();_ecf ._dec =append (_ecf ._dec ,page );_ecf ._efab .Page ++;return nil ;};

// SetMargins sets the Paragraph's margins.
func (_ccdb *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_ccdb ._afbed .Left =left ;_ccdb ._afbed .Right =right ;_ccdb ._afbed .Top =top ;_ccdb ._afbed .Bottom =bottom ;};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_bcgg *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _cdgb (number ,title ,page ,level ,style );};

// SetLineWidth sets the line width.
func (_gecdf *Polyline )SetLineWidth (lineWidth float64 ){_gecdf ._fgae .LineWidth =lineWidth };

// NewCurvePolygon creates a new curve polygon.
func (_beee *Creator )NewCurvePolygon (rings [][]_be .CubicBezierCurve )*CurvePolygon {return _egdf (rings );};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_agfg *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfbba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bafag ,_bcfg :=_cfbba .setOpacity (_agfg ._bgbf ,_agfg ._efeab );if _bcfg !=nil {return nil ,ctx ,_bcfg ;};
_edeae :=_agfg ._aaac ;_edeae .FillEnabled =_edeae .FillColor !=nil ;_edeae .BorderEnabled =_edeae .BorderColor !=nil &&_edeae .BorderWidth > 0;_gdfd :=_edeae .Points ;for _bdff :=range _gdfd {for _acabg :=range _gdfd [_bdff ]{_ffbc :=&_gdfd [_bdff ][_acabg ];
_ffbc .Y =ctx .PageHeight -_ffbc .Y ;};};_dcfb ,_ ,_bcfg :=_edeae .Draw (_bafag );if _bcfg !=nil {return nil ,ctx ,_bcfg ;};if _bcfg =_cfbba .addContentsByString (string (_dcfb ));_bcfg !=nil {return nil ,ctx ,_bcfg ;};return []*Block {_cfbba },ctx ,nil ;
};func _ceadd (_dadd *Block ,_agccc *StyledParagraph ,_badb [][]*TextChunk ,_aadg DrawContext )(DrawContext ,[][]*TextChunk ,error ){_ffec :=1;_dagfe :=_ef .PdfObjectName (_db .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ffec ));for _dadd ._a .HasFontByName (_dagfe ){_ffec ++;
_dagfe =_ef .PdfObjectName (_db .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ffec ));};_cgbcg :=_dadd ._a .SetFontByName (_dagfe ,_agccc ._beeea .Font .ToPdfObject ());if _cgbcg !=nil {return _aadg ,nil ,_cgbcg ;};_ffec ++;_efef :=_dagfe ;_dcdc :=_agccc ._beeea .FontSize ;
_fcba :=_agccc ._cfde .IsRelative ();var _cebcd [][]_ef .PdfObjectName ;var _gbee [][]*TextChunk ;var _gfgd float64 ;for _fefcc ,_fbac :=range _badb {var _fefe []_ef .PdfObjectName ;var _ecbd float64 ;for _ ,_agae :=range _fbac {_cedcc :=_agae .Style ;
if _cedcc .FontSize > _ecbd {_ecbd =_cedcc .FontSize ;};_dagfe =_ef .PdfObjectName (_db .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_ffec ));_ffae :=_dadd ._a .SetFontByName (_dagfe ,_cedcc .Font .ToPdfObject ());if _ffae !=nil {return _aadg ,nil ,_ffae ;
};_fefe =append (_fefe ,_dagfe );_ffec ++;};_ecbd *=_agccc ._bgfc ;if _fcba &&_gfgd +_ecbd > _aadg .Height {_gbee =_badb [_fefcc :];_badb =_badb [:_fefcc ];break ;};_gfgd +=_ecbd ;_cebcd =append (_cebcd ,_fefe );};_cbbag ,_cagg ,_efda :=_agccc .getLineMetrics (0);
_dcada ,_gfcc :=_cbbag *_agccc ._bgfc ,_cagg *_agccc ._bgfc ;_aacbd :=_fb .NewContentCreator ();_aacbd .Add_q ();_bbbd :=_gfcc ;if _agccc ._adfcb ==TextVerticalAlignmentCenter {_bbbd =_cagg +(_cbbag +_efda -_cagg )/2+(_gfcc -_cagg )/2;};_aggd :=_aadg .PageHeight -_aadg .Y -_bbbd ;
_aacbd .Translate (_aadg .X ,_aggd );_ebf :=_aggd ;if _agccc ._febg !=0{_aacbd .RotateDeg (_agccc ._febg );};if _agccc ._fdf ==TextOverflowHidden {_aacbd .Add_re (0,-_gfgd +_dcada +1,_agccc ._aegf ,_gfgd ).Add_W ().Add_n ();};_aacbd .Add_BT ();var _caggd []*_be .BasicLine ;
for _efdb ,_fgad :=range _badb {_abff :=_aadg .X ;if _efdb !=0{_aacbd .Add_Tstar ();};_gbce :=_efdb ==len (_badb )-1;var (_gfceb float64 ;_egfe float64 ;_ggbd float64 ;_gbfd uint ;);var _bdbf []float64 ;for _ ,_fecf :=range _fgad {_fgaec :=&_fecf .Style ;
if _fgaec .FontSize > _egfe {_egfe =_fgaec .FontSize ;};_cggg ,_acce :=_fgaec .Font .GetRuneMetrics (' ');if !_acce {return _aadg ,nil ,_d .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _ecfb uint ;var _bcgb float64 ;_efcdg :=len (_fecf .Text );for _ecbe ,_bgga :=range _fecf .Text {if _bgga ==' '{_ecfb ++;continue ;};if _bgga =='\u000A'{continue ;};_fecaf ,_cbge :=_fgaec .Font .GetRuneMetrics (_bgga );if !_cbge {_dg .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_bgga );
return _aadg ,nil ,_d .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_bcgb +=_fgaec .FontSize *_fecaf .Wx *_fgaec .horizontalScale ();if _ecbe !=_efcdg -1{_bcgb +=_fgaec .CharSpacing *1000.0;
};};_bdbf =append (_bdbf ,_bcgb );_gfceb +=_bcgb ;_ggbd +=float64 (_ecfb )*_cggg .Wx *_fgaec .FontSize *_fgaec .horizontalScale ();_gbfd +=_ecfb ;};_egfe *=_agccc ._bgfc ;var _abgfd []_ef .PdfObject ;_daba :=_agccc ._aegf *1000.0;if _agccc ._ddde ==TextAlignmentJustify {if _gbfd > 0&&!_gbce {_ggbd =(_daba -_gfceb )/float64 (_gbfd )/_dcdc ;
};}else if _agccc ._ddde ==TextAlignmentCenter {_ebfc :=(_daba -_gfceb -_ggbd )/2;_gdba :=_ebfc /_dcdc ;_abgfd =append (_abgfd ,_ef .MakeFloat (-_gdba ));_abff +=_ebfc /1000.0;}else if _agccc ._ddde ==TextAlignmentRight {_cbaad :=(_daba -_gfceb -_ggbd );
_febd :=_cbaad /_dcdc ;_abgfd =append (_abgfd ,_ef .MakeFloat (-_febd ));_abff +=_cbaad /1000.0;};if len (_abgfd )> 0{_aacbd .Add_Tf (_efef ,_dcdc ).Add_TL (_dcdc *_agccc ._bgfc ).Add_TJ (_abgfd ...);};var _ccca float64 ;for _dgege ,_gbef :=range _fgad {_gbbca :=&_gbef .Style ;
if _gbbca .FontSize > _ccca {_ccca =_gbbca .FontSize ;};_efeee :=_efef ;_abda :=_dcdc ;_eccg :=_gbbca .OutlineColor !=nil ;_dgeb :=_gbbca .HorizontalScaling !=DefaultHorizontalScaling ;_fccb :=_gbbca .OutlineSize !=1;if _fccb {_aacbd .Add_w (_gbbca .OutlineSize );
};_adgff :=_gbbca .RenderingMode !=TextRenderingModeFill ;if _adgff {_aacbd .Add_Tr (int64 (_gbbca .RenderingMode ));};_aecda :=_gbbca .CharSpacing !=0;if _aecda {_aacbd .Add_Tc (_gbbca .CharSpacing );};_bebec :=_gbbca .TextRise !=0;if _bebec {_aacbd .Add_Ts (_gbbca .TextRise );
};if _agccc ._ddde !=TextAlignmentJustify ||_gbce {_geabg ,_gfdb :=_gbbca .Font .GetRuneMetrics (' ');if !_gfdb {return _aadg ,nil ,_d .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};_efeee =_cebcd [_efdb ][_dgege ];_abda =_gbbca .FontSize ;_ggbd =_geabg .Wx *_gbbca .horizontalScale ();};_dddca :=_gbbca .Font .Encoder ();var _aadec []byte ;for _ ,_cga :=range _gbef .Text {if _cga =='\u000A'{continue ;};if _cga ==' '{if len (_aadec )> 0{if _eccg {_aacbd .SetStrokingColor (_eba (_gbbca .OutlineColor ));
};if _dgeb {_aacbd .Add_Tz (_gbbca .HorizontalScaling );};_aacbd .SetNonStrokingColor (_eba (_gbbca .Color )).Add_Tf (_cebcd [_efdb ][_dgege ],_gbbca .FontSize ).Add_TJ ([]_ef .PdfObject {_ef .MakeStringFromBytes (_aadec )}...);_aadec =nil ;};if _dgeb {_aacbd .Add_Tz (DefaultHorizontalScaling );
};_aacbd .Add_Tf (_efeee ,_abda ).Add_TJ ([]_ef .PdfObject {_ef .MakeFloat (-_ggbd )}...);_bdbf [_dgege ]+=_ggbd *_abda ;}else {if _ ,_bdec :=_dddca .RuneToCharcode (_cga );!_bdec {_dg .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_cga ,_cga );
continue ;};_aadec =append (_aadec ,_dddca .Encode (string (_cga ))...);};};if len (_aadec )> 0{if _eccg {_aacbd .SetStrokingColor (_eba (_gbbca .OutlineColor ));};if _dgeb {_aacbd .Add_Tz (_gbbca .HorizontalScaling );};_aacbd .SetNonStrokingColor (_eba (_gbbca .Color )).Add_Tf (_cebcd [_efdb ][_dgege ],_gbbca .FontSize ).Add_TJ ([]_ef .PdfObject {_ef .MakeStringFromBytes (_aadec )}...);
};_efefa :=_bdbf [_dgege ]/1000.0;if _gbbca .Underline {_dbgbd :=_gbbca .UnderlineStyle .Color ;if _dbgbd ==nil {_dbgbd =_gbef .Style .Color ;};_decf ,_ecbg ,_deccc :=_dbgbd .ToRGB ();_bcgf :=_abff -_aadg .X ;_fead :=_ebf -_aggd +_gbbca .TextRise -_gbbca .UnderlineStyle .Offset ;
_caggd =append (_caggd ,&_be .BasicLine {X1 :_bcgf ,Y1 :_fead ,X2 :_bcgf +_efefa ,Y2 :_fead ,LineWidth :_gbef .Style .UnderlineStyle .Thickness ,LineColor :_dc .NewPdfColorDeviceRGB (_decf ,_ecbg ,_deccc )});};if _gbef ._cdfcd !=nil {var _gbfa *_ef .PdfObjectArray ;
if !_gbef ._ecdg {switch _fegb :=_gbef ._cdfcd .GetContext ().(type ){case *_dc .PdfAnnotationLink :_gbfa =_ef .MakeArray ();_fegb .Rect =_gbfa ;_eddad ,_eabb :=_fegb .Dest .(*_ef .PdfObjectArray );if _eabb &&_eddad .Len ()==5{_afda ,_eeea :=_eddad .Get (1).(*_ef .PdfObjectName );
if _eeea &&_afda .String ()=="\u0058\u0059\u005a"{_aeacf ,_egdc :=_ef .GetNumberAsFloat (_eddad .Get (3));if _egdc ==nil {_eddad .Set (3,_ef .MakeFloat (_aadg .PageHeight -_aeacf ));};};};};_gbef ._ecdg =true ;};if _gbfa !=nil {_aecf :=_be .NewPoint (_abff -_aadg .X ,_ebf +_gbbca .TextRise -_aggd ).Rotate (_agccc ._febg );
_aecf .X +=_aadg .X ;_aecf .Y +=_aggd ;_baega ,_bgbfc ,_ebgc ,_baac :=_adegb (_efefa ,_egfe ,_agccc ._febg );_aecf .X +=_baega ;_aecf .Y +=_bgbfc ;_gbfa .Clear ();_gbfa .Append (_ef .MakeFloat (_aecf .X ));_gbfa .Append (_ef .MakeFloat (_aecf .Y ));_gbfa .Append (_ef .MakeFloat (_aecf .X +_ebgc ));
_gbfa .Append (_ef .MakeFloat (_aecf .Y +_baac ));};_dadd .AddAnnotation (_gbef ._cdfcd );};_abff +=_efefa ;if _fccb {_aacbd .Add_w (1.0);};if _eccg {_aacbd .Add_RG (0.0,0.0,0.0);};if _adgff {_aacbd .Add_Tr (int64 (TextRenderingModeFill ));};if _aecda {_aacbd .Add_Tc (0);
};if _bebec {_aacbd .Add_Ts (0);};if _dgeb {_aacbd .Add_Tz (DefaultHorizontalScaling );};};_aacbd .Add_TL (_ccca *_agccc ._bgfc );_ebf -=_egfe ;};_aacbd .Add_ET ();for _ ,_afdg :=range _caggd {_aacbd .SetStrokingColor (_afdg .LineColor ).Add_w (_afdg .LineWidth ).Add_m (_afdg .X1 ,_afdg .Y1 ).Add_l (_afdg .X2 ,_afdg .Y2 ).Add_s ();
};_aacbd .Add_Q ();_cdec :=_aacbd .Operations ();_cdec .WrapIfNeeded ();_dadd .addContents (_cdec );if _fcba {_bbgd :=_gfgd +_agccc ._afbed .Bottom ;_aadg .Y +=_bbgd ;_aadg .Height -=_bbgd ;if _aadg .Inline {_aadg .X +=_agccc .Width ()+_agccc ._afbed .Right ;
};};return _aadg ,_gbee ,nil ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_dec []*_dc .PdfPage ;_adce map[*_dc .PdfPage ]*Block ;_ffc map[*_dc .PdfPage ]_cf .Matrix ;_cbec *_dc .PdfPage ;_ceag PageSize ;_efab DrawContext ;_gggg Margins ;_aaaf ,_gbgd float64 ;_dabb int ;_bbbc func (_efg FrontpageFunctionArgs );
_bcd func (_ddbc *TOC )error ;_gcec func (_edac *Block ,_aaef HeaderFunctionArgs );_bfdd func (_ddaeg *Block ,_cecd FooterFunctionArgs );_gff func (_gcb PageFinalizeFunctionArgs )error ;_feeb func (_fcga *_dc .PdfWriter )error ;_bda bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_dadc *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_fage *_dc .Outline ;_fcgad *_dc .PdfOutlineTreeNode ;_ffef *_dc .PdfAcroForm ;_bdedg _ef .PdfObject ;_becg _dc .Optimizer ;_cefb []*_dc .PdfFont ;_gac *_dc .PdfFont ;_gfe *_dc .PdfFont ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cfea *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_febf :=ctx ;_adec ,ctx ,_adad :=_cfea ._gfgedf .GeneratePageBlocks (ctx );if _adad !=nil {return _adec ,ctx ,_adad ;};if _cfea ._ecef .IsRelative (){ctx .X =_febf .X ;
};if _cfea ._ecef .IsAbsolute (){return _adec ,_febf ,nil ;};return _adec ,ctx ,nil ;};func _eaba (_dafea TextStyle )*List {return &List {_bed :TextChunk {Text :"\u2022\u0020",Style :_dafea },_fdagb :0,_bagb :true ,_bbcg :PositionRelative ,_dgg :_dafea };
};

// AddSection adds a new content section at the end of the invoice.
func (_ceae *Invoice )AddSection (title ,content string ){_ceae ._eaac =append (_ceae ._eaac ,[2]string {title ,content });};

// CurCol returns the currently active cell's column number.
func (_fedec *Table )CurCol ()int {_fabb :=(_fedec ._gecf -1)%(_fedec ._gaaa )+1;return _fabb };

// SetTitleStyle sets the style properties of the invoice title.
func (_daede *Invoice )SetTitleStyle (style TextStyle ){_daede ._ggac =style };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_agcc *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_agcc ._beed .Left =left ;_agcc ._beed .Right =right ;_agcc ._beed .Top =top ;_agcc ._beed .Bottom =bottom ;};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_dc .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// SetAngle sets Image rotation angle in degrees.
func (_abed *Image )SetAngle (angle float64 ){_abed ._gdce =angle };

// NewChapter creates a new chapter with the specified title as the heading.
func (_edfgb *Creator )NewChapter (title string )*Chapter {_edfgb ._dabb ++;_ecac :=_edfgb .NewTextStyle ();_ecac .FontSize =16;return _adacg (nil ,_edfgb ._dadc ,_edfgb ._fage ,title ,_edfgb ._dabb ,_ecac );};

// DrawWithContext draws the Block using the specified drawing context.
func (_bea *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_bca ,_ ,_ffd :=d .GeneratePageBlocks (ctx );if _ffd !=nil {return _ffd ;};if len (_bca )!=1{return _d .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_bffa :=range _bca {if _cda :=_bea .mergeBlocks (_bffa );_cda !=nil {return _cda ;};};return nil ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_ecaf *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _ecaf ._fede .Left ,_ecaf ._fede .Right ,_ecaf ._fede .Top ,_ecaf ._fede .Bottom ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_dcfa *Creator )SetPageLabels (pageLabels _ef .PdfObject ){_dcfa ._bdedg =pageLabels };func (_gdda *Division )ctxHeight (_bfc float64 )float64 {var _babc float64 ;for _ ,_affg :=range _gdda ._dbg {switch _dfda :=_affg .(type ){case *Paragraph :if _dfda ._gcfb {_dfda .SetWidth (_bfc );
};_babc +=_dfda .Height ()+_dfda ._agdb .Top +_dfda ._agdb .Bottom ;case *StyledParagraph :if _dfda ._cead {_dfda .SetWidth (_bfc );};_babc +=_dfda .Height ()+_dfda ._afbed .Top +_dfda ._afbed .Bottom ;default:_babc +=_dfda .Height ();};};return _babc ;
};func (_eegg *Block )setOpacity (_eed float64 ,_edb float64 )(string ,error ){if (_eed < 0||_eed >=1.0)&&(_edb < 0||_edb >=1.0){return "",nil ;};_cfg :=0;_fc :=_db .Sprintf ("\u0047\u0053\u0025\u0064",_cfg );for _eegg ._a .HasExtGState (_ef .PdfObjectName (_fc )){_cfg ++;
_fc =_db .Sprintf ("\u0047\u0053\u0025\u0064",_cfg );};_dgf :=_ef .MakeDict ();if _eed >=0&&_eed < 1.0{_dgf .Set ("\u0063\u0061",_ef .MakeFloat (_eed ));};if _edb >=0&&_edb < 1.0{_dgf .Set ("\u0043\u0041",_ef .MakeFloat (_edb ));};_fe :=_eegg ._a .AddExtGState (_ef .PdfObjectName (_fc ),_dgf );
if _fe !=nil {return "",_fe ;};return _fc ,nil ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_bfabc *Invoice )Terms ()(string ,string ){return _bfabc ._eeda [0],_bfabc ._eeda [1]};

// NewList creates a new list.
func (_gaec *Creator )NewList ()*List {return _eaba (_gaec .NewTextStyle ())};func _gddda (_afg string ,_gde _ef .PdfObject ,_bbbe *_dc .PdfPageResources )_ef .PdfObjectName {_abg :=_cec .TrimRightFunc (_cec .TrimSpace (_afg ),func (_fgd rune )bool {return _ce .IsNumber (_fgd )});
if _abg ==""{_abg ="\u0046\u006f\u006e\u0074";};_dcgb :=0;_gfc :=_ef .PdfObjectName (_afg );for {_ade ,_ggge :=_bbbe .GetFontByName (_gfc );if !_ggge ||_ade ==_gde {break ;};_dcgb ++;_gfc =_ef .PdfObjectName (_db .Sprintf ("\u0025\u0073\u0025\u0064",_abg ,_dcgb ));
};return _gfc ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_edbc *Table )SetMargins (left ,right ,top ,bottom float64 ){_edbc ._eeed .Left =left ;_edbc ._eeed .Right =right ;_edbc ._eeed .Top =top ;_edbc ._eeed .Bottom =bottom ;};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_gbd Drawable )(Drawable ,error );};

// NewCell returns a new invoice table cell.
func (_defb *Invoice )NewCell (value string )*InvoiceCell {return _defb .newCell (value ,_defb .NewCellProps ());};

// Lines returns all the lines the table of contents has.
func (_aacaf *TOC )Lines ()[]*TOCLine {return _aacaf ._dccf };func _cde (_adgc ,_cff *_dc .PdfPageResources )error {_gaa ,_ :=_adgc .GetColorspaces ();if _gaa !=nil &&len (_gaa .Colorspaces )> 0{for _eaa ,_eae :=range _gaa .Colorspaces {_abf :=*_ef .MakeName (_eaa );
if _cff .HasColorspaceByName (_abf ){continue ;};_acf :=_cff .SetColorspaceByName (_abf ,_eae );if _acf !=nil {return _acf ;};};};return nil ;};func (_eabg *Creator )getActivePage ()*_dc .PdfPage {if _eabg ._cbec ==nil {if len (_eabg ._dec )==0{return nil ;
};return _eabg ._dec [len (_eabg ._dec )-1];};return _eabg ._cbec ;};

// SetTitle sets the title of the invoice.
func (_ebbg *Invoice )SetTitle (title string ){_ebbg ._bddc =title };

// Width returns the width of the Paragraph.
func (_gbffa *StyledParagraph )Width ()float64 {if _gbffa ._cead &&int (_gbffa ._aegf )> 0{return _gbffa ._aegf ;};return _gbffa .getTextWidth ()/1000.0;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_fagd *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fagd ._beed .Left ,_fagd ._beed .Right ,_fagd ._beed .Top ,_fagd ._beed .Bottom ;};func _fddc (_dfgda *Table ,_faaf DrawContext )([]*Block ,DrawContext ,error ){var _egfc []*Block ;
_agge :=NewBlock (_faaf .PageWidth ,_faaf .PageHeight );_aafad :=_faaf ;if _dfgda ._debec .IsAbsolute (){_faaf .X =_dfgda ._cgaa ;_faaf .Y =_dfgda ._gadae ;}else {_faaf .X +=_dfgda ._eeed .Left ;_faaf .Y +=_dfgda ._eeed .Top ;_faaf .Width -=_dfgda ._eeed .Left +_dfgda ._eeed .Right ;
_faaf .Height -=_dfgda ._eeed .Bottom +_dfgda ._eeed .Top ;};_fcdbc :=_faaf .Width ;_bgae :=_faaf .X ;_abad :=_faaf .Y ;_faaf .Height =_faaf .PageHeight -_faaf .Y -_faaf .Margins .Bottom ;_fdaeb :=_faaf .Height ;_fabe :=0;_adaf ,_ecgbc :=-1,-1;for _gaaaa ,_cecae :=range _dfgda ._fdbg {_gcbea :=_cecae .width (_dfgda ._bbecd ,_fcdbc );
if _dfgda ._deaf {if _cecae ._debc >=_dfgda ._febb &&_cecae ._debc <=_dfgda ._dgaa {if _adaf < 0{_adaf =_gaaaa ;};_ecgbc =_gaaaa ;};};_fdcb :=_dfgda ._degd [_cecae ._debc +_cecae ._feef -2];if _abgfc :=_cecae .height (_gcbea );_abgfc > _fdcb {_dfgda ._degd [_cecae ._debc +_cecae ._feef -2]=_abgfc ;
};};var (_egab bool ;_caef int ;_acded int ;_badbg bool ;_geba int ;_aadgd error ;);for _fedeg :=0;_fedeg < len (_dfgda ._fdbg );_fedeg ++{_gggc :=_dfgda ._fdbg [_fedeg ];_degaa :=_gggc .width (_dfgda ._bbecd ,_fcdbc );_egcc :=float64 (0.0);for _fde :=0;
_fde < _gggc ._agdfg -1;_fde ++{_egcc +=_dfgda ._bbecd [_fde ]*_fcdbc ;};_bffd :=float64 (0.0);for _fecff :=_fabe ;_fecff < _gggc ._debc -1;_fecff ++{_bffd +=_dfgda ._degd [_fecff ];};_faaf .Height =_fdaeb -_bffd ;_dbfe :=float64 (0.0);for _fbdb :=0;_fbdb < _gggc ._feef ;
_fbdb ++{_dbfe +=_dfgda ._degd [_gggc ._debc +_fbdb -1];};_cffa :=_badbg &&_gggc ._debc !=_geba ;_geba =_gggc ._debc ;if _cffa ||_dbfe > _faaf .Height {if _dfgda ._dgdd &&!_badbg {_badbg ,_aadgd =_dfgda .wrapRow (_fedeg ,_faaf ,_fcdbc );if _aadgd !=nil {return nil ,_faaf ,_aadgd ;
};if _badbg {_fedeg --;continue ;};};_egfc =append (_egfc ,_agge );_agge =NewBlock (_faaf .PageWidth ,_faaf .PageHeight );_bgae =_faaf .Margins .Left ;_abad =_faaf .Margins .Top ;_faaf .Height =_faaf .PageHeight -_faaf .Margins .Top -_faaf .Margins .Bottom ;
_faaf .Page ++;_fdaeb =_faaf .Height ;_fabe =_gggc ._debc -1;_bffd =0;_badbg =false ;if _dfgda ._deaf &&_adaf >=0{_caef =_fedeg ;_fedeg =_adaf -1;_acded =_fabe ;_fabe =_dfgda ._febb -1;_egab =true ;continue ;};if _cffa {_fedeg --;continue ;};};_faaf .Width =_degaa ;
_faaf .X =_bgae +_egcc ;_faaf .Y =_abad +_bffd ;_fceee :=_edfg (_faaf .X ,_faaf .Y ,_degaa ,_dbfe );if _gggc ._cdacdg !=nil {_fceee .SetFillColor (_gggc ._cdacdg );};_fceee .LineStyle =_gggc ._egeb ;_fceee ._ddb =_gggc ._eaeg ;_fceee ._aebe =_gggc ._gebae ;
_fceee ._agc =_gggc ._edgf ;_fceee ._cac =_gggc ._bbaf ;if _gggc ._bbeg !=nil {_fceee .SetColorLeft (_gggc ._bbeg );};if _gggc ._cegcg !=nil {_fceee .SetColorBottom (_gggc ._cegcg );};if _gggc ._acfd !=nil {_fceee .SetColorRight (_gggc ._acfd );};if _gggc ._gecdb !=nil {_fceee .SetColorTop (_gggc ._gecdb );
};_fceee .SetWidthBottom (_gggc ._bfga );_fceee .SetWidthLeft (_gggc ._fbfd );_fceee .SetWidthRight (_gggc ._dfba );_fceee .SetWidthTop (_gggc ._cgcbe );_agde :=_agge .Draw (_fceee );if _agde !=nil {_dg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_agde );
};if _gggc ._fagfbd !=nil {_bfdgb :=_gggc ._fagfbd .Width ();_edage :=_gggc ._fagfbd .Height ();_dbcdg :=0.0;switch _bbea :=_gggc ._fagfbd .(type ){case *Paragraph :if _bbea ._gcfb {_bfdgb =_bbea .getMaxLineWidth ()/1000.0;};_bfdgb +=_bbea ._agdb .Left +_bbea ._agdb .Right ;
_edage +=_bbea ._agdb .Top +_bbea ._agdb .Bottom ;case *StyledParagraph :if _bbea ._cead {_bfdgb =_bbea .getMaxLineWidth ()/1000.0;};_gcab ,_bccg ,_ddgad :=_bbea .getLineMetrics (0);_baaa ,_cagf :=_gcab *_bbea ._bgfc ,_bccg *_bbea ._bgfc ;if _bbea ._adfcb ==TextVerticalAlignmentCenter {_dbcdg =_cagf -(_bccg +(_gcab +_ddgad -_bccg )/2+(_cagf -_bccg )/2);
};if len (_bbea ._cfbc )==1{_edage =_baaa ;}else {_edage =_edage -_cagf +_baaa ;};_dbcdg +=_baaa -_cagf ;switch _gggc ._aegef {case CellVerticalAlignmentTop :_dbcdg +=_baaa *0.5;case CellVerticalAlignmentBottom :_dbcdg -=_baaa *0.5;};_bfdgb +=_bbea ._afbed .Left +_bbea ._afbed .Right ;
_edage +=_bbea ._afbed .Top +_bbea ._afbed .Bottom ;case *Table :_bfdgb =_degaa ;case *List :_bfdgb =_degaa ;};switch _gggc ._bfbff {case CellHorizontalAlignmentLeft :_faaf .X +=_gggc ._aefgf ;_faaf .Width -=_gggc ._aefgf ;case CellHorizontalAlignmentCenter :if _bfcc :=_degaa -_bfdgb ;
_bfcc > 0{_faaf .X +=_bfcc /2;_faaf .Width -=_bfcc /2;};case CellHorizontalAlignmentRight :if _degaa > _bfdgb {_faaf .X =_faaf .X +_degaa -_bfdgb -_gggc ._aefgf ;_faaf .Width -=_gggc ._aefgf ;};};_faaf .Y +=_dbcdg ;switch _gggc ._aegef {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _decd :=_dbfe -_edage ;
_decd > 0{_faaf .Y +=_decd /2;_faaf .Height -=_decd /2;};case CellVerticalAlignmentBottom :if _dbfe > _edage {_faaf .Y =_faaf .Y +_dbfe -_edage ;_faaf .Height =_dbfe ;};};_bgda :=_agge .DrawWithContext (_gggc ._fagfbd ,_faaf );if _bgda !=nil {_dg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bgda );
};_faaf .Y -=_dbcdg ;};_faaf .Y +=_dbfe ;_faaf .Height -=_dbfe ;if _egab &&_fedeg +1> _ecgbc {_abad +=_bffd +_dbfe ;_fdaeb -=_dbfe +_bffd ;_fabe =_acded ;_fedeg =_caef -1;_egab =false ;};};_egfc =append (_egfc ,_agge );if _dfgda ._debec .IsAbsolute (){return _egfc ,_aafad ,nil ;
};_faaf .X =_aafad .X ;_faaf .Width =_aafad .Width ;_faaf .Y +=_dfgda ._eeed .Bottom ;_faaf .Height -=_dfgda ._eeed .Bottom ;return _egfc ,_faaf ,nil ;};

// SetMargins sets the margins of the paragraph.
func (_ggbge *List )SetMargins (left ,right ,top ,bottom float64 ){_ggbge ._fede .Left =left ;_ggbge ._fede .Right =right ;_ggbge ._fede .Top =top ;_ggbge ._fede .Bottom =bottom ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_gdeg *Invoice )Notes ()(string ,string ){return _gdeg ._aaae [0],_gdeg ._aaae [1]};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};func (_aaa *Chapter )headingNumber ()string {var _adgfb string ;if _aaa ._cdac {if _aaa ._egfa !=0{_adgfb =_ddd .Itoa (_aaa ._egfa )+"\u002e";};if _aaa ._fbfb !=nil {_bgcb :=_aaa ._fbfb .headingNumber ();if _bgcb !=""{_adgfb =_bgcb +_adgfb ;
};};};return _adgfb ;};

// Context returns the current drawing context.
func (_cfff *Creator )Context ()DrawContext {return _cfff ._efab };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_cdg *Creator )NewPolyBezierCurve (curves []_be .CubicBezierCurve )*PolyBezierCurve {return _ggdae (curves );};