//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_cc "fmt";_d "github.com/unidoc/unipdf/v3/common";_e "math";);func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_dg Matrix )Translate (tx ,ty float64 )Matrix {return _dg .Mult (TranslationMatrix (tx ,ty ))};
func (_ba Point )String ()string {return _cc .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ba .X ,_ba .Y );};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_afc Matrix )Rotate (theta float64 )Matrix {return _afc .Mult (RotationMatrix (theta ))};
func (_eb *Matrix )Clone ()Matrix {return NewMatrix (_eb [0],_eb [1],_eb [3],_eb [4],_eb [6],_eb [7])};func (_f Matrix )Transform (x ,y float64 )(float64 ,float64 ){_fc :=x *_f [0]+y *_f [3]+_f [6];_fg :=x *_f [1]+y *_f [4]+_f [7];return _fc ,_fg ;};const _eeb =1e-6;
func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_ccd *Matrix )Concat (b Matrix ){*_ccd =Matrix {b [0]*_ccd [0]+b [1]*_ccd [3],b [0]*_ccd [1]+b [1]*_ccd [4],0,b [3]*_ccd [0]+b [4]*_ccd [3],b [3]*_ccd [1]+b [4]*_ccd [4],0,b [6]*_ccd [0]+b [7]*_ccd [3]+_ccd [6],b [6]*_ccd [1]+b [7]*_ccd [4]+_ccd [7],1};
_ccd .clampRange ();};func (_dgf Matrix )ScalingFactorY ()float64 {return _e .Hypot (_dgf [3],_dgf [4])};func (_ga Matrix )Scale (xScale ,yScale float64 )Matrix {return _ga .Mult (ScaleMatrix (xScale ,yScale ))};func (_gbe Matrix )ScalingFactorX ()float64 {return _e .Hypot (_gbe [0],_gbe [1])};
func (_cef *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_gac :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cef .transformByMatrix (_gac );};type Point struct{X float64 ;Y float64 ;};func (_gaf Point )Distance (b Point )float64 {return _e .Hypot (_gaf .X -b .X ,_gaf .Y -b .Y )};
func (_fb Matrix )Angle ()float64 {_fd :=_e .Atan2 (-_fb [1],_fb [0]);if _fd < 0.0{_fd +=2*_e .Pi ;};return _fd /_e .Pi *180.0;};const _dda =1.0e-6;func RotationMatrix (angle float64 )Matrix {_bf :=_e .Cos (angle );_ea :=_e .Sin (angle );return NewMatrix (_bf ,_ea ,-_ea ,_bf ,0,0);
};func (_cg *Matrix )clampRange (){for _eadg ,_cd :=range _cg {if _cd > _ceb {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cd ,_ceb );_cg [_eadg ]=_ceb ;}else if _cd < -_ceb {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cd ,-_ceb );
_cg [_eadg ]=-_ceb ;};};};func (_dfdg *Point )Set (x ,y float64 ){_dfdg .X ,_dfdg .Y =x ,y };const _edb =1e-10;func (_ccgg Point )Rotate (theta float64 )Point {_ebg :=_e .Hypot (_ccgg .X ,_ccgg .Y );_ef :=_e .Atan2 (_ccgg .Y ,_ccgg .X );_gaa ,_aac :=_e .Sincos (_ef +theta /180.0*_e .Pi );
return Point {_ebg *_aac ,_ebg *_gaa };};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};const _ceb =1e9;func (_fa Point )Displace (delta Point )Point {return Point {_fa .X +delta .X ,_fa .Y +delta .Y }};
type Matrix [9]float64 ;func (_ag Matrix )Singular ()bool {return _e .Abs (_ag [0]*_ag [4]-_ag [1]*_ag [3])< _edb };func (_eab Matrix )Inverse ()(Matrix ,bool ){_gae ,_ccg :=_eab [0],_eab [1];_fcd ,_eadf :=_eab [3],_eab [4];_ccdd ,_ce :=_eab [6],_eab [7];
_ee :=_gae *_eadf -_ccg *_fcd ;if _e .Abs (_ee )< _dda {return Matrix {},false ;};_bd ,_acc :=_eadf /_ee ,-_ccg /_ee ;_fcc ,_gg :=-_fcd /_ee ,_gae /_ee ;_fcg :=-(_bd *_ccdd +_fcc *_ce );_ad :=-(_acc *_ccdd +_gg *_ce );return NewMatrix (_bd ,_acc ,_fcc ,_gg ,_fcg ,_ad ),true ;
};func (_ca Matrix )String ()string {_af ,_ac ,_aa ,_ed ,_g ,_gb :=_ca [0],_ca [1],_ca [3],_ca [4],_ca [6],_ca [7];return _cc .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_af ,_ac ,_aa ,_ed ,_g ,_gb );
};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_gga Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gga .X +t *b .X ,Y :(1-t )*_gga .Y +t *b .Y };};func (_df Matrix )Identity ()bool {return _df [0]==1&&_df [1]==0&&_df [2]==0&&_df [3]==0&&_df [4]==1&&_df [5]==0&&_df [6]==0&&_df [7]==0&&_df [8]==1;
};func (_bg Matrix )Translation ()(float64 ,float64 ){return _bg [6],_bg [7]};func (_eg *Matrix )Shear (x ,y float64 ){_eg .Concat (ShearMatrix (x ,y ))};func (_ff Matrix )Unrealistic ()bool {_eef ,_dfd ,_dc ,_egf :=_e .Abs (_ff [0]),_e .Abs (_ff [1]),_e .Abs (_ff [3]),_e .Abs (_ff [4]);
_fe :=_eef > _eeb &&_egf > _eeb ;_ddg :=_dfd > _eeb &&_dc > _eeb ;return !(_fe ||_ddg );};func (_b Matrix )Round (precision float64 )Matrix {for _dd :=range _b {_b [_dd ]=_e .Round (_b [_dd ]/precision )*precision ;};return _b ;};func (_ccb Matrix )Mult (b Matrix )Matrix {_ccb .Concat (b );
return _ccb };func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_a :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_a .clampRange ();return _a ;};func (_ead *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ead [0],_ead [1]=a ,b ;_ead [3],_ead [4]=c ,d ;_ead [6],_ead [7]=tx ,ty ;
_ead .clampRange ();};func (_fab *Point )transformByMatrix (_da Matrix ){_fab .X ,_fab .Y =_da .Transform (_fab .X ,_fab .Y )};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};