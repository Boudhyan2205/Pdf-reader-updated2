//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_gd "github.com/unidoc/unipdf/v3/common";_b "math";);func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};
func (_dbd Matrix )ScalingFactorY ()float64 {return _b .Hypot (_dbd [3],_dbd [4])};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_dbdc Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_dbdc .X +t *b .X ,Y :(1-t )*_dbdc .Y +t *b .Y };
};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_abc *Point )transformByMatrix (_bba Matrix ){_abc .X ,_abc .Y =_bba .Transform (_abc .X ,_abc .Y )};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func (_bcb Point )Distance (b Point )float64 {return _b .Hypot (_bcb .X -b .X ,_bcb .Y -b .Y )};const _ed =1e-6;func (_bcc Matrix )Unrealistic ()bool {_agf ,_ec ,_da ,_ee :=_b .Abs (_bcc [0]),_b .Abs (_bcc [1]),_b .Abs (_bcc [3]),_b .Abs (_bcc [4]);_ccb :=_agf > _ed &&_ee > _ed ;
_efb :=_ec > _ed &&_da > _ed ;return !(_ccb ||_efb );};func (_dc Matrix )Rotate (theta float64 )Matrix {return _dc .Mult (RotationMatrix (theta ))};func (_ef Matrix )ScalingFactorX ()float64 {return _b .Hypot (_ef [0],_ef [1])};func (_ag Matrix )Translate (tx ,ty float64 )Matrix {return _ag .Mult (TranslationMatrix (tx ,ty ))};
func RotationMatrix (angle float64 )Matrix {_fg :=_b .Cos (angle );_fb :=_b .Sin (angle );return NewMatrix (_fg ,_fb ,-_fb ,_fg ,0,0);};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_gfg Point )Displace (delta Point )Point {return Point {_gfg .X +delta .X ,_gfg .Y +delta .Y }};
func (_bbe *Matrix )Shear (x ,y float64 ){_bbe .Concat (ShearMatrix (x ,y ))};func (_fd Matrix )Round (precision float64 )Matrix {for _gg :=range _fd {_fd [_gg ]=_b .Round (_fd [_gg ]/precision )*precision ;};return _fd ;};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_d :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_d .clampRange ();return _d ;};const _gcc =1.0e-6;const _bbf =1e-10;func (_ce Matrix )Angle ()float64 {_fc :=_b .Atan2 (-_ce [1],_ce [0]);if _fc < 0.0{_fc +=2*_b .Pi ;};return _fc /_b .Pi *180.0;};func (_cg Matrix )Transform (x ,y float64 )(float64 ,float64 ){_dda :=x *_cg [0]+y *_cg [3]+_cg [6];
_bg :=x *_cg [1]+y *_cg [4]+_cg [7];return _dda ,_bg ;};type Point struct{X float64 ;Y float64 ;};func (_db Matrix )Singular ()bool {return _b .Abs (_db [0]*_db [4]-_db [1]*_db [3])< _bbf };func (_gga Matrix )Identity ()bool {return _gga [0]==1&&_gga [1]==0&&_gga [2]==0&&_gga [3]==0&&_gga [4]==1&&_gga [5]==0&&_gga [6]==0&&_gga [7]==0&&_gga [8]==1;
};func (_cecf *Matrix )clampRange (){for _cc ,_eg :=range _cecf {if _eg > _ffc {_gd .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_eg ,_ffc );_cecf [_cc ]=_ffc ;}else if _eg < -_ffc {_gd .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_eg ,-_ffc );
_cecf [_cc ]=-_ffc ;};};};func (_fce Point )Rotate (theta float64 )Point {_bgc :=_b .Hypot (_fce .X ,_fce .Y );_bd :=_b .Atan2 (_fce .Y ,_fce .X );_efe ,_eeb :=_b .Sincos (_bd +theta /180.0*_b .Pi );return Point {_bgc *_eeb ,_bgc *_efe };};func (_fbe *Matrix )Concat (b Matrix ){*_fbe =Matrix {b [0]*_fbe [0]+b [1]*_fbe [3],b [0]*_fbe [1]+b [1]*_fbe [4],0,b [3]*_fbe [0]+b [4]*_fbe [3],b [3]*_fbe [1]+b [4]*_fbe [4],0,b [6]*_fbe [0]+b [7]*_fbe [3]+_fbe [6],b [6]*_fbe [1]+b [7]*_fbe [4]+_fbe [7],1};
_fbe .clampRange ();};func (_bbc *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_bbc [0],_bbc [1]=a ,b ;_bbc [3],_bbc [4]=c ,d ;_bbc [6],_bbc [7]=tx ,ty ;_bbc .clampRange ();};func (_fa *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fe :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_fa .transformByMatrix (_fe );};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_bb Matrix )String ()string {_gb ,_e ,_dd ,_df ,_a ,_fgg :=_bb [0],_bb [1],_bb [3],_bb [4],_bb [6],_bb [7];return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_gb ,_e ,_dd ,_df ,_a ,_fgg );
};const _ffc =1e9;func (_gf Matrix )Translation ()(float64 ,float64 ){return _gf [6],_gf [7]};func (_c Matrix )Mult (b Matrix )Matrix {_c .Concat (b );return _c };func (_ffcc *Point )Set (x ,y float64 ){_ffcc .X ,_ffcc .Y =x ,y };func (_cb Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_cb .X ,_cb .Y );
};func (_aa Matrix )Inverse ()(Matrix ,bool ){_dg ,_dgc :=_aa [0],_aa [1];_cgf ,_ff :=_aa [3],_aa [4];_cec ,_age :=_aa [6],_aa [7];_ab :=_dg *_ff -_dgc *_cgf ;if _b .Abs (_ab )< _gcc {return Matrix {},false ;};_fff ,_abd :=_ff /_ab ,-_dgc /_ab ;_gfa ,_fdd :=-_cgf /_ab ,_dg /_ab ;
_gdc :=-(_fff *_cec +_gfa *_age );_ea :=-(_abd *_cec +_fdd *_age );return NewMatrix (_fff ,_abd ,_gfa ,_fdd ,_gdc ,_ea ),true ;};func (_gc *Matrix )Clone ()Matrix {return NewMatrix (_gc [0],_gc [1],_gc [3],_gc [4],_gc [6],_gc [7])};type Matrix [9]float64 ;
func (_bc Matrix )Scale (xScale ,yScale float64 )Matrix {return _bc .Mult (ScaleMatrix (xScale ,yScale ))};