//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_a "fmt";_b "github.com/unidoc/unipdf/v3/common";_g "math";);func (_dc *Matrix )Clone ()Matrix {return NewMatrix (_dc [0],_dc [1],_dc [3],_dc [4],_dc [6],_dc [7])};func (_ggd Matrix )Angle ()float64 {_da :=_g .Atan2 (-_ggd [1],_ggd [0]);
if _da < 0.0{_da +=2*_g .Pi ;};return _da /_g .Pi *180.0;};func (_ag Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ag .X ,_ag .Y );};const _adc =1e9;func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};
func (_fe Matrix )String ()string {_ga ,_ae ,_df ,_fde ,_bf ,_ce :=_fe [0],_fe [1],_fe [3],_fe [4],_fe [6],_fe [7];return _a .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ga ,_ae ,_df ,_fde ,_bf ,_ce );
};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ef :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ef .clampRange ();return _ef ;};const _fb =1.0e-6;func (_ebc *Point )Set (x ,y float64 ){_ebc .X ,_ebc .Y =x ,y };
func (_gb Matrix )Scale (xScale ,yScale float64 )Matrix {return _gb .Mult (ScaleMatrix (xScale ,yScale ))};const _ba =1e-10;func (_eb *Matrix )Shear (x ,y float64 ){_eb .Concat (ShearMatrix (x ,y ))};func (_ceg *Matrix )clampRange (){for _bagd ,_cgc :=range _ceg {if _cgc > _adc {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cgc ,_adc );
_ceg [_bagd ]=_adc ;}else if _cgc < -_adc {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cgc ,-_adc );_ceg [_bagd ]=-_adc ;};};};func (_bfb Matrix )Translation ()(float64 ,float64 ){return _bfb [6],_bfb [7]};
func (_d Matrix )Identity ()bool {return _d [0]==1&&_d [1]==0&&_d [2]==0&&_d [3]==0&&_d [4]==1&&_d [5]==0&&_d [6]==0&&_d [7]==0&&_d [8]==1;};func (_cga Matrix )ScalingFactorY ()float64 {return _g .Hypot (_cga [3],_cga [4])};func (_bc *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_dag :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_bc .transformByMatrix (_dag );};func (_ab Matrix )Rotate (theta float64 )Matrix {return _ab .Mult (RotationMatrix (theta ))};func (_bec Point )Rotate (theta float64 )Point {_de :=_g .Hypot (_bec .X ,_bec .Y );_ed :=_g .Atan2 (_bec .Y ,_bec .X );_bddf ,_eae :=_g .Sincos (_ed +theta /180.0*_g .Pi );
return Point {_de *_eae ,_de *_bddf };};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_cgcb Point )Distance (b Point )float64 {return _g .Hypot (_cgcb .X -b .X ,_cgcb .Y -b .Y )};
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_fd Matrix )Round (precision float64 )Matrix {for _c :=range _fd {_fd [_c ]=_g .Round (_fd [_c ]/precision )*precision ;
};return _fd ;};const _fea =1e-6;func (_gga Matrix )Translate (tx ,ty float64 )Matrix {return _gga .Mult (TranslationMatrix (tx ,ty ))};func (_bef Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_bef .X +t *b .X ,Y :(1-t )*_bef .Y +t *b .Y };
};func (_ca *Point )transformByMatrix (_aeec Matrix ){_ca .X ,_ca .Y =_aeec .Transform (_ca .X ,_ca .Y )};type Point struct{X float64 ;Y float64 ;};type Matrix [9]float64 ;func (_ff Matrix )Mult (b Matrix )Matrix {_ff .Concat (b );return _ff };func (_cf Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ffa :=x *_cf [0]+y *_cf [3]+_cf [6];
_cg :=x *_cf [1]+y *_cf [4]+_cf [7];return _ffa ,_cg ;};func RotationMatrix (angle float64 )Matrix {_gg :=_g .Cos (angle );_e :=_g .Sin (angle );return NewMatrix (_gg ,_e ,-_e ,_gg ,0,0);};func (_bag Matrix )ScalingFactorX ()float64 {return _g .Hypot (_bag [0],_bag [1])};
func (_ea *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ea [0],_ea [1]=a ,b ;_ea [3],_ea [4]=c ,d ;_ea [6],_ea [7]=tx ,ty ;_ea .clampRange ();};func (_ggag Matrix )Inverse ()(Matrix ,bool ){_bd ,_eab :=_ggag [0],_ggag [1];_ad ,_baf :=_ggag [3],_ggag [4];
_gf ,_bdd :=_ggag [6],_ggag [7];_aee :=_bd *_baf -_eab *_ad ;if _g .Abs (_aee )< _fb {return Matrix {},false ;};_gd ,_cfe :=_baf /_aee ,-_eab /_aee ;_add ,_be :=-_ad /_aee ,_bd /_aee ;_cgf :=-(_gd *_gf +_add *_bdd );_dd :=-(_cfe *_gf +_be *_bdd );return NewMatrix (_gd ,_cfe ,_add ,_be ,_cgf ,_dd ),true ;
};func (_ee Matrix )Singular ()bool {return _g .Abs (_ee [0]*_ee [4]-_ee [1]*_ee [3])< _ba };func (_dg *Matrix )Concat (b Matrix ){*_dg =Matrix {b [0]*_dg [0]+b [1]*_dg [3],b [0]*_dg [1]+b [1]*_dg [4],0,b [3]*_dg [0]+b [4]*_dg [3],b [3]*_dg [1]+b [4]*_dg [4],0,b [6]*_dg [0]+b [7]*_dg [3]+_dg [6],b [6]*_dg [1]+b [7]*_dg [4]+_dg [7],1};
_dg .clampRange ();};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_gbe Matrix )Unrealistic ()bool {_eg ,_baa ,_cgff ,_ec :=_g .Abs (_gbe [0]),_g .Abs (_gbe [1]),_g .Abs (_gbe [3]),_g .Abs (_gbe [4]);_gag :=_eg > _fea &&_ec > _fea ;
_fc :=_baa > _fea &&_cgff > _fea ;return !(_gag ||_fc );};func (_gdd Point )Displace (delta Point )Point {return Point {_gdd .X +delta .X ,_gdd .Y +delta .Y }};