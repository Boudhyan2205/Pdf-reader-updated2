//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_f "fmt";_ec "github.com/unidoc/unipdf/v3/common";_e "math";);const _gef =1e-10;func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_gb *Matrix )clampRange (){for _bc ,_ff :=range _gb {if _ff > _cg {_ec .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ff ,_cg );_gb [_bc ]=_cg ;}else if _ff < -_cg {_ec .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ff ,-_cg );
_gb [_bc ]=-_cg ;};};};func (_fgg Point )Displace (delta Point )Point {return Point {_fgg .X +delta .X ,_fgg .Y +delta .Y }};const _ecb =1e-6;func (_ecc *Matrix )Shear (x ,y float64 ){_ecc .Concat (ShearMatrix (x ,y ))};func RotationMatrix (angle float64 )Matrix {_d :=_e .Cos (angle );
_bd :=_e .Sin (angle );return NewMatrix (_d ,_bd ,-_bd ,_d ,0,0);};func (_dd Point )Rotate (theta float64 )Point {_cfde :=_e .Hypot (_dd .X ,_dd .Y );_aab :=_e .Atan2 (_dd .Y ,_dd .X );_aag ,_af :=_e .Sincos (_aab +theta /180.0*_e .Pi );return Point {_cfde *_af ,_cfde *_aag };
};func (_bgec Matrix )ScalingFactorY ()float64 {return _e .Hypot (_bgec [3],_bgec [4])};func (_cb *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_cb [0],_cb [1]=a ,b ;_cb [3],_cb [4]=c ,d ;_cb [6],_cb [7]=tx ,ty ;_cb .clampRange ();};const _gbe =1.0e-6;func (_bf Matrix )Rotate (theta float64 )Matrix {return _bf .Mult (RotationMatrix (theta ))};
func (_ab Matrix )Unrealistic ()bool {_ea ,_cfd ,_bca ,_feb :=_e .Abs (_ab [0]),_e .Abs (_ab [1]),_e .Abs (_ab [3]),_e .Abs (_ab [4]);_fga :=_ea > _ecb &&_feb > _ecb ;_eeg :=_cfd > _ecb &&_bca > _ecb ;return !(_fga ||_eeg );};func (_ag *Point )transformByMatrix (_ecd Matrix ){_ag .X ,_ag .Y =_ecd .Transform (_ag .X ,_ag .Y )};
func (_fe *Matrix )Clone ()Matrix {return NewMatrix (_fe [0],_fe [1],_fe [3],_fe [4],_fe [6],_fe [7])};func (_gg Matrix )Identity ()bool {return _gg [0]==1&&_gg [1]==0&&_gg [2]==0&&_gg [3]==0&&_gg [4]==1&&_gg [5]==0&&_gg [6]==0&&_gg [7]==0&&_gg [8]==1;
};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_ga Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bge :=x *_ga [0]+y *_ga [3]+_ga [6];_ce :=x *_ga [1]+y *_ga [4]+_ga [7];
return _bge ,_ce ;};func (_eg Matrix )Inverse ()(Matrix ,bool ){_gf ,_dc :=_eg [0],_eg [1];_gc ,_bfd :=_eg [3],_eg [4];_cd ,_cag :=_eg [6],_eg [7];_fb :=_gf *_bfd -_dc *_gc ;if _e .Abs (_fb )< _gbe {return Matrix {},false ;};_dg ,_cda :=_bfd /_fb ,-_dc /_fb ;
_eeb ,_eed :=-_gc /_fb ,_gf /_fb ;_fbb :=-(_dg *_cd +_eeb *_cag );_ecf :=-(_cda *_cd +_eed *_cag );return NewMatrix (_dg ,_cda ,_eeb ,_eed ,_fbb ,_ecf ),true ;};func (_eb Matrix )ScalingFactorX ()float64 {return _e .Hypot (_eb [0],_eb [1])};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};
func (_bb Matrix )Translation ()(float64 ,float64 ){return _bb [6],_bb [7]};const _cg =1e9;func (_g Matrix )Round (precision float64 )Matrix {for _b :=range _g {_g [_b ]=_e .Round (_g [_b ]/precision )*precision ;};return _g ;};func (_bdd Matrix )Translate (tx ,ty float64 )Matrix {return _bdd .Mult (TranslationMatrix (tx ,ty ))};
func (_bbcf Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_bbcf .X +t *b .X ,Y :(1-t )*_bbcf .Y +t *b .Y };};func (_bbc Point )Distance (b Point )float64 {return _e .Hypot (_bbc .X -b .X ,_bbc .Y -b .Y )};func (_ae *Matrix )Concat (b Matrix ){*_ae =Matrix {b [0]*_ae [0]+b [1]*_ae [3],b [0]*_ae [1]+b [1]*_ae [4],0,b [3]*_ae [0]+b [4]*_ae [3],b [3]*_ae [1]+b [4]*_ae [4],0,b [6]*_ae [0]+b [7]*_ae [3]+_ae [6],b [6]*_ae [1]+b [7]*_ae [4]+_ae [7],1};
_ae .clampRange ();};func (_ge Matrix )Scale (xScale ,yScale float64 )Matrix {return _ge .Mult (ScaleMatrix (xScale ,yScale ))};func (_df Matrix )String ()string {_fg ,_ca ,_ee ,_cf ,_bg ,_ba :=_df [0],_df [1],_df [3],_df [4],_df [6],_df [7];return _f .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_fg ,_ca ,_ee ,_cf ,_bg ,_ba );
};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_a :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_a .clampRange ();return _a ;};func (_ecfe Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ecfe .X ,_ecfe .Y );
};type Matrix [9]float64 ;func (_aa *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_gcf :=NewMatrix (a ,b ,c ,d ,tx ,ty );_aa .transformByMatrix (_gcf );};type Point struct{X float64 ;Y float64 ;};func (_de Matrix )Mult (b Matrix )Matrix {_de .Concat (b );
return _de };func (_bff *Point )Set (x ,y float64 ){_bff .X ,_bff .Y =x ,y };func (_dfc Matrix )Singular ()bool {return _e .Abs (_dfc [0]*_dfc [4]-_dfc [1]*_dfc [3])< _gef };func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_fgc Matrix )Angle ()float64 {_fd :=_e .Atan2 (-_fgc [1],_fgc [0]);if _fd < 0.0{_fd +=2*_e .Pi ;};return _fd /_e .Pi *180.0;};