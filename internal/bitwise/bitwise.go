//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_ag "encoding/binary";_eg "errors";_aa "github.com/unidoc/unipdf/v3/common";_ee "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_eacg *Reader )Length ()uint64 {return uint64 (len (_eacg ._aad ))};func (_af *BufferedWriter )WriteByte (bt byte )error {if _af ._b > len (_af ._d )-1||(_af ._b ==len (_af ._d )-1&&_af ._eb !=0){_af .expandIfNeeded (1);
};_af .writeByte (bt );return nil ;};type BinaryWriter interface{BitWriter ;_e .Writer ;_e .ByteWriter ;Data ()[]byte ;};func (_eee *BufferedWriter )Write (d []byte )(int ,error ){_eee .expandIfNeeded (len (d ));if _eee ._eb ==0{return _eee .writeFullBytes (d ),nil ;
};return _eee .writeShiftedBytes (d ),nil ;};func (_f *BufferedWriter )Reset (){_f ._d =_f ._d [:0];_f ._b =0;_f ._eb =0};func (_gfbg *SubstreamReader )readUnalignedByte ()(_beb byte ,_afdd error ){_defd :=_gfbg ._ad ;_beb =_gfbg ._bee <<(8-_defd );_gfbg ._bee ,_afdd =_gfbg .readBufferByte ();
if _afdd !=nil {return 0,_afdd ;};_beb |=_gfbg ._bee >>_defd ;_gfbg ._bee &=1<<_defd -1;return _beb ,nil ;};func (_egb *Reader )StreamPosition ()int64 {return _egb ._abge };func (_cc *Reader )BitPosition ()int {return int (_cc ._ea )};type Reader struct{_aad []byte ;
_efc byte ;_ea byte ;_abge int64 ;_dc int ;_dab int ;_gcd int64 ;_cea byte ;};func (_eag *SubstreamReader )Align ()(_ggf byte ){_ggf =_eag ._ad ;_eag ._ad =0;return _ggf };func (_egag *Writer )byteCapacity ()int {_dgeb :=len (_egag ._dac )-_egag ._fda ;
if _egag ._bbc !=0{_dgeb --;};return _dgeb ;};func (_be *BufferedWriter )Len ()int {return _be .byteCapacity ()};func (_aec *SubstreamReader )Read (b []byte )(_ecg int ,_gcca error ){if _aec ._afa >=_aec ._daf {_aa .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_aec ._afa ,_aec ._daf );
return 0,_e .EOF ;};for ;_ecg < len (b );_ecg ++{if b [_ecg ],_gcca =_aec .readUnalignedByte ();_gcca !=nil {if _gcca ==_e .EOF {return _ecg ,nil ;};return 0,_gcca ;};};return _ecg ,nil ;};func (_ca *BufferedWriter )writeShiftedBytes (_ace []byte )int {for _ ,_ggb :=range _ace {_ca .writeByte (_ggb );
};return len (_ace );};func (_acee *SubstreamReader )Offset ()uint64 {return _acee ._ddc };func (_bgc *Writer )WriteByte (c byte )error {return _bgc .writeByte (c )};func (_bcd *Reader )ReadByte ()(byte ,error ){if _bcd ._ea ==0{return _bcd .readBufferByte ();
};return _bcd .readUnalignedByte ();};func (_dbd *Reader )ReadBit ()(_gde int ,_agfb error ){_aff ,_agfb :=_dbd .readBool ();if _agfb !=nil {return 0,_agfb ;};if _aff {_gde =1;};return _gde ,nil ;};func (_age *BufferedWriter )FinishByte (){if _age ._eb ==0{return ;
};_age ._eb =0;_age ._b ++;};func (_fdbf *Writer )writeBit (_agcf uint8 )error {if len (_fdbf ._dac )-1< _fdbf ._fda {return _e .EOF ;};_bfc :=_fdbf ._bbc ;if _fdbf ._ddf {_bfc =7-_fdbf ._bbc ;};_fdbf ._dac [_fdbf ._fda ]|=byte (uint16 (_agcf <<_bfc )&0xff);
_fdbf ._bbc ++;if _fdbf ._bbc ==8{_fdbf ._fda ++;_fdbf ._bbc =0;};return nil ;};func _cab (_ada ,_agg uint64 )uint64 {if _ada < _agg {return _ada ;};return _agg ;};func (_dge *Reader )Align ()(_cbf byte ){_cbf =_dge ._ea ;_dge ._ea =0;return _cbf };func (_abg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_cb :=int (_abg ._eb )+skip ;if _cb >=0&&_cb < 8{_abg ._eb =uint8 (_cb );return nil ;};_cb =int (_abg ._eb )+_abg ._b *8+skip ;if _cb < 0{return _ee .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ce :=_cb /8;_bec :=_cb %8;_abg ._eb =uint8 (_bec );if _fa :=_ce -_abg ._b ;_fa > 0&&len (_abg ._d )-1< _ce {if _abg ._eb !=0{_fa ++;};_abg .expandIfNeeded (_fa );};_abg ._b =_ce ;return nil ;};func (_cae *Reader )Read (p []byte )(_cf int ,_fgg error ){if _cae ._ea ==0{return _cae .read (p );
};for ;_cf < len (p );_cf ++{if p [_cf ],_fgg =_cae .readUnalignedByte ();_fgg !=nil {return 0,_fgg ;};};return _cf ,nil ;};func (_fac *SubstreamReader )BitPosition ()int {return int (_fac ._ad )};func NewWriter (data []byte )*Writer {return &Writer {_dac :data }};
func (_bedb *Reader )read (_bbab []byte )(int ,error ){if _bedb ._abge >=int64 (len (_bedb ._aad )){return 0,_e .EOF ;};_bedb ._dab =-1;_aaf :=copy (_bbab ,_bedb ._aad [_bedb ._abge :]);_bedb ._abge +=int64 (_aaf );return _aaf ,nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_eg .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_aa .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_cbd :r ,_ddc :offset ,_daf :length ,_bga :make ([]byte ,length )},nil ;};func (_acg *Reader )ReadBits (n byte )(_fc uint64 ,_acd error ){if n < _acg ._ea {_gdb :=_acg ._ea -n ;_fc =uint64 (_acg ._efc >>_gdb );_acg ._efc &=1<<_gdb -1;
_acg ._ea =_gdb ;return _fc ,nil ;};if n > _acg ._ea {if _acg ._ea > 0{_fc =uint64 (_acg ._efc );n -=_acg ._ea ;};for n >=8{_bg ,_fge :=_acg .readBufferByte ();if _fge !=nil {return 0,_fge ;};_fc =_fc <<8+uint64 (_bg );n -=8;};if n > 0{if _acg ._efc ,_acd =_acg .readBufferByte ();
_acd !=nil {return 0,_acd ;};_ed :=8-n ;_fc =_fc <<n +uint64 (_acg ._efc >>_ed );_acg ._efc &=1<<_ed -1;_acg ._ea =_ed ;}else {_acg ._ea =0;};return _fc ,nil ;};_acg ._ea =0;return uint64 (_acg ._efc ),nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_dac :data ,_ddf :true }};
func (_ef *BufferedWriter )writeByte (_abc byte ){switch {case _ef ._eb ==0:_ef ._d [_ef ._b ]=_abc ;_ef ._b ++;case _ef ._ge :_ef ._d [_ef ._b ]|=_abc >>_ef ._eb ;_ef ._b ++;_ef ._d [_ef ._b ]=byte (uint16 (_abc )<<(8-_ef ._eb )&0xff);default:_ef ._d [_ef ._b ]|=byte (uint16 (_abc )<<_ef ._eb &0xff);
_ef ._b ++;_ef ._d [_ef ._b ]=_abc >>(8-_ef ._eb );};};func (_fad *SubstreamReader )ReadUint32 ()(uint32 ,error ){_dgc :=make ([]byte ,4);_ ,_cddb :=_fad .Read (_dgc );if _cddb !=nil {return 0,_cddb ;};return _ag .BigEndian .Uint32 (_dgc ),nil ;};func (_gccb *Writer )WriteBits (bits uint64 ,number int )(_edb int ,_aedc error ){const _cbdb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_ee .Errorf (_cbdb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_fggd :=number /8;if _fggd > 0{_cff :=number -_fggd *8;for _bbca :=_fggd -1;_bbca >=0;_bbca --{_edc :=byte ((bits >>uint (_bbca *8+_cff ))&0xff);if _aedc =_gccb .WriteByte (_edc );_aedc !=nil {return _edb ,_ee .Wrapf (_aedc ,_cbdb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fggd -_bbca +1);
};};number -=_fggd *8;if number ==0{return _fggd ,nil ;};};var _bbdg int ;for _afef :=0;_afef < number ;_afef ++{if _gccb ._ddf {_bbdg =int ((bits >>uint (number -1-_afef ))&0x1);}else {_bbdg =int (bits &0x1);bits >>=1;};if _aedc =_gccb .WriteBit (_bbdg );
_aedc !=nil {return _edb ,_ee .Wrapf (_aedc ,_cbdb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_afef );};};return _fggd ,nil ;};type SubstreamReader struct{_afa uint64 ;_cbd StreamReader ;_ddc uint64 ;_daf uint64 ;_bga []byte ;_gfb uint64 ;_dgd uint64 ;_bee byte ;
_ad byte ;_aedb uint64 ;_gbd byte ;};func (_ged *BufferedWriter )byteCapacity ()int {_cdg :=len (_ged ._d )-_ged ._b ;if _ged ._eb !=0{_cdg --;};return _cdg ;};type Writer struct{_dac []byte ;_bbc uint8 ;_fda int ;_ddf bool ;};func (_fdga *SubstreamReader )ReadBit ()(_gfg int ,_agb error ){_de ,_agb :=_fdga .readBool ();
if _agb !=nil {return 0,_agb ;};if _de {_gfg =1;};return _gfg ,nil ;};func (_dfb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ee .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_dfb ._d )-1< _dfb ._b {_dfb .expandIfNeeded (1);};_gc :=_dfb ._eb ;if _dfb ._ge {_gc =7-_dfb ._eb ;};_dfb ._d [_dfb ._b ]|=byte (uint16 (bit <<_gc )&0xff);_dfb ._eb ++;if _dfb ._eb ==8{_dfb ._b ++;_dfb ._eb =0;};return nil ;};var _ BinaryWriter =&Writer {};
func (_fbg *Reader )Reset (){_fbg ._abge =_fbg ._gcd ;_fbg ._ea =_fbg ._cea };func (_fbf *SubstreamReader )Reset (){_fbf ._afa =_fbf ._aedb ;_fbf ._ad =_fbf ._gbd };func (_cd *BufferedWriter )Data ()[]byte {return _cd ._d };func (_ac *BufferedWriter )grow (_bd int ){if _ac ._d ==nil &&_bd < _c {_ac ._d =make ([]byte ,_bd ,_c );
return ;};_gd :=len (_ac ._d );if _ac ._eb !=0{_gd ++;};_aaa :=cap (_ac ._d );switch {case _bd <=_aaa /2-_gd :_aa .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ac ._d ),cap (_ac ._d ),_bd );
_aa .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_aaa ,_gd );copy (_ac ._d ,_ac ._d [_ac .fullOffset ():]);
case _aaa > _ab -_aaa -_bd :_aa .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_cda :=make ([]byte ,2*_aaa +_bd );copy (_cda ,_ac ._d );_ac ._d =_cda ;};_ac ._d =_ac ._d [:_gd +_bd ];
};type BitWriter interface{WriteBit (_gcc int )error ;WriteBits (_ebb uint64 ,_cdb int )(_bed int ,_bc error );FinishByte ();SkipBits (_cba int )error ;};func (_ebg *SubstreamReader )ReadBool ()(bool ,error ){return _ebg .readBool ()};func (_aed *Reader )ConsumeRemainingBits (){if _aed ._ea !=0{_ ,_efca :=_aed .ReadBits (_aed ._ea );
if _efca !=nil {_aa .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_efca );};};};func (_fada *SubstreamReader )fillBuffer ()error {if uint64 (_fada ._cbd .StreamPosition ())!=_fada ._afa +_fada ._ddc {_ ,_fbd :=_fada ._cbd .Seek (int64 (_fada ._afa +_fada ._ddc ),_e .SeekStart );
if _fbd !=nil {return _fbd ;};};_fada ._gfb =_fada ._afa ;_bfb :=_cab (uint64 (len (_fada ._bga )),_fada ._daf -_fada ._afa );_agc :=make ([]byte ,_bfb );_gda ,_aced :=_fada ._cbd .Read (_agc );if _aced !=nil {return _aced ;};for _ddb :=uint64 (0);_ddb < _bfb ;
_ddb ++{_fada ._bga [_ddb ]=_agc [_ddb ];};_fada ._dgd =_fada ._gfb +uint64 (_gda );return nil ;};func (_ebbg *Reader )readBool ()(_dd bool ,_ff error ){if _ebbg ._ea ==0{_ebbg ._efc ,_ff =_ebbg .readBufferByte ();if _ff !=nil {return false ,_ff ;};_dd =(_ebbg ._efc &0x80)!=0;
_ebbg ._efc ,_ebbg ._ea =_ebbg ._efc &0x7f,7;return _dd ,nil ;};_ebbg ._ea --;_dd =(_ebbg ._efc &(1<<_ebbg ._ea ))!=0;_ebbg ._efc &=1<<_ebbg ._ea -1;return _dd ,nil ;};func (_fdb *SubstreamReader )StreamPosition ()int64 {return int64 (_fdb ._afa )};func (_gccf *SubstreamReader )Mark (){_gccf ._aedb =_gccf ._afa ;
_gccf ._gbd =_gccf ._ad };func NewReader (data []byte )*Reader {return &Reader {_aad :data }};func (_ccb *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _e .SeekStart :_ccb ._afa =uint64 (offset );case _e .SeekCurrent :_ccb ._afa +=uint64 (offset );
case _e .SeekEnd :_ccb ._afa =_ccb ._daf +uint64 (offset );default:return 0,_eg .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_ccb ._ad =0;return int64 (_ccb ._afa ),nil ;};func (_aga *BufferedWriter )writeFullBytes (_da []byte )int {_gca :=copy (_aga ._d [_aga .fullOffset ():],_da );_aga ._b +=_gca ;return _gca ;};var _ BinaryWriter =&BufferedWriter {};func (_gf *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_gf ._dab =-1;
var _agfd int64 ;switch whence {case _e .SeekStart :_agfd =offset ;case _e .SeekCurrent :_agfd =_gf ._abge +offset ;case _e .SeekEnd :_agfd =int64 (len (_gf ._aad ))+offset ;default:return 0,_eg .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _agfd < 0{return 0,_eg .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_gf ._abge =_agfd ;
_gf ._ea =0;return _agfd ,nil ;};func (_acb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _acb .writeBit (uint8 (bit ));};return _ee .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_eaf *Writer )SkipBits (skip int )error {const _adb ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_dacd :=int (_eaf ._bbc )+skip ;if _dacd >=0&&_dacd < 8{_eaf ._bbc =uint8 (_dacd );
return nil ;};_dacd =int (_eaf ._bbc )+_eaf ._fda *8+skip ;if _dacd < 0{return _ee .Errorf (_adb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ggc :=_dacd /8;_fddf :=_dacd %8;_aa .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_aa .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_eaf ._bbc ,_eaf ._fda ,int (_eaf ._bbc )+(_eaf ._fda )*8,len (_eaf ._dac ),cap (_eaf ._dac ));
_aa .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_dacd ,_fddf );_eaf ._bbc =uint8 (_fddf );
if _eec :=_ggc -_eaf ._fda ;_eec > 0&&len (_eaf ._dac )-1< _ggc {_aa .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_eec );return _ee .Errorf (_adb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_eaf ._fda =_ggc ;_aa .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_eaf ._bbc ,_eaf ._fda );return nil ;};func (_def *SubstreamReader )readBool ()(_fdd bool ,_bbb error ){if _def ._ad ==0{_def ._bee ,_bbb =_def .readBufferByte ();
if _bbb !=nil {return false ,_bbb ;};_fdd =(_def ._bee &0x80)!=0;_def ._bee ,_def ._ad =_def ._bee &0x7f,7;return _fdd ,nil ;};_def ._ad --;_fdd =(_def ._bee &(1<<_def ._ad ))!=0;_def ._bee &=1<<_def ._ad -1;return _fdd ,nil ;};func (_cgd *Writer )Write (p []byte )(int ,error ){if len (p )> _cgd .byteCapacity (){return 0,_e .EOF ;
};for _ ,_agcb :=range p {if _adbe :=_cgd .writeByte (_agcb );_adbe !=nil {return 0,_adbe ;};};return len (p ),nil ;};func (_dagb *SubstreamReader )ReadByte ()(byte ,error ){if _dagb ._ad ==0{return _dagb .readBufferByte ();};return _dagb .readUnalignedByte ();
};func (_gdd *SubstreamReader )Length ()uint64 {return _gdd ._daf };const (_c =64;_ab =int (^uint (0)>>1););type StreamReader interface{_e .Reader ;_e .ByteReader ;_e .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );
ReadBits (_agf byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_bf *Reader )ReadBool ()(bool ,error ){return _bf .readBool ()};func (_df *BufferedWriter )ResetBitIndex (){_df ._eb =0};
func (_gff *Writer )FinishByte (){if _gff ._bbc ==0{return ;};_gff ._bbc =0;_gff ._fda ++;};var (_ _e .Reader =&Reader {};_ _e .ByteReader =&Reader {};_ _e .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_fdg *BufferedWriter )expandIfNeeded (_abgg int ){if !_fdg .tryGrowByReslice (_abgg ){_fdg .grow (_abgg );
};};func (_fgc *Writer )writeByte (_abb byte )error {if _fgc ._fda > len (_fgc ._dac )-1{return _e .EOF ;};if _fgc ._fda ==len (_fgc ._dac )-1&&_fgc ._bbc !=0{return _e .EOF ;};if _fgc ._bbc ==0{_fgc ._dac [_fgc ._fda ]=_abb ;_fgc ._fda ++;return nil ;
};if _fgc ._ddf {_fgc ._dac [_fgc ._fda ]|=_abb >>_fgc ._bbc ;_fgc ._fda ++;_fgc ._dac [_fgc ._fda ]=byte (uint16 (_abb )<<(8-_fgc ._bbc )&0xff);}else {_fgc ._dac [_fgc ._fda ]|=byte (uint16 (_abb )<<_fgc ._bbc &0xff);_fgc ._fda ++;_fgc ._dac [_fgc ._fda ]=_abb >>(8-_fgc ._bbc );
};return nil ;};func (_bcb *Writer )UseMSB ()bool {return _bcb ._ddf };func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ge :true }};func (_cac *SubstreamReader )ReadBits (n byte )(_fbe uint64 ,_aab error ){if n < _cac ._ad {_ggd :=_cac ._ad -n ;
_fbe =uint64 (_cac ._bee >>_ggd );_cac ._bee &=1<<_ggd -1;_cac ._ad =_ggd ;return _fbe ,nil ;};if n > _cac ._ad {if _cac ._ad > 0{_fbe =uint64 (_cac ._bee );n -=_cac ._ad ;};var _dag byte ;for n >=8{_dag ,_aab =_cac .readBufferByte ();if _aab !=nil {return 0,_aab ;
};_fbe =_fbe <<8+uint64 (_dag );n -=8;};if n > 0{if _cac ._bee ,_aab =_cac .readBufferByte ();_aab !=nil {return 0,_aab ;};_bbd :=8-n ;_fbe =_fbe <<n +uint64 (_cac ._bee >>_bbd );_cac ._bee &=1<<_bbd -1;_cac ._ad =_bbd ;}else {_cac ._ad =0;};return _fbe ,nil ;
};_cac ._ad =0;return uint64 (_cac ._bee ),nil ;};var _ _e .Writer =&BufferedWriter {};func (_eacf *Writer )ResetBit (){_eacf ._bbc =0};var _ _e .ByteWriter =&BufferedWriter {};func (_cagf *Reader )ReadUint32 ()(uint32 ,error ){_dca :=make ([]byte ,4);
_ ,_aag :=_cagf .Read (_dca );if _aag !=nil {return 0,_aag ;};return _ag .BigEndian .Uint32 (_dca ),nil ;};func (_dbe *Reader )readBufferByte ()(byte ,error ){if _dbe ._abge >=int64 (len (_dbe ._aad )){return 0,_e .EOF ;};_dbe ._dab =-1;_cdac :=_dbe ._aad [_dbe ._abge ];
_dbe ._abge ++;_dbe ._dc =int (_cdac );return _cdac ,nil ;};func (_eae *Writer )Data ()[]byte {return _eae ._dac };func (_db *BufferedWriter )WriteBits (bits uint64 ,number int )(_fb int ,_afd error ){const _cdd ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_ee .Errorf (_cdd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_ba :=number /8;if _ba > 0{_bb :=number -_ba *8;for _gg :=_ba -1;_gg >=0;_gg --{_bba :=byte ((bits >>uint (_gg *8+_bb ))&0xff);if _afd =_db .WriteByte (_bba );_afd !=nil {return _fb ,_ee .Wrapf (_afd ,_cdd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ba -_gg +1);
};};number -=_ba *8;if number ==0{return _ba ,nil ;};};var _afb int ;for _fg :=0;_fg < number ;_fg ++{if _db ._ge {_afb =int ((bits >>uint (number -1-_fg ))&0x1);}else {_afb =int (bits &0x1);bits >>=1;};if _afd =_db .WriteBit (_afb );_afd !=nil {return _fb ,_ee .Wrapf (_afd ,_cdd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fg );
};};return _ba ,nil ;};type BufferedWriter struct{_d []byte ;_eb uint8 ;_b int ;_ge bool ;};func (_cg *BufferedWriter )fullOffset ()int {_ec :=_cg ._b ;if _cg ._eb !=0{_ec ++;};return _ec ;};func (_egg *SubstreamReader )readBufferByte ()(byte ,error ){if _egg ._afa >=_egg ._daf {return 0,_e .EOF ;
};if _egg ._afa >=_egg ._dgd ||_egg ._afa < _egg ._gfb {if _ceg :=_egg .fillBuffer ();_ceg !=nil {return 0,_ceg ;};};_cfa :=_egg ._bga [_egg ._afa -_egg ._gfb ];_egg ._afa ++;return _cfa ,nil ;};func (_afdb *Reader )Mark (){_afdb ._gcd =_afdb ._abge ;_afdb ._cea =_afdb ._ea };
func (_bef *BufferedWriter )tryGrowByReslice (_ga int )bool {if _eeg :=len (_bef ._d );_ga <=cap (_bef ._d )-_eeg {_bef ._d =_bef ._d [:_eeg +_ga ];return true ;};return false ;};func (_dcg *Reader )readUnalignedByte ()(_bgg byte ,_fag error ){_eef :=_dcg ._ea ;
_bgg =_dcg ._efc <<(8-_eef );_dcg ._efc ,_fag =_dcg .readBufferByte ();if _fag !=nil {return 0,_fag ;};_bgg |=_dcg ._efc >>_eef ;_dcg ._efc &=1<<_eef -1;return _bgg ,nil ;};