//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_f "encoding/binary";_a "errors";_e "github.com/unidoc/unipdf/v3/common";_cf "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_fc *Reader )Align ()(_dfd byte ){_dfd =_fc ._bb ;_fc ._bb =0;return _dfd };func (_bc *BufferedWriter )Len ()int {return _bc .byteCapacity ()};
func (_de *BufferedWriter )FinishByte (){if _de ._ed ==0{return ;};_de ._ed =0;_de ._ad ++;};func (_bffb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _bffb .writeBit (uint8 (bit ));};return _cf .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_a .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_e .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_cef :r ,_acb :offset ,_cgcg :length ,_bec :make ([]byte ,length )},nil ;};func (_fa *BufferedWriter )writeFullBytes (_bg []byte )int {_ea :=copy (_fa ._ca [_fa .fullOffset ():],_bg );_fa ._ad +=_ea ;return _ea ;};func (_feg *SubstreamReader )fillBuffer ()error {if uint64 (_feg ._cef .StreamPosition ())!=_feg ._agf +_feg ._acb {_ ,_faa :=_feg ._cef .Seek (int64 (_feg ._agf +_feg ._acb ),_b .SeekStart );
if _faa !=nil {return _faa ;};};_feg ._adg =_feg ._agf ;_fbaf :=_aeeb (uint64 (len (_feg ._bec )),_feg ._cgcg -_feg ._agf );_bde :=make ([]byte ,_fbaf );_bbbbd ,_gdf :=_feg ._cef .Read (_bde );if _gdf !=nil {return _gdf ;};for _ccfd :=uint64 (0);_ccfd < _fbaf ;
_ccfd ++{_feg ._bec [_ccfd ]=_bde [_ccfd ];};_feg ._ccg =_feg ._adg +uint64 (_bbbbd );return nil ;};func (_ccf *Reader )ReadUint32 ()(uint32 ,error ){_cce :=make ([]byte ,4);_ ,_geg :=_ccf .Read (_cce );if _geg !=nil {return 0,_geg ;};return _f .BigEndian .Uint32 (_cce ),nil ;
};func (_ggb *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_ggb ._bfe =-1;var _eab int64 ;switch whence {case _b .SeekStart :_eab =offset ;case _b .SeekCurrent :_eab =_ggb ._ff +offset ;case _b .SeekEnd :_eab =int64 (len (_ggb ._def ))+offset ;
default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _eab < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_ggb ._ff =_eab ;_ggb ._bb =0;return _eab ,nil ;};type BitWriter interface{WriteBit (_eba int )error ;WriteBits (_cee uint64 ,_fag int )(_cec int ,_fagf error );FinishByte ();SkipBits (_dae int )error ;};const (_ac =64;_eg =int (^uint (0)>>1););func (_agc *Reader )BitPosition ()int {return int (_agc ._bb )};
func (_edb *Reader )readBool ()(_dbb bool ,_eea error ){if _edb ._bb ==0{_edb ._gcb ,_eea =_edb .readBufferByte ();if _eea !=nil {return false ,_eea ;};_dbb =(_edb ._gcb &0x80)!=0;_edb ._gcb ,_edb ._bb =_edb ._gcb &0x7f,7;return _dbb ,nil ;};_edb ._bb --;
_dbb =(_edb ._gcb &(1<<_edb ._bb ))!=0;_edb ._gcb &=1<<_edb ._bb -1;return _dbb ,nil ;};func (_dd *BufferedWriter )Write (d []byte )(int ,error ){_dd .expandIfNeeded (len (d ));if _dd ._ed ==0{return _dd .writeFullBytes (d ),nil ;};return _dd .writeShiftedBytes (d ),nil ;
};func (_eae *BufferedWriter )writeShiftedBytes (_ged []byte )int {for _ ,_ddd :=range _ged {_eae .writeByte (_ddd );};return len (_ged );};func (_ef *SubstreamReader )Mark (){_ef ._fba =_ef ._agf ;_ef ._bef =_ef ._cad };func (_bbba *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _b .SeekStart :_bbba ._agf =uint64 (offset );
case _b .SeekCurrent :_bbba ._agf +=uint64 (offset );case _b .SeekEnd :_bbba ._agf =_bbba ._cgcg +uint64 (offset );default:return 0,_a .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_bbba ._cad =0;return int64 (_bbba ._agf ),nil ;};func (_cdb *Reader )read (_cgf []byte )(int ,error ){if _cdb ._ff >=int64 (len (_cdb ._def )){return 0,_b .EOF ;};_cdb ._bfe =-1;_cbe :=copy (_cgf ,_cdb ._def [_cdb ._ff :]);_cdb ._ff +=int64 (_cbe );
return _cbe ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_gfa :data ,_ced :true }};func (_eaae *SubstreamReader )Length ()uint64 {return _eaae ._cgcg };func (_gbec *SubstreamReader )ReadUint32 ()(uint32 ,error ){_cfb :=make ([]byte ,4);
_ ,_bbbb :=_gbec .Read (_cfb );if _bbbb !=nil {return 0,_bbbb ;};return _f .BigEndian .Uint32 (_cfb ),nil ;};type Reader struct{_def []byte ;_gcb byte ;_bb byte ;_ff int64 ;_ag int ;_bfe int ;_dgf int64 ;_dc byte ;};type Writer struct{_gfa []byte ;_eecf uint8 ;
_gegd int ;_ced bool ;};func (_cgb *SubstreamReader )ReadByte ()(byte ,error ){if _cgb ._cad ==0{return _cgb .readBufferByte ();};return _cgb .readUnalignedByte ();};func (_gc *BufferedWriter )fullOffset ()int {_db :=_gc ._ad ;if _gc ._ed !=0{_db ++;};
return _db ;};var (_ _b .Reader =&Reader {};_ _b .ByteReader =&Reader {};_ _b .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_gdc *Writer )SkipBits (skip int )error {const _cfcf ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_dac :=int (_gdc ._eecf )+skip ;if _dac >=0&&_dac < 8{_gdc ._eecf =uint8 (_dac );return nil ;};_dac =int (_gdc ._eecf )+_gdc ._gegd *8+skip ;if _dac < 0{return _cf .Errorf (_cfcf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ecdd :=_dac /8;_aeb :=_dac %8;_e .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_e .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_gdc ._eecf ,_gdc ._gegd ,int (_gdc ._eecf )+(_gdc ._gegd )*8,len (_gdc ._gfa ),cap (_gdc ._gfa ));
_e .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_dac ,_aeb );_gdc ._eecf =uint8 (_aeb );if _ggf :=_ecdd -_gdc ._gegd ;
_ggf > 0&&len (_gdc ._gfa )-1< _ecdd {_e .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ggf );return _cf .Errorf (_cfcf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_gdc ._gegd =_ecdd ;_e .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_gdc ._eecf ,_gdc ._gegd );return nil ;};func (_ga *BufferedWriter )WriteByte (bt byte )error {if _ga ._ad > len (_ga ._ca )-1||(_ga ._ad ==len (_ga ._ca )-1&&_ga ._ed !=0){_ga .expandIfNeeded (1);
};_ga .writeByte (bt );return nil ;};func (_aab *SubstreamReader )ReadBool ()(bool ,error ){return _aab .readBool ()};func (_cbd *Writer )byteCapacity ()int {_bdae :=len (_cbd ._gfa )-_cbd ._gegd ;if _cbd ._eecf !=0{_bdae --;};return _bdae ;};func (_fgg *Reader )ReadBits (n byte )(_aa uint64 ,_cb error ){if n < _fgg ._bb {_gag :=_fgg ._bb -n ;
_aa =uint64 (_fgg ._gcb >>_gag );_fgg ._gcb &=1<<_gag -1;_fgg ._bb =_gag ;return _aa ,nil ;};if n > _fgg ._bb {if _fgg ._bb > 0{_aa =uint64 (_fgg ._gcb );n -=_fgg ._bb ;};for n >=8{_gg ,_agcb :=_fgg .readBufferByte ();if _agcb !=nil {return 0,_agcb ;};
_aa =_aa <<8+uint64 (_gg );n -=8;};if n > 0{if _fgg ._gcb ,_cb =_fgg .readBufferByte ();_cb !=nil {return 0,_cb ;};_cdc :=8-n ;_aa =_aa <<n +uint64 (_fgg ._gcb >>_cdc );_fgg ._gcb &=1<<_cdc -1;_fgg ._bb =_cdc ;}else {_fgg ._bb =0;};return _aa ,nil ;};_fgg ._bb =0;
return uint64 (_fgg ._gcb ),nil ;};func (_caf *Reader )ConsumeRemainingBits (){if _caf ._bb !=0{_ ,_gbeg :=_caf .ReadBits (_caf ._bb );if _gbeg !=nil {_e .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_gbeg );
};};};func (_ege *Reader )readUnalignedByte ()(_fe byte ,_geb error ){_fb :=_ege ._bb ;_fe =_ege ._gcb <<(8-_fb );_ege ._gcb ,_geb =_ege .readBufferByte ();if _geb !=nil {return 0,_geb ;};_fe |=_ege ._gcb >>_fb ;_ege ._gcb &=1<<_fb -1;return _fe ,nil ;
};func (_be *BufferedWriter )WriteBits (bits uint64 ,number int )(_dgb int ,_ae error ){const _ec ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_cf .Errorf (_ec ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_gae :=number /8;if _gae > 0{_adc :=number -_gae *8;for _dec :=_gae -1;_dec >=0;_dec --{_cc :=byte ((bits >>uint (_dec *8+_adc ))&0xff);if _ae =_be .WriteByte (_cc );_ae !=nil {return _dgb ,_cf .Wrapf (_ae ,_ec ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gae -_dec +1);
};};number -=_gae *8;if number ==0{return _gae ,nil ;};};var _dad int ;for _gb :=0;_gb < number ;_gb ++{if _be ._g {_dad =int ((bits >>uint (number -1-_gb ))&0x1);}else {_dad =int (bits &0x1);bits >>=1;};if _ae =_be .WriteBit (_dad );_ae !=nil {return _dgb ,_cf .Wrapf (_ae ,_ec ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gb );
};};return _gae ,nil ;};var _ BinaryWriter =&BufferedWriter {};func (_gfg *Writer )UseMSB ()bool {return _gfg ._ced };func (_ada *Writer )WriteByte (c byte )error {return _ada .writeByte (c )};func (_aeeg *SubstreamReader )Offset ()uint64 {return _aeeg ._acb };
func (_dbf *SubstreamReader )ReadBit ()(_fgd int ,_cafe error ){_faeb ,_cafe :=_dbf .readBool ();if _cafe !=nil {return 0,_cafe ;};if _faeb {_fgd =1;};return _fgd ,nil ;};func (_eaa *Reader )ReadByte ()(byte ,error ){if _eaa ._bb ==0{return _eaa .readBufferByte ();
};return _eaa .readUnalignedByte ();};type BufferedWriter struct{_ca []byte ;_ed uint8 ;_ad int ;_g bool ;};func (_cafd *Reader )ReadBool ()(bool ,error ){return _cafd .readBool ()};func (_cae *Writer )writeByte (_bcf byte )error {if _cae ._gegd > len (_cae ._gfa )-1{return _b .EOF ;
};if _cae ._gegd ==len (_cae ._gfa )-1&&_cae ._eecf !=0{return _b .EOF ;};if _cae ._eecf ==0{_cae ._gfa [_cae ._gegd ]=_bcf ;_cae ._gegd ++;return nil ;};if _cae ._ced {_cae ._gfa [_cae ._gegd ]|=_bcf >>_cae ._eecf ;_cae ._gegd ++;_cae ._gfa [_cae ._gegd ]=byte (uint16 (_bcf )<<(8-_cae ._eecf )&0xff);
}else {_cae ._gfa [_cae ._gegd ]|=byte (uint16 (_bcf )<<_cae ._eecf &0xff);_cae ._gegd ++;_cae ._gfa [_cae ._gegd ]=_bcf >>(8-_cae ._eecf );};return nil ;};func NewReader (data []byte )*Reader {return &Reader {_def :data }};func _aeeb (_egg ,_gfc uint64 )uint64 {if _egg < _gfc {return _egg ;
};return _gfc ;};func (_gac *Reader )Reset (){_gac ._ff =_gac ._dgf ;_gac ._bb =_gac ._dc };func (_dfgg *SubstreamReader )ReadBits (n byte )(_cgg uint64 ,_bbb error ){if n < _dfgg ._cad {_cfg :=_dfgg ._cad -n ;_cgg =uint64 (_dfgg ._fge >>_cfg );_dfgg ._fge &=1<<_cfg -1;
_dfgg ._cad =_cfg ;return _cgg ,nil ;};if n > _dfgg ._cad {if _dfgg ._cad > 0{_cgg =uint64 (_dfgg ._fge );n -=_dfgg ._cad ;};var _dbe byte ;for n >=8{_dbe ,_bbb =_dfgg .readBufferByte ();if _bbb !=nil {return 0,_bbb ;};_cgg =_cgg <<8+uint64 (_dbe );n -=8;
};if n > 0{if _dfgg ._fge ,_bbb =_dfgg .readBufferByte ();_bbb !=nil {return 0,_bbb ;};_fdg :=8-n ;_cgg =_cgg <<n +uint64 (_dfgg ._fge >>_fdg );_dfgg ._fge &=1<<_fdg -1;_dfgg ._cad =_fdg ;}else {_dfgg ._cad =0;};return _cgg ,nil ;};_dfgg ._cad =0;return uint64 (_dfgg ._fge ),nil ;
};func (_cd *Reader )Length ()uint64 {return uint64 (len (_cd ._def ))};func (_bcg *SubstreamReader )readBool ()(_daaf bool ,_ddf error ){if _bcg ._cad ==0{_bcg ._fge ,_ddf =_bcg .readBufferByte ();if _ddf !=nil {return false ,_ddf ;};_daaf =(_bcg ._fge &0x80)!=0;
_bcg ._fge ,_bcg ._cad =_bcg ._fge &0x7f,7;return _daaf ,nil ;};_bcg ._cad --;_daaf =(_bcg ._fge &(1<<_bcg ._cad ))!=0;_bcg ._fge &=1<<_bcg ._cad -1;return _daaf ,nil ;};func (_cdg *SubstreamReader )StreamPosition ()int64 {return int64 (_cdg ._agf )};func (_bff *Reader )Read (p []byte )(_dge int ,_bfa error ){if _bff ._bb ==0{return _bff .read (p );
};for ;_dge < len (p );_dge ++{if p [_dge ],_bfa =_bff .readUnalignedByte ();_bfa !=nil {return 0,_bfa ;};};return _dge ,nil ;};func (_fgeg *SubstreamReader )Read (b []byte )(_aad int ,_fae error ){if _fgeg ._agf >=_fgeg ._cgcg {_e .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_fgeg ._agf ,_fgeg ._cgcg );
return 0,_b .EOF ;};for ;_aad < len (b );_aad ++{if b [_aad ],_fae =_fgeg .readUnalignedByte ();_fae !=nil {if _fae ==_b .EOF {return _aad ,nil ;};return 0,_fae ;};};return _aad ,nil ;};func (_af *BufferedWriter )Data ()[]byte {return _af ._ca };func (_ddc *SubstreamReader )Align ()(_cfc byte ){_cfc =_ddc ._cad ;
_ddc ._cad =0;return _cfc };func (_fd *Reader )Mark (){_fd ._dgf =_fd ._ff ;_fd ._dc =_fd ._bb };func (_ace *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_fg :=int (_ace ._ed )+skip ;if _fg >=0&&_fg < 8{_ace ._ed =uint8 (_fg );return nil ;
};_fg =int (_ace ._ed )+_ace ._ad *8+skip ;if _fg < 0{return _cf .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cg :=_fg /8;
_df :=_fg %8;_ace ._ed =uint8 (_df );if _dfg :=_cg -_ace ._ad ;_dfg > 0&&len (_ace ._ca )-1< _cg {if _ace ._ed !=0{_dfg ++;};_ace .expandIfNeeded (_dfg );};_ace ._ad =_cg ;return nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_g :true }};
func (_aadc *SubstreamReader )readBufferByte ()(byte ,error ){if _aadc ._agf >=_aadc ._cgcg {return 0,_b .EOF ;};if _aadc ._agf >=_aadc ._ccg ||_aadc ._agf < _aadc ._adg {if _fgb :=_aadc .fillBuffer ();_fgb !=nil {return 0,_fgb ;};};_bafb :=_aadc ._bec [_aadc ._agf -_aadc ._adg ];
_aadc ._agf ++;return _bafb ,nil ;};func (_gbe *BufferedWriter )writeByte (_aec byte ){switch {case _gbe ._ed ==0:_gbe ._ca [_gbe ._ad ]=_aec ;_gbe ._ad ++;case _gbe ._g :_gbe ._ca [_gbe ._ad ]|=_aec >>_gbe ._ed ;_gbe ._ad ++;_gbe ._ca [_gbe ._ad ]=byte (uint16 (_aec )<<(8-_gbe ._ed )&0xff);
default:_gbe ._ca [_gbe ._ad ]|=byte (uint16 (_aec )<<_gbe ._ed &0xff);_gbe ._ad ++;_gbe ._ca [_gbe ._ad ]=_aec >>(8-_gbe ._ed );};};func (_eda *BufferedWriter )ResetBitIndex (){_eda ._ed =0};func NewWriter (data []byte )*Writer {return &Writer {_gfa :data }};
func (_eef *Writer )Data ()[]byte {return _eef ._gfa };func (_gcd *Writer )writeBit (_cda uint8 )error {if len (_gcd ._gfa )-1< _gcd ._gegd {return _b .EOF ;};_eeag :=_gcd ._eecf ;if _gcd ._ced {_eeag =7-_gcd ._eecf ;};_gcd ._gfa [_gcd ._gegd ]|=byte (uint16 (_cda <<_eeag )&0xff);
_gcd ._eecf ++;if _gcd ._eecf ==8{_gcd ._gegd ++;_gcd ._eecf =0;};return nil ;};func (_edd *BufferedWriter )expandIfNeeded (_ecg int ){if !_edd .tryGrowByReslice (_ecg ){_edd .grow (_ecg );};};type BinaryWriter interface{BitWriter ;_b .Writer ;_b .ByteWriter ;
Data ()[]byte ;};func (_ge *BufferedWriter )byteCapacity ()int {_acg :=len (_ge ._ca )-_ge ._ad ;if _ge ._ed !=0{_acg --;};return _acg ;};var _ _b .ByteWriter =&BufferedWriter {};type SubstreamReader struct{_agf uint64 ;_cef StreamReader ;_acb uint64 ;
_cgcg uint64 ;_bec []byte ;_adg uint64 ;_ccg uint64 ;_fge byte ;_cad byte ;_fba uint64 ;_bef byte ;};func (_acc *Reader )StreamPosition ()int64 {return _acc ._ff };type StreamReader interface{_b .Reader ;_b .ByteReader ;_b .Seeker ;Align ()byte ;BitPosition ()int ;
Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_aeg byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_gec *SubstreamReader )Reset (){_gec ._agf =_gec ._fba ;_gec ._cad =_gec ._bef };
func (_eb *BufferedWriter )grow (_cgc int ){if _eb ._ca ==nil &&_cgc < _ac {_eb ._ca =make ([]byte ,_cgc ,_ac );return ;};_bd :=len (_eb ._ca );if _eb ._ed !=0{_bd ++;};_ab :=cap (_eb ._ca );switch {case _cgc <=_ab /2-_bd :_e .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_eb ._ca ),cap (_eb ._ca ),_cgc );
_e .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ab ,_bd );copy (_eb ._ca ,_eb ._ca [_eb .fullOffset ():]);
case _ab > _eg -_ab -_cgc :_e .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_gd :=make ([]byte ,2*_ab +_cgc );copy (_gd ,_eb ._ca );_eb ._ca =_gd ;};_eb ._ca =_eb ._ca [:_bd +_cgc ];
};func (_dfdg *Writer )FinishByte (){if _dfdg ._eecf ==0{return ;};_dfdg ._eecf =0;_dfdg ._gegd ++;};func (_daa *BufferedWriter )tryGrowByReslice (_ebg int )bool {if _dbc :=len (_daa ._ca );_ebg <=cap (_daa ._ca )-_dbc {_daa ._ca =_daa ._ca [:_dbc +_ebg ];
return true ;};return false ;};func (_ee *BufferedWriter )Reset (){_ee ._ca =_ee ._ca [:0];_ee ._ad =0;_ee ._ed =0};func (_cfe *Writer )WriteBits (bits uint64 ,number int )(_ecc int ,_cfgc error ){const _deb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_cf .Errorf (_deb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cab :=number /8;if _cab > 0{_bda :=number -_cab *8;for _ffc :=_cab -1;_ffc >=0;_ffc --{_beaa :=byte ((bits >>uint (_ffc *8+_bda ))&0xff);if _cfgc =_cfe .WriteByte (_beaa );_cfgc !=nil {return _ecc ,_cf .Wrapf (_cfgc ,_deb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cab -_ffc +1);
};};number -=_cab *8;if number ==0{return _cab ,nil ;};};var _gega int ;for _dcc :=0;_dcc < number ;_dcc ++{if _cfe ._ced {_gega =int ((bits >>uint (number -1-_dcc ))&0x1);}else {_gega =int (bits &0x1);bits >>=1;};if _cfgc =_cfe .WriteBit (_gega );_cfgc !=nil {return _ecc ,_cf .Wrapf (_cfgc ,_deb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dcc );
};};return _cab ,nil ;};func (_bge *Reader )ReadBit ()(_bfd int ,_ecd error ){_bea ,_ecd :=_bge .readBool ();if _ecd !=nil {return 0,_ecd ;};if _bea {_bfd =1;};return _bfd ,nil ;};func (_eec *SubstreamReader )readUnalignedByte ()(_fbab byte ,_fgea error ){_afa :=_eec ._cad ;
_fbab =_eec ._fge <<(8-_afa );_eec ._fge ,_fgea =_eec .readBufferByte ();if _fgea !=nil {return 0,_fgea ;};_fbab |=_eec ._fge >>_afa ;_eec ._fge &=1<<_afa -1;return _fbab ,nil ;};func (_bfg *Writer )Write (p []byte )(int ,error ){if len (p )> _bfg .byteCapacity (){return 0,_b .EOF ;
};for _ ,_ggbg :=range p {if _aece :=_bfg .writeByte (_ggbg );_aece !=nil {return 0,_aece ;};};return len (p ),nil ;};func (_gf *Reader )readBufferByte ()(byte ,error ){if _gf ._ff >=int64 (len (_gf ._def )){return 0,_b .EOF ;};_gf ._bfe =-1;_ddb :=_gf ._def [_gf ._ff ];
_gf ._ff ++;_gf ._ag =int (_ddb );return _ddb ,nil ;};func (_gaf *SubstreamReader )BitPosition ()int {return int (_gaf ._cad )};func (_ba *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _cf .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ba ._ca )-1< _ba ._ad {_ba .expandIfNeeded (1);};_dg :=_ba ._ed ;if _ba ._g {_dg =7-_ba ._ed ;};_ba ._ca [_ba ._ad ]|=byte (uint16 (bit <<_dg )&0xff);_ba ._ed ++;if _ba ._ed ==8{_ba ._ad ++;_ba ._ed =0;};return nil ;};var _ BinaryWriter =&Writer {};
func (_ece *Writer )ResetBit (){_ece ._eecf =0};var _ _b .Writer =&BufferedWriter {};