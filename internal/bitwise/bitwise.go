//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_ba "encoding/binary";_bf "errors";_b "fmt";_d "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_g "io";);var _ BinaryWriter =&BufferedWriter {};type Writer struct{_aff []byte ;_gee uint8 ;
_gdg int ;_cee bool ;};func (_bge *Writer )WriteByte (c byte )error {return _bge .writeByte (c )};func (_dfe *BufferedWriter )grow (_dff int ){if _dfe ._bg ==nil &&_dff < _f {_dfe ._bg =make ([]byte ,_dff ,_f );return ;};_cb :=len (_dfe ._bg );if _dfe ._de !=0{_cb ++;
};_ga :=cap (_dfe ._bg );switch {case _dff <=_ga /2-_cb :_d .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_dfe ._bg ),cap (_dfe ._bg ),_dff );
_d .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ga ,_cb );copy (_dfe ._bg ,_dfe ._bg [_dfe .fullOffset ():]);
case _ga > _ae -_ga -_dff :_d .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_af :=make ([]byte ,2*_ga +_dff );copy (_af ,_dfe ._bg );_dfe ._bg =_af ;};_dfe ._bg =_dfe ._bg [:_cb +_dff ];
};func (_gfc *Reader )ReadBool ()(bool ,error ){return _gfc .readBool ()};func (_ce *BufferedWriter )Reset (){_ce ._bg =_ce ._bg [:0];_ce ._aeg =0;_ce ._de =0};func (_ebc *Writer )WriteBits (bits uint64 ,number int )(_ggda int ,_dbe error ){const _dca ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_a .Errorf (_dca ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_egde :=number /8;if _egde > 0{_cgd :=number -_egde *8;for _ccg :=_egde -1;_ccg >=0;_ccg --{_gea :=byte ((bits >>uint (_ccg *8+_cgd ))&0xff);if _dbe =_ebc .WriteByte (_gea );_dbe !=nil {return _ggda ,_a .Wrapf (_dbe ,_dca ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_egde -_ccg +1);
};};number -=_egde *8;if number ==0{return _egde ,nil ;};};var _gfb int ;for _afa :=0;_afa < number ;_afa ++{if _ebc ._cee {_gfb =int ((bits >>uint (number -1-_afa ))&0x1);}else {_gfb =int (bits &0x1);bits >>=1;};if _dbe =_ebc .WriteBit (_gfb );_dbe !=nil {return _ggda ,_a .Wrapf (_dbe ,_dca ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_afa );
};};return _egde ,nil ;};type BufferedWriter struct{_bg []byte ;_de uint8 ;_aeg int ;_e bool ;};func (_afbd *Reader )readBool ()(_caf bool ,_eag error ){if _afbd ._fdd ==0{_afbd ._fgb ,_eag =_afbd .readBufferByte ();if _eag !=nil {return false ,_eag ;};
_caf =(_afbd ._fgb &0x80)!=0;_afbd ._fgb ,_afbd ._fdd =_afbd ._fgb &0x7f,7;return _caf ,nil ;};_afbd ._fdd --;_caf =(_afbd ._fgb &(1<<_afbd ._fdd ))!=0;_afbd ._fgb &=1<<_afbd ._fdd -1;return _caf ,nil ;};func (_cgab *Reader )BitPosition ()int {return int (_cgab ._fdd )};
func (_acbc *Reader )ReadUint32 ()(uint32 ,error ){_fgbe :=make ([]byte ,4);_ ,_cfe :=_acbc .Read (_fgbe );if _cfe !=nil {return 0,_cfe ;};return _ba .BigEndian .Uint32 (_fgbe ),nil ;};type readerSource struct{_bb []byte ;_dbf int ;_aed int ;};func (_cac *Reader )Mark (){_cac ._gdc =_cac ._eg ;
_cac ._eae =_cac ._fdd ;_cac ._fdbb =_cac ._fgb ;_cac ._cdc =_cac ._fc ;};func (_gbc *BufferedWriter )Write (d []byte )(int ,error ){_gbc .expandIfNeeded (len (d ));if _gbc ._de ==0{return _gbc .writeFullBytes (d ),nil ;};return _gbc .writeShiftedBytes (d ),nil ;
};func (_aag *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_bf .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_aag ._gdb ._dbf +offset ;};if length > 0{_gc :=len (_aag ._gdb ._bb );if relative {_gc =_aag ._gdb ._aed ;};if offset +length > _gc {return nil ,_b .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_aag ._gdb ._aed );
};};if length < 0{_cga :=len (_aag ._gdb ._bb );if relative {_cga =_aag ._gdb ._aed ;};length =_cga -offset ;};return &Reader {_gdb :readerSource {_bb :_aag ._gdb ._bb ,_aed :length ,_dbf :offset }},nil ;};func (_egg *Writer )FinishByte (){if _egg ._gee ==0{return ;
};_egg ._gee =0;_egg ._gdg ++;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_e :true }};var _ _g .ByteWriter =&BufferedWriter {};func (_bag *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_cg :=int (_bag ._de )+skip ;
if _cg >=0&&_cg < 8{_bag ._de =uint8 (_cg );return nil ;};_cg =int (_bag ._de )+_bag ._aeg *8+skip ;if _cg < 0{return _a .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_eb :=_cg /8;_gb :=_cg %8;_bag ._de =uint8 (_gb );if _fd :=_eb -_bag ._aeg ;_fd > 0&&len (_bag ._bg )-1< _eb {if _bag ._de !=0{_fd ++;};_bag .expandIfNeeded (_fd );};_bag ._aeg =_eb ;return nil ;};type Reader struct{_gdb readerSource ;_fgb byte ;_fdd byte ;
_eg int64 ;_fc int ;_acb int ;_gdc int64 ;_eae byte ;_fdbb byte ;_cdc int ;};func (_bcg *BufferedWriter )writeShiftedBytes (_fgc []byte )int {for _ ,_gbg :=range _fgc {_bcg .writeByte (_gbg );};return len (_fgc );};var _ BinaryWriter =&Writer {};func (_cgae *Reader )ReadBits (n byte )(_fac uint64 ,_bacd error ){if n < _cgae ._fdd {_bae :=_cgae ._fdd -n ;
_fac =uint64 (_cgae ._fgb >>_bae );_cgae ._fgb &=1<<_bae -1;_cgae ._fdd =_bae ;return _fac ,nil ;};if n > _cgae ._fdd {if _cgae ._fdd > 0{_fac =uint64 (_cgae ._fgb );n -=_cgae ._fdd ;};for n >=8{_fde ,_cfd :=_cgae .readBufferByte ();if _cfd !=nil {return 0,_cfd ;
};_fac =_fac <<8+uint64 (_fde );n -=8;};if n > 0{if _cgae ._fgb ,_bacd =_cgae .readBufferByte ();_bacd !=nil {return 0,_bacd ;};_def :=8-n ;_fac =_fac <<n +uint64 (_cgae ._fgb >>_def );_cgae ._fgb &=1<<_def -1;_cgae ._fdd =_def ;}else {_cgae ._fdd =0;};
return _fac ,nil ;};_cgae ._fdd =0;return uint64 (_cgae ._fgb ),nil ;};func (_bfc *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_bfc ._acb =-1;_bfc ._fdd =0;_bfc ._fgb =0;_bfc ._fc =0;var _fda int64 ;switch whence {case _g .SeekStart :_fda =offset ;
case _g .SeekCurrent :_fda =_bfc ._eg +offset ;case _g .SeekEnd :_fda =int64 (_bfc ._gdb ._aed )+offset ;default:return 0,_bf .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _fda < 0{return 0,_bf .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_bfc ._eg =_fda ;
_bfc ._fdd =0;return _fda ,nil ;};func (_ad *BufferedWriter )WriteBits (bits uint64 ,number int )(_gg int ,_dd error ){const _aa ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_a .Errorf (_aa ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_eba :=number /8;if _eba > 0{_gdf :=number -_eba *8;for _cda :=_eba -1;_cda >=0;_cda --{_fa :=byte ((bits >>uint (_cda *8+_gdf ))&0xff);if _dd =_ad .WriteByte (_fa );_dd !=nil {return _gg ,_a .Wrapf (_dd ,_aa ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_eba -_cda +1);
};};number -=_eba *8;if number ==0{return _eba ,nil ;};};var _ddc int ;for _ceb :=0;_ceb < number ;_ceb ++{if _ad ._e {_ddc =int ((bits >>uint (number -1-_ceb ))&0x1);}else {_ddc =int (bits &0x1);bits >>=1;};if _dd =_ad .WriteBit (_ddc );_dd !=nil {return _gg ,_a .Wrapf (_dd ,_aa ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ceb );
};};return _eba ,nil ;};func (_dee *Writer )writeBit (_dcd uint8 )error {if len (_dee ._aff )-1< _dee ._gdg {return _g .EOF ;};_bagg :=_dee ._gee ;if _dee ._cee {_bagg =7-_dee ._gee ;};_dee ._aff [_dee ._gdg ]|=byte (uint16 (_dcd <<_bagg )&0xff);_dee ._gee ++;
if _dee ._gee ==8{_dee ._gdg ++;_dee ._gee =0;};return nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_aff :data ,_cee :true }};func (_dc *BufferedWriter )WriteByte (bt byte )error {if _dc ._aeg > len (_dc ._bg )-1||(_dc ._aeg ==len (_dc ._bg )-1&&_dc ._de !=0){_dc .expandIfNeeded (1);
};_dc .writeByte (bt );return nil ;};var _ _g .Writer =&BufferedWriter {};func (_feb *Reader )ReadByte ()(byte ,error ){if _feb ._fdd ==0{return _feb .readBufferByte ();};return _feb .readUnalignedByte ();};func (_gd *BufferedWriter )FinishByte (){if _gd ._de ==0{return ;
};_gd ._de =0;_gd ._aeg ++;};func (_db *BufferedWriter )writeFullBytes (_fge []byte )int {_be :=copy (_db ._bg [_db .fullOffset ():],_fge );_db ._aeg +=_be ;return _be ;};func (_afd *Reader )Align ()(_ca byte ){_ca =_afd ._fdd ;_afd ._fdd =0;return _ca };
func (_bc *BufferedWriter )byteCapacity ()int {_bac :=len (_bc ._bg )-_bc ._aeg ;if _bc ._de !=0{_bac --;};return _bac ;};func (_ef *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _a .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ef ._bg )-1< _ef ._aeg {_ef .expandIfNeeded (1);};_ac :=_ef ._de ;if _ef ._e {_ac =7-_ef ._de ;};_ef ._bg [_ef ._aeg ]|=byte (uint16 (bit <<_ac )&0xff);_ef ._de ++;if _ef ._de ==8{_ef ._aeg ++;_ef ._de =0;};return nil ;};func (_fdg *Reader )Read (p []byte )(_ace int ,_gde error ){if _fdg ._fdd ==0{return _fdg .read (p );
};for ;_ace < len (p );_ace ++{if p [_ace ],_gde =_fdg .readUnalignedByte ();_gde !=nil {return 0,_gde ;};};return _ace ,nil ;};func (_ed *Reader )readBufferByte ()(byte ,error ){if _ed ._eg >=int64 (_ed ._gdb ._aed ){return 0,_g .EOF ;};_ed ._acb =-1;
_bd :=_ed ._gdb ._bb [int64 (_ed ._gdb ._dbf )+_ed ._eg ];_ed ._eg ++;_ed ._fc =int (_bd );return _bd ,nil ;};func (_df *BufferedWriter )Len ()int {return _df .byteCapacity ()};type StreamReader interface{_g .Reader ;_g .ByteReader ;_g .Seeker ;Align ()byte ;
BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_cebb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func NewWriter (data []byte )*Writer {return &Writer {_aff :data }};
type BitWriter interface{WriteBit (_ggd int )error ;WriteBits (_ea uint64 ,_fdf int )(_bea int ,_ddf error );FinishByte ();SkipBits (_cc int )error ;};func (_gbe *Reader )AbsolutePosition ()int64 {return _gbe ._eg +int64 (_gbe ._gdb ._dbf )};var (_ _g .Reader =&Reader {};
_ _g .ByteReader =&Reader {};_ _g .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_eff *BufferedWriter )writeByte (_dcb byte ){switch {case _eff ._de ==0:_eff ._bg [_eff ._aeg ]=_dcb ;_eff ._aeg ++;case _eff ._e :_eff ._bg [_eff ._aeg ]|=_dcb >>_eff ._de ;
_eff ._aeg ++;_eff ._bg [_eff ._aeg ]=byte (uint16 (_dcb )<<(8-_eff ._de )&0xff);default:_eff ._bg [_eff ._aeg ]|=byte (uint16 (_dcb )<<_eff ._de &0xff);_eff ._aeg ++;_eff ._bg [_eff ._aeg ]=_dcb >>(8-_eff ._de );};};func (_fef *Writer )UseMSB ()bool {return _fef ._cee };
func (_bgg *BufferedWriter )tryGrowByReslice (_gf int )bool {if _cdd :=len (_bgg ._bg );_gf <=cap (_bgg ._bg )-_cdd {_bgg ._bg =_bgg ._bg [:_cdd +_gf ];return true ;};return false ;};const (_f =64;_ae =int (^uint (0)>>1););func (_gge *Writer )SkipBits (skip int )error {const _gbga ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_dbfb :=int (_gge ._gee )+skip ;if _dbfb >=0&&_dbfb < 8{_gge ._gee =uint8 (_dbfb );return nil ;};_dbfb =int (_gge ._gee )+_gge ._gdg *8+skip ;if _dbfb < 0{return _a .Errorf (_gbga ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_geb :=_dbfb /8;_acc :=_dbfb %8;_d .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_d .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_gge ._gee ,_gge ._gdg ,int (_gge ._gee )+(_gge ._gdg )*8,len (_gge ._aff ),cap (_gge ._aff ));
_d .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_dbfb ,_acc );_gge ._gee =uint8 (_acc );if _aegg :=_geb -_gge ._gdg ;
_aegg > 0&&len (_gge ._aff )-1< _geb {_d .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_aegg );return _a .Errorf (_gbga ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_gge ._gdg =_geb ;_d .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_gge ._gee ,_gge ._gdg );return nil ;};func (_cdg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _cdg .writeBit (uint8 (bit ));
};return _a .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_ggf *Reader )Reset (){_ggf ._eg =_ggf ._gdc ;_ggf ._fdd =_ggf ._eae ;_ggf ._fgb =_ggf ._fdbb ;
_ggf ._fc =_ggf ._cdc ;};func (_bca *Reader )Length ()uint64 {return uint64 (_bca ._gdb ._aed )};type BinaryWriter interface{BitWriter ;_g .Writer ;_g .ByteWriter ;Data ()[]byte ;};func (_fe *Reader )AbsoluteLength ()uint64 {return uint64 (len (_fe ._gdb ._bb ))};
func (_ee *Reader )readUnalignedByte ()(_afg byte ,_gaf error ){_fdeg :=_ee ._fdd ;_afg =_ee ._fgb <<(8-_fdeg );_ee ._fgb ,_gaf =_ee .readBufferByte ();if _gaf !=nil {return 0,_gaf ;};_afg |=_ee ._fgb >>_fdeg ;_ee ._fgb &=1<<_fdeg -1;return _afg ,nil ;
};func (_ceg *Writer )Write (p []byte )(int ,error ){if len (p )> _ceg .byteCapacity (){return 0,_g .EOF ;};for _ ,_da :=range p {if _cgf :=_ceg .writeByte (_da );_cgf !=nil {return 0,_cgf ;};};return len (p ),nil ;};func (_gdaf *Writer )Data ()[]byte {return _gdaf ._aff };
func (_gdd *Writer )writeByte (_eed byte )error {if _gdd ._gdg > len (_gdd ._aff )-1{return _g .EOF ;};if _gdd ._gdg ==len (_gdd ._aff )-1&&_gdd ._gee !=0{return _g .EOF ;};if _gdd ._gee ==0{_gdd ._aff [_gdd ._gdg ]=_eed ;_gdd ._gdg ++;return nil ;};if _gdd ._cee {_gdd ._aff [_gdd ._gdg ]|=_eed >>_gdd ._gee ;
_gdd ._gdg ++;_gdd ._aff [_gdd ._gdg ]=byte (uint16 (_eed )<<(8-_gdd ._gee )&0xff);}else {_gdd ._aff [_gdd ._gdg ]|=byte (uint16 (_eed )<<_gdd ._gee &0xff);_gdd ._gdg ++;_gdd ._aff [_gdd ._gdg ]=_eed >>(8-_gdd ._gee );};return nil ;};func (_ab *Reader )ReadBit ()(_dfd int ,_ge error ){_effb ,_ge :=_ab .readBool ();
if _ge !=nil {return 0,_ge ;};if _effb {_dfd =1;};return _dfd ,nil ;};func (_fba *Writer )byteCapacity ()int {_aecd :=len (_fba ._aff )-_fba ._gdg ;if _fba ._gee !=0{_aecd --;};return _aecd ;};func (_gcc *Reader )RelativePosition ()int64 {return _gcc ._eg };
func (_fdb *BufferedWriter )fullOffset ()int {_gda :=_fdb ._aeg ;if _fdb ._de !=0{_gda ++;};return _gda ;};func (_bce *Writer )ResetBit (){_bce ._gee =0};func (_cd *BufferedWriter )Data ()[]byte {return _cd ._bg };func NewReader (data []byte )*Reader {return &Reader {_gdb :readerSource {_bb :data ,_aed :len (data ),_dbf :0}};
};func (_cff *BufferedWriter )expandIfNeeded (_fb int ){if !_cff .tryGrowByReslice (_fb ){_cff .grow (_fb );};};func (_bgb *Reader )read (_gad []byte )(int ,error ){if _bgb ._eg >=int64 (_bgb ._gdb ._aed ){return 0,_g .EOF ;};_bgb ._acb =-1;_egdb :=copy (_gad ,_bgb ._gdb ._bb [(int64 (_bgb ._gdb ._dbf )+_bgb ._eg ):(_bgb ._gdb ._dbf +_bgb ._gdb ._aed )]);
_bgb ._eg +=int64 (_egdb );return _egdb ,nil ;};func (_ec *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _ec ._fdd !=0{return _ec .ReadBits (_ec ._fdd );};return 0,nil ;};func (_dg *BufferedWriter )ResetBitIndex (){_dg ._de =0};