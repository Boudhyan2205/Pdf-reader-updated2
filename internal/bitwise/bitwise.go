//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_bg "encoding/binary";_ae "errors";_b "fmt";_be "github.com/unidoc/unipdf/v3/common";_bge "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ad "io";);func (_cg *BufferedWriter )Write (d []byte )(int ,error ){_cg .expandIfNeeded (len (d ));
if _cg ._ba ==0{return _cg .writeFullBytes (d ),nil ;};return _cg .writeShiftedBytes (d ),nil ;};type BitWriter interface{WriteBit (_gg int )error ;WriteBits (_fa uint64 ,_ebf int )(_cbb int ,_dea error );FinishByte ();SkipBits (_faa int )error ;};func (_cd *BufferedWriter )Data ()[]byte {return _cd ._eb };
func (_gfd *Reader )AbsoluteLength ()uint64 {return uint64 (len (_gfd ._fcb ._gc ))};func (_cfa *Reader )readBufferByte ()(byte ,error ){if _cfa ._ged >=int64 (_cfa ._fcb ._ed ){return 0,_ad .EOF ;};_cfa ._fcba =-1;_adg :=_cfa ._fcb ._gc [int64 (_cfa ._fcb ._ca )+_cfa ._ged ];
_cfa ._ged ++;_cfa ._ega =int (_adg );return _adg ,nil ;};func (_dga *Writer )Write (p []byte )(int ,error ){if len (p )> _dga .byteCapacity (){return 0,_ad .EOF ;};for _ ,_gdf :=range p {if _aff :=_dga .writeByte (_gdf );_aff !=nil {return 0,_aff ;};};
return len (p ),nil ;};func (_eadc *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_eadc ._fcba =-1;_eadc ._eg =0;_eadc ._gf =0;_eadc ._ega =0;var _aa int64 ;switch whence {case _ad .SeekStart :_aa =offset ;case _ad .SeekCurrent :_aa =_eadc ._ged +offset ;
case _ad .SeekEnd :_aa =int64 (_eadc ._fcb ._ed )+offset ;default:return 0,_ae .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _aa < 0{return 0,_ae .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_eadc ._ged =_aa ;
_eadc ._eg =0;return _aa ,nil ;};type StreamReader interface{_ad .Reader ;_ad .ByteReader ;_ad .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_bcb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );
Reset ();AbsolutePosition ()int64 ;};type Writer struct{_fdge []byte ;_cdc uint8 ;_ebd int ;_cba bool ;};func (_cc *BufferedWriter )tryGrowByReslice (_gd int )bool {if _efb :=len (_cc ._eb );_gd <=cap (_cc ._eb )-_efb {_cc ._eb =_cc ._eb [:_efb +_gd ];
return true ;};return false ;};func (_dce *BufferedWriter )grow (_ddf int ){if _dce ._eb ==nil &&_ddf < _e {_dce ._eb =make ([]byte ,_ddf ,_e );return ;};_ab :=len (_dce ._eb );if _dce ._ba !=0{_ab ++;};_fc :=cap (_dce ._eb );switch {case _ddf <=_fc /2-_ab :_be .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_dce ._eb ),cap (_dce ._eb ),_ddf );
_be .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_fc ,_ab );copy (_dce ._eb ,_dce ._eb [_dce .fullOffset ():]);
case _fc > _d -_fc -_ddf :_be .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_geag :=make ([]byte ,2*_fc +_ddf );copy (_geag ,_dce ._eb );_dce ._eb =_geag ;};_dce ._eb =_dce ._eb [:_ab +_ddf ];
};func (_aee *Reader )Read (p []byte )(_gaf int ,_cbc error ){if _aee ._eg ==0{return _aee .read (p );};for ;_gaf < len (p );_gaf ++{if p [_gaf ],_cbc =_aee .readUnalignedByte ();_cbc !=nil {return 0,_cbc ;};};return _gaf ,nil ;};type BufferedWriter struct{_eb []byte ;
_ba uint8 ;_c int ;_bd bool ;};func (_cbf *Reader )readBool ()(_fcbg bool ,_fecb error ){if _cbf ._eg ==0{_cbf ._gf ,_fecb =_cbf .readBufferByte ();if _fecb !=nil {return false ,_fecb ;};_fcbg =(_cbf ._gf &0x80)!=0;_cbf ._gf ,_cbf ._eg =_cbf ._gf &0x7f,7;
return _fcbg ,nil ;};_cbf ._eg --;_fcbg =(_cbf ._gf &(1<<_cbf ._eg ))!=0;_cbf ._gf &=1<<_cbf ._eg -1;return _fcbg ,nil ;};var _ _ad .ByteWriter =&BufferedWriter {};func (_ea *BufferedWriter )FinishByte (){if _ea ._ba ==0{return ;};_ea ._ba =0;_ea ._c ++;
};type Reader struct{_fcb readerSource ;_gf byte ;_eg byte ;_ged int64 ;_ega int ;_fcba int ;_bfa int64 ;_dbg byte ;_cf byte ;_cca int ;};func NewReader (data []byte )*Reader {return &Reader {_fcb :readerSource {_gc :data ,_ed :len (data ),_ca :0}};};func (_bcg *Reader )BitPosition ()int {return int (_bcg ._eg )};
func (_ga *BufferedWriter )Reset (){_ga ._eb =_ga ._eb [:0];_ga ._c =0;_ga ._ba =0};func (_eac *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _bge .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_eac ._eb )-1< _eac ._c {_eac .expandIfNeeded (1);};_cb :=_eac ._ba ;if _eac ._bd {_cb =7-_eac ._ba ;};_eac ._eb [_eac ._c ]|=byte (uint16 (bit <<_cb )&0xff);_eac ._ba ++;if _eac ._ba ==8{_eac ._c ++;_eac ._ba =0;};return nil ;};func (_ff *Reader )ReadUint32 ()(uint32 ,error ){_acc :=make ([]byte ,4);
_ ,_fbg :=_ff .Read (_acc );if _fbg !=nil {return 0,_fbg ;};return _bg .BigEndian .Uint32 (_acc ),nil ;};func (_agb *Writer )Data ()[]byte {return _agb ._fdge };func (_aaa *Writer )FinishByte (){if _aaa ._cdc ==0{return ;};_aaa ._cdc =0;_aaa ._ebd ++;};
func (_dgf *Reader )Align ()(_fdg byte ){_fdg =_dgf ._eg ;_dgf ._eg =0;return _fdg };func (_gbf *Reader )ReadByte ()(byte ,error ){if _gbf ._eg ==0{return _gbf .readBufferByte ();};return _gbf .readUnalignedByte ();};func NewWriter (data []byte )*Writer {return &Writer {_fdge :data }};
func (_aef *BufferedWriter )writeShiftedBytes (_abg []byte )int {for _ ,_ebg :=range _abg {_aef .writeByte (_ebg );};return len (_abg );};var (_ _ad .Reader =&Reader {};_ _ad .ByteReader =&Reader {};_ _ad .Seeker =&Reader {};_ StreamReader =&Reader {};
);func (_fd *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_ae .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_fd ._fcb ._ca +offset ;};if length > 0{_bef :=len (_fd ._fcb ._gc );if relative {_bef =_fd ._fcb ._ed ;};if offset +length > _bef {return nil ,_b .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_fd ._fcb ._ed );
};};if length < 0{_beb :=len (_fd ._fcb ._gc );if relative {_beb =_fd ._fcb ._ed ;};length =_beb -offset ;};return &Reader {_fcb :readerSource {_gc :_fd ._fcb ._gc ,_ed :length ,_ca :offset }},nil ;};func (_fag *Reader )readUnalignedByte ()(_fagc byte ,_fbga error ){_abe :=_fag ._eg ;
_fagc =_fag ._gf <<(8-_abe );_fag ._gf ,_fbga =_fag .readBufferByte ();if _fbga !=nil {return 0,_fbga ;};_fagc |=_fag ._gf >>_abe ;_fag ._gf &=1<<_abe -1;return _fagc ,nil ;};func (_bc *BufferedWriter )writeFullBytes (_bb []byte )int {_cdd :=copy (_bc ._eb [_bc .fullOffset ():],_bb );
_bc ._c +=_cdd ;return _cdd ;};func (_gfg *Reader )Length ()uint64 {return uint64 (_gfg ._fcb ._ed )};type BinaryWriter interface{BitWriter ;_ad .Writer ;_ad .ByteWriter ;Data ()[]byte ;};func (_ccad *Writer )WriteByte (c byte )error {return _ccad .writeByte (c )};
func (_edb *Writer )SkipBits (skip int )error {const _ccd ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_ggac :=int (_edb ._cdc )+skip ;if _ggac >=0&&_ggac < 8{_edb ._cdc =uint8 (_ggac );return nil ;
};_ggac =int (_edb ._cdc )+_edb ._ebd *8+skip ;if _ggac < 0{return _bge .Errorf (_ccd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ceg :=_ggac /8;_feg :=_ggac %8;_be .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_be .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_edb ._cdc ,_edb ._ebd ,int (_edb ._cdc )+(_edb ._ebd )*8,len (_edb ._fdge ),cap (_edb ._fdge ));
_be .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ggac ,_feg );_edb ._cdc =uint8 (_feg );if _cec :=_ceg -_edb ._ebd ;
_cec > 0&&len (_edb ._fdge )-1< _ceg {_be .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_cec );return _bge .Errorf (_ccd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_edb ._ebd =_ceg ;_be .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_edb ._cdc ,_edb ._ebd );return nil ;};func (_dag *Writer )byteCapacity ()int {_age :=len (_dag ._fdge )-_dag ._ebd ;
if _dag ._cdc !=0{_age --;};return _age ;};func (_bf *BufferedWriter )byteCapacity ()int {_dc :=len (_bf ._eb )-_bf ._c ;if _bf ._ba !=0{_dc --;};return _dc ;};func (_caa *Writer )UseMSB ()bool {return _caa ._cba };const (_e =64;_d =int (^uint (0)>>1);
);func (_cge *Writer )writeBit (_bfb uint8 )error {if len (_cge ._fdge )-1< _cge ._ebd {return _ad .EOF ;};_cfg :=_cge ._cdc ;if _cge ._cba {_cfg =7-_cge ._cdc ;};_cge ._fdge [_cge ._ebd ]|=byte (uint16 (_bfb <<_cfg )&0xff);_cge ._cdc ++;if _cge ._cdc ==8{_cge ._ebd ++;
_cge ._cdc =0;};return nil ;};func (_adcf *Reader )ReadBits (n byte )(_ag uint64 ,_dffd error ){if n < _adcf ._eg {_gdb :=_adcf ._eg -n ;_ag =uint64 (_adcf ._gf >>_gdb );_adcf ._gf &=1<<_gdb -1;_adcf ._eg =_gdb ;return _ag ,nil ;};if n > _adcf ._eg {if _adcf ._eg > 0{_ag =uint64 (_adcf ._gf );
n -=_adcf ._eg ;};for n >=8{_gff ,_gaa :=_adcf .readBufferByte ();if _gaa !=nil {return 0,_gaa ;};_ag =_ag <<8+uint64 (_gff );n -=8;};if n > 0{if _adcf ._gf ,_dffd =_adcf .readBufferByte ();_dffd !=nil {return 0,_dffd ;};_gcf :=8-n ;_ag =_ag <<n +uint64 (_adcf ._gf >>_gcf );
_adcf ._gf &=1<<_gcf -1;_adcf ._eg =_gcf ;}else {_adcf ._eg =0;};return _ag ,nil ;};_adcf ._eg =0;return uint64 (_adcf ._gf ),nil ;};func (_dcf *Reader )ReadBit ()(_dcg int ,_fbe error ){_faaa ,_fbe :=_dcf .readBool ();if _fbe !=nil {return 0,_fbe ;};if _faaa {_dcg =1;
};return _dcg ,nil ;};func (_cga *Reader )RelativePosition ()int64 {return _cga ._ged };func (_caf *Writer )ResetBit (){_caf ._cdc =0};func (_aga *Reader )ReadBool ()(bool ,error ){return _aga .readBool ()};var _ BinaryWriter =&Writer {};var _ BinaryWriter =&BufferedWriter {};
type readerSource struct{_gc []byte ;_ca int ;_ed int ;};func (_gac *Writer )writeByte (_fbf byte )error {if _gac ._ebd > len (_gac ._fdge )-1{return _ad .EOF ;};if _gac ._ebd ==len (_gac ._fdge )-1&&_gac ._cdc !=0{return _ad .EOF ;};if _gac ._cdc ==0{_gac ._fdge [_gac ._ebd ]=_fbf ;
_gac ._ebd ++;return nil ;};if _gac ._cba {_gac ._fdge [_gac ._ebd ]|=_fbf >>_gac ._cdc ;_gac ._ebd ++;_gac ._fdge [_gac ._ebd ]=byte (uint16 (_fbf )<<(8-_gac ._cdc )&0xff);}else {_gac ._fdge [_gac ._ebd ]|=byte (uint16 (_fbf )<<_gac ._cdc &0xff);_gac ._ebd ++;
_gac ._fdge [_gac ._ebd ]=_fbf >>(8-_gac ._cdc );};return nil ;};func (_db *BufferedWriter )WriteByte (bt byte )error {if _db ._c > len (_db ._eb )-1||(_db ._c ==len (_db ._eb )-1&&_db ._ba !=0){_db .expandIfNeeded (1);};_db .writeByte (bt );return nil ;
};func NewWriterMSB (data []byte )*Writer {return &Writer {_fdge :data ,_cba :true }};func (_fg *Reader )read (_ffc []byte )(int ,error ){if _fg ._ged >=int64 (_fg ._fcb ._ed ){return 0,_ad .EOF ;};_fg ._fcba =-1;_fdf :=copy (_ffc ,_fg ._fcb ._gc [(int64 (_fg ._fcb ._ca )+_fg ._ged ):(_fg ._fcb ._ca +_fg ._fcb ._ed )]);
_fg ._ged +=int64 (_fdf );return _fdf ,nil ;};func (_add *BufferedWriter )writeByte (_fec byte ){switch {case _add ._ba ==0:_add ._eb [_add ._c ]=_fec ;_add ._c ++;case _add ._bd :_add ._eb [_add ._c ]|=_fec >>_add ._ba ;_add ._c ++;_add ._eb [_add ._c ]=byte (uint16 (_fec )<<(8-_add ._ba )&0xff);
default:_add ._eb [_add ._c ]|=byte (uint16 (_fec )<<_add ._ba &0xff);_add ._c ++;_add ._eb [_add ._c ]=_fec >>(8-_add ._ba );};};func (_af *BufferedWriter )ResetBitIndex (){_af ._ba =0};func (_gea *BufferedWriter )fullOffset ()int {_cgf :=_gea ._c ;if _gea ._ba !=0{_cgf ++;
};return _cgf ;};var _ _ad .Writer =&BufferedWriter {};func (_bba *Writer )WriteBits (bits uint64 ,number int )(_ggd int ,_fda error ){const _ege ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_bge .Errorf (_ege ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cfd :=number /8;if _cfd > 0{_dbb :=number -_cfd *8;for _dec :=_cfd -1;_dec >=0;_dec --{_daf :=byte ((bits >>uint (_dec *8+_dbb ))&0xff);if _fda =_bba .WriteByte (_daf );_fda !=nil {return _ggd ,_bge .Wrapf (_fda ,_ege ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cfd -_dec +1);
};};number -=_cfd *8;if number ==0{return _cfd ,nil ;};};var _aab int ;for _adcd :=0;_adcd < number ;_adcd ++{if _bba ._cba {_aab =int ((bits >>uint (number -1-_adcd ))&0x1);}else {_aab =int (bits &0x1);bits >>=1;};if _fda =_bba .WriteBit (_aab );_fda !=nil {return _ggd ,_bge .Wrapf (_fda ,_ege ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_adcd );
};};return _cfd ,nil ;};func (_ge *BufferedWriter )WriteBits (bits uint64 ,number int )(_ef int ,_fe error ){const _de ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_bge .Errorf (_de ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_eba :=number /8;if _eba > 0{_dg :=number -_eba *8;for _dff :=_eba -1;_dff >=0;_dff --{_efg :=byte ((bits >>uint (_dff *8+_dg ))&0xff);if _fe =_ge .WriteByte (_efg );_fe !=nil {return _ef ,_bge .Wrapf (_fe ,_de ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_eba -_dff +1);
};};number -=_eba *8;if number ==0{return _eba ,nil ;};};var _ceb int ;for _eff :=0;_eff < number ;_eff ++{if _ge ._bd {_ceb =int ((bits >>uint (number -1-_eff ))&0x1);}else {_ceb =int (bits &0x1);bits >>=1;};if _fe =_ge .WriteBit (_ceb );_fe !=nil {return _ef ,_bge .Wrapf (_fe ,_de ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_eff );
};};return _eba ,nil ;};func (_gdd *Reader )Mark (){_gdd ._bfa =_gdd ._ged ;_gdd ._dbg =_gdd ._eg ;_gdd ._cf =_gdd ._gf ;_gdd ._cca =_gdd ._ega ;};func (_da *Reader )Reset (){_da ._ged =_da ._bfa ;_da ._eg =_da ._dbg ;_da ._gf =_da ._cf ;_da ._ega =_da ._cca ;
};func (_df *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_f :=int (_df ._ba )+skip ;if _f >=0&&_f < 8{_df ._ba =uint8 (_f );return nil ;};_f =int (_df ._ba )+_df ._c *8+skip ;if _f < 0{return _bge .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ce :=_f /8;_afe :=_f %8;_df ._ba =uint8 (_afe );if _ead :=_ce -_df ._c ;_ead > 0&&len (_df ._eb )-1< _ce {if _df ._ba !=0{_ead ++;};_df .expandIfNeeded (_ead );};_df ._c =_ce ;return nil ;};func (_edg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _edg .writeBit (uint8 (bit ));
};return _bge .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_bd :true }};func (_g *BufferedWriter )Len ()int {return _g .byteCapacity ()};
func (_gga *Reader )AbsolutePosition ()int64 {return _gga ._ged +int64 (_gga ._fcb ._ca )};func (_bfc *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _bfc ._eg !=0{return _bfc .ReadBits (_bfc ._eg );};return 0,nil ;};func (_dd *BufferedWriter )expandIfNeeded (_gb int ){if !_dd .tryGrowByReslice (_gb ){_dd .grow (_gb );
};};