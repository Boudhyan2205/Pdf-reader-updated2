//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_g "github.com/unidoc/unipdf/v3/internal/bitwise";_eg "github.com/unidoc/unipdf/v3/internal/imageutil";_d "io";);func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _edd []uint32 ;
_abe :=bitsPerOutputSample ;var _cb uint32 ;var _ac uint32 ;_aa :=0;_abc :=0;_dg :=0;for _dg < len (data ){if _aa > 0{_ef :=_aa ;if _abe < _ef {_ef =_abe ;};_cb =(_cb <<uint (_ef ))|(_ac >>uint (bitsPerInputSample -_ef ));_aa -=_ef ;if _aa > 0{_ac =_ac <<uint (_ef );
}else {_ac =0;};_abe -=_ef ;if _abe ==0{_edd =append (_edd ,_cb );_abe =bitsPerOutputSample ;_cb =0;_abc ++;};}else {_bd :=data [_dg ];_dg ++;_fa :=bitsPerInputSample ;if _abe < _fa {_fa =_abe ;};_aa =bitsPerInputSample -_fa ;_cb =(_cb <<uint (_fa ))|(_bd >>uint (_aa ));
if _fa < bitsPerInputSample {_ac =_bd <<uint (_fa );};_abe -=_fa ;if _abe ==0{_edd =append (_edd ,_cb );_abe =bitsPerOutputSample ;_cb =0;_abc ++;};};};for _aa >=bitsPerOutputSample {_bb :=_aa ;if _abe < _bb {_bb =_abe ;};_cb =(_cb <<uint (_bb ))|(_ac >>uint (bitsPerInputSample -_bb ));
_aa -=_bb ;if _aa > 0{_ac =_ac <<uint (_bb );}else {_ac =0;};_abe -=_bb ;if _abe ==0{_edd =append (_edd ,_cb );_abe =bitsPerOutputSample ;_cb =0;_abc ++;};};if _abe > 0&&_abe < bitsPerOutputSample {_cb <<=uint (_abe );_edd =append (_edd ,_cb );};return _edd ;
};func (_dcf *Reader )ReadSamples (samples []uint32 )(_a error ){for _ae :=0;_ae < len (samples );_ae ++{samples [_ae ],_a =_dcf .ReadSample ();if _a !=nil {return _a ;};};return nil ;};type Writer struct{_ace _eg .ImageBase ;_df *_g .Writer ;_dce ,_ea int ;
_gf bool ;};func (_bf *Writer )WriteSample (sample uint32 )error {if _ ,_ge :=_bf ._df .WriteBits (uint64 (sample ),_bf ._ace .BitsPerComponent );_ge !=nil {return _ge ;};_bf ._ea --;if _bf ._ea ==0{_bf ._ea =_bf ._ace .ColorComponents ;_bf ._dce ++;};
if _bf ._dce ==_bf ._ace .Width {if _bf ._gf {_bf ._df .FinishByte ();};_bf ._dce =0;};return nil ;};func (_ff *Reader )ReadSample ()(uint32 ,error ){if _ff ._ec ==_ff ._gd .Height {return 0,_d .EOF ;};_b ,_dc :=_ff ._gg .ReadBits (byte (_ff ._gd .BitsPerComponent ));
if _dc !=nil {return 0,_dc ;};_ff ._cd --;if _ff ._cd ==0{_ff ._cd =_ff ._gd .ColorComponents ;_ff ._f ++;};if _ff ._f ==_ff ._gd .Width {if _ff ._cf {_ff ._gg .ConsumeRemainingBits ();};_ff ._f =0;_ff ._ec ++;};return uint32 (_b ),nil ;};func NewReader (img _eg .ImageBase )*Reader {return &Reader {_gg :_g .NewReader (img .Data ),_gd :img ,_cd :img .ColorComponents ,_cf :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_c []uint32 )error ;};func (_bccf *Writer )WriteSamples (samples []uint32 )error {for _eab :=0;_eab < len (samples );_eab ++{if _cc :=_bccf .WriteSample (samples [_eab ]);_cc !=nil {return _cc ;
};};return nil ;};func NewWriter (img _eg .ImageBase )*Writer {return &Writer {_df :_g .NewWriterMSB (img .Data ),_ace :img ,_ea :img .ColorComponents ,_gf :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};type SampleWriter interface{WriteSample (_acc uint32 )error ;
WriteSamples (_cgd []uint32 )error ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ab []uint32 ;_aee :=bitsPerSample ;var _fb uint32 ;var _bc byte ;_bcc :=0;_de :=0;_ed :=0;for _ed < len (data ){if _bcc > 0{_bcf :=_bcc ;if _aee < _bcf {_bcf =_aee ;
};_fb =(_fb <<uint (_bcf ))|uint32 (_bc >>uint (8-_bcf ));_bcc -=_bcf ;if _bcc > 0{_bc =_bc <<uint (_bcf );}else {_bc =0;};_aee -=_bcf ;if _aee ==0{_ab =append (_ab ,_fb );_aee =bitsPerSample ;_fb =0;_de ++;};}else {_cg :=data [_ed ];_ed ++;_bg :=8;if _aee < _bg {_bg =_aee ;
};_bcc =8-_bg ;_fb =(_fb <<uint (_bg ))|uint32 (_cg >>uint (_bcc ));if _bg < 8{_bc =_cg <<uint (_bg );};_aee -=_bg ;if _aee ==0{_ab =append (_ab ,_fb );_aee =bitsPerSample ;_fb =0;_de ++;};};};for _bcc >=bitsPerSample {_ca :=_bcc ;if _aee < _ca {_ca =_aee ;
};_fb =(_fb <<uint (_ca ))|uint32 (_bc >>uint (8-_ca ));_bcc -=_ca ;if _bcc > 0{_bc =_bc <<uint (_ca );}else {_bc =0;};_aee -=_ca ;if _aee ==0{_ab =append (_ab ,_fb );_aee =bitsPerSample ;_fb =0;_de ++;};};return _ab ;};type Reader struct{_gd _eg .ImageBase ;
_gg *_g .Reader ;_f ,_ec ,_cd int ;_cf bool ;};