//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_a "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/imageutil";_e "io";);func (_ea *Reader )ReadSamples (samples []uint32 )(_ca error ){for _af :=0;_af < len (samples );_af ++{samples [_af ],_ca =_ea .ReadSample ();
if _ca !=nil {return _ca ;};};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ba []uint32 ;_adf :=bitsPerOutputSample ;var _eab uint32 ;var _bb uint32 ;_baf :=0;_aeg :=0;_ed :=0;for _ed < len (data ){if _baf > 0{_cg :=_baf ;
if _adf < _cg {_cg =_adf ;};_eab =(_eab <<uint (_cg ))|(_bb >>uint (bitsPerInputSample -_cg ));_baf -=_cg ;if _baf > 0{_bb =_bb <<uint (_cg );}else {_bb =0;};_adf -=_cg ;if _adf ==0{_ba =append (_ba ,_eab );_adf =bitsPerOutputSample ;_eab =0;_aeg ++;};
}else {_gb :=data [_ed ];_ed ++;_ab :=bitsPerInputSample ;if _adf < _ab {_ab =_adf ;};_baf =bitsPerInputSample -_ab ;_eab =(_eab <<uint (_ab ))|(_gb >>uint (_baf ));if _ab < bitsPerInputSample {_bb =_gb <<uint (_ab );};_adf -=_ab ;if _adf ==0{_ba =append (_ba ,_eab );
_adf =bitsPerOutputSample ;_eab =0;_aeg ++;};};};for _baf >=bitsPerOutputSample {_dc :=_baf ;if _adf < _dc {_dc =_adf ;};_eab =(_eab <<uint (_dc ))|(_bb >>uint (bitsPerInputSample -_dc ));_baf -=_dc ;if _baf > 0{_bb =_bb <<uint (_dc );}else {_bb =0;};_adf -=_dc ;
if _adf ==0{_ba =append (_ba ,_eab );_adf =bitsPerOutputSample ;_eab =0;_aeg ++;};};if _adf > 0&&_adf < bitsPerOutputSample {_eab <<=uint (_adf );_ba =append (_ba ,_eab );};return _ba ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _cac []uint32 ;
_d :=bitsPerSample ;var _dg uint32 ;var _fe byte ;_aa :=0;_ad :=0;_aed :=0;for _aed < len (data ){if _aa > 0{_ec :=_aa ;if _d < _ec {_ec =_d ;};_dg =(_dg <<uint (_ec ))|uint32 (_fe >>uint (8-_ec ));_aa -=_ec ;if _aa > 0{_fe =_fe <<uint (_ec );}else {_fe =0;
};_d -=_ec ;if _d ==0{_cac =append (_cac ,_dg );_d =bitsPerSample ;_dg =0;_ad ++;};}else {_dd :=data [_aed ];_aed ++;_cf :=8;if _d < _cf {_cf =_d ;};_aa =8-_cf ;_dg =(_dg <<uint (_cf ))|uint32 (_dd >>uint (_aa ));if _cf < 8{_fe =_dd <<uint (_cf );};_d -=_cf ;
if _d ==0{_cac =append (_cac ,_dg );_d =bitsPerSample ;_dg =0;_ad ++;};};};for _aa >=bitsPerSample {_ade :=_aa ;if _d < _ade {_ade =_d ;};_dg =(_dg <<uint (_ade ))|uint32 (_fe >>uint (8-_ade ));_aa -=_ade ;if _aa > 0{_fe =_fe <<uint (_ade );}else {_fe =0;
};_d -=_ade ;if _d ==0{_cac =append (_cac ,_dg );_d =bitsPerSample ;_dg =0;_ad ++;};};return _cac ;};func NewReader (img _f .ImageBase )*Reader {return &Reader {_cd :_a .NewReader (img .Data ),_gg :img ,_eb :img .ColorComponents ,_b :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Reader struct{_gg _f .ImageBase ;_cd *_a .Reader ;_gc ,_fd ,_eb int ;_b bool ;};func (_abc *Writer )WriteSamples (samples []uint32 )error {for _fdd :=0;_fdd < len (samples );_fdd ++{if _afc :=_abc .WriteSample (samples [_fdd ]);_afc !=nil {return _afc ;
};};return nil ;};func NewWriter (img _f .ImageBase )*Writer {return &Writer {_gf :_a .NewWriterMSB (img .Data ),_da :img ,_adeb :img .ColorComponents ,_add :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_ff *Reader )ReadSample ()(uint32 ,error ){if _ff ._fd ==_ff ._gg .Height {return 0,_e .EOF ;
};_ae ,_bf :=_ff ._cd .ReadBits (byte (_ff ._gg .BitsPerComponent ));if _bf !=nil {return 0,_bf ;};_ff ._eb --;if _ff ._eb ==0{_ff ._eb =_ff ._gg .ColorComponents ;_ff ._gc ++;};if _ff ._gc ==_ff ._gg .Width {if _ff ._b {_ff ._cd .ConsumeRemainingBits ();
};_ff ._gc =0;_ff ._fd ++;};return uint32 (_ae ),nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_g []uint32 )error ;};func (_afe *Writer )WriteSample (sample uint32 )error {if _ ,_aegc :=_afe ._gf .WriteBits (uint64 (sample ),_afe ._da .BitsPerComponent );
_aegc !=nil {return _aegc ;};_afe ._adeb --;if _afe ._adeb ==0{_afe ._adeb =_afe ._da .ColorComponents ;_afe ._cb ++;};if _afe ._cb ==_afe ._da .Width {if _afe ._add {_afe ._gf .FinishByte ();};_afe ._cb =0;};return nil ;};type Writer struct{_da _f .ImageBase ;
_gf *_a .Writer ;_cb ,_adeb int ;_add bool ;};type SampleWriter interface{WriteSample (_eaf uint32 )error ;WriteSamples (_caa []uint32 )error ;};