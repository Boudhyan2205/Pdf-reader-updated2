//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_ff "github.com/unidoc/unipdf/v3/internal/bitwise";_cb "github.com/unidoc/unipdf/v3/internal/imageutil";_f "io";);func (_ae *Reader )ReadSample ()(uint32 ,error ){if _ae ._ec ==_ae ._e .Height {return 0,_f .EOF ;};_ee ,_d :=_ae ._g .ReadBits (byte (_ae ._e .BitsPerComponent ));
if _d !=nil {return 0,_d ;};_ae ._ge --;if _ae ._ge ==0{_ae ._ge =_ae ._e .ColorComponents ;_ae ._b ++;};if _ae ._b ==_ae ._e .Width {if _ae ._ce {_ae ._g .ConsumeRemainingBits ();};_ae ._b =0;_ae ._ec ++;};return uint32 (_ee ),nil ;};type Reader struct{_e _cb .ImageBase ;
_g *_ff .Reader ;_b ,_ec ,_ge int ;_ce bool ;};func (_eba *Writer )WriteSample (sample uint32 )error {if _ ,_add :=_eba ._adf .WriteBits (uint64 (sample ),_eba ._ga .BitsPerComponent );_add !=nil {return _add ;};_eba ._aee --;if _eba ._aee ==0{_eba ._aee =_eba ._ga .ColorComponents ;
_eba ._cee ++;};if _eba ._cee ==_eba ._ga .Width {if _eba ._gc {_eba ._adf .FinishByte ();};_eba ._cee =0;};return nil ;};type SampleWriter interface{WriteSample (_ecg uint32 )error ;WriteSamples (_afe []uint32 )error ;};type Writer struct{_ga _cb .ImageBase ;
_adf *_ff .Writer ;_cee ,_aee int ;_gc bool ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_a []uint32 )error ;};func (_dc *Reader )ReadSamples (samples []uint32 )(_dcf error ){for _ef :=0;_ef < len (samples );_ef ++{samples [_ef ],_dcf =_dc .ReadSample ();
if _dcf !=nil {return _dcf ;};};return nil ;};func NewReader (img _cb .ImageBase )*Reader {return &Reader {_g :_ff .NewReader (img .Data ),_e :img ,_ge :img .ColorComponents ,_ce :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _bc []uint32 ;_aa :=bitsPerSample ;var _eea uint32 ;var _dd byte ;_gea :=0;_da :=0;_ad :=0;for _ad < len (data ){if _gea > 0{_bb :=_gea ;if _aa < _bb {_bb =_aa ;};_eea =(_eea <<uint (_bb ))|uint32 (_dd >>uint (8-_bb ));
_gea -=_bb ;if _gea > 0{_dd =_dd <<uint (_bb );}else {_dd =0;};_aa -=_bb ;if _aa ==0{_bc =append (_bc ,_eea );_aa =bitsPerSample ;_eea =0;_da ++;};}else {_ecb :=data [_ad ];_ad ++;_dcfb :=8;if _aa < _dcfb {_dcfb =_aa ;};_gea =8-_dcfb ;_eea =(_eea <<uint (_dcfb ))|uint32 (_ecb >>uint (_gea ));
if _dcfb < 8{_dd =_ecb <<uint (_dcfb );};_aa -=_dcfb ;if _aa ==0{_bc =append (_bc ,_eea );_aa =bitsPerSample ;_eea =0;_da ++;};};};for _gea >=bitsPerSample {_ffc :=_gea ;if _aa < _ffc {_ffc =_aa ;};_eea =(_eea <<uint (_ffc ))|uint32 (_dd >>uint (8-_ffc ));
_gea -=_ffc ;if _gea > 0{_dd =_dd <<uint (_ffc );}else {_dd =0;};_aa -=_ffc ;if _aa ==0{_bc =append (_bc ,_eea );_aa =bitsPerSample ;_eea =0;_da ++;};};return _bc ;};func (_cc *Writer )WriteSamples (samples []uint32 )error {for _ged :=0;_ged < len (samples );
_ged ++{if _gcd :=_cc .WriteSample (samples [_ged ]);_gcd !=nil {return _gcd ;};};return nil ;};func NewWriter (img _cb .ImageBase )*Writer {return &Writer {_adf :_ff .NewWriterMSB (img .Data ),_ga :img ,_aee :img .ColorComponents ,_gc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _cg []uint32 ;_daa :=bitsPerOutputSample ;var _df uint32 ;var _efg uint32 ;_bbb :=0;_dcd :=0;_ddb :=0;for _ddb < len (data ){if _bbb > 0{_eb :=_bbb ;if _daa < _eb {_eb =_daa ;
};_df =(_df <<uint (_eb ))|(_efg >>uint (bitsPerInputSample -_eb ));_bbb -=_eb ;if _bbb > 0{_efg =_efg <<uint (_eb );}else {_efg =0;};_daa -=_eb ;if _daa ==0{_cg =append (_cg ,_df );_daa =bitsPerOutputSample ;_df =0;_dcd ++;};}else {_be :=data [_ddb ];
_ddb ++;_af :=bitsPerInputSample ;if _daa < _af {_af =_daa ;};_bbb =bitsPerInputSample -_af ;_df =(_df <<uint (_af ))|(_be >>uint (_bbb ));if _af < bitsPerInputSample {_efg =_be <<uint (_af );};_daa -=_af ;if _daa ==0{_cg =append (_cg ,_df );_daa =bitsPerOutputSample ;
_df =0;_dcd ++;};};};for _bbb >=bitsPerOutputSample {_fg :=_bbb ;if _daa < _fg {_fg =_daa ;};_df =(_df <<uint (_fg ))|(_efg >>uint (bitsPerInputSample -_fg ));_bbb -=_fg ;if _bbb > 0{_efg =_efg <<uint (_fg );}else {_efg =0;};_daa -=_fg ;if _daa ==0{_cg =append (_cg ,_df );
_daa =bitsPerOutputSample ;_df =0;_dcd ++;};};if _daa > 0&&_daa < bitsPerOutputSample {_df <<=uint (_daa );_cg =append (_cg ,_df );};return _cg ;};