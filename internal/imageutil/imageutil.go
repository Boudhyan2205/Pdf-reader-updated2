//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_fa "encoding/binary";_a "errors";_e "fmt";_ga "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/bitwise";_f "image";_c "image/color";_d "image/draw";_ae "math";);var _ _f .Image =&Monochrome {};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_egc :=y *bytesPerLine +x >>3;
if _egc >=len (data ){return _c .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cacc :=data [_egc ]>>uint (7-(x &7))&1;if len (decode )==2{_cacc =uint8 (LinearInterpolate (float64 (_cacc ),0.0,1.0,decode [0],decode [1]))&1;};return _c .Gray {Y :_cacc *255},nil ;};type shift int ;type RGBA32 struct{ImageBase };func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_e .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_faga *Gray16 )Set (x ,y int ,c _c .Color ){_ade :=(y *_faga .BytesPerLine /2+x )*2;if _ade +1>=len (_faga .Data ){return ;};_cga :=_c .Gray16Model .Convert (c ).(_c .Gray16 );_faga .Data [_ade ],_faga .Data [_ade +1]=uint8 (_cga .Y >>8),uint8 (_cga .Y &0xff);
};var _ Image =&CMYK32 {};func _aeegc (_fcab *Monochrome ,_abca ,_eegaef int ,_bag ,_dcef int ,_fafg RasterOperator ){var (_dgaf int ;_fggc byte ;_ggfd ,_cbbcd int ;_adca int ;);_fadf :=_bag >>3;_aafb :=_bag &7;if _aafb > 0{_fggc =_bdbd [_aafb ];};_dgaf =_fcab .BytesPerLine *_eegaef +(_abca >>3);
switch _fafg {case PixClr :for _ggfd =0;_ggfd < _dcef ;_ggfd ++{_adca =_dgaf +_ggfd *_fcab .BytesPerLine ;for _cbbcd =0;_cbbcd < _fadf ;_cbbcd ++{_fcab .Data [_adca ]=0x0;_adca ++;};if _aafb > 0{_fcab .Data [_adca ]=_bacd (_fcab .Data [_adca ],0x0,_fggc );
};};case PixSet :for _ggfd =0;_ggfd < _dcef ;_ggfd ++{_adca =_dgaf +_ggfd *_fcab .BytesPerLine ;for _cbbcd =0;_cbbcd < _fadf ;_cbbcd ++{_fcab .Data [_adca ]=0xff;_adca ++;};if _aafb > 0{_fcab .Data [_adca ]=_bacd (_fcab .Data [_adca ],0xff,_fggc );};};
case PixNotDst :for _ggfd =0;_ggfd < _dcef ;_ggfd ++{_adca =_dgaf +_ggfd *_fcab .BytesPerLine ;for _cbbcd =0;_cbbcd < _fadf ;_cbbcd ++{_fcab .Data [_adca ]=^_fcab .Data [_adca ];_adca ++;};if _aafb > 0{_fcab .Data [_adca ]=_bacd (_fcab .Data [_adca ],^_fcab .Data [_adca ],_fggc );
};};};};func (_acdd *NRGBA16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_acdd .Width ,Y :_acdd .Height }};};var (MonochromeConverter =ConverterFunc (_gdd );Gray2Converter =ConverterFunc (_dgdb );Gray4Converter =ConverterFunc (_eaad );
GrayConverter =ConverterFunc (_ddd );Gray16Converter =ConverterFunc (_deae );NRGBA16Converter =ConverterFunc (_dfdgc );NRGBAConverter =ConverterFunc (_fgceg );NRGBA64Converter =ConverterFunc (_cgaa );RGBAConverter =ConverterFunc (_dcac );CMYKConverter =ConverterFunc (_bcfg );
);func (_bbff *RGBA32 )At (x ,y int )_c .Color {_gedeg ,_ :=_bbff .ColorAt (x ,y );return _gedeg };type NRGBA interface{NRGBAAt (_fcag ,_fgbe int )_c .NRGBA ;SetNRGBA (_aaef ,_gaaeg int ,_dccb _c .NRGBA );};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_ff :=BytesPerLine (width ,8,1);
if len (data )< _ff *height {return nil ,nil ;};_gae :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_cd ,_bb :=MonochromeConverter .Convert (_gae );if _bb !=nil {return nil ,_bb ;};return _cd .Base ().Data ,nil ;};func (_abfd *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _gad bool ;
_fegg :=scale ;if scale < 1{_fegg =1/scale ;_gad =true ;};_aeeg :=NextPowerOf2 (uint (_fegg ));if InDelta (float64 (_aeeg ),_fegg ,0.001){if _gad {return _abfd .ReduceBinary (_fegg );};return _abfd .ExpandBinary (int (_aeeg ));};_gaeg :=int (_ae .RoundToEven (float64 (_abfd .Width )*scale ));
_ddbc :=int (_ae .RoundToEven (float64 (_abfd .Height )*scale ));return _abfd .ScaleLow (_gaeg ,_ddbc );};type colorConverter struct{_bffb func (_fce _f .Image )(Image ,error );};func (_ebccc *RGBA32 )Validate ()error {if len (_ebccc .Data )!=3*_ebccc .Width *_ebccc .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ Gray =&Monochrome {};type ColorConverter interface{Convert (_ecge _f .Image )(Image ,error );};func _aaag (_dfdg int ,_ecae int )int {if _dfdg < _ecae {return _dfdg ;};return _ecae ;};func _bec (_afda ,_geb CMYK ,_cfb _f .Rectangle ){for _cfad :=0;
_cfad < _cfb .Max .X ;_cfad ++{for _fede :=0;_fede < _cfb .Max .Y ;_fede ++{_geb .SetCMYK (_cfad ,_fede ,_afda .CMYKAt (_cfad ,_fede ));};};};func _cbdf (_fgcc RGBA ,_ggc Gray ,_cabg _f .Rectangle ){for _dbeg :=0;_dbeg < _cabg .Max .X ;_dbeg ++{for _fge :=0;
_fge < _cabg .Max .Y ;_fge ++{_dbac :=_aedf (_fgcc .RGBAAt (_dbeg ,_fge ));_ggc .SetGray (_dbeg ,_fge ,_dbac );};};};func _bga (_eacf ,_fcad NRGBA ,_cfac _f .Rectangle ){for _cafd :=0;_cafd < _cfac .Max .X ;_cafd ++{for _cgcf :=0;_cgcf < _cfac .Max .Y ;
_cgcf ++{_fcad .SetNRGBA (_cafd ,_cgcf ,_eacf .NRGBAAt (_cafd ,_cgcf ));};};};func _bbad (_cagf Gray ,_bfef nrgba64 ,_dbba _f .Rectangle ){for _cfef :=0;_cfef < _dbba .Max .X ;_cfef ++{for _ged :=0;_ged < _dbba .Max .Y ;_ged ++{_eeg :=_ffdf (_bfef .NRGBA64At (_cfef ,_ged ));
_cagf .SetGray (_cfef ,_ged ,_eeg );};};};func _cfbd (_bdffe _c .NRGBA )_c .Gray {var _gcd _c .NRGBA ;if _bdffe ==_gcd {return _c .Gray {Y :0xff};};_ddeg ,_bge ,_gdeg ,_ :=_bdffe .RGBA ();_abcg :=(19595*_ddeg +38470*_bge +7471*_gdeg +1<<15)>>24;return _c .Gray {Y :uint8 (_abcg )};
};type Gray4 struct{ImageBase };func (_bdfde *RGBA32 )ColorModel ()_c .Model {return _c .NRGBAModel };var _ Gray =&Gray16 {};func _edc (_add NRGBA ,_cabd CMYK ,_ecee _f .Rectangle ){for _cdbe :=0;_cdbe < _ecee .Max .X ;_cdbe ++{for _eea :=0;_eea < _ecee .Max .Y ;
_eea ++{_bfce :=_add .NRGBAAt (_cdbe ,_eea );_cabd .SetCMYK (_cdbe ,_eea ,_cdc (_bfce ));};};};func _dfa ()(_aag [256]uint16 ){for _fag :=0;_fag < 256;_fag ++{if _fag &0x01!=0{_aag [_fag ]|=0x3;};if _fag &0x02!=0{_aag [_fag ]|=0xc;};if _fag &0x04!=0{_aag [_fag ]|=0x30;
};if _fag &0x08!=0{_aag [_fag ]|=0xc0;};if _fag &0x10!=0{_aag [_fag ]|=0x300;};if _fag &0x20!=0{_aag [_fag ]|=0xc00;};if _fag &0x40!=0{_aag [_fag ]|=0x3000;};if _fag &0x80!=0{_aag [_fag ]|=0xc000;};};return _aag ;};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_e .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func InDelta (expected ,current ,delta float64 )bool {_bede :=expected -current ;if _bede <=-delta ||_bede >=delta {return false ;};return true ;};func (_cdgaa *RGBA32 )Set (x ,y int ,c _c .Color ){_fegc :=y *_cdgaa .Width +x ;_baca :=3*_fegc ;if _baca +2>=len (_cdgaa .Data ){return ;
};_dgbfb :=_c .RGBAModel .Convert (c ).(_c .RGBA );_cdgaa .setRGBA (_fegc ,_dgbfb );};func (_eege *Gray8 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_eege .Width ,Y :_eege .Height }};};func (_eeed *NRGBA64 )At (x ,y int )_c .Color {_affed ,_ :=_eeed .ColorAt (x ,y );
return _affed };func (_gcgb *NRGBA32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA32 (x ,y ,_gcgb .Width ,_gcgb .Data ,_gcgb .Alpha ,_gcgb .Decode );};func (_gdae *NRGBA32 )Base ()*ImageBase {return &_gdae .ImageBase };func _fad (_fagb *Monochrome ,_cede ,_bgde ,_bca ,_ebe int ,_fcdb RasterOperator ,_gbdc *Monochrome ,_gacg ,_begf int )error {var (_gega byte ;
_bdfd int ;_fgff int ;_fabg ,_eabc int ;_bgda ,_caag int ;);_befa :=_bca >>3;_efbba :=_bca &7;if _efbba > 0{_gega =_bdbd [_efbba ];};_bdfd =_gbdc .BytesPerLine *_begf +(_gacg >>3);_fgff =_fagb .BytesPerLine *_bgde +(_cede >>3);switch _fcdb {case PixSrc :for _bgda =0;
_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]=_gbdc .Data [_fabg ];_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],_gbdc .Data [_fabg ],_gega );
};};case PixNotSrc :for _bgda =0;_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]=^(_gbdc .Data [_fabg ]);_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],^_gbdc .Data [_fabg ],_gega );
};};case PixSrcOrDst :for _bgda =0;_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]|=_gbdc .Data [_fabg ];_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],_gbdc .Data [_fabg ]|_fagb .Data [_eabc ],_gega );
};};case PixSrcAndDst :for _bgda =0;_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]&=_gbdc .Data [_fabg ];_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],_gbdc .Data [_fabg ]&_fagb .Data [_eabc ],_gega );
};};case PixSrcXorDst :for _bgda =0;_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]^=_gbdc .Data [_fabg ];_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],_gbdc .Data [_fabg ]^_fagb .Data [_eabc ],_gega );
};};case PixNotSrcOrDst :for _bgda =0;_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]|=^(_gbdc .Data [_fabg ]);_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],^(_gbdc .Data [_fabg ])|_fagb .Data [_eabc ],_gega );
};};case PixNotSrcAndDst :for _bgda =0;_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]&=^(_gbdc .Data [_fabg ]);_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],^(_gbdc .Data [_fabg ])&_fagb .Data [_eabc ],_gega );
};};case PixSrcOrNotDst :for _bgda =0;_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]=_gbdc .Data [_fabg ]|^(_fagb .Data [_eabc ]);_eabc ++;
_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],_gbdc .Data [_fabg ]|^(_fagb .Data [_eabc ]),_gega );};};case PixSrcAndNotDst :for _bgda =0;_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;
for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]=_gbdc .Data [_fabg ]&^(_fagb .Data [_eabc ]);_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],_gbdc .Data [_fabg ]&^(_fagb .Data [_eabc ]),_gega );};};case PixNotPixSrcOrDst :for _bgda =0;
_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]=^(_gbdc .Data [_fabg ]|_fagb .Data [_eabc ]);_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],^(_gbdc .Data [_fabg ]|_fagb .Data [_eabc ]),_gega );
};};case PixNotPixSrcAndDst :for _bgda =0;_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]=^(_gbdc .Data [_fabg ]&_fagb .Data [_eabc ]);
_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],^(_gbdc .Data [_fabg ]&_fagb .Data [_eabc ]),_gega );};};case PixNotPixSrcXorDst :for _bgda =0;_bgda < _ebe ;_bgda ++{_fabg =_bdfd +_bgda *_gbdc .BytesPerLine ;_eabc =_fgff +_bgda *_fagb .BytesPerLine ;
for _caag =0;_caag < _befa ;_caag ++{_fagb .Data [_eabc ]=^(_gbdc .Data [_fabg ]^_fagb .Data [_eabc ]);_eabc ++;_fabg ++;};if _efbba > 0{_fagb .Data [_eabc ]=_bacd (_fagb .Data [_eabc ],^(_gbdc .Data [_fabg ]^_fagb .Data [_eabc ]),_gega );};};default:_ga .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_fcdb );
return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_gggf *Gray8 )Base ()*ImageBase {return &_gggf .ImageBase };func _fadgc (_bdffg _f .Image ,_gfda Image ,_dbdb _f .Rectangle ){if _gbdfa ,_gbeb :=_bdffg .(SMasker );
_gbeb &&_gbdfa .HasAlpha (){_gfda .(SMasker ).MakeAlpha ();};switch _fccfg :=_bdffg .(type ){case Gray :_egfdd (_fccfg ,_gfda .(NRGBA ),_dbdb );case NRGBA :_bga (_fccfg ,_gfda .(NRGBA ),_dbdb );case *_f .NYCbCrA :_ddea (_fccfg ,_gfda .(NRGBA ),_dbdb );
case CMYK :_dgaff (_fccfg ,_gfda .(NRGBA ),_dbdb );case RGBA :_bcbc (_fccfg ,_gfda .(NRGBA ),_dbdb );case nrgba64 :_fbga (_fccfg ,_gfda .(NRGBA ),_dbdb );default:_afc (_bdffg ,_gfda ,_dbdb );};};func _cdc (_cbc _c .NRGBA )_c .CMYK {_faa ,_fda ,_fdg ,_ :=_cbc .RGBA ();
_cgc ,_edf ,_fcg ,_gdge :=_c .RGBToCMYK (uint8 (_faa >>8),uint8 (_fda >>8),uint8 (_fdg >>8));return _c .CMYK {C :_cgc ,M :_edf ,Y :_fcg ,K :_gdge };};func (_egced *ImageBase )getByte (_aedd int )(byte ,error ){if _aedd > len (_egced .Data )-1||_aedd < 0{return 0,_e .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_aedd );
};return _egced .Data [_aedd ],nil ;};func _faebf (_gffg _c .NYCbCrA )_c .NRGBA {_edd :=int32 (_gffg .Y )*0x10101;_aebb :=int32 (_gffg .Cb )-128;_gfaa :=int32 (_gffg .Cr )-128;_gbee :=_edd +91881*_gfaa ;if uint32 (_gbee )&0xff000000==0{_gbee >>=8;}else {_gbee =^(_gbee >>31)&0xffff;
};_cabb :=_edd -22554*_aebb -46802*_gfaa ;if uint32 (_cabb )&0xff000000==0{_cabb >>=8;}else {_cabb =^(_cabb >>31)&0xffff;};_ffdg :=_edd +116130*_aebb ;if uint32 (_ffdg )&0xff000000==0{_ffdg >>=8;}else {_ffdg =^(_ffdg >>31)&0xffff;};return _c .NRGBA {R :uint8 (_gbee >>8),G :uint8 (_cabb >>8),B :uint8 (_ffdg >>8),A :_gffg .A };
};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_eaafb :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_eaafb .Data =make ([]byte ,height *_eaafb .BytesPerLine );};return _eaafb ;};func _fgceg (_befe _f .Image )(Image ,error ){if _cbeaf ,_aaeg :=_befe .(*NRGBA32 );_aaeg {return _cbeaf .Copy (),nil ;};_bdbe ,_efcbg ,_dbgb :=_gcae (_befe ,1);
_ddgfa ,_cgea :=NewImage (_bdbe .Max .X ,_bdbe .Max .Y ,8,3,nil ,_dbgb ,nil );if _cgea !=nil {return nil ,_cgea ;};_fadgc (_befe ,_ddgfa ,_bdbe );if len (_dbgb )!=0&&!_efcbg {if _caaa :=_cafb (_dbgb ,_ddgfa );_caaa !=nil {return nil ,_caaa ;};};return _ddgfa ,nil ;
};func (_bea *Gray16 )At (x ,y int )_c .Color {_gccb ,_ :=_bea .ColorAt (x ,y );return _gccb };func _efdg (_abdb _c .CMYK )_c .NRGBA {_dgc ,_abg ,_aee :=_c .CMYKToRGB (_abdb .C ,_abdb .M ,_abdb .Y ,_abdb .K );return _c .NRGBA {R :_dgc ,G :_abg ,B :_aee ,A :0xff};
};func _ebce (_dabc _c .NRGBA64 )_c .NRGBA {return _c .NRGBA {R :uint8 (_dabc .R >>8),G :uint8 (_dabc .G >>8),B :uint8 (_dabc .B >>8),A :uint8 (_dabc .A >>8)};};func (_dbf *NRGBA64 )Set (x ,y int ,c _c .Color ){_ecgb :=(y *_dbf .Width +x )*2;_afef :=_ecgb *3;
if _afef +5>=len (_dbf .Data ){return ;};_bbfe :=_c .NRGBA64Model .Convert (c ).(_c .NRGBA64 );_dbf .setNRGBA64 (_afef ,_bbfe ,_ecgb );};func _fae (_acg int )[]uint {var _ecf []uint ;_gaee :=_acg ;_cgbe :=_gaee /8;if _cgbe !=0{for _fgdf :=0;_fgdf < _cgbe ;
_fgdf ++{_ecf =append (_ecf ,8);};_feb :=_gaee %8;_gaee =0;if _feb !=0{_gaee =_feb ;};};_eeb :=_gaee /4;if _eeb !=0{for _gbc :=0;_gbc < _eeb ;_gbc ++{_ecf =append (_ecf ,4);};_gbg :=_gaee %4;_gaee =0;if _gbg !=0{_gaee =_gbg ;};};_cgf :=_gaee /2;if _cgf !=0{for _bae :=0;
_bae < _cgf ;_bae ++{_ecf =append (_ecf ,2);};};return _ecf ;};func (_gggb *Gray4 )SetGray (x ,y int ,g _c .Gray ){if x >=_gggb .Width ||y >=_gggb .Height {return ;};g =_dabd (g );_gggb .setGray (x ,y ,g );};func (_fee *Gray4 )Set (x ,y int ,c _c .Color ){if x >=_fee .Width ||y >=_fee .Height {return ;
};_bbee :=Gray4Model .Convert (c ).(_c .Gray );_fee .setGray (x ,y ,_bbee );};func (_dabf *NRGBA32 )At (x ,y int )_c .Color {_eabf ,_ :=_dabf .ColorAt (x ,y );return _eabf };func (_ceb *Monochrome )IsUnpadded ()bool {return (_ceb .Width *_ceb .Height )==len (_ceb .Data )};
func _gdd (_ggf _f .Image )(Image ,error ){if _fdad ,_dfba :=_ggf .(*Monochrome );_dfba {return _fdad ,nil ;};_aecd :=_ggf .Bounds ();var _dag Gray ;switch _fgdg :=_ggf .(type ){case Gray :_dag =_fgdg ;case NRGBA :_dag =&Gray8 {ImageBase :NewImageBase (_aecd .Max .X ,_aecd .Max .Y ,8,1,nil ,nil ,nil )};
_ccaa (_dag ,_fgdg ,_aecd );case nrgba64 :_dag =&Gray8 {ImageBase :NewImageBase (_aecd .Max .X ,_aecd .Max .Y ,8,1,nil ,nil ,nil )};_bbad (_dag ,_fgdg ,_aecd );default:_beb ,_ecac :=GrayConverter .Convert (_ggf );if _ecac !=nil {return nil ,_ecac ;};_dag =_beb .(Gray );
};_dga ,_dea :=NewImage (_aecd .Max .X ,_aecd .Max .Y ,1,1,nil ,nil ,nil );if _dea !=nil {return nil ,_dea ;};_fbff :=_dga .(*Monochrome );_gfaaf :=AutoThresholdTriangle (GrayHistogram (_dag ));for _afe :=0;_afe < _aecd .Max .X ;_afe ++{for _cbcc :=0;_cbcc < _aecd .Max .Y ;
_cbcc ++{_afea :=_ggde (_dag .GrayAt (_afe ,_cbcc ),monochromeModel (_gfaaf ));_fbff .SetGray (_afe ,_cbcc ,_afea );};};return _dga ,nil ;};func (_caa *Gray2 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_caa .Width ,Y :_caa .Height }};
};var _ Image =&NRGBA64 {};func (_acb *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_acf :=_ddab (uint (factor ));if !IsPowerOf2 (uint (factor )){_acf ++;};_bbaf :=make ([]int ,_acf );for _aef :=range _bbaf {_bbaf [_aef ]=4;};_ecag ,_cfdc :=_dbe (_acb ,_bbaf ...);
if _cfdc !=nil {return nil ,_cfdc ;};return _ecag ,nil ;};func (_febc *CMYK32 )Validate ()error {if len (_febc .Data )!=4*_febc .Width *_febc .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fef *ImageBase )MakeAlpha (){_fef .newAlpha ()};var _ Image =&NRGBA16 {};func _dabd (_gaba _c .Gray )_c .Gray {_gaba .Y >>=4;_gaba .Y |=_gaba .Y <<4;return _gaba };func (_abea *ImageBase )setEightPartlyBytes (_bcc ,_abdd int ,_agcg uint64 )(_bbbd error ){var (_bbbg byte ;
_fcdce int ;);for _aedga :=1;_aedga <=_abdd ;_aedga ++{_fcdce =64-_aedga *8;_bbbg =byte (_agcg >>uint (_fcdce )&0xff);if _bbbd =_abea .setByte (_bcc +_aedga -1,_bbbg );_bbbd !=nil {return _bbbd ;};};_gedf :=_abea .BytesPerLine *8-_abea .Width ;if _gedf ==0{return nil ;
};_fcdce -=8;_bbbg =byte (_agcg >>uint (_fcdce )&0xff)<<uint (_gedf );if _bbbd =_abea .setByte (_bcc +_abdd ,_bbbg );_bbbd !=nil {return _bbbd ;};return nil ;};func (_fbac *Gray16 )Base ()*ImageBase {return &_fbac .ImageBase };func _bd ()(_efbf [256]uint64 ){for _dff :=0;
_dff < 256;_dff ++{if _dff &0x01!=0{_efbf [_dff ]|=0xff;};if _dff &0x02!=0{_efbf [_dff ]|=0xff00;};if _dff &0x04!=0{_efbf [_dff ]|=0xff0000;};if _dff &0x08!=0{_efbf [_dff ]|=0xff000000;};if _dff &0x10!=0{_efbf [_dff ]|=0xff00000000;};if _dff &0x20!=0{_efbf [_dff ]|=0xff0000000000;
};if _dff &0x40!=0{_efbf [_dff ]|=0xff000000000000;};if _dff &0x80!=0{_efbf [_dff ]|=0xff00000000000000;};};return _efbf ;};func (_badb *NRGBA16 )Set (x ,y int ,c _c .Color ){_ffbb :=y *_badb .BytesPerLine +x *3/2;if _ffbb +1>=len (_badb .Data ){return ;
};_dgge :=NRGBA16Model .Convert (c ).(_c .NRGBA );_badb .setNRGBA (x ,y ,_ffbb ,_dgge );};func FromGoImage (i _f .Image )(Image ,error ){switch _abag :=i .(type ){case Image :return _abag .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_f .Gray16 :return Gray16Converter .Convert (i );
case CMYK :return CMYKConverter .Convert (i );case *_f .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_eeda *Gray2 )Set (x ,y int ,c _c .Color ){if x >=_eeda .Width ||y >=_eeda .Height {return ;};_dcfaa :=Gray2Model .Convert (c ).(_c .Gray );
_ddfd :=y *_eeda .BytesPerLine ;_cgba :=_ddfd +(x >>2);_dbaa :=_dcfaa .Y >>6;_eeda .Data [_cgba ]=(_eeda .Data [_cgba ]&(^(0xc0>>uint (2*((x )&3)))))|(_dbaa <<uint (6-2*(x &3)));};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _fec (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_efcb *Monochrome )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_efcb .Width ,Y :_efcb .Height }};};func init (){_agg ()};func (_ccg *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_ccg .copy ()}};func _ebdf (_fbfc *Monochrome ,_dbg ,_dfbgd ,_efce ,_gbdg int ,_gfe RasterOperator ){if _dbg < 0{_efce +=_dbg ;
_dbg =0;};_bce :=_dbg +_efce -_fbfc .Width ;if _bce > 0{_efce -=_bce ;};if _dfbgd < 0{_gbdg +=_dfbgd ;_dfbgd =0;};_age :=_dfbgd +_gbdg -_fbfc .Height ;if _age > 0{_gbdg -=_age ;};if _efce <=0||_gbdg <=0{return ;};if (_dbg &7)==0{_aeegc (_fbfc ,_dbg ,_dfbgd ,_efce ,_gbdg ,_gfe );
}else {_dddgb (_fbfc ,_dbg ,_dfbgd ,_efce ,_gbdg ,_gfe );};};func (_becf *Gray2 )SetGray (x ,y int ,gray _c .Gray ){_bbbe :=_aced (gray );_cfaf :=y *_becf .BytesPerLine ;_aea :=_cfaf +(x >>2);if _aea >=len (_becf .Data ){return ;};_fbfa :=_bbbe .Y >>6;
_becf .Data [_aea ]=(_becf .Data [_aea ]&(^(0xc0>>uint (2*((x )&3)))))|(_fbfa <<uint (6-2*(x &3)));};func (_gbea *Monochrome )setBit (_cgca ,_ecc int ){_gbea .Data [_cgca +(_ecc >>3)]|=0x80>>uint (_ecc &7)};type RGBA interface{RGBAAt (_ddgf ,_gafe int )_c .RGBA ;
SetRGBA (_baaf ,_dfdgd int ,_gceb _c .RGBA );};func (_gdc *Gray16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_gdc .Width ,Y :_gdc .Height }};};func _deae (_cfbc _f .Image )(Image ,error ){if _cgfa ,_dbdg :=_cfbc .(*Gray16 );_dbdg {return _cgfa .Copy (),nil ;
};_eegae :=_cfbc .Bounds ();_dgad ,_dege :=NewImage (_eegae .Max .X ,_eegae .Max .Y ,16,1,nil ,nil ,nil );if _dege !=nil {return nil ,_dege ;};_ggec (_cfbc ,_dgad ,_eegae );return _dgad ,nil ;};func (_dffe *NRGBA16 )setNRGBA (_fdcce ,_cdcf ,_ggfdf int ,_ebge _c .NRGBA ){if _fdcce *3%2==0{_dffe .Data [_ggfdf ]=(_ebge .R >>4)<<4|(_ebge .G >>4);
_dffe .Data [_ggfdf +1]=(_ebge .B >>4)<<4|(_dffe .Data [_ggfdf +1]&0xf);}else {_dffe .Data [_ggfdf ]=(_dffe .Data [_ggfdf ]&0xf0)|(_ebge .R >>4);_dffe .Data [_ggfdf +1]=(_ebge .G >>4)<<4|(_ebge .B >>4);};if _dffe .Alpha !=nil {_eecc :=_cdcf *BytesPerLine (_dffe .Width ,4,1);
if _eecc < len (_dffe .Alpha ){if _fdcce %2==0{_dffe .Alpha [_eecc ]=(_ebge .A >>uint (4))<<uint (4)|(_dffe .Alpha [_ggfdf ]&0xf);}else {_dffe .Alpha [_eecc ]=(_dffe .Alpha [_eecc ]&0xf0)|(_ebge .A >>uint (4));};};};};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_ddaf :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _ddaf ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_gaaeb :=width *colorComponents *bitsPerComponent ;_addc :=_ddaf *8;_fbb :=8-(_addc -_gaaeb );_bbfa :=_b .NewReader (data );_feda :=_ddaf -1;_egfd :=make ([]byte ,_feda );_gec :=make ([]byte ,height *_ddaf );
_cbdcb :=_b .NewWriterMSB (_gec );var _edca uint64 ;var _acea error ;for _fega :=0;_fega < height ;_fega ++{_ ,_acea =_bbfa .Read (_egfd );if _acea !=nil {return nil ,_acea ;};_ ,_acea =_cbdcb .Write (_egfd );if _acea !=nil {return nil ,_acea ;};_edca ,_acea =_bbfa .ReadBits (byte (_fbb ));
if _acea !=nil {return nil ,_acea ;};_ ,_acea =_cbdcb .WriteBits (_edca ,_fbb );if _acea !=nil {return nil ,_acea ;};_cbdcb .FinishByte ();};return _gec ,nil ;};func (_bfcg *Gray4 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray4BPC (x ,y ,_bfcg .BytesPerLine ,_bfcg .Data ,_bfcg .Decode );
};func (_cfd *CMYK32 )CMYKAt (x ,y int )_c .CMYK {_fde ,_ :=ColorAtCMYK (x ,y ,_cfd .Width ,_cfd .Data ,_cfd .Decode );return _fde ;};func ConverterFunc (converterFunc func (_dgf _f .Image )(Image ,error ))ColorConverter {return colorConverter {_bffb :converterFunc };
};func (_bcgb *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _ab (_bcgb ,factor );};func _cafb (_acffe []byte ,_gaag Image )error {_ebaf :=true ;for _bedc :=0;_bedc < len (_acffe );_bedc ++{if _acffe [_bedc ]!=0xff{_ebaf =false ;break ;};};if _ebaf {switch _ggff :=_gaag .(type ){case *NRGBA32 :_ggff .Alpha =nil ;
case *NRGBA64 :_ggff .Alpha =nil ;default:return _e .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_gaag );
};};return nil ;};func (_bde *Gray8 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray8BPC (x ,y ,_bde .BytesPerLine ,_bde .Data ,_bde .Decode );};func _ccgd (_bbc _c .CMYK )_c .Gray {_cceg ,_cbd ,_geaf :=_c .CMYKToRGB (_bbc .C ,_bbc .M ,_bbc .Y ,_bbc .K );
_fagg :=(19595*uint32 (_cceg )+38470*uint32 (_cbd )+7471*uint32 (_geaf )+1<<7)>>16;return _c .Gray {Y :uint8 (_fagg )};};type nrgba64 interface{NRGBA64At (_babe ,_ffbcb int )_c .NRGBA64 ;SetNRGBA64 (_bbcc ,_bdbg int ,_fadd _c .NRGBA64 );};func (_cfc *Gray16 )ColorModel ()_c .Model {return _c .Gray16Model };
var (_bdbd =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_faebe =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func (_cbba *NRGBA32 )ColorModel ()_c .Model {return _c .NRGBAModel };func _gaad ()(_ece []byte ){_ece =make ([]byte ,256);
for _eca :=0;_eca < 256;_eca ++{_fgc :=byte (_eca );_ece [_fgc ]=(_fgc &0x01)|((_fgc &0x04)>>1)|((_fgc &0x10)>>2)|((_fgc &0x40)>>3)|((_fgc &0x02)<<3)|((_fgc &0x08)<<2)|((_fgc &0x20)<<1)|(_fgc &0x80);};return _ece ;};func (_gadf *NRGBA32 )Validate ()error {if len (_gadf .Data )!=3*_gadf .Width *_gadf .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_cgbg colorConverter )Convert (src _f .Image )(Image ,error ){return _cgbg ._bffb (src )};func _ddab (_fbee uint )uint {var _aede uint ;for _fbee !=0{_fbee >>=1;_aede ++;};return _aede -1;};var _ Image =&NRGBA32 {};func (_ccac *Gray2 )ColorModel ()_c .Model {return Gray2Model };
func (_fccfb *Gray2 )Validate ()error {if len (_fccfb .Data )!=_fccfb .Height *_fccfb .BytesPerLine {return ErrInvalidImage ;};return nil ;};type Gray16 struct{ImageBase };func (_efbd *ImageBase )newAlpha (){_bdc :=BytesPerLine (_efbd .Width ,_efbd .BitsPerComponent ,1);
_efbd .Alpha =make ([]byte ,_efbd .Height *_bdc );};func (_ccegf *ImageBase )setEightFullBytes (_aggd int ,_fcgc uint64 )error {if _aggd +7> len (_ccegf .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ccegf .Data [_aggd ]=byte ((_fcgc &0xff00000000000000)>>56);_ccegf .Data [_aggd +1]=byte ((_fcgc &0xff000000000000)>>48);_ccegf .Data [_aggd +2]=byte ((_fcgc &0xff0000000000)>>40);_ccegf .Data [_aggd +3]=byte ((_fcgc &0xff00000000)>>32);_ccegf .Data [_aggd +4]=byte ((_fcgc &0xff000000)>>24);
_ccegf .Data [_aggd +5]=byte ((_fcgc &0xff0000)>>16);_ccegf .Data [_aggd +6]=byte ((_fcgc &0xff00)>>8);_ccegf .Data [_aggd +7]=byte (_fcgc &0xff);return nil ;};var (Gray2Model =_c .ModelFunc (_ddgg );Gray4Model =_c .ModelFunc (_gagg );NRGBA16Model =_c .ModelFunc (_cfde );
);func _ggec (_fdcd _f .Image ,_cfaea Image ,_agcb _f .Rectangle ){switch _caea :=_fdcd .(type ){case Gray :_agcd (_caea ,_cfaea .(Gray ),_agcb );case NRGBA :_bbf (_caea ,_cfaea .(Gray ),_agcb );case CMYK :_afgb (_caea ,_cfaea .(Gray ),_agcb );case RGBA :_cbdf (_caea ,_cfaea .(Gray ),_agcb );
default:_afc (_fdcd ,_cfaea .(Image ),_agcb );};};func (_dfbd *NRGBA16 )SetNRGBA (x ,y int ,c _c .NRGBA ){_gccbb :=y *_dfbd .BytesPerLine +x *3/2;if _gccbb +1>=len (_dfbd .Data ){return ;};c =_eecg (c );_dfbd .setNRGBA (x ,y ,_gccbb ,c );};func (_fbdf *Monochrome )getBitAt (_fdd ,_begd int )bool {_dbbb :=_begd *_fbdf .BytesPerLine +(_fdd >>3);
_bgbd :=_fdd &0x07;_abcga :=uint (7-_bgbd );if _dbbb > len (_fbdf .Data )-1{return false ;};if (_fbdf .Data [_dbbb ]>>_abcga )&0x01>=1{return true ;};return false ;};func (_deedd *Gray4 )ColorModel ()_c .Model {return Gray4Model };func (_ggda *Gray4 )Base ()*ImageBase {return &_ggda .ImageBase };
func _fcge (_fgbf *Monochrome ,_deaa ,_egfga ,_fcgee ,_caca int ,_cafgf RasterOperator ,_dcca *Monochrome ,_cdfga ,_fece int )error {var (_efef bool ;_eaab bool ;_cbgg byte ;_beag int ;_gcfb int ;_adce int ;_fdccd int ;_dbec bool ;_gede int ;_egdd int ;
_bfec int ;_fccb bool ;_facc byte ;_edbga int ;_adag int ;_fgbg int ;_efbe byte ;_bfcc int ;_geab int ;_cdfgg uint ;_ggcf uint ;_ffg byte ;_aaae shift ;_gbb bool ;_eecf bool ;_gedd ,_bac int ;);if _cdfga &7!=0{_geab =8-(_cdfga &7);};if _deaa &7!=0{_gcfb =8-(_deaa &7);
};if _geab ==0&&_gcfb ==0{_ffg =_faebe [0];}else {if _gcfb > _geab {_cdfgg =uint (_gcfb -_geab );}else {_cdfgg =uint (8-(_geab -_gcfb ));};_ggcf =8-_cdfgg ;_ffg =_faebe [_cdfgg ];};if (_deaa &7)!=0{_efef =true ;_beag =8-(_deaa &7);_cbgg =_faebe [_beag ];
_adce =_fgbf .BytesPerLine *_egfga +(_deaa >>3);_fdccd =_dcca .BytesPerLine *_fece +(_cdfga >>3);_bfcc =8-(_cdfga &7);if _beag > _bfcc {_aaae =_gbdd ;if _fcgee >=_geab {_gbb =true ;};}else {_aaae =_ccdb ;};};if _fcgee < _beag {_eaab =true ;_cbgg &=_bdbd [8-_beag +_fcgee ];
};if !_eaab {_gede =(_fcgee -_beag )>>3;if _gede !=0{_dbec =true ;_egdd =_fgbf .BytesPerLine *_egfga +((_deaa +_gcfb )>>3);_bfec =_dcca .BytesPerLine *_fece +((_cdfga +_gcfb )>>3);};};_edbga =(_deaa +_fcgee )&7;if !(_eaab ||_edbga ==0){_fccb =true ;_facc =_bdbd [_edbga ];
_adag =_fgbf .BytesPerLine *_egfga +((_deaa +_gcfb )>>3)+_gede ;_fgbg =_dcca .BytesPerLine *_fece +((_cdfga +_gcfb )>>3)+_gede ;if _edbga > int (_ggcf ){_eecf =true ;};};switch _cafgf {case PixSrc :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;
if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],_efbe ,_cbgg );_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;
_gedd < _caca ;_gedd ++{for _bac =0;_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]=_efbe ;};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;
_gedd < _caca ;_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],_efbe ,_facc );_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;
};};case PixNotSrc :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],^_efbe ,_cbgg );
_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]=^_efbe ;
};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;_gedd < _caca ;_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],^_efbe ,_facc );
_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;};};case PixSrcOrDst :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );
};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],_efbe |_fgbf .Data [_adce ],_cbgg );_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;
_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]|=_efbe ;};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;_gedd < _caca ;
_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],_efbe |_fgbf .Data [_adag ],_facc );_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;
};};case PixSrcAndDst :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],_efbe &_fgbf .Data [_adce ],_cbgg );
_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]&=_efbe ;
};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;_gedd < _caca ;_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],_efbe &_fgbf .Data [_adag ],_facc );
_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;};};case PixSrcXorDst :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );
};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],_efbe ^_fgbf .Data [_adce ],_cbgg );_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;
_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]^=_efbe ;};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;_gedd < _caca ;
_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],_efbe ^_fgbf .Data [_adag ],_facc );_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;
};};case PixNotSrcOrDst :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],^_efbe |_fgbf .Data [_adce ],_cbgg );
_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]|=^_efbe ;
};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;_gedd < _caca ;_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],^_efbe |_fgbf .Data [_adag ],_facc );
_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;};};case PixNotSrcAndDst :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );
};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],^_efbe &_fgbf .Data [_adce ],_cbgg );_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;
_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]&=^_efbe ;};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;_gedd < _caca ;
_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],^_efbe &_fgbf .Data [_adag ],_facc );_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;
};};case PixSrcOrNotDst :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],_efbe |^_fgbf .Data [_adce ],_cbgg );
_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]=_efbe |^_fgbf .Data [_egdd +_bac ];
};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;_gedd < _caca ;_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],_efbe |^_fgbf .Data [_adag ],_facc );
_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;};};case PixSrcAndNotDst :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );
};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],_efbe &^_fgbf .Data [_adce ],_cbgg );_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;
_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]=_efbe &^_fgbf .Data [_egdd +_bac ];};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;
_gedd < _caca ;_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],_efbe &^_fgbf .Data [_adag ],_facc );_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;
};};case PixNotPixSrcOrDst :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],^(_efbe |_fgbf .Data [_adce ]),_cbgg );
_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]=^(_efbe |_fgbf .Data [_egdd +_bac ]);
};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;_gedd < _caca ;_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],^(_efbe |_fgbf .Data [_adag ]),_facc );
_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;};};case PixNotPixSrcAndDst :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );
};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],^(_efbe &_fgbf .Data [_adce ]),_cbgg );_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;
_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]=^(_efbe &_fgbf .Data [_egdd +_bac ]);};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;
_gedd < _caca ;_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],^(_efbe &_fgbf .Data [_adag ]),_facc );_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;
};};case PixNotPixSrcXorDst :if _efef {for _gedd =0;_gedd < _caca ;_gedd ++{if _aaae ==_gbdd {_efbe =_dcca .Data [_fdccd ]<<_cdfgg ;if _gbb {_efbe =_bacd (_efbe ,_dcca .Data [_fdccd +1]>>_ggcf ,_ffg );};}else {_efbe =_dcca .Data [_fdccd ]>>_ggcf ;};_fgbf .Data [_adce ]=_bacd (_fgbf .Data [_adce ],^(_efbe ^_fgbf .Data [_adce ]),_cbgg );
_adce +=_fgbf .BytesPerLine ;_fdccd +=_dcca .BytesPerLine ;};};if _dbec {for _gedd =0;_gedd < _caca ;_gedd ++{for _bac =0;_bac < _gede ;_bac ++{_efbe =_bacd (_dcca .Data [_bfec +_bac ]<<_cdfgg ,_dcca .Data [_bfec +_bac +1]>>_ggcf ,_ffg );_fgbf .Data [_egdd +_bac ]=^(_efbe ^_fgbf .Data [_egdd +_bac ]);
};_egdd +=_fgbf .BytesPerLine ;_bfec +=_dcca .BytesPerLine ;};};if _fccb {for _gedd =0;_gedd < _caca ;_gedd ++{_efbe =_dcca .Data [_fgbg ]<<_cdfgg ;if _eecf {_efbe =_bacd (_efbe ,_dcca .Data [_fgbg +1]>>_ggcf ,_ffg );};_fgbf .Data [_adag ]=_bacd (_fgbf .Data [_adag ],^(_efbe ^_fgbf .Data [_adag ]),_facc );
_adag +=_fgbf .BytesPerLine ;_fgbg +=_dcca .BytesPerLine ;};};default:_ga .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_cafgf );
return _a .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func (_fafb *Monochrome )clearBit (_ggfa ,_abab int ){_fafb .Data [_ggfa ]&=^(0x80>>uint (_abab &7))};
func (_cgeg *Monochrome )AddPadding ()(_cegf error ){if _ggdf :=((_cgeg .Width *_cgeg .Height )+7)>>3;len (_cgeg .Data )< _ggdf {return _e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_cgeg .Data ),_ggdf );
};_deea :=_cgeg .Width %8;if _deea ==0{return nil ;};_afdf :=_cgeg .Width /8;_dbd :=_b .NewReader (_cgeg .Data );_dgag :=make ([]byte ,_cgeg .Height *_cgeg .BytesPerLine );_fdaa :=_b .NewWriterMSB (_dgag );_abdbf :=make ([]byte ,_afdf );var (_ceae int ;
_dcb uint64 ;);for _ceae =0;_ceae < _cgeg .Height ;_ceae ++{if _ ,_cegf =_dbd .Read (_abdbf );_cegf !=nil {return _cegf ;};if _ ,_cegf =_fdaa .Write (_abdbf );_cegf !=nil {return _cegf ;};if _dcb ,_cegf =_dbd .ReadBits (byte (_deea ));_cegf !=nil {return _cegf ;
};if _cegf =_fdaa .WriteByte (byte (_dcb )<<uint (8-_deea ));_cegf !=nil {return _cegf ;};};_cgeg .Data =_fdaa .Data ();return nil ;};func _ddea (_cedee *_f .NYCbCrA ,_fbddf NRGBA ,_ebdg _f .Rectangle ){for _dbgd :=0;_dbgd < _ebdg .Max .X ;_dbgd ++{for _fcda :=0;
_fcda < _ebdg .Max .Y ;_fcda ++{_bcfge :=_cedee .NYCbCrAAt (_dbgd ,_fcda );_fbddf .SetNRGBA (_dbgd ,_fcda ,_faebf (_bcfge ));};};};var _ Image =&RGBA32 {};func _deba (_cffa _c .NRGBA )_c .Gray {_cgbgd ,_cdee ,_acc ,_ :=_cffa .RGBA ();_fgg :=(19595*_cgbgd +38470*_cdee +7471*_acc +1<<15)>>24;
return _c .Gray {Y :uint8 (_fgg )};};var _ _f .Image =&Gray8 {};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _ccaa (_fcdc Gray ,_gcef NRGBA ,_dbcf _f .Rectangle ){for _ced :=0;_ced < _dbcf .Max .X ;_ced ++{for _gagf :=0;_gagf < _dbcf .Max .Y ;
_gagf ++{_babca :=_cfbd (_gcef .NRGBAAt (_ced ,_gagf ));_fcdc .SetGray (_ced ,_gagf ,_babca );};};};func (_ebfd *NRGBA64 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA64 (x ,y ,_ebfd .Width ,_ebfd .Data ,_ebfd .Alpha ,_ebfd .Decode );};type CMYK interface{CMYKAt (_ege ,_dbc int )_c .CMYK ;
SetCMYK (_daa ,_bgbg int ,_ggef _c .CMYK );};func ImgToBinary (i _f .Image ,threshold uint8 )*_f .Gray {switch _cfee :=i .(type ){case *_f .Gray :if _gdgg (_cfee ){return _cfee ;};return _ceec (_cfee ,threshold );case *_f .Gray16 :return _gbgg (_cfee ,threshold );
default:return _bgdaa (_cfee ,threshold );};};func (_gegbe *NRGBA32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_gegbe .Width ,Y :_gegbe .Height }};};var _gggc [256]uint8 ;func (_ccd *Monochrome )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray1BPC (x ,y ,_ccd .BytesPerLine ,_ccd .Data ,_ccd .Decode );
};func (_dabda *ImageBase )HasAlpha ()bool {if _dabda .Alpha ==nil {return false ;};for _gbcc :=range _dabda .Alpha {if _dabda .Alpha [_gbcc ]!=0xff{return true ;};};return false ;};func _eaad (_efbg _f .Image )(Image ,error ){if _agd ,_dccc :=_efbg .(*Gray4 );
_dccc {return _agd .Copy (),nil ;};_cef :=_efbg .Bounds ();_dfgf ,_fcaf :=NewImage (_cef .Max .X ,_cef .Max .Y ,4,1,nil ,nil ,nil );if _fcaf !=nil {return nil ,_fcaf ;};_ggec (_efbg ,_dfgf ,_cef );return _dfgf ,nil ;};func _ggde (_faaa _c .Gray ,_eeee monochromeModel )_c .Gray {if _faaa .Y > uint8 (_eeee ){return _c .Gray {Y :_ae .MaxUint8 };
};return _c .Gray {};};type monochromeModel uint8 ;type NRGBA32 struct{ImageBase };func _fbg (_efd ,_fac int ,_af []byte )*Monochrome {_edb :=_gcf (_efd ,_fac );_edb .Data =_af ;return _edb ;};var _ Gray =&Gray4 {};var ErrInvalidImage =_a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func _aedf (_aad _c .RGBA )_c .Gray {_gbce :=(19595*uint32 (_aad .R )+38470*uint32 (_aad .G )+7471*uint32 (_aad .B )+1<<7)>>16;return _c .Gray {Y :uint8 (_gbce )};};func (_gfb *monochromeThresholdConverter )Convert (img _f .Image )(Image ,error ){if _agaf ,_cge :=img .(*Monochrome );
_cge {return _agaf .Copy (),nil ;};_gef :=img .Bounds ();_bcbb ,_fdb :=NewImage (_gef .Max .X ,_gef .Max .Y ,1,1,nil ,nil ,nil );if _fdb !=nil {return nil ,_fdb ;};_bcbb .(*Monochrome ).ModelThreshold =_gfb .Threshold ;for _fgfd :=0;_fgfd < _gef .Max .X ;
_fgfd ++{for _bcfb :=0;_bcfb < _gef .Max .Y ;_bcfb ++{_fegf :=img .At (_fgfd ,_bcfb );_bcbb .Set (_fgfd ,_bcfb ,_fegf );};};return _bcbb ,nil ;};func _dbe (_gdb *Monochrome ,_fagd ...int )(_fbf *Monochrome ,_ggd error ){if _gdb ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_fagd )==0{return nil ,_a .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_ebad :=_gaad ();_fbf =_gdb ;for _ ,_eag :=range _fagd {if _eag <=0{break ;};_fbf ,_ggd =_fgb (_fbf ,_eag ,_ebad );if _ggd !=nil {return nil ,_ggd ;};};return _fbf ,nil ;};func GrayHistogram (g Gray )(_adcac [256]int ){switch _defc :=g .(type ){case Histogramer :return _defc .Histogram ();
case _f .Image :_eadf :=_defc .Bounds ();for _eegea :=0;_eegea < _eadf .Max .X ;_eegea ++{for _gbga :=0;_gbga < _eadf .Max .Y ;_gbga ++{_adcac [g .GrayAt (_eegea ,_gbga ).Y ]++;};};return _adcac ;default:return [256]int {};};};func _fgce (_eff _c .Gray )_c .RGBA {return _c .RGBA {R :_eff .Y ,G :_eff .Y ,B :_eff .Y ,A :0xff}};
func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_faebfb :=y *bytesPerLine +x >>2;if _faebfb >=len (data ){return _c .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bgeg :=data [_faebfb ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_bgeg =uint8 (uint32 (LinearInterpolate (float64 (_bgeg ),0,3.0,decode [0],decode [1]))&3);};return _c .Gray {Y :_bgeg *85},nil ;};func _acgb (_aeca Gray ,_cbee RGBA ,_agade _f .Rectangle ){for _abbb :=0;
_abbb < _agade .Max .X ;_abbb ++{for _facg :=0;_facg < _agade .Max .Y ;_facg ++{_adgd :=_aeca .GrayAt (_abbb ,_facg );_cbee .SetRGBA (_abbb ,_facg ,_fgce (_adgd ));};};};func (_acd *CMYK32 )Base ()*ImageBase {return &_acd .ImageBase };func _bcb (_gaac Gray ,_adfa CMYK ,_gdab _f .Rectangle ){for _dcfa :=0;
_dcfa < _gdab .Max .X ;_dcfa ++{for _face :=0;_face < _gdab .Max .Y ;_face ++{_fded :=_gaac .GrayAt (_dcfa ,_face );_adfa .SetCMYK (_dcfa ,_face ,_ebde (_fded ));};};};func _ada (_eg ,_ffc *Monochrome ,_fgf []byte ,_dac int )(_faf error ){var (_aeb ,_bgf ,_bbga ,_bdb ,_adga ,_gdg ,_aba ,_gcc int ;
_gead ,_dfd ,_eeec ,_bcf uint32 ;_cca ,_bdf byte ;_feg uint16 ;);_ecb :=make ([]byte ,4);_ceg :=make ([]byte ,4);for _bbga =0;_bbga < _eg .Height -1;_bbga ,_bdb =_bbga +2,_bdb +1{_aeb =_bbga *_eg .BytesPerLine ;_bgf =_bdb *_ffc .BytesPerLine ;for _adga ,_gdg =0,0;
_adga < _dac ;_adga ,_gdg =_adga +4,_gdg +1{for _aba =0;_aba < 4;_aba ++{_gcc =_aeb +_adga +_aba ;if _gcc <=len (_eg .Data )-1&&_gcc < _aeb +_eg .BytesPerLine {_ecb [_aba ]=_eg .Data [_gcc ];}else {_ecb [_aba ]=0x00;};_gcc =_aeb +_eg .BytesPerLine +_adga +_aba ;
if _gcc <=len (_eg .Data )-1&&_gcc < _aeb +(2*_eg .BytesPerLine ){_ceg [_aba ]=_eg .Data [_gcc ];}else {_ceg [_aba ]=0x00;};};_gead =_fa .BigEndian .Uint32 (_ecb );_dfd =_fa .BigEndian .Uint32 (_ceg );_eeec =_gead &_dfd ;_eeec |=_eeec <<1;_bcf =_gead |_dfd ;
_bcf &=_bcf <<1;_dfd =_eeec &_bcf ;_dfd &=0xaaaaaaaa;_gead =_dfd |(_dfd <<7);_cca =byte (_gead >>24);_bdf =byte ((_gead >>8)&0xff);_gcc =_bgf +_gdg ;if _gcc +1==len (_ffc .Data )-1||_gcc +1>=_bgf +_ffc .BytesPerLine {if _faf =_ffc .setByte (_gcc ,_fgf [_cca ]);
_faf !=nil {return _e .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gcc );};}else {_feg =(uint16 (_fgf [_cca ])<<8)|uint16 (_fgf [_bdf ]);if _faf =_ffc .setTwoBytes (_gcc ,_feg );_faf !=nil {return _e .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gcc );
};_gdg ++;};};};return nil ;};var (_eed =_dfa ();_edg =_ebd ();_aab =_bd (););func _dcg (_cab ,_dfc *Monochrome ,_cde []byte ,_fd int )(_ecg error ){var (_gbef ,_gfc ,_aga ,_bfc ,_adg ,_efda ,_fgdb ,_fcd int ;_cff ,_adb ,_fdf ,_gda uint32 ;_eae ,_fbfb byte ;
_ebbg uint16 ;);_cfg :=make ([]byte ,4);_ceaf :=make ([]byte ,4);for _aga =0;_aga < _cab .Height -1;_aga ,_bfc =_aga +2,_bfc +1{_gbef =_aga *_cab .BytesPerLine ;_gfc =_bfc *_dfc .BytesPerLine ;for _adg ,_efda =0,0;_adg < _fd ;_adg ,_efda =_adg +4,_efda +1{for _fgdb =0;
_fgdb < 4;_fgdb ++{_fcd =_gbef +_adg +_fgdb ;if _fcd <=len (_cab .Data )-1&&_fcd < _gbef +_cab .BytesPerLine {_cfg [_fgdb ]=_cab .Data [_fcd ];}else {_cfg [_fgdb ]=0x00;};_fcd =_gbef +_cab .BytesPerLine +_adg +_fgdb ;if _fcd <=len (_cab .Data )-1&&_fcd < _gbef +(2*_cab .BytesPerLine ){_ceaf [_fgdb ]=_cab .Data [_fcd ];
}else {_ceaf [_fgdb ]=0x00;};};_cff =_fa .BigEndian .Uint32 (_cfg );_adb =_fa .BigEndian .Uint32 (_ceaf );_fdf =_cff &_adb ;_fdf |=_fdf <<1;_gda =_cff |_adb ;_gda &=_gda <<1;_adb =_fdf |_gda ;_adb &=0xaaaaaaaa;_cff =_adb |(_adb <<7);_eae =byte (_cff >>24);
_fbfb =byte ((_cff >>8)&0xff);_fcd =_gfc +_efda ;if _fcd +1==len (_dfc .Data )-1||_fcd +1>=_gfc +_dfc .BytesPerLine {if _ecg =_dfc .setByte (_fcd ,_cde [_eae ]);_ecg !=nil {return _e .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fcd );};}else {_ebbg =(uint16 (_cde [_eae ])<<8)|uint16 (_cde [_fbfb ]);
if _ecg =_dfc .setTwoBytes (_fcd ,_ebbg );_ecg !=nil {return _e .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fcd );
};_efda ++;};};};return nil ;};var _ NRGBA =&NRGBA32 {};var _ Image =&Gray2 {};func (_ead *CMYK32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_ead .Width ,Y :_ead .Height }};};func _aa (_da ,_cea *Monochrome )(_cg error ){_ebcc :=_cea .BytesPerLine ;
_ed :=_da .BytesPerLine ;_fff :=_cea .BytesPerLine *4-_da .BytesPerLine ;var (_abd ,_cf byte ;_gc uint32 ;_fe ,_gag ,_aae ,_df ,_ba ,_ad ,_gaa int ;);for _aae =0;_aae < _cea .Height ;_aae ++{_fe =_aae *_ebcc ;_gag =4*_aae *_ed ;for _df =0;_df < _ebcc ;
_df ++{_abd =_cea .Data [_fe +_df ];_gc =_edg [_abd ];_ad =_gag +_df *4;if _fff !=0&&(_df +1)*4> _da .BytesPerLine {for _ba =_fff ;_ba > 0;_ba --{_cf =byte ((_gc >>uint (_ba *8))&0xff);_gaa =_ad +(_fff -_ba );if _cg =_da .setByte (_gaa ,_cf );_cg !=nil {return _cg ;
};};}else if _cg =_da .setFourBytes (_ad ,_gc );_cg !=nil {return _cg ;};if _cg =_da .setFourBytes (_gag +_df *4,_edg [_cea .Data [_fe +_df ]]);_cg !=nil {return _cg ;};};for _ba =1;_ba < 4;_ba ++{for _df =0;_df < _ed ;_df ++{if _cg =_da .setByte (_gag +_ba *_ed +_df ,_da .Data [_gag +_df ]);
_cg !=nil {return _cg ;};};};};return nil ;};func (_agdb *NRGBA16 )At (x ,y int )_c .Color {_fdee ,_ :=_agdb .ColorAt (x ,y );return _fdee };func (_edfg *Monochrome )Set (x ,y int ,c _c .Color ){_cbbd :=y *_edfg .BytesPerLine +x >>3;if _cbbd > len (_edfg .Data )-1{return ;
};_edfd :=_edfg .ColorModel ().Convert (c ).(_c .Gray );_edfg .setGray (x ,_edfd ,_cbbd );};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA64 ,error ){_addag :=(y *width +x )*2;_baaa :=_addag *3;if _baaa +5>=len (data ){return _c .NRGBA64 {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _dfgd =0xffff;_fgab :=uint16 (_dfgd );if alpha !=nil &&len (alpha )> _addag +1{_fgab =uint16 (alpha [_addag ])<<8|uint16 (alpha [_addag +1]);};_gcfg :=uint16 (data [_baaa ])<<8|uint16 (data [_baaa +1]);_ecba :=uint16 (data [_baaa +2])<<8|uint16 (data [_baaa +3]);
_eced :=uint16 (data [_baaa +4])<<8|uint16 (data [_baaa +5]);if len (decode )==6{_gcfg =uint16 (uint64 (LinearInterpolate (float64 (_gcfg ),0,65535,decode [0],decode [1]))&_dfgd );_ecba =uint16 (uint64 (LinearInterpolate (float64 (_ecba ),0,65535,decode [2],decode [3]))&_dfgd );
_eced =uint16 (uint64 (LinearInterpolate (float64 (_eced ),0,65535,decode [4],decode [5]))&_dfgd );};return _c .NRGBA64 {R :_gcfg ,G :_ecba ,B :_eced ,A :_fgab },nil ;};func (_ccgf *NRGBA16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA16 (x ,y ,_ccgf .Width ,_ccgf .BytesPerLine ,_ccgf .Data ,_ccgf .Alpha ,_ccgf .Decode );
};func (_afgd *NRGBA64 )ColorModel ()_c .Model {return _c .NRGBA64Model };func _ecad (_bdeb CMYK ,_dcee RGBA ,_ccagg _f .Rectangle ){for _dgdbc :=0;_dgdbc < _ccagg .Max .X ;_dgdbc ++{for _dfdb :=0;_dfdb < _ccagg .Max .Y ;_dfdb ++{_effa :=_bdeb .CMYKAt (_dgdbc ,_dfdb );
_dcee .SetRGBA (_dgdbc ,_dfdb ,_dgfd (_effa ));};};};func _dbdbf (_dggc ,_ccbb uint8 )uint8 {if _dggc < _ccbb {return 255;};return 0;};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_fdeg *Gray2 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray2BPC (x ,y ,_fdeg .BytesPerLine ,_fdeg .Data ,_fdeg .Decode );
};func (_dbcfa *Gray16 )Validate ()error {if len (_dbcfa .Data )!=_dbcfa .Height *_dbcfa .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_dfae *Gray2 )Base ()*ImageBase {return &_dfae .ImageBase };func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_e .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _ddd (_eded _f .Image )(Image ,error ){if _cbfe ,_cfae :=_eded .(*Gray8 );_cfae {return _cbfe .Copy (),nil ;};_dbbbb :=_eded .Bounds ();_gee ,_abcb :=NewImage (_dbbbb .Max .X ,_dbbbb .Max .Y ,8,1,nil ,nil ,nil );if _abcb !=nil {return nil ,_abcb ;
};_ggec (_eded ,_gee ,_dbbbb );return _gee ,nil ;};var _ _f .Image =&NRGBA16 {};func (_cbdc *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_cbdc .copy ()}};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func _caege (_bcgg int ,_dbgg int )error {return _e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_bcgg ,_dbgg );
};type CMYK32 struct{ImageBase };func _ddgg (_ddff _c .Color )_c .Color {_gceg :=_c .GrayModel .Convert (_ddff ).(_c .Gray );return _aced (_gceg );};func _eeef (_deee *_f .NYCbCrA ,_adeg RGBA ,_aafd _f .Rectangle ){for _fbcf :=0;_fbcf < _aafd .Max .X ;
_fbcf ++{for _gfcff :=0;_gfcff < _aafd .Max .Y ;_gfcff ++{_acgbb :=_deee .NYCbCrAAt (_fbcf ,_gfcff );_adeg .SetRGBA (_fbcf ,_gfcff ,_gbdf (_acgbb ));};};};func (_abe *Monochrome )ColorModel ()_c .Model {return MonochromeModel (_abe .ModelThreshold )};func _cgaa (_affb _f .Image )(Image ,error ){if _gdaf ,_dfad :=_affb .(*NRGBA64 );
_dfad {return _gdaf .Copy (),nil ;};_gaaed ,_cebb ,_gfbf :=_gcae (_affb ,2);_egea ,_cacca :=NewImage (_gaaed .Max .X ,_gaaed .Max .Y ,16,3,nil ,_gfbf ,nil );if _cacca !=nil {return nil ,_cacca ;};_fcca (_affb ,_egea ,_gaaed );if len (_gfbf )!=0&&!_cebb {if _cgd :=_cafb (_gfbf ,_egea );
_cgd !=nil {return nil ,_cgd ;};};return _egea ,nil ;};func _aece (_acbe *Monochrome ,_afec ,_gdbff ,_bgg ,_bdcg int ,_aaf RasterOperator ,_eebe *Monochrome ,_fdac ,_gcega int )error {var (_dccg bool ;_cbccf bool ;_befb int ;_gfg int ;_ggdb int ;_adeeg bool ;
_gaaa byte ;_gbceg int ;_ffbd int ;_fadg int ;_cdca ,_effd int ;);_daaec :=8-(_afec &7);_agaa :=_faebe [_daaec ];_ecbd :=_acbe .BytesPerLine *_gdbff +(_afec >>3);_agadg :=_eebe .BytesPerLine *_gcega +(_fdac >>3);if _bgg < _daaec {_dccg =true ;_agaa &=_bdbd [8-_daaec +_bgg ];
};if !_dccg {_befb =(_bgg -_daaec )>>3;if _befb > 0{_cbccf =true ;_gfg =_ecbd +1;_ggdb =_agadg +1;};};_gbceg =(_afec +_bgg )&7;if !(_dccg ||_gbceg ==0){_adeeg =true ;_gaaa =_bdbd [_gbceg ];_ffbd =_ecbd +1+_befb ;_fadg =_agadg +1+_befb ;};switch _aaf {case PixSrc :for _cdca =0;
_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],_eebe .Data [_agadg ],_agaa );_ecbd +=_acbe .BytesPerLine ;_agadg +=_eebe .BytesPerLine ;};if _cbccf {for _cdca =0;_cdca < _bdcg ;_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]=_eebe .Data [_ggdb +_effd ];
};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],_eebe .Data [_fadg ],_gaaa );_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};case PixNotSrc :for _cdca =0;
_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],^_eebe .Data [_agadg ],_agaa );_ecbd +=_acbe .BytesPerLine ;_agadg +=_eebe .BytesPerLine ;};if _cbccf {for _cdca =0;_cdca < _bdcg ;_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]=^_eebe .Data [_ggdb +_effd ];
};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],^_eebe .Data [_fadg ],_gaaa );_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};
case PixSrcOrDst :for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],_eebe .Data [_agadg ]|_acbe .Data [_ecbd ],_agaa );_ecbd +=_acbe .BytesPerLine ;_agadg +=_eebe .BytesPerLine ;};if _cbccf {for _cdca =0;_cdca < _bdcg ;
_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]|=_eebe .Data [_ggdb +_effd ];};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],_eebe .Data [_fadg ]|_acbe .Data [_ffbd ],_gaaa );
_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};case PixSrcAndDst :for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],_eebe .Data [_agadg ]&_acbe .Data [_ecbd ],_agaa );_ecbd +=_acbe .BytesPerLine ;_agadg +=_eebe .BytesPerLine ;
};if _cbccf {for _cdca =0;_cdca < _bdcg ;_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]&=_eebe .Data [_ggdb +_effd ];};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],_eebe .Data [_fadg ]&_acbe .Data [_ffbd ],_gaaa );
_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};case PixSrcXorDst :for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],_eebe .Data [_agadg ]^_acbe .Data [_ecbd ],_agaa );_ecbd +=_acbe .BytesPerLine ;_agadg +=_eebe .BytesPerLine ;
};if _cbccf {for _cdca =0;_cdca < _bdcg ;_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]^=_eebe .Data [_ggdb +_effd ];};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],_eebe .Data [_fadg ]^_acbe .Data [_ffbd ],_gaaa );
_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};case PixNotSrcOrDst :for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],^(_eebe .Data [_agadg ])|_acbe .Data [_ecbd ],_agaa );_ecbd +=_acbe .BytesPerLine ;
_agadg +=_eebe .BytesPerLine ;};if _cbccf {for _cdca =0;_cdca < _bdcg ;_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]|=^(_eebe .Data [_ggdb +_effd ]);};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;};};if _adeeg {for _cdca =0;
_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],^(_eebe .Data [_fadg ])|_acbe .Data [_ffbd ],_gaaa );_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};case PixNotSrcAndDst :for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],^(_eebe .Data [_agadg ])&_acbe .Data [_ecbd ],_agaa );
_ecbd +=_acbe .BytesPerLine ;_agadg +=_eebe .BytesPerLine ;};if _cbccf {for _cdca =0;_cdca < _bdcg ;_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]&=^_eebe .Data [_ggdb +_effd ];};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;
};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],^(_eebe .Data [_fadg ])&_acbe .Data [_ffbd ],_gaaa );_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};case PixSrcOrNotDst :for _cdca =0;_cdca < _bdcg ;
_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],_eebe .Data [_agadg ]|^(_acbe .Data [_ecbd ]),_agaa );_ecbd +=_acbe .BytesPerLine ;_agadg +=_eebe .BytesPerLine ;};if _cbccf {for _cdca =0;_cdca < _bdcg ;_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]=_eebe .Data [_ggdb +_effd ]|^(_acbe .Data [_gfg +_effd ]);
};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],_eebe .Data [_fadg ]|^(_acbe .Data [_ffbd ]),_gaaa );_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;
};};case PixSrcAndNotDst :for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],_eebe .Data [_agadg ]&^(_acbe .Data [_ecbd ]),_agaa );_ecbd +=_acbe .BytesPerLine ;_agadg +=_eebe .BytesPerLine ;};if _cbccf {for _cdca =0;_cdca < _bdcg ;
_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]=_eebe .Data [_ggdb +_effd ]&^(_acbe .Data [_gfg +_effd ]);};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],_eebe .Data [_fadg ]&^(_acbe .Data [_ffbd ]),_gaaa );
_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};case PixNotPixSrcOrDst :for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],^(_eebe .Data [_agadg ]|_acbe .Data [_ecbd ]),_agaa );_ecbd +=_acbe .BytesPerLine ;
_agadg +=_eebe .BytesPerLine ;};if _cbccf {for _cdca =0;_cdca < _bdcg ;_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]=^(_eebe .Data [_ggdb +_effd ]|_acbe .Data [_gfg +_effd ]);};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;
};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],^(_eebe .Data [_fadg ]|_acbe .Data [_ffbd ]),_gaaa );_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};case PixNotPixSrcAndDst :for _cdca =0;
_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],^(_eebe .Data [_agadg ]&_acbe .Data [_ecbd ]),_agaa );_ecbd +=_acbe .BytesPerLine ;_agadg +=_eebe .BytesPerLine ;};if _cbccf {for _cdca =0;_cdca < _bdcg ;_cdca ++{for _effd =0;_effd < _befb ;
_effd ++{_acbe .Data [_gfg +_effd ]=^(_eebe .Data [_ggdb +_effd ]&_acbe .Data [_gfg +_effd ]);};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],^(_eebe .Data [_fadg ]&_acbe .Data [_ffbd ]),_gaaa );
_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};case PixNotPixSrcXorDst :for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ecbd ]=_bacd (_acbe .Data [_ecbd ],^(_eebe .Data [_agadg ]^_acbe .Data [_ecbd ]),_agaa );_ecbd +=_acbe .BytesPerLine ;
_agadg +=_eebe .BytesPerLine ;};if _cbccf {for _cdca =0;_cdca < _bdcg ;_cdca ++{for _effd =0;_effd < _befb ;_effd ++{_acbe .Data [_gfg +_effd ]=^(_eebe .Data [_ggdb +_effd ]^_acbe .Data [_gfg +_effd ]);};_gfg +=_acbe .BytesPerLine ;_ggdb +=_eebe .BytesPerLine ;
};};if _adeeg {for _cdca =0;_cdca < _bdcg ;_cdca ++{_acbe .Data [_ffbd ]=_bacd (_acbe .Data [_ffbd ],^(_eebe .Data [_fadg ]^_acbe .Data [_ffbd ]),_gaaa );_ffbd +=_acbe .BytesPerLine ;_fadg +=_eebe .BytesPerLine ;};};default:_ga .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_aaf );
return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_afdd *Gray8 )Set (x ,y int ,c _c .Color ){_gdfe :=y *_afdd .BytesPerLine +x ;if _gdfe > len (_afdd .Data )-1{return ;
};_bee :=_c .GrayModel .Convert (c );_afdd .Data [_gdfe ]=_bee .(_c .Gray ).Y ;};func _dee (_dfbg _c .NRGBA64 )_c .RGBA {_bbb ,_ddb ,_eaa ,_eaaf :=_dfbg .RGBA ();return _c .RGBA {R :uint8 (_bbb >>8),G :uint8 (_ddb >>8),B :uint8 (_eaa >>8),A :uint8 (_eaaf >>8)};
};func (_bfeb *Monochrome )setGray (_def int ,_gdaa _c .Gray ,_adda int ){if _gdaa .Y ==0{_bfeb .clearBit (_adda ,_def );}else {_bfeb .setGrayBit (_adda ,_def );};};func _ebb (_fcc ,_agb *Monochrome ,_cbg []byte ,_cfec int )(_fbe error ){var (_bfe ,_adf ,_gfa ,_caf ,_dgb ,_dfg ,_afd ,_cbb int ;
_fba ,_ffb uint32 ;_gge ,_efed byte ;_ede uint16 ;);_be :=make ([]byte ,4);_bba :=make ([]byte ,4);for _gfa =0;_gfa < _fcc .Height -1;_gfa ,_caf =_gfa +2,_caf +1{_bfe =_gfa *_fcc .BytesPerLine ;_adf =_caf *_agb .BytesPerLine ;for _dgb ,_dfg =0,0;_dgb < _cfec ;
_dgb ,_dfg =_dgb +4,_dfg +1{for _afd =0;_afd < 4;_afd ++{_cbb =_bfe +_dgb +_afd ;if _cbb <=len (_fcc .Data )-1&&_cbb < _bfe +_fcc .BytesPerLine {_be [_afd ]=_fcc .Data [_cbb ];}else {_be [_afd ]=0x00;};_cbb =_bfe +_fcc .BytesPerLine +_dgb +_afd ;if _cbb <=len (_fcc .Data )-1&&_cbb < _bfe +(2*_fcc .BytesPerLine ){_bba [_afd ]=_fcc .Data [_cbb ];
}else {_bba [_afd ]=0x00;};};_fba =_fa .BigEndian .Uint32 (_be );_ffb =_fa .BigEndian .Uint32 (_bba );_ffb |=_fba ;_ffb |=_ffb <<1;_ffb &=0xaaaaaaaa;_fba =_ffb |(_ffb <<7);_gge =byte (_fba >>24);_efed =byte ((_fba >>8)&0xff);_cbb =_adf +_dfg ;if _cbb +1==len (_agb .Data )-1||_cbb +1>=_adf +_agb .BytesPerLine {_agb .Data [_cbb ]=_cbg [_gge ];
}else {_ede =(uint16 (_cbg [_gge ])<<8)|uint16 (_cbg [_efed ]);if _fbe =_agb .setTwoBytes (_cbb ,_ede );_fbe !=nil {return _e .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cbb );
};_dfg ++;};};};return nil ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _fbfd ,_fbea ,_ffgg ,_bdgf int ;for _bbbae :=0;_bbbae < len (histogram );_bbbae ++{if histogram [_bbbae ]> 0{_fbfd =_bbbae ;break ;};};if _fbfd > 0{_fbfd --;};for _fgeae :=255;
_fgeae > 0;_fgeae --{if histogram [_fgeae ]> 0{_bdgf =_fgeae ;break ;};};if _bdgf < 255{_bdgf ++;};for _ccdf :=0;_ccdf < 256;_ccdf ++{if histogram [_ccdf ]> _fbea {_ffgg =_ccdf ;_fbea =histogram [_ccdf ];};};var _ccf bool ;if (_ffgg -_fbfd )< (_bdgf -_ffgg ){_ccf =true ;
var _efdb int ;_dbggf :=255;for _efdb < _dbggf {_bcdf :=histogram [_efdb ];histogram [_efdb ]=histogram [_dbggf ];histogram [_dbggf ]=_bcdf ;_efdb ++;_dbggf --;};_fbfd =255-_bdgf ;_ffgg =255-_ffgg ;};if _fbfd ==_ffgg {return uint8 (_fbfd );};_gcb :=float64 (histogram [_ffgg ]);
_fgeg :=float64 (_fbfd -_ffgg );_dbcc :=_ae .Sqrt (_gcb *_gcb +_fgeg *_fgeg );_gcb /=_dbcc ;_fgeg /=_dbcc ;_dbcc =_gcb *float64 (_fbfd )+_fgeg *float64 (histogram [_fbfd ]);_dbacc :=_fbfd ;var _aeag float64 ;for _gfbfg :=_fbfd +1;_gfbfg <=_ffgg ;_gfbfg ++{_fedd :=_gcb *float64 (_gfbfg )+_fgeg *float64 (histogram [_gfbfg ])-_dbcc ;
if _fedd > _aeag {_dbacc =_gfbfg ;_aeag =_fedd ;};};_dbacc --;if _ccf {var _baad int ;_gcff :=255;for _baad < _gcff {_adgg :=histogram [_baad ];histogram [_baad ]=histogram [_gcff ];histogram [_gcff ]=_adgg ;_baad ++;_gcff --;};return uint8 (255-_dbacc );
};return uint8 (_dbacc );};func _bfgg (_dggg _f .Image ,_ddddd Image ,_cfadf _f .Rectangle ){if _ecgbg ,_edee :=_dggg .(SMasker );_edee &&_ecgbg .HasAlpha (){_ddddd .(SMasker ).MakeAlpha ();};switch _beaa :=_dggg .(type ){case Gray :_acgb (_beaa ,_ddddd .(RGBA ),_cfadf );
case NRGBA :_gbfe (_beaa ,_ddddd .(RGBA ),_cfadf );case *_f .NYCbCrA :_eeef (_beaa ,_ddddd .(RGBA ),_cfadf );case CMYK :_ecad (_beaa ,_ddddd .(RGBA ),_cfadf );case RGBA :_addbg (_beaa ,_ddddd .(RGBA ),_cfadf );case nrgba64 :_bfadd (_beaa ,_ddddd .(RGBA ),_cfadf );
default:_afc (_dggg ,_ddddd ,_cfadf );};};func _ce (_ge *Monochrome ,_dg int ,_gg []uint )(*Monochrome ,error ){_gb :=_dg *_ge .Width ;_fc :=_dg *_ge .Height ;_bg :=_gcf (_gb ,_fc );for _ac ,_aec :=range _gg {var _fb error ;switch _aec {case 2:_fb =_aed (_bg ,_ge );
case 4:_fb =_aa (_bg ,_ge );case 8:_fb =_cb (_bg ,_ge );};if _fb !=nil {return nil ,_fb ;};if _ac !=len (_gg )-1{_ge =_bg .copy ();};};return _bg ,nil ;};func (_ddfdc *Gray16 )Histogram ()(_fbdd [256]int ){for _ebg :=0;_ebg < _ddfdc .Width ;_ebg ++{for _ecdf :=0;
_ecdf < _ddfdc .Height ;_ecdf ++{_fbdd [_ddfdc .GrayAt (_ebg ,_ecdf ).Y ]++;};};return _fbdd ;};func (_aagfa *Monochrome )setGrayBit (_dad ,_bfb int ){_aagfa .Data [_dad ]|=0x80>>uint (_bfb &7)};func (_fagc *ImageBase )Pix ()[]byte {return _fagc .Data };
func (_ddgd *RGBA32 )Base ()*ImageBase {return &_ddgd .ImageBase };func (_fbgf *CMYK32 )At (x ,y int )_c .Color {_dggd ,_ :=_fbgf .ColorAt (x ,y );return _dggd };func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray16 ,error ){_gaace :=(y *bytesPerLine /2+x )*2;
if _gaace +1>=len (data ){return _c .Gray16 {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cbea :=uint16 (data [_gaace ])<<8|uint16 (data [_gaace +1]);if len (decode )==2{_cbea =uint16 (uint64 (LinearInterpolate (float64 (_cbea ),0,65535,decode [0],decode [1])));};return _c .Gray16 {Y :_cbea },nil ;};func _cdb (_gca *Monochrome ,_cec ,_dgg int )(*Monochrome ,error ){if _gca ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _cec <=0||_dgg <=0{return nil ,_a .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _cec ==_dgg {if _cec ==1{return _gca .copy (),nil ;};
if _cec ==2||_cec ==4||_cec ==8{_gde ,_dda :=_ab (_gca ,_cec );if _dda !=nil {return nil ,_dda ;};return _gde ,nil ;};};_db :=_cec *_gca .Width ;_gbf :=_dgg *_gca .Height ;_cdd :=_gcf (_db ,_gbf );_gdeb :=_cdd .BytesPerLine ;var (_fed ,_ddc ,_efe ,_ddae ,_ffd int ;
_fgd byte ;_gbe error ;);for _ddc =0;_ddc < _gca .Height ;_ddc ++{_fed =_dgg *_ddc *_gdeb ;for _efe =0;_efe < _gca .Width ;_efe ++{if _ea :=_gca .getBitAt (_efe ,_ddc );_ea {_ffd =_cec *_efe ;for _ddae =0;_ddae < _cec ;_ddae ++{_cdd .setIndexedBit (_fed *8+_ffd +_ddae );
};};};for _ddae =1;_ddae < _dgg ;_ddae ++{_abc :=_fed +_ddae *_gdeb ;for _ag :=0;_ag < _gdeb ;_ag ++{if _fgd ,_gbe =_cdd .getByte (_fed +_ag );_gbe !=nil {return nil ,_gbe ;};if _gbe =_cdd .setByte (_abc +_ag ,_fgd );_gbe !=nil {return nil ,_gbe ;};};};
};return _cdd ,nil ;};func (_gddc *Monochrome )At (x ,y int )_c .Color {_fagga ,_ :=_gddc .ColorAt (x ,y );return _fagga };func (_fbcg *Gray16 )GrayAt (x ,y int )_c .Gray {_cdg ,_ :=_fbcg .ColorAt (x ,y );return _c .Gray {Y :uint8 (_cdg .(_c .Gray16 ).Y >>8)};
};func (_cbdg *NRGBA16 )Base ()*ImageBase {return &_cbdg .ImageBase };func (_dba *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_a .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_cecd :=_gcf (width ,height );_ddac :=make ([]int ,height );_aac :=make ([]int ,width );_ace :=float64 (_dba .Width )/float64 (width );_fedb :=float64 (_dba .Height )/float64 (height );for _fdfg :=0;_fdfg < height ;_fdfg ++{_ddac [_fdfg ]=int (_ae .Min (_fedb *float64 (_fdfg )+0.5,float64 (_dba .Height -1)));
};for _gegf :=0;_gegf < width ;_gegf ++{_aac [_gegf ]=int (_ae .Min (_ace *float64 (_gegf )+0.5,float64 (_dba .Width -1)));};_dacc :=-1;_ccc :=byte (0);for _fcbcg :=0;_fcbcg < height ;_fcbcg ++{_cac :=_ddac [_fcbcg ]*_dba .BytesPerLine ;_ffa :=_fcbcg *_cecd .BytesPerLine ;
for _ddag :=0;_ddag < width ;_ddag ++{_fab :=_aac [_ddag ];if _fab !=_dacc {_ccc =_dba .getBit (_cac ,_fab );if _ccc !=0{_cecd .setBit (_ffa ,_ddag );};_dacc =_fab ;}else {if _ccc !=0{_cecd .setBit (_ffa ,_ddag );};};};};return _cecd ,nil ;};type RasterOperator int ;
var _ _f .Image =&NRGBA64 {};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_dbga :=y *bytesPerLine +x *3/2;if _dbga +1>=len (data ){return _c .NRGBA {},_caege (x ,y );};const (_fdaaf =0xf;
_bfcec =uint8 (0xff););_bdad :=_bfcec ;if alpha !=nil {_bagf :=y *BytesPerLine (width ,4,1);if _bagf < len (alpha ){if x %2==0{_bdad =(alpha [_bagf ]>>uint (4))&_fdaaf ;}else {_bdad =alpha [_bagf ]&_fdaaf ;};_bdad |=_bdad <<4;};};var _bacb ,_acab ,_bdaa uint8 ;
if x *3%2==0{_bacb =(data [_dbga ]>>uint (4))&_fdaaf ;_acab =data [_dbga ]&_fdaaf ;_bdaa =(data [_dbga +1]>>uint (4))&_fdaaf ;}else {_bacb =data [_dbga ]&_fdaaf ;_acab =(data [_dbga +1]>>uint (4))&_fdaaf ;_bdaa =data [_dbga +1]&_fdaaf ;};if len (decode )==6{_bacb =uint8 (uint32 (LinearInterpolate (float64 (_bacb ),0,15,decode [0],decode [1]))&0xf);
_acab =uint8 (uint32 (LinearInterpolate (float64 (_acab ),0,15,decode [2],decode [3]))&0xf);_bdaa =uint8 (uint32 (LinearInterpolate (float64 (_bdaa ),0,15,decode [4],decode [5]))&0xf);};return _c .NRGBA {R :(_bacb <<4)|(_bacb &0xf),G :(_acab <<4)|(_acab &0xf),B :(_bdaa <<4)|(_bdaa &0xf),A :_bdad },nil ;
};func (_bfced *Gray8 )Validate ()error {if len (_bfced .Data )!=_bfced .Height *_bfced .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _ecdb (_ccfe uint8 )bool {if _ccfe ==0||_ccfe ==255{return true ;};return false ;};func (_gegc *Gray8 )SetGray (x ,y int ,g _c .Gray ){_aebg :=y *_gegc .BytesPerLine +x ;
if _aebg > len (_gegc .Data )-1{return ;};_gegc .Data [_aebg ]=g .Y ;};func (_cdga *NRGBA64 )SetNRGBA64 (x ,y int ,c _c .NRGBA64 ){_ebbe :=(y *_cdga .Width +x )*2;_dedg :=_ebbe *3;if _dedg +5>=len (_cdga .Data ){return ;};_cdga .setNRGBA64 (_dedg ,c ,_ebbe );
};func (_becd *RGBA32 )RGBAAt (x ,y int )_c .RGBA {_fcgg ,_ :=ColorAtRGBA32 (x ,y ,_becd .Width ,_becd .Data ,_becd .Alpha ,_becd .Decode );return _fcgg ;};func _bfadd (_gefc nrgba64 ,_fadde RGBA ,_aabf _f .Rectangle ){for _agfb :=0;_agfb < _aabf .Max .X ;
_agfb ++{for _dgeaa :=0;_dgeaa < _aabf .Max .Y ;_dgeaa ++{_aefd :=_gefc .NRGBA64At (_agfb ,_dgeaa );_fadde .SetRGBA (_agfb ,_dgeaa ,_dee (_aefd ));};};};func _ffdf (_agbc _c .NRGBA64 )_c .Gray {var _gced _c .NRGBA64 ;if _agbc ==_gced {return _c .Gray {Y :0xff};
};_bbe ,_bcba ,_aff ,_ :=_agbc .RGBA ();_efc :=(19595*_bbe +38470*_bcba +7471*_aff +1<<15)>>24;return _c .Gray {Y :uint8 (_efc )};};func (_eaed *Gray4 )GrayAt (x ,y int )_c .Gray {_ecd ,_ :=ColorAtGray4BPC (x ,y ,_eaed .BytesPerLine ,_eaed .Data ,_eaed .Decode );
return _ecd ;};func (_cbca *Gray16 )SetGray (x ,y int ,g _c .Gray ){_gdff :=(y *_cbca .BytesPerLine /2+x )*2;if _gdff +1>=len (_cbca .Data ){return ;};_cbca .Data [_gdff ]=g .Y ;_cbca .Data [_gdff +1]=g .Y ;};func (_ebf *Monochrome )GrayAt (x ,y int )_c .Gray {_gaae ,_ :=ColorAtGray1BPC (x ,y ,_ebf .BytesPerLine ,_ebf .Data ,_ebf .Decode );
return _gaae ;};func (_afg *Gray4 )At (x ,y int )_c .Color {_gcg ,_ :=_afg .ColorAt (x ,y );return _gcg };func (_dcc *CMYK32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtCMYK (x ,y ,_dcc .Width ,_dcc .Data ,_dcc .Decode );};func (_bff *CMYK32 )ColorModel ()_c .Model {return _c .CMYKModel };
func (_bfd *CMYK32 )Set (x ,y int ,c _c .Color ){_bdff :=4*(y *_bfd .Width +x );if _bdff +3>=len (_bfd .Data ){return ;};_bab :=_c .CMYKModel .Convert (c ).(_c .CMYK );_bfd .Data [_bdff ]=_bab .C ;_bfd .Data [_bdff +1]=_bab .M ;_bfd .Data [_bdff +2]=_bab .Y ;
_bfd .Data [_bdff +3]=_bab .K ;};func (_dadb *NRGBA32 )NRGBAAt (x ,y int )_c .NRGBA {_defd ,_ :=ColorAtNRGBA32 (x ,y ,_dadb .Width ,_dadb .Data ,_dadb .Alpha ,_dadb .Decode );return _defd ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_ecaga :=y *bytesPerLine +x >>1;
if _ecaga >=len (data ){return _c .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_abfa :=data [_ecaga ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_abfa =uint8 (uint32 (LinearInterpolate (float64 (_abfa ),0,15,decode [0],decode [1]))&0xf);};return _c .Gray {Y :_abfa *17&0xff},nil ;};func _fgb (_fcf *Monochrome ,_gabg int ,_gbd []byte )(_bgb *Monochrome ,_ddca error ){const _fga ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _fcf ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _gabg < 1||_gabg > 4{return nil ,_a .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _fcf .Height <=1{return nil ,_a .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_bgb =_gcf (_fcf .Width /2,_fcf .Height /2);
if _gbd ==nil {_gbd =_gaad ();};_ca :=_aaag (_fcf .BytesPerLine ,2*_bgb .BytesPerLine );switch _gabg {case 1:_ddca =_ebb (_fcf ,_bgb ,_gbd ,_ca );case 2:_ddca =_dcg (_fcf ,_bgb ,_gbd ,_ca );case 3:_ddca =_ada (_fcf ,_bgb ,_gbd ,_ca );case 4:_ddca =_ggg (_fcf ,_bgb ,_gbd ,_ca );
};if _ddca !=nil {return nil ,_ddca ;};return _bgb ,nil ;};type NRGBA16 struct{ImageBase };func (_gbfb *Gray4 )Histogram ()(_bedb [256]int ){for _cfdf :=0;_cfdf < _gbfb .Width ;_cfdf ++{for _cda :=0;_cda < _gbfb .Height ;_cda ++{_bedb [_gbfb .GrayAt (_cfdf ,_cda ).Y ]++;
};};return _bedb ;};type Gray8 struct{ImageBase };type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _gcae (_gbaf _f .Image ,_daaf int )(_f .Rectangle ,bool ,[]byte ){_ecab :=_gbaf .Bounds ();var (_egbd bool ;_aedeb []byte ;
);switch _cdfc :=_gbaf .(type ){case SMasker :_egbd =_cdfc .HasAlpha ();case NRGBA ,RGBA ,*_f .RGBA64 ,nrgba64 ,*_f .NYCbCrA :_aedeb =make ([]byte ,_ecab .Max .X *_ecab .Max .Y *_daaf );case *_f .Paletted :var _eef bool ;for _ ,_abdg :=range _cdfc .Palette {_gaegb ,_abead ,_gbbe ,_bcce :=_abdg .RGBA ();
if _gaegb ==0&&_abead ==0&&_gbbe ==0&&_bcce !=0{_eef =true ;break ;};};if _eef {_aedeb =make ([]byte ,_ecab .Max .X *_ecab .Max .Y *_daaf );};};return _ecab ,_egbd ,_aedeb ;};var _ _f .Image =&Gray16 {};func _ggg (_bgfc ,_eab *Monochrome ,_baa []byte ,_gdbf int )(_ddg error ){var (_efg ,_fcff ,_egg ,_cad ,_gcfe ,_gfd ,_agc ,_bdbb int ;
_fdc ,_geg uint32 ;_beg ,_abac byte ;_gcag uint16 ;);_agbe :=make ([]byte ,4);_bcd :=make ([]byte ,4);for _egg =0;_egg < _bgfc .Height -1;_egg ,_cad =_egg +2,_cad +1{_efg =_egg *_bgfc .BytesPerLine ;_fcff =_cad *_eab .BytesPerLine ;for _gcfe ,_gfd =0,0;
_gcfe < _gdbf ;_gcfe ,_gfd =_gcfe +4,_gfd +1{for _agc =0;_agc < 4;_agc ++{_bdbb =_efg +_gcfe +_agc ;if _bdbb <=len (_bgfc .Data )-1&&_bdbb < _efg +_bgfc .BytesPerLine {_agbe [_agc ]=_bgfc .Data [_bdbb ];}else {_agbe [_agc ]=0x00;};_bdbb =_efg +_bgfc .BytesPerLine +_gcfe +_agc ;
if _bdbb <=len (_bgfc .Data )-1&&_bdbb < _efg +(2*_bgfc .BytesPerLine ){_bcd [_agc ]=_bgfc .Data [_bdbb ];}else {_bcd [_agc ]=0x00;};};_fdc =_fa .BigEndian .Uint32 (_agbe );_geg =_fa .BigEndian .Uint32 (_bcd );_geg &=_fdc ;_geg &=_geg <<1;_geg &=0xaaaaaaaa;
_fdc =_geg |(_geg <<7);_beg =byte (_fdc >>24);_abac =byte ((_fdc >>8)&0xff);_bdbb =_fcff +_gfd ;if _bdbb +1==len (_eab .Data )-1||_bdbb +1>=_fcff +_eab .BytesPerLine {_eab .Data [_bdbb ]=_baa [_beg ];if _ddg =_eab .setByte (_bdbb ,_baa [_beg ]);_ddg !=nil {return _e .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_bdbb );
};}else {_gcag =(uint16 (_baa [_beg ])<<8)|uint16 (_baa [_abac ]);if _ddg =_eab .setTwoBytes (_bdbb ,_gcag );_ddg !=nil {return _e .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_bdbb );
};_gfd ++;};};};return nil ;};func (_gadfe *NRGBA32 )SetNRGBA (x ,y int ,c _c .NRGBA ){_ccec :=y *_gadfe .Width +x ;_febe :=3*_ccec ;if _febe +2>=len (_gadfe .Data ){return ;};_gadfe .setRGBA (_ccec ,c );};func (_fcbc *Monochrome )Base ()*ImageBase {return &_fcbc .ImageBase };
func _bcbc (_gfeg RGBA ,_eecd NRGBA ,_adec _f .Rectangle ){for _dddc :=0;_dddc < _adec .Max .X ;_dddc ++{for _cfba :=0;_cfba < _adec .Max .Y ;_cfba ++{_dadg :=_gfeg .RGBAAt (_dddc ,_cfba );_eecd .SetNRGBA (_dddc ,_cfba ,_begb (_dadg ));};};};func _dgaff (_dgbf CMYK ,_dddd NRGBA ,_cbbf _f .Rectangle ){for _cecc :=0;
_cecc < _cbbf .Max .X ;_cecc ++{for _addg :=0;_addg < _cbbf .Max .Y ;_addg ++{_efab :=_dgbf .CMYKAt (_cecc ,_addg );_dddd .SetNRGBA (_cecc ,_addg ,_efdg (_efab ));};};};func (_eeegd *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_eeegd .copy ()}};func (_agbg *NRGBA32 )Set (x ,y int ,c _c .Color ){_ggdag :=y *_agbg .Width +x ;
_bfdg :=3*_ggdag ;if _bfdg +2>=len (_agbg .Data ){return ;};_gccd :=_c .NRGBAModel .Convert (c ).(_c .NRGBA );_agbg .setRGBA (_ggdag ,_gccd );};func _cb (_ec ,_bf *Monochrome )(_gd error ){_dgd :=_bf .BytesPerLine ;_efb :=_ec .BytesPerLine ;var _dab ,_ee ,_cgb ,_cfe ,_gce int ;
for _cgb =0;_cgb < _bf .Height ;_cgb ++{_dab =_cgb *_dgd ;_ee =8*_cgb *_efb ;for _cfe =0;_cfe < _dgd ;_cfe ++{if _gd =_ec .setEightBytes (_ee +_cfe *8,_aab [_bf .Data [_dab +_cfe ]]);_gd !=nil {return _gd ;};};for _gce =1;_gce < 8;_gce ++{for _cfe =0;_cfe < _efb ;
_cfe ++{if _gd =_ec .setByte (_ee +_gce *_efb +_cfe ,_ec .Data [_ee +_cfe ]);_gd !=nil {return _gd ;};};};};return nil ;};func _begb (_acdb _c .RGBA )_c .NRGBA {switch _acdb .A {case 0xff:return _c .NRGBA {R :_acdb .R ,G :_acdb .G ,B :_acdb .B ,A :0xff};
case 0x00:return _c .NRGBA {};default:_cae ,_fcef ,_bfdd ,_cece :=_acdb .RGBA ();_cae =(_cae *0xffff)/_cece ;_fcef =(_fcef *0xffff)/_cece ;_bfdd =(_bfdd *0xffff)/_cece ;return _c .NRGBA {R :uint8 (_cae >>8),G :uint8 (_fcef >>8),B :uint8 (_bfdd >>8),A :uint8 (_cece >>8)};
};};func _dfdgc (_dgda _f .Image )(Image ,error ){if _aeaa ,_cbcg :=_dgda .(*NRGBA16 );_cbcg {return _aeaa .Copy (),nil ;};_faccf :=_dgda .Bounds ();_cdgc ,_cdec :=NewImage (_faccf .Max .X ,_faccf .Max .Y ,4,3,nil ,nil ,nil );if _cdec !=nil {return nil ,_cdec ;
};_fadgc (_dgda ,_cdgc ,_faccf );return _cdgc ,nil ;};var _ _f .Image =&NRGBA32 {};func (_gcca *Monochrome )Histogram ()(_aagf [256]int ){for _ ,_ecbc :=range _gcca .Data {_aagf [0xff]+=int (_gggc [_gcca .Data [_ecbc ]]);};return _aagf ;};func (_afgf *NRGBA64 )Validate ()error {if len (_afgf .Data )!=3*2*_afgf .Width *_afgf .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _gdgg (_eadfg *_f .Gray )bool {for _bbd :=0;_bbd < len (_eadfg .Pix );_bbd ++{if !_ecdb (_eadfg .Pix [_bbd ]){return false ;};};return true ;};func (_agfa *NRGBA64 )setNRGBA64 (_cgbc int ,_ega _c .NRGBA64 ,_fgba int ){_agfa .Data [_cgbc ]=uint8 (_ega .R >>8);
_agfa .Data [_cgbc +1]=uint8 (_ega .R &0xff);_agfa .Data [_cgbc +2]=uint8 (_ega .G >>8);_agfa .Data [_cgbc +3]=uint8 (_ega .G &0xff);_agfa .Data [_cgbc +4]=uint8 (_ega .B >>8);_agfa .Data [_cgbc +5]=uint8 (_ega .B &0xff);if _fgba +1< len (_agfa .Alpha ){_agfa .Alpha [_fgba ]=uint8 (_ega .A >>8);
_agfa .Alpha [_fgba +1]=uint8 (_ega .A &0xff);};};func (_bfeba *RGBA32 )setRGBA (_faeg int ,_gggfg _c .RGBA ){_bgaa :=3*_faeg ;_bfeba .Data [_bgaa ]=_gggfg .R ;_bfeba .Data [_bgaa +1]=_gggfg .G ;_bfeba .Data [_bgaa +2]=_gggfg .B ;if _faeg < len (_bfeba .Alpha ){_bfeba .Alpha [_faeg ]=_gggfg .A ;
};};func (_bgd *Gray2 )At (x ,y int )_c .Color {_dcfb ,_ :=_bgd .ColorAt (x ,y );return _dcfb };var _ Image =&Gray4 {};type Gray2 struct{ImageBase };func _eecg (_gage _c .NRGBA )_c .NRGBA {_gage .R =_gage .R >>4|(_gage .R >>4)<<4;_gage .G =_gage .G >>4|(_gage .G >>4)<<4;
_gage .B =_gage .B >>4|(_gage .B >>4)<<4;return _gage ;};func _gbgg (_faee *_f .Gray16 ,_caeb uint8 )*_f .Gray {_cgg :=_faee .Bounds ();_adgab :=_f .NewGray (_cgg );for _baaef :=0;_baaef < _cgg .Dx ();_baaef ++{for _gcbg :=0;_gcbg < _cgg .Dy ();_gcbg ++{_dgae :=_faee .Gray16At (_baaef ,_gcbg );
_adgab .SetGray (_baaef ,_gcbg ,_c .Gray {Y :_dbdbf (uint8 (_dgae .Y /256),_caeb )});};};return _adgab ;};func _gbdf (_gaab _c .NYCbCrA )_c .RGBA {_aedg ,_cgfb ,_adae ,_aca :=_faebf (_gaab ).RGBA ();return _c .RGBA {R :uint8 (_aedg >>8),G :uint8 (_cgfb >>8),B :uint8 (_adae >>8),A :uint8 (_aca >>8)};
};func _afc (_abf _f .Image ,_egd Image ,_bed _f .Rectangle ){for _bbgc :=0;_bbgc < _bed .Max .X ;_bbgc ++{for _cdf :=0;_cdf < _bed .Max .Y ;_cdf ++{_daf :=_abf .At (_bbgc ,_cdf );_egd .Set (_bbgc ,_cdf ,_daf );};};};var _ Image =&Monochrome {};func _bcfg (_faeb _f .Image )(Image ,error ){if _cbe ,_babc :=_faeb .(*CMYK32 );
_babc {return _cbe .Copy (),nil ;};_cag :=_faeb .Bounds ();_agad ,_cabf :=NewImage (_cag .Max .X ,_cag .Max .Y ,8,4,nil ,nil ,nil );if _cabf !=nil {return nil ,_cabf ;};switch _bfga :=_faeb .(type ){case CMYK :_bec (_bfga ,_agad .(CMYK ),_cag );case Gray :_bcb (_bfga ,_agad .(CMYK ),_cag );
case NRGBA :_edc (_bfga ,_agad .(CMYK ),_cag );case RGBA :_gff (_bfga ,_agad .(CMYK ),_cag );default:_afc (_faeb ,_agad ,_cag );};return _agad ,nil ;};func (_egfa *NRGBA16 )ColorModel ()_c .Model {return NRGBA16Model };func _bgdaa (_faad _f .Image ,_baebe uint8 )*_f .Gray {_caaag :=_faad .Bounds ();
_gdcb :=_f .NewGray (_caaag );var (_gaaf _c .Color ;_aebd _c .Gray ;);for _daga :=0;_daga < _caaag .Max .X ;_daga ++{for _eddb :=0;_eddb < _caaag .Max .Y ;_eddb ++{_gaaf =_faad .At (_daga ,_eddb );_gdcb .Set (_daga ,_eddb ,_gaaf );_aebd =_gdcb .GrayAt (_daga ,_eddb );
_gdcb .SetGray (_daga ,_eddb ,_c .Gray {Y :_dbdbf (_aebd .Y ,_baebe )});};};return _gdcb ;};func _dgfd (_cbbc _c .CMYK )_c .RGBA {_cce ,_cddf ,_gbge :=_c .CMYKToRGB (_cbbc .C ,_cbbc .M ,_cbbc .Y ,_cbbc .K );return _c .RGBA {R :_cce ,G :_cddf ,B :_gbge ,A :0xff};
};func (_gdgc *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_gdgc .copy ()}};func (_gcfea *Gray16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray16BPC (x ,y ,_gcfea .BytesPerLine ,_gcfea .Data ,_gcfea .Decode );};func _ab (_eb *Monochrome ,_fg int )(*Monochrome ,error ){if _eb ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _fg ==1{return _eb .copy (),nil ;};if !IsPowerOf2 (uint (_fg )){return nil ,_e .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_fg );
};_eba :=_fae (_fg );return _ce (_eb ,_fg ,_eba );};func (_fdfad *RGBA32 )SetRGBA (x ,y int ,c _c .RGBA ){_fffd :=y *_fdfad .Width +x ;_gbefd :=3*_fffd ;if _gbefd +2>=len (_fdfad .Data ){return ;};_fdfad .setRGBA (_fffd ,c );};func (_fdab *Monochrome )copy ()*Monochrome {_afa :=_gcf (_fdab .Width ,_fdab .Height );
_afa .ModelThreshold =_fdab .ModelThreshold ;_afa .Data =make ([]byte ,len (_fdab .Data ));copy (_afa .Data ,_fdab .Data );if len (_fdab .Decode )!=0{_afa .Decode =make ([]float64 ,len (_fdab .Decode ));copy (_afa .Decode ,_fdab .Decode );};if len (_fdab .Alpha )!=0{_afa .Alpha =make ([]byte ,len (_fdab .Alpha ));
copy (_afa .Alpha ,_fdab .Alpha );};return _afa ;};func (_ccag *NRGBA64 )NRGBA64At (x ,y int )_c .NRGBA64 {_gegfd ,_ :=ColorAtNRGBA64 (x ,y ,_ccag .Width ,_ccag .Data ,_ccag .Alpha ,_ccag .Decode );return _gegfd ;};func (_bgdab *NRGBA16 )Validate ()error {if len (_bgdab .Data )!=3*_bgdab .Width *_bgdab .Height /2{return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ Gray =&Gray2 {};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .RGBA ,error ){_edgc :=y *width +x ;_aagb :=3*_edgc ;if _aagb +2>=len (data ){return _c .RGBA {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_agdbd :=uint8 (0xff);if alpha !=nil &&len (alpha )> _edgc {_agdbd =alpha [_edgc ];};_ddeaf ,_cegd ,_gdbg :=data [_aagb ],data [_aagb +1],data [_aagb +2];if len (decode )==6{_ddeaf =uint8 (uint32 (LinearInterpolate (float64 (_ddeaf ),0,255,decode [0],decode [1]))&0xff);
_cegd =uint8 (uint32 (LinearInterpolate (float64 (_cegd ),0,255,decode [2],decode [3]))&0xff);_gdbg =uint8 (uint32 (LinearInterpolate (float64 (_gdbg ),0,255,decode [4],decode [5]))&0xff);};return _c .RGBA {R :_ddeaf ,G :_cegd ,B :_gdbg ,A :_agdbd },nil ;
};func _cfde (_bgga _c .Color )_c .Color {_bfad :=_c .NRGBAModel .Convert (_bgga ).(_c .NRGBA );return _eecg (_bfad );};func (_efedb *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _fec (_efedb ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;
PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;
PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func (_eegf *Monochrome )InverseData ()error {return _eegf .RasterOperation (0,0,_eegf .Width ,_eegf .Height ,PixNotDst ,nil ,0,0);};var _ RGBA =&RGBA32 {};func (_baeb monochromeModel )Convert (c _c .Color )_c .Color {_abb :=_c .GrayModel .Convert (c ).(_c .Gray );
return _ggde (_abb ,_baeb );};func (_gba *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_gba .copy ()}};var _ _f .Image =&Gray4 {};func (_efa *Gray2 )Histogram ()(_egde [256]int ){for _eged :=0;_eged < _efa .Width ;_eged ++{for _edba :=0;_edba < _efa .Height ;
_edba ++{_egde [_efa .GrayAt (_eged ,_edba ).Y ]++;};};return _egde ;};func _egfdd (_dccbc Gray ,_ebed NRGBA ,_cedf _f .Rectangle ){for _fefc :=0;_fefc < _cedf .Max .X ;_fefc ++{for _cefc :=0;_cefc < _cedf .Max .Y ;_cefc ++{_cgee :=_dccbc .GrayAt (_fefc ,_cefc );
_ebed .SetNRGBA (_fefc ,_cefc ,_ecbe (_cgee ));};};};func MonochromeModel (threshold uint8 )_c .Model {return monochromeModel (threshold )};func (_cacf *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_cacf .copy ()}};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_c .CMYK ,error ){_fccf :=4*(y *width +x );
if _fccf +3>=len (data ){return _c .CMYK {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_fccf ]&0xff;M :=data [_fccf +1]&0xff;Y :=data [_fccf +2]&0xff;K :=data [_fccf +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _c .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_e .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};var _ Image =&Gray8 {};func (_gaec *Gray8 )At (x ,y int )_c .Color {_aeda ,_ :=_gaec .ColorAt (x ,y );return _aeda };func (_eebf *ImageBase )setFourBytes (_ddffe int ,_ebgf uint32 )error {if _ddffe +3> len (_eebf .Data )-1{return _e .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_ddffe );
};_eebf .Data [_ddffe ]=byte ((_ebgf &0xff000000)>>24);_eebf .Data [_ddffe +1]=byte ((_ebgf &0xff0000)>>16);_eebf .Data [_ddffe +2]=byte ((_ebgf &0xff00)>>8);_eebf .Data [_ddffe +3]=byte (_ebgf &0xff);return nil ;};func (_beda *Monochrome )setIndexedBit (_dabg int ){_beda .Data [(_dabg >>3)]|=0x80>>uint (_dabg &7)};
func _aed (_ef ,_gf *Monochrome )(_de error ){_gea :=_gf .BytesPerLine ;_gab :=_ef .BytesPerLine ;var (_bc byte ;_bbg uint16 ;_cc ,_dd ,_dc ,_dcf ,_ebc int ;);for _dc =0;_dc < _gf .Height ;_dc ++{_cc =_dc *_gea ;_dd =2*_dc *_gab ;for _dcf =0;_dcf < _gea ;
_dcf ++{_bc =_gf .Data [_cc +_dcf ];_bbg =_eed [_bc ];_ebc =_dd +_dcf *2;if _ef .BytesPerLine !=_gf .BytesPerLine *2&&(_dcf +1)*2> _ef .BytesPerLine {_de =_ef .setByte (_ebc ,byte (_bbg >>8));}else {_de =_ef .setTwoBytes (_ebc ,_bbg );};if _de !=nil {return _de ;
};};for _dcf =0;_dcf < _gab ;_dcf ++{_ebc =_dd +_gab +_dcf ;_bc =_ef .Data [_dd +_dcf ];if _de =_ef .setByte (_ebc ,_bc );_de !=nil {return _de ;};};};return nil ;};func (_ebag *RGBA32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_ebag .Width ,Y :_ebag .Height }};
};func (_cfgb *Monochrome )getBit (_caeg ,_aege int )uint8 {return _cfgb .Data [_caeg +(_aege >>3)]>>uint (7-(_aege &7))&1;};type Gray interface{GrayAt (_deed ,_fcb int )_c .Gray ;SetGray (_degc ,_dgcb int ,_eede _c .Gray );};func _ccgcg (_efgg *Monochrome ,_gcec ,_gffef int ,_fecg ,_baac int ,_egfg RasterOperator ,_bddg *Monochrome ,_cefb ,_caegd int )error {var _cafc ,_ebdb ,_abacd ,_eafe int ;
if _gcec < 0{_cefb -=_gcec ;_fecg +=_gcec ;_gcec =0;};if _cefb < 0{_gcec -=_cefb ;_fecg +=_cefb ;_cefb =0;};_cafc =_gcec +_fecg -_efgg .Width ;if _cafc > 0{_fecg -=_cafc ;};_ebdb =_cefb +_fecg -_bddg .Width ;if _ebdb > 0{_fecg -=_ebdb ;};if _gffef < 0{_caegd -=_gffef ;
_baac +=_gffef ;_gffef =0;};if _caegd < 0{_gffef -=_caegd ;_baac +=_caegd ;_caegd =0;};_abacd =_gffef +_baac -_efgg .Height ;if _abacd > 0{_baac -=_abacd ;};_eafe =_caegd +_baac -_bddg .Height ;if _eafe > 0{_baac -=_eafe ;};if _fecg <=0||_baac <=0{return nil ;
};var _cdag error ;switch {case _gcec &7==0&&_cefb &7==0:_cdag =_fad (_efgg ,_gcec ,_gffef ,_fecg ,_baac ,_egfg ,_bddg ,_cefb ,_caegd );case _gcec &7==_cefb &7:_cdag =_aece (_efgg ,_gcec ,_gffef ,_fecg ,_baac ,_egfg ,_bddg ,_cefb ,_caegd );default:_cdag =_fcge (_efgg ,_gcec ,_gffef ,_fecg ,_baac ,_egfg ,_bddg ,_cefb ,_caegd );
};if _cdag !=nil {return _cdag ;};return nil ;};func _agg (){for _cafg :=0;_cafg < 256;_cafg ++{_gggc [_cafg ]=uint8 (_cafg &0x1)+(uint8 (_cafg >>1)&0x1)+(uint8 (_cafg >>2)&0x1)+(uint8 (_cafg >>3)&0x1)+(uint8 (_cafg >>4)&0x1)+(uint8 (_cafg >>5)&0x1)+(uint8 (_cafg >>6)&0x1)+(uint8 (_cafg >>7)&0x1);
};};func _bbf (_bbeb NRGBA ,_ceba Gray ,_acff _f .Rectangle ){for _affa :=0;_affa < _acff .Max .X ;_affa ++{for _abcba :=0;_abcba < _acff .Max .Y ;_abcba ++{_ccdc :=_deba (_bbeb .NRGBAAt (_affa ,_abcba ));_ceba .SetGray (_affa ,_abcba ,_ccdc );};};};func (_adfd *ImageBase )GetAlpha ()[]byte {return _adfd .Alpha };
func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _ae .Abs (xmax -xmin )< 0.000001{return ymin ;};_adfg :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _adfg ;};func (_abfb *Monochrome )Validate ()error {if len (_abfb .Data )!=_abfb .Height *_abfb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};type NRGBA64 struct{ImageBase };func _afgb (_caccf CMYK ,_fdca Gray ,_cdaf _f .Rectangle ){for _cdfg :=0;_cdfg < _cdaf .Max .X ;_cdfg ++{for _dae :=0;_dae < _cdaf .Max .Y ;_dae ++{_edda :=_ccgd (_caccf .CMYKAt (_cdfg ,_dae ));_fdca .SetGray (_cdfg ,_dae ,_edda );
};};};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _bacd (_gfcf ,_accf ,_dfcc byte )byte {return (_gfcf &^(_dfcc ))|(_accf &_dfcc )};func _ecbe (_eac _c .Gray )_c .NRGBA {return _c .NRGBA {R :_eac .Y ,G :_eac .Y ,B :_eac .Y ,A :0xff}};
func _aced (_bdg _c .Gray )_c .Gray {_cacd :=_bdg .Y >>6;_cacd |=_cacd <<2;_bdg .Y =_cacd |_cacd <<4;return _bdg ;};func (_aefc *ImageBase )setTwoBytes (_ccga int ,_badc uint16 )error {if _ccga +1> len (_aefc .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aefc .Data [_ccga ]=byte ((_badc &0xff00)>>8);_aefc .Data [_ccga +1]=byte (_badc &0xff);return nil ;};func (_fbef *Monochrome )ResolveDecode ()error {if len (_fbef .Decode )!=2{return nil ;};if _fbef .Decode [0]==1&&_fbef .Decode [1]==0{if _fca :=_fbef .InverseData ();
_fca !=nil {return _fca ;};_fbef .Decode =nil ;};return nil ;};func (_ccgc *Gray8 )Histogram ()(_gcgc [256]int ){for _bgeb :=0;_bgeb < len (_ccgc .Data );_bgeb ++{_gcgc [_ccgc .Data [_bgeb ]]++;};return _gcgc ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_ebgea :=y *width +x ;
_cfag :=3*_ebgea ;if _cfag +2>=len (data ){return _c .NRGBA {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bfdb :=uint8 (0xff);if alpha !=nil &&len (alpha )> _ebgea {_bfdb =alpha [_ebgea ];};_agf ,_bbba ,_dffg :=data [_cfag ],data [_cfag +1],data [_cfag +2];if len (decode )==6{_agf =uint8 (uint32 (LinearInterpolate (float64 (_agf ),0,255,decode [0],decode [1]))&0xff);
_bbba =uint8 (uint32 (LinearInterpolate (float64 (_bbba ),0,255,decode [2],decode [3]))&0xff);_dffg =uint8 (uint32 (LinearInterpolate (float64 (_dffg ),0,255,decode [4],decode [5]))&0xff);};return _c .NRGBA {R :_agf ,G :_bbba ,B :_dffg ,A :_bfdb },nil ;
};func (_adee *ImageBase )setEightBytes (_eece int ,_bfda uint64 )error {_dge :=_adee .BytesPerLine -(_eece %_adee .BytesPerLine );if _adee .BytesPerLine !=_adee .Width >>3{_dge --;};if _dge >=8{return _adee .setEightFullBytes (_eece ,_bfda );};return _adee .setEightPartlyBytes (_eece ,_dge ,_bfda );
};func (_addaa *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_addaa .copy ()}};var _ _f .Image =&RGBA32 {};var _ _f .Image =&Gray2 {};func _ebde (_bcg _c .Gray )_c .CMYK {return _c .CMYK {K :0xff-_bcg .Y }};func (_eaggf *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_eaggf .copy ()}};
func (_adde *NRGBA32 )setRGBA (_gcaac int ,_cbfd _c .NRGBA ){_agdf :=3*_gcaac ;_adde .Data [_agdf ]=_cbfd .R ;_adde .Data [_agdf +1]=_cbfd .G ;_adde .Data [_agdf +2]=_cbfd .B ;if _gcaac < len (_adde .Alpha ){_adde .Alpha [_gcaac ]=_cbfd .A ;};};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_cdff :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _bgfeb Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_bgfeb =&Monochrome {ImageBase :_cdff ,ModelThreshold :0x0f};case 2:_bgfeb =&Gray2 {ImageBase :_cdff };case 4:_bgfeb =&Gray4 {ImageBase :_cdff };case 8:_bgfeb =&Gray8 {ImageBase :_cdff };
case 16:_bgfeb =&Gray16 {ImageBase :_cdff };};case 3:switch bitsPerComponent {case 4:_bgfeb =&NRGBA16 {ImageBase :_cdff };case 8:_bgfeb =&NRGBA32 {ImageBase :_cdff };case 16:_bgfeb =&NRGBA64 {ImageBase :_cdff };};case 4:_bgfeb =&CMYK32 {ImageBase :_cdff };
};if _bgfeb ==nil {return nil ,ErrInvalidImage ;};return _bgfeb ,nil ;};func _fcca (_cdac _f .Image ,_fada Image ,_afae _f .Rectangle ){if _aegf ,_gddb :=_cdac .(SMasker );_gddb &&_aegf .HasAlpha (){_fada .(SMasker ).MakeAlpha ();};_afc (_cdac ,_fada ,_afae );
};func (_ddf *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_ddf .ImageBase .copy (),ModelThreshold :_ddf .ModelThreshold };};func (_beff *Gray4 )Validate ()error {if len (_beff .Data )!=_beff .Height *_beff .BytesPerLine {return ErrInvalidImage ;
};return nil ;};var _ Gray =&Gray8 {};func (_dded *Gray4 )setGray (_bdd int ,_dead int ,_ffe _c .Gray ){_cbf :=_dead *_dded .BytesPerLine ;_dce :=_cbf +(_bdd >>1);if _dce >=len (_dded .Data ){return ;};_fcbg :=_ffe .Y >>4;_dded .Data [_dce ]=(_dded .Data [_dce ]&(^(0xf0>>uint (4*(_bdd &1)))))|(_fcbg <<uint (4-4*(_bdd &1)));
};func (_ffcg *Gray8 )GrayAt (x ,y int )_c .Gray {_fdcc ,_ :=ColorAtGray8BPC (x ,y ,_ffcg .BytesPerLine ,_ffcg .Data ,_ffcg .Decode );return _fdcc ;};func _addbg (_cgbd ,_cdba RGBA ,_fdccc _f .Rectangle ){for _adea :=0;_adea < _fdccc .Max .X ;_adea ++{for _fecb :=0;
_fecb < _fdccc .Max .Y ;_fecb ++{_cdba .SetRGBA (_adea ,_fecb ,_cgbd .RGBAAt (_adea ,_fecb ));};};};var _ NRGBA =&NRGBA16 {};func (_gcaa *NRGBA16 )NRGBAAt (x ,y int )_c .NRGBA {_ggeb ,_ :=ColorAtNRGBA16 (x ,y ,_gcaa .Width ,_gcaa .BytesPerLine ,_gcaa .Data ,_gcaa .Alpha ,_gcaa .Decode );
return _ggeb ;};func _gcf (_cfa ,_eee int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_cfa ,_eee ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func _dcac (_efga _f .Image )(Image ,error ){if _egca ,_fabd :=_efga .(*RGBA32 );_fabd {return _egca .Copy (),nil ;
};_fdef ,_eebea ,_eedae :=_gcae (_efga ,1);_gcadc ,_fgea :=NewImage (_fdef .Max .X ,_fdef .Max .Y ,8,3,nil ,_eedae ,nil );if _fgea !=nil {return nil ,_fgea ;};_bfgg (_efga ,_gcadc ,_fdef );if len (_eedae )!=0&&!_eebea {if _aabb :=_cafb (_eedae ,_gcadc );
_aabb !=nil {return nil ,_aabb ;};};return _gcadc ,nil ;};func _gff (_addb RGBA ,_bdbbd CMYK ,_dde _f .Rectangle ){for _aeg :=0;_aeg < _dde .Max .X ;_aeg ++{for _deb :=0;_deb < _dde .Max .Y ;_deb ++{_fbd :=_addb .RGBAAt (_aeg ,_deb );_bdbbd .SetCMYK (_aeg ,_deb ,_fegb (_fbd ));
};};};func (_acef *Gray2 )GrayAt (x ,y int )_c .Gray {_bef ,_ :=ColorAtGray2BPC (x ,y ,_acef .BytesPerLine ,_acef .Data ,_acef .Decode );return _bef ;};var _ Image =&Gray16 {};func _ebd ()(_gdf [256]uint32 ){for _dfb :=0;_dfb < 256;_dfb ++{if _dfb &0x01!=0{_gdf [_dfb ]|=0xf;
};if _dfb &0x02!=0{_gdf [_dfb ]|=0xf0;};if _dfb &0x04!=0{_gdf [_dfb ]|=0xf00;};if _dfb &0x08!=0{_gdf [_dfb ]|=0xf000;};if _dfb &0x10!=0{_gdf [_dfb ]|=0xf0000;};if _dfb &0x20!=0{_gdf [_dfb ]|=0xf00000;};if _dfb &0x40!=0{_gdf [_dfb ]|=0xf000000;};if _dfb &0x80!=0{_gdf [_dfb ]|=0xf0000000;
};};return _gdf ;};func _dgdb (_cddc _f .Image )(Image ,error ){if _aead ,_decb :=_cddc .(*Gray2 );_decb {return _aead .Copy (),nil ;};_egb :=_cddc .Bounds ();_fbc ,_eccb :=NewImage (_egb .Max .X ,_egb .Max .Y ,2,1,nil ,nil ,nil );if _eccb !=nil {return nil ,_eccb ;
};_ggec (_cddc ,_fbc ,_egb );return _fbc ,nil ;};func _agcd (_cgcag ,_ccb Gray ,_dbdf _f .Rectangle ){for _cgfd :=0;_cgfd < _dbdf .Max .X ;_cgfd ++{for _dgdd :=0;_dgdd < _dbdf .Max .Y ;_dgdd ++{_ccb .SetGray (_cgfd ,_dgdd ,_cgcag .GrayAt (_cgfd ,_dgdd ));
};};};func (_daae *Monochrome )SetGray (x ,y int ,g _c .Gray ){_eceg :=y *_daae .BytesPerLine +x >>3;if _eceg > len (_daae .Data )-1{return ;};g =_ggde (g ,monochromeModel (_daae .ModelThreshold ));_daae .setGray (x ,g ,_eceg );};func (_aefg *ImageBase )copy ()ImageBase {_dfdc :=*_aefg ;
_dfdc .Data =make ([]byte ,len (_aefg .Data ));copy (_dfdc .Data ,_aefg .Data );return _dfdc ;};func IsGrayImgBlackAndWhite (i *_f .Gray )bool {return _gdgg (i )};func (_cee *ImageBase )setByte (_ffbc int ,_dca byte )error {if _ffbc > len (_cee .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_cee .Data [_ffbc ]=_dca ;return nil ;};func _dfdd (_aaa _c .NRGBA )_c .RGBA {_gdfd ,_gegb ,_dec ,_egf :=_aaa .RGBA ();return _c .RGBA {R :uint8 (_gdfd >>8),G :uint8 (_gegb >>8),B :uint8 (_dec >>8),A :uint8 (_egf >>8)};};const (_gbdd shift =iota ;_ccdb ;
);func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_ddab (n )+1);};func _gbfe (_bcfd NRGBA ,_bdgc RGBA ,_bdec _f .Rectangle ){for _abgb :=0;_abgb < _bdec .Max .X ;_abgb ++{for _eda :=0;_eda < _bdec .Max .Y ;_eda ++{_gbec :=_bcfd .NRGBAAt (_abgb ,_eda );
_bdgc .SetRGBA (_abgb ,_eda ,_dfdd (_gbec ));};};};func (_deeb *NRGBA64 )Base ()*ImageBase {return &_deeb .ImageBase };func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_fedbf *RGBA32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtRGBA32 (x ,y ,_fedbf .Width ,_fedbf .Data ,_fedbf .Alpha ,_fedbf .Decode );
};type Histogramer interface{Histogram ()[256]int ;};func (_efbb *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_efbb .copy ()}};type Image interface{_d .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_baec ,_dddg int )(_c .Color ,error );
Validate ()error ;};func _fegb (_gcad _c .RGBA )_c .CMYK {_deg ,_eadc ,_gebc ,_abcgb :=_c .RGBToCMYK (_gcad .R ,_gcad .G ,_gcad .B );return _c .CMYK {C :_deg ,M :_eadc ,Y :_gebc ,K :_abcgb };};func _gagg (_egbf _c .Color )_c .Color {_eggc :=_c .GrayModel .Convert (_egbf ).(_c .Gray );
return _dabd (_eggc );};func (_ffeg *Gray8 )ColorModel ()_c .Model {return _c .GrayModel };func _fbga (_ecea nrgba64 ,_cbcd NRGBA ,_gada _f .Rectangle ){for _aeac :=0;_aeac < _gada .Max .X ;_aeac ++{for _cfeg :=0;_cfeg < _gada .Max .Y ;_cfeg ++{_gebdd :=_ecea .NRGBA64At (_aeac ,_cfeg );
_cbcd .SetNRGBA (_aeac ,_cfeg ,_ebce (_gebdd ));};};};func _ceec (_debc *_f .Gray ,_ceac uint8 )*_f .Gray {_ggb :=_debc .Bounds ();_efgb :=_f .NewGray (_ggb );for _fgceb :=0;_fgceb < _ggb .Dx ();_fgceb ++{for _fcbcge :=0;_fcbcge < _ggb .Dy ();_fcbcge ++{_efedc :=_debc .GrayAt (_fgceb ,_fcbcge );
_efgb .SetGray (_fgceb ,_fcbcge ,_c .Gray {Y :_dbdbf (_efedc .Y ,_ceac )});};};return _efgb ;};func _dddgb (_bdfc *Monochrome ,_aecg ,_ffae int ,_bada ,_faeba int ,_aaaef RasterOperator ){var (_cdbg bool ;_ebdc bool ;_baf int ;_bfa int ;_ecfa int ;_daab int ;
_bcga bool ;_dacge byte ;);_aggb :=8-(_aecg &7);_ffdc :=_faebe [_aggb ];_affd :=_bdfc .BytesPerLine *_ffae +(_aecg >>3);if _bada < _aggb {_cdbg =true ;_ffdc &=_bdbd [8-_aggb +_bada ];};if !_cdbg {_baf =(_bada -_aggb )>>3;if _baf !=0{_ebdc =true ;_bfa =_affd +1;
};};_ecfa =(_aecg +_bada )&7;if !(_cdbg ||_ecfa ==0){_bcga =true ;_dacge =_bdbd [_ecfa ];_daab =_affd +1+_baf ;};var _aeff ,_dccag int ;switch _aaaef {case PixClr :for _aeff =0;_aeff < _faeba ;_aeff ++{_bdfc .Data [_affd ]=_bacd (_bdfc .Data [_affd ],0x0,_ffdc );
_affd +=_bdfc .BytesPerLine ;};if _ebdc {for _aeff =0;_aeff < _faeba ;_aeff ++{for _dccag =0;_dccag < _baf ;_dccag ++{_bdfc .Data [_bfa +_dccag ]=0x0;};_bfa +=_bdfc .BytesPerLine ;};};if _bcga {for _aeff =0;_aeff < _faeba ;_aeff ++{_bdfc .Data [_daab ]=_bacd (_bdfc .Data [_daab ],0x0,_dacge );
_daab +=_bdfc .BytesPerLine ;};};case PixSet :for _aeff =0;_aeff < _faeba ;_aeff ++{_bdfc .Data [_affd ]=_bacd (_bdfc .Data [_affd ],0xff,_ffdc );_affd +=_bdfc .BytesPerLine ;};if _ebdc {for _aeff =0;_aeff < _faeba ;_aeff ++{for _dccag =0;_dccag < _baf ;
_dccag ++{_bdfc .Data [_bfa +_dccag ]=0xff;};_bfa +=_bdfc .BytesPerLine ;};};if _bcga {for _aeff =0;_aeff < _faeba ;_aeff ++{_bdfc .Data [_daab ]=_bacd (_bdfc .Data [_daab ],0xff,_dacge );_daab +=_bdfc .BytesPerLine ;};};case PixNotDst :for _aeff =0;_aeff < _faeba ;
_aeff ++{_bdfc .Data [_affd ]=_bacd (_bdfc .Data [_affd ],^_bdfc .Data [_affd ],_ffdc );_affd +=_bdfc .BytesPerLine ;};if _ebdc {for _aeff =0;_aeff < _faeba ;_aeff ++{for _dccag =0;_dccag < _baf ;_dccag ++{_bdfc .Data [_bfa +_dccag ]=^(_bdfc .Data [_bfa +_dccag ]);
};_bfa +=_bdfc .BytesPerLine ;};};if _bcga {for _aeff =0;_aeff < _faeba ;_aeff ++{_bdfc .Data [_daab ]=_bacd (_bdfc .Data [_daab ],^_bdfc .Data [_daab ],_dacge );_daab +=_bdfc .BytesPerLine ;};};};};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_egeb :=y *bytesPerLine +x ;
if _egeb >=len (data ){return _c .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gffe :=data [_egeb ];if len (decode )==2{_gffe =uint8 (uint32 (LinearInterpolate (float64 (_gffe ),0,255,decode [0],decode [1]))&0xff);};return _c .Gray {Y :_gffe },nil ;};func (_ded *CMYK32 )SetCMYK (x ,y int ,c _c .CMYK ){_ecgc :=4*(y *_ded .Width +x );
if _ecgc +3>=len (_ded .Data ){return ;};_ded .Data [_ecgc ]=c .C ;_ded .Data [_ecgc +1]=c .M ;_ded .Data [_ecgc +2]=c .Y ;_ded .Data [_ecgc +3]=c .K ;};func (_fdfa *Gray4 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_fdfa .Width ,Y :_fdfa .Height }};
};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func _fec (_aadc *Monochrome ,_dggb ,_gaf ,_fdfag ,_gaabd int ,_cbeg RasterOperator ,_ffda *Monochrome ,_feec ,_egga int )error {if _aadc ==nil {return _a .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _cbeg ==PixDst {return nil ;};switch _cbeg {case PixClr ,PixSet ,PixNotDst :_ebdf (_aadc ,_dggb ,_gaf ,_fdfag ,_gaabd ,_cbeg );return nil ;};if _ffda ==nil {_ga .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _a .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _aefa :=_ccgcg (_aadc ,_dggb ,_gaf ,_fdfag ,_gaabd ,_cbeg ,_ffda ,_feec ,_egga );_aefa !=nil {return _aefa ;};return nil ;};func (_aeffg *NRGBA64 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_aeffg .Width ,Y :_aeffg .Height }};
};func ImgToGray (i _f .Image )*_f .Gray {if _affad ,_ceafb :=i .(*_f .Gray );_ceafb {return _affad ;};_ffga :=i .Bounds ();_ebccf :=_f .NewGray (_ffga );for _dada :=0;_dada < _ffga .Max .X ;_dada ++{for _fgffb :=0;_fgffb < _ffga .Max .Y ;_fgffb ++{_dedgf :=i .At (_dada ,_fgffb );
_ebccf .Set (_dada ,_fgffb ,_dedgf );};};return _ebccf ;};