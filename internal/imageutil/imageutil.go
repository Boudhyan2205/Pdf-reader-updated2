//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_d "encoding/binary";_ge "errors";_ed "fmt";_b "github.com/unidoc/unipdf/v3/common";_dg "github.com/unidoc/unipdf/v3/internal/bitwise";_e "image";_a "image/color";_f "image/draw";_c "math";);func _ecfb (_adgf RGBA ,_geac CMYK ,_cbb _e .Rectangle ){for _ccc :=0;
_ccc < _cbb .Max .X ;_ccc ++{for _ceaf :=0;_ceaf < _cbb .Max .Y ;_ceaf ++{_baaf :=_adgf .RGBAAt (_ccc ,_ceaf );_geac .SetCMYK (_ccc ,_ceaf ,_gbde (_baaf ));};};};func ConverterFunc (converterFunc func (_acde _e .Image )(Image ,error ))ColorConverter {return colorConverter {_edeg :converterFunc };
};func _eaffg (_gaedb ,_dbc NRGBA ,_ebd _e .Rectangle ){for _ffee :=0;_ffee < _ebd .Max .X ;_ffee ++{for _cgcf :=0;_cgcf < _ebd .Max .Y ;_cgcf ++{_dbc .SetNRGBA (_ffee ,_cgcf ,_gaedb .NRGBAAt (_ffee ,_cgcf ));};};};type CMYK32 struct{ImageBase };type ColorConverter interface{Convert (_degf _e .Image )(Image ,error );
};func (_bfe *Monochrome )InverseData ()error {return _bfe .RasterOperation (0,0,_bfe .Width ,_bfe .Height ,PixNotDst ,nil ,0,0);};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_a .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_ed .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func _bacf (_degge uint8 )bool {if _degge ==0||_degge ==255{return true ;};return false ;};var _ Image =&Gray8 {};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_bgag :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_bgag .Data =make ([]byte ,height *_bgag .BytesPerLine );};return _bgag ;};type NRGBA64 struct{ImageBase };func FromGoImage (i _e .Image )(Image ,error ){switch _edad :=i .(type ){case Image :return _edad .Copy (),nil ;case Gray :return GrayConverter .Convert (i );
case *_e .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_e .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_caa *ImageBase )setFourBytes (_bead int ,_faag uint32 )error {if _bead +3> len (_caa .Data )-1{return _ed .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_bead );
};_caa .Data [_bead ]=byte ((_faag &0xff000000)>>24);_caa .Data [_bead +1]=byte ((_faag &0xff0000)>>16);_caa .Data [_bead +2]=byte ((_faag &0xff00)>>8);_caa .Data [_bead +3]=byte (_faag &0xff);return nil ;};func (_agce *NRGBA32 )ColorModel ()_a .Model {return _a .NRGBAModel };
func (_ecc colorConverter )Convert (src _e .Image )(Image ,error ){return _ecc ._edeg (src )};func _efbd (_eaaba RGBA ,_bdcg NRGBA ,_aggfe _e .Rectangle ){for _dffgc :=0;_dffgc < _aggfe .Max .X ;_dffgc ++{for _egaf :=0;_egaf < _aggfe .Max .Y ;_egaf ++{_cgda :=_eaaba .RGBAAt (_dffgc ,_egaf );
_bdcg .SetNRGBA (_dffgc ,_egaf ,_dfc (_cgda ));};};};func _cbcd (_bcab *Monochrome ,_dccd ,_efedc ,_fgcd ,_fbce int ,_ecaag RasterOperator ,_dabg *Monochrome ,_ecdc ,_aaad int )error {if _bcab ==nil {return _ge .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _ecaag ==PixDst {return nil ;};switch _ecaag {case PixClr ,PixSet ,PixNotDst :_dgag (_bcab ,_dccd ,_efedc ,_fgcd ,_fbce ,_ecaag );return nil ;};if _dabg ==nil {_b .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _ge .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _bfefd :=_bebb (_bcab ,_dccd ,_efedc ,_fgcd ,_fbce ,_ecaag ,_dabg ,_ecdc ,_aaad );_bfefd !=nil {return _bfefd ;};return nil ;};func (_bca *monochromeThresholdConverter )Convert (img _e .Image )(Image ,error ){if _ecg ,_dgdf :=img .(*Monochrome );
_dgdf {return _ecg .Copy (),nil ;};_cedc :=img .Bounds ();_bbfd ,_eab :=NewImage (_cedc .Max .X ,_cedc .Max .Y ,1,1,nil ,nil ,nil );if _eab !=nil {return nil ,_eab ;};_bbfd .(*Monochrome ).ModelThreshold =_bca .Threshold ;for _aag :=0;_aag < _cedc .Max .X ;
_aag ++{for _aacd :=0;_aacd < _cedc .Max .Y ;_aacd ++{_gde :=img .At (_aag ,_aacd );_bbfd .Set (_aag ,_aacd ,_gde );};};return _bbfd ,nil ;};func _dee (_bcgc Gray ,_bfcf NRGBA ,_efc _e .Rectangle ){for _ecb :=0;_ecb < _efc .Max .X ;_ecb ++{for _bdeb :=0;
_bdeb < _efc .Max .Y ;_bdeb ++{_agf :=_geg (_bfcf .NRGBAAt (_ecb ,_bdeb ));_bcgc .SetGray (_ecb ,_bdeb ,_agf );};};};func (_bcede *Monochrome )setIndexedBit (_affb int ){_bcede .Data [(_affb >>3)]|=0x80>>uint (_affb &7);};func (_bbdf *Gray8 )Set (x ,y int ,c _a .Color ){_agfg :=y *_bbdf .BytesPerLine +x ;
if _agfg > len (_bbdf .Data )-1{return ;};_caf :=_a .GrayModel .Convert (c );_bbdf .Data [_agfg ]=_caf .(_a .Gray ).Y ;};func (_aeb *CMYK32 )Base ()*ImageBase {return &_aeb .ImageBase };func (_fdd *ImageBase )HasAlpha ()bool {if _fdd .Alpha ==nil {return false ;
};for _fcaf :=range _fdd .Alpha {if _fdd .Alpha [_fcaf ]!=0xff{return true ;};};return false ;};func (_cfcd *ImageBase )getByte (_daa int )(byte ,error ){if _daa > len (_cfcd .Data )-1||_daa < 0{return 0,_ed .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_daa );
};return _cfcd .Data [_daa ],nil ;};func _dd (_ff *Monochrome ,_acc int ,_dc []uint )(*Monochrome ,error ){_fe :=_acc *_ff .Width ;_gd :=_acc *_ff .Height ;_beg :=_fd (_fe ,_gd );for _eg ,_gag :=range _dc {var _gea error ;switch _gag {case 2:_gea =_eb (_beg ,_ff );
case 4:_gea =_af (_beg ,_ff );case 8:_gea =_gaad (_beg ,_ff );};if _gea !=nil {return nil ,_gea ;};if _eg !=len (_dc )-1{_ff =_beg .copy ();};};return _beg ,nil ;};func _fbdce (_bacea Gray ,_ddef RGBA ,_cgab _e .Rectangle ){for _edg :=0;_edg < _cgab .Max .X ;
_edg ++{for _ffda :=0;_ffda < _cgab .Max .Y ;_ffda ++{_ggdcg :=_bacea .GrayAt (_edg ,_ffda );_ddef .SetRGBA (_edg ,_ffda ,_fcb (_ggdcg ));};};};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA64 ,error ){_acec :=(y *width +x )*2;
_cadb :=_acec *3;if _cadb +5>=len (data ){return _a .NRGBA64 {},_ed .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _cdbef =0xffff;_bffd :=uint16 (_cdbef );if alpha !=nil &&len (alpha )> _acec +1{_bffd =uint16 (alpha [_acec ])<<8|uint16 (alpha [_acec +1]);};_eacd :=uint16 (data [_cadb ])<<8|uint16 (data [_cadb +1]);_gca :=uint16 (data [_cadb +2])<<8|uint16 (data [_cadb +3]);
_aaea :=uint16 (data [_cadb +4])<<8|uint16 (data [_cadb +5]);if len (decode )==6{_eacd =uint16 (uint64 (LinearInterpolate (float64 (_eacd ),0,65535,decode [0],decode [1]))&_cdbef );_gca =uint16 (uint64 (LinearInterpolate (float64 (_gca ),0,65535,decode [2],decode [3]))&_cdbef );
_aaea =uint16 (uint64 (LinearInterpolate (float64 (_aaea ),0,65535,decode [4],decode [5]))&_cdbef );};return _a .NRGBA64 {R :_eacd ,G :_gca ,B :_aaea ,A :_bffd },nil ;};func (_fdee *Monochrome )GrayAt (x ,y int )_a .Gray {_bfef ,_ :=ColorAtGray1BPC (x ,y ,_fdee .BytesPerLine ,_fdee .Data ,_fdee .Decode );
return _bfef ;};func _gegc (){for _agcd :=0;_agcd < 256;_agcd ++{_dcgb [_agcd ]=uint8 (_agcd &0x1)+(uint8 (_agcd >>1)&0x1)+(uint8 (_agcd >>2)&0x1)+(uint8 (_agcd >>3)&0x1)+(uint8 (_agcd >>4)&0x1)+(uint8 (_agcd >>5)&0x1)+(uint8 (_agcd >>6)&0x1)+(uint8 (_agcd >>7)&0x1);
};};func (_aeeg *NRGBA16 )At (x ,y int )_a .Color {_ffdbg ,_ :=_aeeg .ColorAt (x ,y );return _ffdbg };func _eebfc (_fcgc _e .Image )(Image ,error ){if _fcad ,_adad :=_fcgc .(*Monochrome );_adad {return _fcad ,nil ;};_eaag :=_fcgc .Bounds ();var _ebe Gray ;
switch _abe :=_fcgc .(type ){case Gray :_ebe =_abe ;case NRGBA :_ebe =&Gray8 {ImageBase :NewImageBase (_eaag .Max .X ,_eaag .Max .Y ,8,1,nil ,nil ,nil )};_dee (_ebe ,_abe ,_eaag );case nrgba64 :_ebe =&Gray8 {ImageBase :NewImageBase (_eaag .Max .X ,_eaag .Max .Y ,8,1,nil ,nil ,nil )};
_dgbf (_ebe ,_abe ,_eaag );default:_bcedc ,_aeff :=GrayConverter .Convert (_fcgc );if _aeff !=nil {return nil ,_aeff ;};_ebe =_bcedc .(Gray );};_abdb ,_dgcd :=NewImage (_eaag .Max .X ,_eaag .Max .Y ,1,1,nil ,nil ,nil );if _dgcd !=nil {return nil ,_dgcd ;
};_ecfd :=_abdb .(*Monochrome );_bdf :=AutoThresholdTriangle (GrayHistogram (_ebe ));for _cbgd :=0;_cbgd < _eaag .Max .X ;_cbgd ++{for _fde :=0;_fde < _eaag .Max .Y ;_fde ++{_bdade :=_dadfd (_ebe .GrayAt (_cbgd ,_fde ),monochromeModel (_bdf ));_ecfd .SetGray (_cbgd ,_fde ,_bdade );
};};return _abdb ,nil ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_a .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_ed .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};const (_gggge shift =iota ;_acee ;);func (_eeeb *NRGBA64 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_eeeb .Width ,Y :_eeeb .Height }};};func _fdbd (_cfb _a .Gray )_a .NRGBA {return _a .NRGBA {R :_cfb .Y ,G :_cfb .Y ,B :_cfb .Y ,A :0xff}};
func (_bgdb *Monochrome )Histogram ()(_ggg [256]int ){for _ ,_ffa :=range _bgdb .Data {_ggg [0xff]+=int (_dcgb [_bgdb .Data [_ffa ]]);};return _ggg ;};func (_accf *Gray4 )GrayAt (x ,y int )_a .Gray {_ccf ,_ :=ColorAtGray4BPC (x ,y ,_accf .BytesPerLine ,_accf .Data ,_accf .Decode );
return _ccf ;};var _ _e .Image =&Gray2 {};func _cbcc (_bcee ,_geda ,_fgfc byte )byte {return (_bcee &^(_fgfc ))|(_geda &_fgfc )};type monochromeModel uint8 ;func _ccdd (_geag *_e .NYCbCrA ,_dfda RGBA ,_abgeg _e .Rectangle ){for _cdcd :=0;_cdcd < _abgeg .Max .X ;
_cdcd ++{for _fcadc :=0;_fcadc < _abgeg .Max .Y ;_fcadc ++{_ffdc :=_geag .NYCbCrAAt (_cdcd ,_fcadc );_dfda .SetRGBA (_cdcd ,_fcadc ,_cee (_ffdc ));};};};func (_ceafb *Gray8 )ColorModel ()_a .Model {return _a .GrayModel };func (_gfda *CMYK32 )CMYKAt (x ,y int )_a .CMYK {_bced ,_ :=ColorAtCMYK (x ,y ,_gfda .Width ,_gfda .Data ,_gfda .Decode );
return _bced ;};func (_gbbc monochromeModel )Convert (c _a .Color )_a .Color {_gdfe :=_a .GrayModel .Convert (c ).(_a .Gray );return _dadfd (_gdfe ,_gbbc );};func _cace (_ceda _a .Gray )_a .CMYK {return _a .CMYK {K :0xff-_ceda .Y }};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _c .Abs (xmax -xmin )< 0.000001{return ymin ;
};_dddc :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _dddc ;};func (_dggc *Monochrome )ResolveDecode ()error {if len (_dggc .Decode )!=2{return nil ;};if _dggc .Decode [0]==1&&_dggc .Decode [1]==0{if _cbc :=_dggc .InverseData ();_cbc !=nil {return _cbc ;
};_dggc .Decode =nil ;};return nil ;};func _ecffg (_gdfdd nrgba64 ,_ggdb RGBA ,_bgebd _e .Rectangle ){for _egge :=0;_egge < _bgebd .Max .X ;_egge ++{for _fgbb :=0;_fgbb < _bgebd .Max .Y ;_fgbb ++{_edcb :=_gdfdd .NRGBA64At (_egge ,_fgbb );_ggdb .SetRGBA (_egge ,_fgbb ,_ggb (_edcb ));
};};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_ddcf :=y *bytesPerLine +x >>3;if _ddcf >=len (data ){return _a .Gray {},_ed .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ddcg :=data [_ddcf ]>>uint (7-(x &7))&1;if len (decode )==2{_ddcg =uint8 (LinearInterpolate (float64 (_ddcg ),0.0,1.0,decode [0],decode [1]))&1;};return _a .Gray {Y :_ddcg *255},nil ;};func (_gebf *Gray16 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray16BPC (x ,y ,_gebf .BytesPerLine ,_gebf .Data ,_gebf .Decode );
};func _agee (_deggb *Monochrome ,_gagbf ,_afed ,_fgcg ,_fgag int ,_dedg RasterOperator ,_dagb *Monochrome ,_bgaa ,_gdaa int )error {var (_cegc bool ;_agdda bool ;_bgfb int ;_ageg int ;_edfc int ;_fbcg bool ;_cgee byte ;_fgef int ;_febbb int ;_dccdd int ;
_bfbc ,_aaba int ;);_fgcgb :=8-(_gagbf &7);_gefg :=_aefc [_fgcgb ];_dgcc :=_deggb .BytesPerLine *_afed +(_gagbf >>3);_abfde :=_dagb .BytesPerLine *_gdaa +(_bgaa >>3);if _fgcg < _fgcgb {_cegc =true ;_gefg &=_agcf [8-_fgcgb +_fgcg ];};if !_cegc {_bgfb =(_fgcg -_fgcgb )>>3;
if _bgfb > 0{_agdda =true ;_ageg =_dgcc +1;_edfc =_abfde +1;};};_fgef =(_gagbf +_fgcg )&7;if !(_cegc ||_fgef ==0){_fbcg =true ;_cgee =_agcf [_fgef ];_febbb =_dgcc +1+_bgfb ;_dccdd =_abfde +1+_bgfb ;};switch _dedg {case PixSrc :for _bfbc =0;_bfbc < _fgag ;
_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],_dagb .Data [_abfde ],_gefg );_dgcc +=_deggb .BytesPerLine ;_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]=_dagb .Data [_edfc +_aaba ];
};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;};};if _fbcg {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],_dagb .Data [_dccdd ],_cgee );_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;
};};case PixNotSrc :for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],^_dagb .Data [_abfde ],_gefg );_dgcc +=_deggb .BytesPerLine ;_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;
_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]=^_dagb .Data [_edfc +_aaba ];};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;};};if _fbcg {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],^_dagb .Data [_dccdd ],_cgee );
_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};case PixSrcOrDst :for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],_dagb .Data [_abfde ]|_deggb .Data [_dgcc ],_gefg );_dgcc +=_deggb .BytesPerLine ;
_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]|=_dagb .Data [_edfc +_aaba ];};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;};};if _fbcg {for _bfbc =0;
_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],_dagb .Data [_dccdd ]|_deggb .Data [_febbb ],_cgee );_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};case PixSrcAndDst :for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],_dagb .Data [_abfde ]&_deggb .Data [_dgcc ],_gefg );
_dgcc +=_deggb .BytesPerLine ;_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]&=_dagb .Data [_edfc +_aaba ];};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;
};};if _fbcg {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],_dagb .Data [_dccdd ]&_deggb .Data [_febbb ],_cgee );_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};case PixSrcXorDst :for _bfbc =0;
_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],_dagb .Data [_abfde ]^_deggb .Data [_dgcc ],_gefg );_dgcc +=_deggb .BytesPerLine ;_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;_aaba < _bgfb ;
_aaba ++{_deggb .Data [_ageg +_aaba ]^=_dagb .Data [_edfc +_aaba ];};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;};};if _fbcg {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],_dagb .Data [_dccdd ]^_deggb .Data [_febbb ],_cgee );
_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};case PixNotSrcOrDst :for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],^(_dagb .Data [_abfde ])|_deggb .Data [_dgcc ],_gefg );_dgcc +=_deggb .BytesPerLine ;
_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]|=^(_dagb .Data [_edfc +_aaba ]);};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;};};if _fbcg {for _bfbc =0;
_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],^(_dagb .Data [_dccdd ])|_deggb .Data [_febbb ],_cgee );_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};case PixNotSrcAndDst :for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],^(_dagb .Data [_abfde ])&_deggb .Data [_dgcc ],_gefg );
_dgcc +=_deggb .BytesPerLine ;_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]&=^_dagb .Data [_edfc +_aaba ];};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;
};};if _fbcg {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],^(_dagb .Data [_dccdd ])&_deggb .Data [_febbb ],_cgee );_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};case PixSrcOrNotDst :for _bfbc =0;
_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],_dagb .Data [_abfde ]|^(_deggb .Data [_dgcc ]),_gefg );_dgcc +=_deggb .BytesPerLine ;_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;
_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]=_dagb .Data [_edfc +_aaba ]|^(_deggb .Data [_ageg +_aaba ]);};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;};};if _fbcg {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],_dagb .Data [_dccdd ]|^(_deggb .Data [_febbb ]),_cgee );
_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};case PixSrcAndNotDst :for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],_dagb .Data [_abfde ]&^(_deggb .Data [_dgcc ]),_gefg );_dgcc +=_deggb .BytesPerLine ;
_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]=_dagb .Data [_edfc +_aaba ]&^(_deggb .Data [_ageg +_aaba ]);};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;
};};if _fbcg {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],_dagb .Data [_dccdd ]&^(_deggb .Data [_febbb ]),_cgee );_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};case PixNotPixSrcOrDst :for _bfbc =0;
_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],^(_dagb .Data [_abfde ]|_deggb .Data [_dgcc ]),_gefg );_dgcc +=_deggb .BytesPerLine ;_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;
_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]=^(_dagb .Data [_edfc +_aaba ]|_deggb .Data [_ageg +_aaba ]);};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;};};if _fbcg {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],^(_dagb .Data [_dccdd ]|_deggb .Data [_febbb ]),_cgee );
_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};case PixNotPixSrcAndDst :for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],^(_dagb .Data [_abfde ]&_deggb .Data [_dgcc ]),_gefg );_dgcc +=_deggb .BytesPerLine ;
_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]=^(_dagb .Data [_edfc +_aaba ]&_deggb .Data [_ageg +_aaba ]);};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;
};};if _fbcg {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],^(_dagb .Data [_dccdd ]&_deggb .Data [_febbb ]),_cgee );_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};case PixNotPixSrcXorDst :for _bfbc =0;
_bfbc < _fgag ;_bfbc ++{_deggb .Data [_dgcc ]=_cbcc (_deggb .Data [_dgcc ],^(_dagb .Data [_abfde ]^_deggb .Data [_dgcc ]),_gefg );_dgcc +=_deggb .BytesPerLine ;_abfde +=_dagb .BytesPerLine ;};if _agdda {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{for _aaba =0;
_aaba < _bgfb ;_aaba ++{_deggb .Data [_ageg +_aaba ]=^(_dagb .Data [_edfc +_aaba ]^_deggb .Data [_ageg +_aaba ]);};_ageg +=_deggb .BytesPerLine ;_edfc +=_dagb .BytesPerLine ;};};if _fbcg {for _bfbc =0;_bfbc < _fgag ;_bfbc ++{_deggb .Data [_febbb ]=_cbcc (_deggb .Data [_febbb ],^(_dagb .Data [_dccdd ]^_deggb .Data [_febbb ]),_cgee );
_febbb +=_deggb .BytesPerLine ;_dccdd +=_dagb .BytesPerLine ;};};default:_b .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_dedg );return _ge .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func (_gge *RGBA32 )RGBAAt (x ,y int )_a .RGBA {_eeab ,_ :=ColorAtRGBA32 (x ,y ,_gge .Width ,_gge .Data ,_gge .Alpha ,_gge .Decode );return _eeab ;};func (_ccfb *ImageBase )setEightFullBytes (_fcda int ,_bdbe uint64 )error {if _fcda +7> len (_ccfb .Data )-1{return _ge .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ccfb .Data [_fcda ]=byte ((_bdbe &0xff00000000000000)>>56);_ccfb .Data [_fcda +1]=byte ((_bdbe &0xff000000000000)>>48);_ccfb .Data [_fcda +2]=byte ((_bdbe &0xff0000000000)>>40);_ccfb .Data [_fcda +3]=byte ((_bdbe &0xff00000000)>>32);_ccfb .Data [_fcda +4]=byte ((_bdbe &0xff000000)>>24);
_ccfb .Data [_fcda +5]=byte ((_bdbe &0xff0000)>>16);_ccfb .Data [_fcda +6]=byte ((_bdbe &0xff00)>>8);_ccfb .Data [_fcda +7]=byte (_bdbe &0xff);return nil ;};func _dae (_aee *Monochrome ,_deg ...int )(_cf *Monochrome ,_fff error ){if _aee ==nil {return nil ,_ge .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_deg )==0{return nil ,_ge .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_fca :=_ecaf ();_cf =_aee ;for _ ,_ebff :=range _deg {if _ebff <=0{break ;};_cf ,_fff =_eee (_cf ,_ebff ,_fca );if _fff !=nil {return nil ,_fff ;};};return _cf ,nil ;};func _gaead (_ageb nrgba64 ,_fdde NRGBA ,_fgg _e .Rectangle ){for _ggdc :=0;_ggdc < _fgg .Max .X ;
_ggdc ++{for _gffgb :=0;_gffgb < _fgg .Max .Y ;_gffgb ++{_cedb :=_ageb .NRGBA64At (_ggdc ,_gffgb );_fdde .SetNRGBA (_ggdc ,_gffgb ,_ffg (_cedb ));};};};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_bbbf (n )+1);};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_ed .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _dgeag (_cgca CMYK ,_agdd Gray ,_gecg _e .Rectangle ){for _dgfe :=0;_dgfe < _gecg .Max .X ;_dgfe ++{for _fafd :=0;_fafd < _gecg .Max .Y ;_fafd ++{_bgea :=_cdae (_cgca .CMYKAt (_dgfe ,_fafd ));_agdd .SetGray (_dgfe ,_fafd ,_bgea );};};};func (_daef *Gray16 )At (x ,y int )_a .Color {_bfgf ,_ :=_daef .ColorAt (x ,y );
return _bfgf };type RGBA32 struct{ImageBase };func (_ggdea *Gray4 )Set (x ,y int ,c _a .Color ){if x >=_ggdea .Width ||y >=_ggdea .Height {return ;};_cacdb :=Gray4Model .Convert (c ).(_a .Gray );_ggdea .setGray (x ,y ,_cacdb );};var _ Image =&Gray2 {};
func (_cgbd *Monochrome )setGrayBit (_dggg ,_aaggd int ){_cgbd .Data [_dggg ]|=0x80>>uint (_aaggd &7)};var _ Image =&Gray4 {};func _cggg (_afeg *Monochrome ,_fcfbb ,_aedb int ,_ebcb ,_babc int ,_fbca RasterOperator ){var (_bgdd bool ;_dbdc bool ;_fddc int ;
_edbb int ;_agfa int ;_fafa int ;_fece bool ;_aebe byte ;);_bffb :=8-(_fcfbb &7);_cbcg :=_aefc [_bffb ];_eafe :=_afeg .BytesPerLine *_aedb +(_fcfbb >>3);if _ebcb < _bffb {_bgdd =true ;_cbcg &=_agcf [8-_bffb +_ebcb ];};if !_bgdd {_fddc =(_ebcb -_bffb )>>3;
if _fddc !=0{_dbdc =true ;_edbb =_eafe +1;};};_agfa =(_fcfbb +_ebcb )&7;if !(_bgdd ||_agfa ==0){_fece =true ;_aebe =_agcf [_agfa ];_fafa =_eafe +1+_fddc ;};var _fgaa ,_aeab int ;switch _fbca {case PixClr :for _fgaa =0;_fgaa < _babc ;_fgaa ++{_afeg .Data [_eafe ]=_cbcc (_afeg .Data [_eafe ],0x0,_cbcg );
_eafe +=_afeg .BytesPerLine ;};if _dbdc {for _fgaa =0;_fgaa < _babc ;_fgaa ++{for _aeab =0;_aeab < _fddc ;_aeab ++{_afeg .Data [_edbb +_aeab ]=0x0;};_edbb +=_afeg .BytesPerLine ;};};if _fece {for _fgaa =0;_fgaa < _babc ;_fgaa ++{_afeg .Data [_fafa ]=_cbcc (_afeg .Data [_fafa ],0x0,_aebe );
_fafa +=_afeg .BytesPerLine ;};};case PixSet :for _fgaa =0;_fgaa < _babc ;_fgaa ++{_afeg .Data [_eafe ]=_cbcc (_afeg .Data [_eafe ],0xff,_cbcg );_eafe +=_afeg .BytesPerLine ;};if _dbdc {for _fgaa =0;_fgaa < _babc ;_fgaa ++{for _aeab =0;_aeab < _fddc ;_aeab ++{_afeg .Data [_edbb +_aeab ]=0xff;
};_edbb +=_afeg .BytesPerLine ;};};if _fece {for _fgaa =0;_fgaa < _babc ;_fgaa ++{_afeg .Data [_fafa ]=_cbcc (_afeg .Data [_fafa ],0xff,_aebe );_fafa +=_afeg .BytesPerLine ;};};case PixNotDst :for _fgaa =0;_fgaa < _babc ;_fgaa ++{_afeg .Data [_eafe ]=_cbcc (_afeg .Data [_eafe ],^_afeg .Data [_eafe ],_cbcg );
_eafe +=_afeg .BytesPerLine ;};if _dbdc {for _fgaa =0;_fgaa < _babc ;_fgaa ++{for _aeab =0;_aeab < _fddc ;_aeab ++{_afeg .Data [_edbb +_aeab ]=^(_afeg .Data [_edbb +_aeab ]);};_edbb +=_afeg .BytesPerLine ;};};if _fece {for _fgaa =0;_fgaa < _babc ;_fgaa ++{_afeg .Data [_fafa ]=_cbcc (_afeg .Data [_fafa ],^_afeg .Data [_fafa ],_aebe );
_fafa +=_afeg .BytesPerLine ;};};};};func (_edf *CMYK32 )ColorModel ()_a .Model {return _a .CMYKModel };func IsGrayImgBlackAndWhite (i *_e .Gray )bool {return _gfeff (i )};var _ Image =&Monochrome {};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_gaff :=y *bytesPerLine +x >>1;
if _gaff >=len (data ){return _a .Gray {},_ed .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bfg :=data [_gaff ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_bfg =uint8 (uint32 (LinearInterpolate (float64 (_bfg ),0,15,decode [0],decode [1]))&0xf);};return _a .Gray {Y :_bfg *17&0xff},nil ;};func init (){_gegc ()};func (_bdfb *Monochrome )getBitAt (_eaba ,_aegc int )bool {_dfa :=_aegc *_bdfb .BytesPerLine +(_eaba >>3);
_dea :=_eaba &0x07;_cdeg :=uint (7-_dea );if _dfa > len (_bdfb .Data )-1{return false ;};if (_bdfb .Data [_dfa ]>>_cdeg )&0x01>=1{return true ;};return false ;};type RasterOperator int ;func (_efd *CMYK32 )Validate ()error {if len (_efd .Data )!=4*_efd .Width *_efd .Height {return _ge .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _fadf (_eaec CMYK ,_edef RGBA ,_fbgf _e .Rectangle ){for _gded :=0;_gded < _fbgf .Max .X ;_gded ++{for _adec :=0;_adec < _fbgf .Max .Y ;_adec ++{_bbag :=_eaec .CMYKAt (_gded ,_adec );_edef .SetRGBA (_gded ,_adec ,_add (_bbag ));};};
};var (Gray2Model =_a .ModelFunc (_dbe );Gray4Model =_a .ModelFunc (_cfae );NRGBA16Model =_a .ModelFunc (_acef ););func _ecabf (_cgc _a .NRGBA )_a .Gray {_dec ,_fba ,_befe ,_ :=_cgc .RGBA ();_edb :=(19595*_dec +38470*_fba +7471*_befe +1<<15)>>24;return _a .Gray {Y :uint8 (_edb )};
};func _dbe (_dgcb _a .Color )_a .Color {_cbff :=_a .GrayModel .Convert (_dgcb ).(_a .Gray );return _ffae (_cbff );};func _bagd (_fbf ,_bebcb uint8 )uint8 {if _fbf < _bebcb {return 255;};return 0;};type Image interface{_f .Image ;Base ()*ImageBase ;Copy ()Image ;
Pix ()[]byte ;ColorAt (_adbb ,_dgff int )(_a .Color ,error );Validate ()error ;};func _ggad (_bfc ,_ebcf *Monochrome ,_fab []byte ,_adea int )(_fgc error ){var (_cbgb ,_gbae ,_cba ,_aega ,_dbde ,_afd ,_cef ,_ccb int ;_bdaf ,_gfd uint32 ;_eeg ,_dgd byte ;
_cbab uint16 ;);_bed :=make ([]byte ,4);_eed :=make ([]byte ,4);for _cba =0;_cba < _bfc .Height -1;_cba ,_aega =_cba +2,_aega +1{_cbgb =_cba *_bfc .BytesPerLine ;_gbae =_aega *_ebcf .BytesPerLine ;for _dbde ,_afd =0,0;_dbde < _adea ;_dbde ,_afd =_dbde +4,_afd +1{for _cef =0;
_cef < 4;_cef ++{_ccb =_cbgb +_dbde +_cef ;if _ccb <=len (_bfc .Data )-1&&_ccb < _cbgb +_bfc .BytesPerLine {_bed [_cef ]=_bfc .Data [_ccb ];}else {_bed [_cef ]=0x00;};_ccb =_cbgb +_bfc .BytesPerLine +_dbde +_cef ;if _ccb <=len (_bfc .Data )-1&&_ccb < _cbgb +(2*_bfc .BytesPerLine ){_eed [_cef ]=_bfc .Data [_ccb ];
}else {_eed [_cef ]=0x00;};};_bdaf =_d .BigEndian .Uint32 (_bed );_gfd =_d .BigEndian .Uint32 (_eed );_gfd &=_bdaf ;_gfd &=_gfd <<1;_gfd &=0xaaaaaaaa;_bdaf =_gfd |(_gfd <<7);_eeg =byte (_bdaf >>24);_dgd =byte ((_bdaf >>8)&0xff);_ccb =_gbae +_afd ;if _ccb +1==len (_ebcf .Data )-1||_ccb +1>=_gbae +_ebcf .BytesPerLine {_ebcf .Data [_ccb ]=_fab [_eeg ];
if _fgc =_ebcf .setByte (_ccb ,_fab [_eeg ]);_fgc !=nil {return _ed .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ccb );};}else {_cbab =(uint16 (_fab [_eeg ])<<8)|uint16 (_fab [_dgd ]);if _fgc =_ebcf .setTwoBytes (_ccb ,_cbab );_fgc !=nil {return _ed .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ccb );
};_afd ++;};};};return nil ;};func (_accd *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_accd .copy ()}};func (_bfb *Monochrome )Base ()*ImageBase {return &_bfb .ImageBase };func _cfdb (_acdg *Monochrome ,_abge ,_acaa ,_cbca ,_ccdef int ,_fafb RasterOperator ,_adff *Monochrome ,_fgefb ,_bgec int )error {var (_afa bool ;
_cegd bool ;_cggf byte ;_eagd int ;_dcfe int ;_egbe int ;_dbgd int ;_abde bool ;_ebee int ;_efdcg int ;_daae int ;_bcaf bool ;_gdcd byte ;_cad int ;_agcb int ;_caga int ;_gfbe byte ;_bdbd int ;_fgb int ;_ccff uint ;_aefa uint ;_cface byte ;_dbgcf shift ;
_eagg bool ;_fcc bool ;_efcd ,_gffg int ;);if _fgefb &7!=0{_fgb =8-(_fgefb &7);};if _abge &7!=0{_dcfe =8-(_abge &7);};if _fgb ==0&&_dcfe ==0{_cface =_aefc [0];}else {if _dcfe > _fgb {_ccff =uint (_dcfe -_fgb );}else {_ccff =uint (8-(_fgb -_dcfe ));};_aefa =8-_ccff ;
_cface =_aefc [_ccff ];};if (_abge &7)!=0{_afa =true ;_eagd =8-(_abge &7);_cggf =_aefc [_eagd ];_egbe =_acdg .BytesPerLine *_acaa +(_abge >>3);_dbgd =_adff .BytesPerLine *_bgec +(_fgefb >>3);_bdbd =8-(_fgefb &7);if _eagd > _bdbd {_dbgcf =_gggge ;if _cbca >=_fgb {_eagg =true ;
};}else {_dbgcf =_acee ;};};if _cbca < _eagd {_cegd =true ;_cggf &=_agcf [8-_eagd +_cbca ];};if !_cegd {_ebee =(_cbca -_eagd )>>3;if _ebee !=0{_abde =true ;_efdcg =_acdg .BytesPerLine *_acaa +((_abge +_dcfe )>>3);_daae =_adff .BytesPerLine *_bgec +((_fgefb +_dcfe )>>3);
};};_cad =(_abge +_cbca )&7;if !(_cegd ||_cad ==0){_bcaf =true ;_gdcd =_agcf [_cad ];_agcb =_acdg .BytesPerLine *_acaa +((_abge +_dcfe )>>3)+_ebee ;_caga =_adff .BytesPerLine *_bgec +((_fgefb +_dcfe )>>3)+_ebee ;if _cad > int (_aefa ){_fcc =true ;};};switch _fafb {case PixSrc :if _afa {for _efcd =0;
_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],_gfbe ,_cggf );
_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );_acdg .Data [_efdcg +_gffg ]=_gfbe ;
};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};if _bcaf {for _efcd =0;_efcd < _ccdef ;_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],_gfbe ,_gdcd );
_agcb +=_acdg .BytesPerLine ;_caga +=_adff .BytesPerLine ;};};case PixNotSrc :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );
};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],^_gfbe ,_cggf );_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );
_acdg .Data [_efdcg +_gffg ]=^_gfbe ;};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};if _bcaf {for _efcd =0;_efcd < _ccdef ;_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );
};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],^_gfbe ,_gdcd );_agcb +=_acdg .BytesPerLine ;_caga +=_adff .BytesPerLine ;};};case PixSrcOrDst :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );
};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],_gfbe |_acdg .Data [_egbe ],_cggf );_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;
_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );_acdg .Data [_efdcg +_gffg ]|=_gfbe ;};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};if _bcaf {for _efcd =0;_efcd < _ccdef ;
_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],_gfbe |_acdg .Data [_agcb ],_gdcd );_agcb +=_acdg .BytesPerLine ;_caga +=_adff .BytesPerLine ;
};};case PixSrcAndDst :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],_gfbe &_acdg .Data [_egbe ],_cggf );
_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );_acdg .Data [_efdcg +_gffg ]&=_gfbe ;
};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};if _bcaf {for _efcd =0;_efcd < _ccdef ;_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],_gfbe &_acdg .Data [_agcb ],_gdcd );
_agcb +=_acdg .BytesPerLine ;_caga +=_adff .BytesPerLine ;};};case PixSrcXorDst :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );
};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],_gfbe ^_acdg .Data [_egbe ],_cggf );_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;
_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );_acdg .Data [_efdcg +_gffg ]^=_gfbe ;};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};if _bcaf {for _efcd =0;_efcd < _ccdef ;
_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],_gfbe ^_acdg .Data [_agcb ],_gdcd );_agcb +=_acdg .BytesPerLine ;_caga +=_adff .BytesPerLine ;
};};case PixNotSrcOrDst :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],^_gfbe |_acdg .Data [_egbe ],_cggf );
_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );_acdg .Data [_efdcg +_gffg ]|=^_gfbe ;
};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};if _bcaf {for _efcd =0;_efcd < _ccdef ;_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],^_gfbe |_acdg .Data [_agcb ],_gdcd );
_agcb +=_acdg .BytesPerLine ;_caga +=_adff .BytesPerLine ;};};case PixNotSrcAndDst :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );
};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],^_gfbe &_acdg .Data [_egbe ],_cggf );_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;
_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );_acdg .Data [_efdcg +_gffg ]&=^_gfbe ;};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};if _bcaf {for _efcd =0;_efcd < _ccdef ;
_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],^_gfbe &_acdg .Data [_agcb ],_gdcd );_agcb +=_acdg .BytesPerLine ;_caga +=_adff .BytesPerLine ;
};};case PixSrcOrNotDst :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],_gfbe |^_acdg .Data [_egbe ],_cggf );
_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );_acdg .Data [_efdcg +_gffg ]=_gfbe |^_acdg .Data [_efdcg +_gffg ];
};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};if _bcaf {for _efcd =0;_efcd < _ccdef ;_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],_gfbe |^_acdg .Data [_agcb ],_gdcd );
_agcb +=_acdg .BytesPerLine ;_caga +=_adff .BytesPerLine ;};};case PixSrcAndNotDst :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );
};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],_gfbe &^_acdg .Data [_egbe ],_cggf );_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;
_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );_acdg .Data [_efdcg +_gffg ]=_gfbe &^_acdg .Data [_efdcg +_gffg ];};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};
if _bcaf {for _efcd =0;_efcd < _ccdef ;_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],_gfbe &^_acdg .Data [_agcb ],_gdcd );_agcb +=_acdg .BytesPerLine ;
_caga +=_adff .BytesPerLine ;};};case PixNotPixSrcOrDst :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;
};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],^(_gfbe |_acdg .Data [_egbe ]),_cggf );_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );
_acdg .Data [_efdcg +_gffg ]=^(_gfbe |_acdg .Data [_efdcg +_gffg ]);};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};if _bcaf {for _efcd =0;_efcd < _ccdef ;_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );
};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],^(_gfbe |_acdg .Data [_agcb ]),_gdcd );_agcb +=_acdg .BytesPerLine ;_caga +=_adff .BytesPerLine ;};};case PixNotPixSrcAndDst :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;
if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],^(_gfbe &_acdg .Data [_egbe ]),_cggf );_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;
};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );_acdg .Data [_efdcg +_gffg ]=^(_gfbe &_acdg .Data [_efdcg +_gffg ]);
};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};};if _bcaf {for _efcd =0;_efcd < _ccdef ;_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],^(_gfbe &_acdg .Data [_agcb ]),_gdcd );
_agcb +=_acdg .BytesPerLine ;_caga +=_adff .BytesPerLine ;};};case PixNotPixSrcXorDst :if _afa {for _efcd =0;_efcd < _ccdef ;_efcd ++{if _dbgcf ==_gggge {_gfbe =_adff .Data [_dbgd ]<<_ccff ;if _eagg {_gfbe =_cbcc (_gfbe ,_adff .Data [_dbgd +1]>>_aefa ,_cface );
};}else {_gfbe =_adff .Data [_dbgd ]>>_aefa ;};_acdg .Data [_egbe ]=_cbcc (_acdg .Data [_egbe ],^(_gfbe ^_acdg .Data [_egbe ]),_cggf );_egbe +=_acdg .BytesPerLine ;_dbgd +=_adff .BytesPerLine ;};};if _abde {for _efcd =0;_efcd < _ccdef ;_efcd ++{for _gffg =0;
_gffg < _ebee ;_gffg ++{_gfbe =_cbcc (_adff .Data [_daae +_gffg ]<<_ccff ,_adff .Data [_daae +_gffg +1]>>_aefa ,_cface );_acdg .Data [_efdcg +_gffg ]=^(_gfbe ^_acdg .Data [_efdcg +_gffg ]);};_efdcg +=_acdg .BytesPerLine ;_daae +=_adff .BytesPerLine ;};
};if _bcaf {for _efcd =0;_efcd < _ccdef ;_efcd ++{_gfbe =_adff .Data [_caga ]<<_ccff ;if _fcc {_gfbe =_cbcc (_gfbe ,_adff .Data [_caga +1]>>_aefa ,_cface );};_acdg .Data [_agcb ]=_cbcc (_acdg .Data [_agcb ],^(_gfbe ^_acdg .Data [_agcb ]),_gdcd );_agcb +=_acdg .BytesPerLine ;
_caga +=_adff .BytesPerLine ;};};default:_b .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_fafb );return _ge .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");
};return nil ;};func (_bdfa *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_bdfa .copy ()}};func (_daed *NRGBA64 )Base ()*ImageBase {return &_daed .ImageBase };func _acef (_dbdeg _a .Color )_a .Color {_aedg :=_a .NRGBAModel .Convert (_dbdeg ).(_a .NRGBA );
return _afec (_aedg );};func (_gacc *Gray4 )At (x ,y int )_a .Color {_bebe ,_ :=_gacc .ColorAt (x ,y );return _bebe };func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA ,error ){_efac :=y *bytesPerLine +x *3/2;
if _efac +1>=len (data ){return _a .NRGBA {},_ceaaf (x ,y );};const (_aeda =0xf;_ccfc =uint8 (0xff););_dbdf :=_ccfc ;if alpha !=nil {_bcega :=y *BytesPerLine (width ,4,1);if _bcega < len (alpha ){if x %2==0{_dbdf =(alpha [_bcega ]>>uint (4))&_aeda ;}else {_dbdf =alpha [_bcega ]&_aeda ;
};_dbdf |=_dbdf <<4;};};var _acfb ,_fbdd ,_bbgb uint8 ;if x *3%2==0{_acfb =(data [_efac ]>>uint (4))&_aeda ;_fbdd =data [_efac ]&_aeda ;_bbgb =(data [_efac +1]>>uint (4))&_aeda ;}else {_acfb =data [_efac ]&_aeda ;_fbdd =(data [_efac +1]>>uint (4))&_aeda ;
_bbgb =data [_efac +1]&_aeda ;};if len (decode )==6{_acfb =uint8 (uint32 (LinearInterpolate (float64 (_acfb ),0,15,decode [0],decode [1]))&0xf);_fbdd =uint8 (uint32 (LinearInterpolate (float64 (_fbdd ),0,15,decode [2],decode [3]))&0xf);_bbgb =uint8 (uint32 (LinearInterpolate (float64 (_bbgb ),0,15,decode [4],decode [5]))&0xf);
};return _a .NRGBA {R :(_acfb <<4)|(_acfb &0xf),G :(_fbdd <<4)|(_fbdd &0xf),B :(_bbgb <<4)|(_bbgb &0xf),A :_dbdf },nil ;};func (_facb *Gray8 )GrayAt (x ,y int )_a .Gray {_aab ,_ :=ColorAtGray8BPC (x ,y ,_facb .BytesPerLine ,_facb .Data ,_facb .Decode );
return _aab ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func _geg (_afg _a .NRGBA )_a .Gray {var _cde _a .NRGBA ;if _afg ==_cde {return _a .Gray {Y :0xff};};_dccf ,_cfg ,_gcba ,_ :=_afg .RGBA ();_ced :=(19595*_dccf +38470*_cfg +7471*_gcba +1<<15)>>24;
return _a .Gray {Y :uint8 (_ced )};};func (_fbef *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_fbef .copy ()}};func _dge (_gadeg _a .NRGBA )_a .CMYK {_gbc ,_gfa ,_abd ,_ :=_gadeg .RGBA ();_dbdg ,_gbcb ,_cdeb ,_ddc :=_a .RGBToCMYK (uint8 (_gbc >>8),uint8 (_gfa >>8),uint8 (_abd >>8));
return _a .CMYK {C :_dbdg ,M :_gbcb ,Y :_cdeb ,K :_ddc };};func (_ddg *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_ddg .copy ()}};func (_dgec *ImageBase )setTwoBytes (_ccaf int ,_ded uint16 )error {if _ccaf +1> len (_dgec .Data )-1{return _ge .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dgec .Data [_ccaf ]=byte ((_ded &0xff00)>>8);_dgec .Data [_ccaf +1]=byte (_ded &0xff);return nil ;};func (_feeg *Monochrome )getBit (_geeb ,_dabf int )uint8 {return _feeg .Data [_geeb +(_dabf >>3)]>>uint (7-(_dabf &7))&1;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_fbdbf :=y *bytesPerLine +x >>2;
if _fbdbf >=len (data ){return _a .Gray {},_ed .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_egec :=data [_fbdbf ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_egec =uint8 (uint32 (LinearInterpolate (float64 (_egec ),0,3.0,decode [0],decode [1]))&3);};return _a .Gray {Y :_egec *85},nil ;};func (_aege *NRGBA16 )Base ()*ImageBase {return &_aege .ImageBase };
func (_ecff *NRGBA64 )NRGBA64At (x ,y int )_a .NRGBA64 {_cebf ,_ :=ColorAtNRGBA64 (x ,y ,_ecff .Width ,_ecff .Data ,_ecff .Alpha ,_ecff .Decode );return _cebf ;};func (_bfgb *Gray8 )Validate ()error {if len (_bfgb .Data )!=_bfgb .Height *_bfgb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _ffbbf (_deff _e .Image ,_faege Image ,_fddea _e .Rectangle ){if _dcfgc ,_aaadc :=_deff .(SMasker );_aaadc &&_dcfgc .HasAlpha (){_faege .(SMasker ).MakeAlpha ();};switch _bgcf :=_deff .(type ){case Gray :_fbdce (_bgcf ,_faege .(RGBA ),_fddea );
case NRGBA :_dbbab (_bgcf ,_faege .(RGBA ),_fddea );case *_e .NYCbCrA :_ccdd (_bgcf ,_faege .(RGBA ),_fddea );case CMYK :_fadf (_bgcf ,_faege .(RGBA ),_fddea );case RGBA :_dgga (_bgcf ,_faege .(RGBA ),_fddea );case nrgba64 :_ecffg (_bgcf ,_faege .(RGBA ),_fddea );
default:_ceff (_deff ,_faege ,_fddea );};};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _ggb (_bcdg _a .NRGBA64 )_a .RGBA {_febb ,_deba ,_ddca ,_ddd :=_bcdg .RGBA ();
return _a .RGBA {R :uint8 (_febb >>8),G :uint8 (_deba >>8),B :uint8 (_ddca >>8),A :uint8 (_ddd >>8)};};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};var _ Image =&NRGBA64 {};
func (_gbged *RGBA32 )ColorModel ()_a .Model {return _a .NRGBAModel };func _cee (_dcb _a .NYCbCrA )_a .RGBA {_ceed ,_cgbb ,_fegd ,_ddfb :=_agb (_dcb ).RGBA ();return _a .RGBA {R :uint8 (_ceed >>8),G :uint8 (_cgbb >>8),B :uint8 (_fegd >>8),A :uint8 (_ddfb >>8)};
};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_ed .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};type Gray4 struct{ImageBase };type Gray interface{GrayAt (_gbacg ,_egf int )_a .Gray ;SetGray (_dbbe ,_ecac int ,_fdbb _a .Gray );};func (_dbda *Gray4 )ColorModel ()_a .Model {return Gray4Model };func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_ecdb :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _ecdb ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_fada :=width *colorComponents *bitsPerComponent ;_efbg :=_ecdb *8;_dgbfa :=8-(_efbg -_fada );_feeb :=_dg .NewReader (data );_dfdf :=_ecdb -1;_fbc :=make ([]byte ,_dfdf );_gaga :=make ([]byte ,height *_ecdb );
_dece :=_dg .NewWriterMSB (_gaga );var _dffb uint64 ;var _egae error ;for _cfagg :=0;_cfagg < height ;_cfagg ++{_ ,_egae =_feeb .Read (_fbc );if _egae !=nil {return nil ,_egae ;};_ ,_egae =_dece .Write (_fbc );if _egae !=nil {return nil ,_egae ;};_dffb ,_egae =_feeb .ReadBits (byte (_dgbfa ));
if _egae !=nil {return nil ,_egae ;};_ ,_egae =_dece .WriteBits (_dffb ,_dgbfa );if _egae !=nil {return nil ,_egae ;};_dece .FinishByte ();};return _gaga ,nil ;};var _ Image =&CMYK32 {};var _ _e .Image =&Monochrome {};var (_agcf =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};
_aefc =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func _dfgg (_bfcd _e .Image )(Image ,error ){if _agea ,_eddb :=_bfcd .(*Gray4 );_eddb {return _agea .Copy (),nil ;};_cgbfd :=_bfcd .Bounds ();_cabc ,_ffdg :=NewImage (_cgbfd .Max .X ,_cgbfd .Max .Y ,4,1,nil ,nil ,nil );
if _ffdg !=nil {return nil ,_ffdg ;};_bdec (_bfcd ,_cabc ,_cgbfd );return _cabc ,nil ;};func _ffae (_dbgg _a .Gray )_a .Gray {_fgf :=_dbgg .Y >>6;_fgf |=_fgf <<2;_dbgg .Y =_fgf |_fgf <<4;return _dbgg ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_bff :=y *bytesPerLine +x ;
if _bff >=len (data ){return _a .Gray {},_ed .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gfdg :=data [_bff ];if len (decode )==2{_gfdg =uint8 (uint32 (LinearInterpolate (float64 (_gfdg ),0,255,decode [0],decode [1]))&0xff);};return _a .Gray {Y :_gfdg },nil ;};func (_efbf *NRGBA64 )Set (x ,y int ,c _a .Color ){_gedb :=(y *_efbf .Width +x )*2;
_egbc :=_gedb *3;if _egbc +5>=len (_efbf .Data ){return ;};_agfb :=_a .NRGBA64Model .Convert (c ).(_a .NRGBA64 );_efbf .setNRGBA64 (_egbc ,_agfb ,_gedb );};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func _gfce (_eccb _e .Image )(Image ,error ){if _eegc ,_eagc :=_eccb .(*NRGBA16 );_eagc {return _eegc .Copy (),nil ;};_efaa :=_eccb .Bounds ();_eaac ,_gaca :=NewImage (_efaa .Max .X ,_efaa .Max .Y ,4,3,nil ,nil ,nil );if _gaca !=nil {return nil ,_gaca ;
};_bebca (_eccb ,_eaac ,_efaa );return _eaac ,nil ;};func (_eafa *NRGBA32 )Base ()*ImageBase {return &_eafa .ImageBase };func (_afbg *NRGBA16 )NRGBAAt (x ,y int )_a .NRGBA {_adgg ,_ :=ColorAtNRGBA16 (x ,y ,_afbg .Width ,_afbg .BytesPerLine ,_afbg .Data ,_afbg .Alpha ,_afbg .Decode );
return _adgg ;};func (_feac *NRGBA64 )setNRGBA64 (_dcaga int ,_egbbe _a .NRGBA64 ,_gbgg int ){_feac .Data [_dcaga ]=uint8 (_egbbe .R >>8);_feac .Data [_dcaga +1]=uint8 (_egbbe .R &0xff);_feac .Data [_dcaga +2]=uint8 (_egbbe .G >>8);_feac .Data [_dcaga +3]=uint8 (_egbbe .G &0xff);
_feac .Data [_dcaga +4]=uint8 (_egbbe .B >>8);_feac .Data [_dcaga +5]=uint8 (_egbbe .B &0xff);if _gbgg +1< len (_feac .Alpha ){_feac .Alpha [_gbgg ]=uint8 (_egbbe .A >>8);_feac .Alpha [_gbgg +1]=uint8 (_egbbe .A &0xff);};};func _cfae (_dgge _a .Color )_a .Color {_gfeb :=_a .GrayModel .Convert (_dgge ).(_a .Gray );
return _cce (_gfeb );};func (_afdb *NRGBA64 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA64 (x ,y ,_afdb .Width ,_afdb .Data ,_afdb .Alpha ,_afdb .Decode );};func _add (_cec _a .CMYK )_a .RGBA {_gadeb ,_cbbc ,_aac :=_a .CMYKToRGB (_cec .C ,_cec .M ,_cec .Y ,_cec .K );
return _a .RGBA {R :_gadeb ,G :_cbbc ,B :_aac ,A :0xff};};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;
PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;
PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);type nrgba64 interface{NRGBA64At (_bffa ,_ebbdf int )_a .NRGBA64 ;SetNRGBA64 (_cgba ,_bgdbd int ,_bggg _a .NRGBA64 );};func ImgToBinary (i _e .Image ,threshold uint8 )*_e .Gray {switch _acdf :=i .(type ){case *_e .Gray :if _gfeff (_acdf ){return _acdf ;
};return _eagcf (_acdf ,threshold );case *_e .Gray16 :return _adbfc (_acdf ,threshold );default:return _adebf (_acdf ,threshold );};};func (_eegb *Gray2 )Validate ()error {if len (_eegb .Data )!=_eegb .Height *_eegb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_gagbd *Gray16 )Set (x ,y int ,c _a .Color ){_fcec :=(y *_gagbd .BytesPerLine /2+x )*2;if _fcec +1>=len (_gagbd .Data ){return ;};_bgad :=_a .Gray16Model .Convert (c ).(_a .Gray16 );_gagbd .Data [_fcec ],_gagbd .Data [_fcec +1]=uint8 (_bgad .Y >>8),uint8 (_bgad .Y &0xff);
};func (_ceb *CMYK32 )SetCMYK (x ,y int ,c _a .CMYK ){_fcdb :=4*(y *_ceb .Width +x );if _fcdb +3>=len (_ceb .Data ){return ;};_ceb .Data [_fcdb ]=c .C ;_ceb .Data [_fcdb +1]=c .M ;_ceb .Data [_fcdb +2]=c .Y ;_ceb .Data [_fcdb +3]=c .K ;};func (_dgdb *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_dgdb .copy ()}};
func (_bbdg *Gray2 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_bbdg .Width ,Y :_bbdg .Height }};};func (_ggab *RGBA32 )At (x ,y int )_a .Color {_ecegg ,_ :=_ggab .ColorAt (x ,y );return _ecegg };func (_aeabc *RGBA32 )Validate ()error {if len (_aeabc .Data )!=3*_aeabc .Width *_aeabc .Height {return _ge .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _bbdfa (_egca _e .Image )(Image ,error ){if _fae ,_ceaa :=_egca .(*Gray16 );_ceaa {return _fae .Copy (),nil ;};_feaa :=_egca .Bounds ();_eabe ,_gacd :=NewImage (_feaa .Max .X ,_feaa .Max .Y ,16,1,nil ,nil ,nil );if _gacd !=nil {return nil ,_gacd ;
};_bdec (_egca ,_eabe ,_feaa );return _eabe ,nil ;};func _gfeff (_aaab *_e .Gray )bool {for _efee :=0;_efee < len (_aaab .Pix );_efee ++{if !_bacf (_aaab .Pix [_efee ]){return false ;};};return true ;};func _dbd (_ccg int )[]uint {var _geff []uint ;_dbb :=_ccg ;
_egg :=_dbb /8;if _egg !=0{for _bad :=0;_bad < _egg ;_bad ++{_geff =append (_geff ,8);};_ddb :=_dbb %8;_dbb =0;if _ddb !=0{_dbb =_ddb ;};};_ggc :=_dbb /4;if _ggc !=0{for _gga :=0;_gga < _ggc ;_gga ++{_geff =append (_geff ,4);};_aca :=_dbb %4;_dbb =0;if _aca !=0{_dbb =_aca ;
};};_ce :=_dbb /2;if _ce !=0{for _ebf :=0;_ebf < _ce ;_ebf ++{_geff =append (_geff ,2);};};return _geff ;};func _ega (_ddf ,_gbd CMYK ,_ccge _e .Rectangle ){for _ecf :=0;_ecf < _ccge .Max .X ;_ecf ++{for _ffe :=0;_ffe < _ccge .Max .Y ;_ffe ++{_gbd .SetCMYK (_ecf ,_ffe ,_ddf .CMYKAt (_ecf ,_ffe ));
};};};func (_abgg *Gray8 )At (x ,y int )_a .Color {_eag ,_ :=_abgg .ColorAt (x ,y );return _eag };type Gray8 struct{ImageBase };func _dbbab (_dbbf NRGBA ,_caae RGBA ,_fgaed _e .Rectangle ){for _ddbg :=0;_ddbg < _fgaed .Max .X ;_ddbg ++{for _eddba :=0;_eddba < _fgaed .Max .Y ;
_eddba ++{_ffeb :=_dbbf .NRGBAAt (_ddbg ,_eddba );_caae .SetRGBA (_ddbg ,_eddba ,_daec (_ffeb ));};};};func _ccbb (_bcecf _e .Image )(Image ,error ){if _dcff ,_gbdb :=_bcecf .(*NRGBA64 );_gbdb {return _dcff .Copy (),nil ;};_gefdc ,_gddd ,_gfgd :=_fgdc (_bcecf ,2);
_egded ,_cgfe :=NewImage (_gefdc .Max .X ,_gefdc .Max .Y ,16,3,nil ,_gfgd ,nil );if _cgfe !=nil {return nil ,_cgfe ;};_dgcg (_bcecf ,_egded ,_gefdc );if len (_gfgd )!=0&&!_gddd {if _edda :=_gaef (_gfgd ,_egded );_edda !=nil {return nil ,_edda ;};};return _egded ,nil ;
};func _gaad (_ffb ,_fa *Monochrome )(_eff error ){_gb :=_fa .BytesPerLine ;_ege :=_ffb .BytesPerLine ;var _gef ,_agcc ,_ca ,_fcd ,_db int ;for _ca =0;_ca < _fa .Height ;_ca ++{_gef =_ca *_gb ;_agcc =8*_ca *_ege ;for _fcd =0;_fcd < _gb ;_fcd ++{if _eff =_ffb .setEightBytes (_agcc +_fcd *8,_eda [_fa .Data [_gef +_fcd ]]);
_eff !=nil {return _eff ;};};for _db =1;_db < 8;_db ++{for _fcd =0;_fcd < _ege ;_fcd ++{if _eff =_ffb .setByte (_agcc +_db *_ege +_fcd ,_ffb .Data [_agcc +_fcd ]);_eff !=nil {return _eff ;};};};};return nil ;};func _dgag (_dcag *Monochrome ,_dcge ,_fddg ,_ceaag ,_fedg int ,_egce RasterOperator ){if _dcge < 0{_ceaag +=_dcge ;
_dcge =0;};_ebbd :=_dcge +_ceaag -_dcag .Width ;if _ebbd > 0{_ceaag -=_ebbd ;};if _fddg < 0{_fedg +=_fddg ;_fddg =0;};_cdc :=_fddg +_fedg -_dcag .Height ;if _cdc > 0{_fedg -=_cdc ;};if _ceaag <=0||_fedg <=0{return ;};if (_dcge &7)==0{_gcda (_dcag ,_dcge ,_fddg ,_ceaag ,_fedg ,_egce );
}else {_cggg (_dcag ,_dcge ,_fddg ,_ceaag ,_fedg ,_egce );};};func (_eaff *Monochrome )At (x ,y int )_a .Color {_addd ,_ :=_eaff .ColorAt (x ,y );return _addd };func _eca (_dga *Monochrome ,_def ,_gad int )(*Monochrome ,error ){if _dga ==nil {return nil ,_ge .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _def <=0||_gad <=0{return nil ,_ge .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _def ==_gad {if _def ==1{return _dga .copy (),nil ;
};if _def ==2||_def ==4||_def ==8{_fga ,_defb :=_ac (_dga ,_def );if _defb !=nil {return nil ,_defb ;};return _fga ,nil ;};};_bab :=_def *_dga .Width ;_gc :=_gad *_dga .Height ;_ccd :=_fd (_bab ,_gc );_eaab :=_ccd .BytesPerLine ;var (_bg ,_ecab ,_agccf ,_afc ,_ecad int ;
_bag byte ;_ecd error ;);for _ecab =0;_ecab < _dga .Height ;_ecab ++{_bg =_gad *_ecab *_eaab ;for _agccf =0;_agccf < _dga .Width ;_agccf ++{if _gcf :=_dga .getBitAt (_agccf ,_ecab );_gcf {_ecad =_def *_agccf ;for _afc =0;_afc < _def ;_afc ++{_ccd .setIndexedBit (_bg *8+_ecad +_afc );
};};};for _afc =1;_afc < _gad ;_afc ++{_cdf :=_bg +_afc *_eaab ;for _gade :=0;_gade < _eaab ;_gade ++{if _bag ,_ecd =_ccd .getByte (_bg +_gade );_ecd !=nil {return nil ,_ecd ;};if _ecd =_ccd .setByte (_cdf +_gade ,_bag );_ecd !=nil {return nil ,_ecd ;};
};};};return _ccd ,nil ;};func (_adfd *RGBA32 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtRGBA32 (x ,y ,_adfd .Width ,_adfd .Data ,_adfd .Alpha ,_adfd .Decode );};var _ Gray =&Gray8 {};func (_cgge *RGBA32 )setRGBA (_bgeb int ,_dcaf _a .RGBA ){_gddg :=3*_bgeb ;
_cgge .Data [_gddg ]=_dcaf .R ;_cgge .Data [_gddg +1]=_dcaf .G ;_cgge .Data [_gddg +2]=_dcaf .B ;if _bgeb < len (_cgge .Alpha ){_cgge .Alpha [_bgeb ]=_dcaf .A ;};};type Gray16 struct{ImageBase };func _ecaf ()(_gcb []byte ){_gcb =make ([]byte ,256);for _fea :=0;
_fea < 256;_fea ++{_ead :=byte (_fea );_gcb [_ead ]=(_ead &0x01)|((_ead &0x04)>>1)|((_ead &0x10)>>2)|((_ead &0x40)>>3)|((_ead &0x02)<<3)|((_ead &0x08)<<2)|((_ead &0x20)<<1)|(_ead &0x80);};return _gcb ;};func (_ebae *ImageBase )Pix ()[]byte {return _ebae .Data };
var _ _e .Image =&Gray16 {};func (_cedea *NRGBA16 )Validate ()error {if len (_cedea .Data )!=3*_cedea .Width *_cedea .Height /2{return _ge .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fcea *Gray16 )Validate ()error {if len (_fcea .Data )!=_fcea .Height *_fcea .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_efcb *NRGBA32 )At (x ,y int )_a .Color {_efbc ,_ :=_efcb .ColorAt (x ,y );return _efbc };var _ Gray =&Gray16 {};
func (_fgbe *NRGBA16 )Set (x ,y int ,c _a .Color ){_bace :=y *_fgbe .BytesPerLine +x *3/2;if _bace +1>=len (_fgbe .Data ){return ;};_ccfg :=NRGBA16Model .Convert (c ).(_a .NRGBA );_fgbe .setNRGBA (x ,y ,_bace ,_ccfg );};type CMYK interface{CMYKAt (_bbe ,_bcd int )_a .CMYK ;
SetCMYK (_gfc ,_gdf int ,_faf _a .CMYK );};func (_ddcgb *Gray4 )setGray (_gaea int ,_efdc int ,_defg _a .Gray ){_ccde :=_efdc *_ddcgb .BytesPerLine ;_eafc :=_ccde +(_gaea >>1);if _eafc >=len (_ddcgb .Data ){return ;};_ecfa :=_defg .Y >>4;_ddcgb .Data [_eafc ]=(_ddcgb .Data [_eafc ]&(^(0xf0>>uint (4*(_gaea &1)))))|(_ecfa <<uint (4-4*(_gaea &1)));
};func (_egeab *Gray16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_egeab .Width ,Y :_egeab .Height }};};func _agb (_dagd _a .NYCbCrA )_a .NRGBA {_fedbg :=int32 (_dagd .Y )*0x10101;_ggfea :=int32 (_dagd .Cb )-128;_bge :=int32 (_dagd .Cr )-128;
_bdad :=_fedbg +91881*_bge ;if uint32 (_bdad )&0xff000000==0{_bdad >>=8;}else {_bdad =^(_bdad >>31)&0xffff;};_eecbe :=_fedbg -22554*_ggfea -46802*_bge ;if uint32 (_eecbe )&0xff000000==0{_eecbe >>=8;}else {_eecbe =^(_eecbe >>31)&0xffff;};_ffd :=_fedbg +116130*_ggfea ;
if uint32 (_ffd )&0xff000000==0{_ffd >>=8;}else {_ffd =^(_ffd >>31)&0xffff;};return _a .NRGBA {R :uint8 (_bdad >>8),G :uint8 (_eecbe >>8),B :uint8 (_ffd >>8),A :_dagd .A };};func _afec (_dgffg _a .NRGBA )_a .NRGBA {_dgffg .R =_dgffg .R >>4|(_dgffg .R >>4)<<4;
_dgffg .G =_dgffg .G >>4|(_dgffg .G >>4)<<4;_dgffg .B =_dgffg .B >>4|(_dgffg .B >>4)<<4;return _dgffg ;};func (_fdf *Gray4 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray4BPC (x ,y ,_fdf .BytesPerLine ,_fdf .Data ,_fdf .Decode );};func _ac (_ga *Monochrome ,_da int )(*Monochrome ,error ){if _ga ==nil {return nil ,_ge .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _da ==1{return _ga .copy (),nil ;};if !IsPowerOf2 (uint (_da )){return nil ,_ed .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_da );
};_aa :=_dbd (_da );return _dd (_ga ,_da ,_aa );};func (_adee *Gray2 )Base ()*ImageBase {return &_adee .ImageBase };var _ _e .Image =&Gray8 {};func _aec (_gda _e .Image )(Image ,error ){if _bfba ,_cfag :=_gda .(*Gray2 );_cfag {return _bfba .Copy (),nil ;
};_bba :=_gda .Bounds ();_bage ,_agd :=NewImage (_bba .Max .X ,_bba .Max .Y ,2,1,nil ,nil ,nil );if _agd !=nil {return nil ,_agd ;};_bdec (_gda ,_bage ,_bba );return _bage ,nil ;};func _ffg (_aggg _a .NRGBA64 )_a .NRGBA {return _a .NRGBA {R :uint8 (_aggg .R >>8),G :uint8 (_aggg .G >>8),B :uint8 (_aggg .B >>8),A :uint8 (_aggg .A >>8)};
};func _gdb (_gfdgc RGBA ,_dbaf Gray ,_bfdd _e .Rectangle ){for _dgf :=0;_dgf < _bfdd .Max .X ;_dgf ++{for _edc :=0;_edc < _bfdd .Max .Y ;_edc ++{_dgea :=_gcbcb (_gfdgc .RGBAAt (_dgf ,_edc ));_dbaf .SetGray (_dgf ,_edc ,_dgea );};};};func (_bbab *Gray16 )GrayAt (x ,y int )_a .Gray {_egc ,_ :=_bbab .ColorAt (x ,y );
return _a .Gray {Y :uint8 (_egc .(_a .Gray16 ).Y >>8)};};func (_eccf *RGBA32 )SetRGBA (x ,y int ,c _a .RGBA ){_ecdf :=y *_eccf .Width +x ;_eead :=3*_ecdf ;if _eead +2>=len (_eccf .Data ){return ;};_eccf .setRGBA (_ecdf ,c );};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _cbcd (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_bebc *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_bebc .copy ()}};func (_efgf *ImageBase )newAlpha (){_faeg :=BytesPerLine (_efgf .Width ,_efgf .BitsPerComponent ,1);_efgf .Alpha =make ([]byte ,_efgf .Height *_faeg );};func (_cged *NRGBA32 )Validate ()error {if len (_cged .Data )!=3*_cged .Width *_cged .Height {return _ge .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gafc *Monochrome )Set (x ,y int ,c _a .Color ){_acab :=y *_gafc .BytesPerLine +x >>3;if _acab > len (_gafc .Data )-1{return ;};_fcgd :=_gafc .ColorModel ().Convert (c ).(_a .Gray );_gafc .setGray (x ,_fcgd ,_acab );};func (_geaa *Monochrome )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray1BPC (x ,y ,_geaa .BytesPerLine ,_geaa .Data ,_geaa .Decode );
};func (_dafc *Gray4 )SetGray (x ,y int ,g _a .Gray ){if x >=_dafc .Width ||y >=_dafc .Height {return ;};g =_cce (g );_dafc .setGray (x ,y ,g );};var _ _e .Image =&NRGBA32 {};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_fdc :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _gbcf Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_gbcf =&Monochrome {ImageBase :_fdc ,ModelThreshold :0x0f};case 2:_gbcf =&Gray2 {ImageBase :_fdc };case 4:_gbcf =&Gray4 {ImageBase :_fdc };case 8:_gbcf =&Gray8 {ImageBase :_fdc };
case 16:_gbcf =&Gray16 {ImageBase :_fdc };};case 3:switch bitsPerComponent {case 4:_gbcf =&NRGBA16 {ImageBase :_fdc };case 8:_gbcf =&NRGBA32 {ImageBase :_fdc };case 16:_gbcf =&NRGBA64 {ImageBase :_fdc };};case 4:_gbcf =&CMYK32 {ImageBase :_fdc };};if _gbcf ==nil {return nil ,ErrInvalidImage ;
};return _gbcf ,nil ;};func (_cgd *Gray2 )SetGray (x ,y int ,gray _a .Gray ){_beea :=_ffae (gray );_fabc :=y *_cgd .BytesPerLine ;_cdbg :=_fabc +(x >>2);if _cdbg >=len (_cgd .Data ){return ;};_fbdb :=_beea .Y >>6;_cgd .Data [_cdbg ]=(_cgd .Data [_cdbg ]&(^(0xc0>>uint (2*((x )&3)))))|(_fbdb <<uint (6-2*(x &3)));
};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_gg :=BytesPerLine (width ,8,1);if len (data )< _gg *height {return nil ,nil ;};_be :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_fg ,_cg :=MonochromeConverter .Convert (_be );
if _cg !=nil {return nil ,_cg ;};return _fg .Base ().Data ,nil ;};func _ddaf (_eafg int ,_fcgdf int )int {if _eafg < _fcgdf {return _eafg ;};return _fcgdf ;};func (_dega *Gray16 )ColorModel ()_a .Model {return _a .Gray16Model };func (_dcbg *NRGBA32 )Set (x ,y int ,c _a .Color ){_afeb :=y *_dcbg .Width +x ;
_dac :=3*_afeb ;if _dac +2>=len (_dcbg .Data ){return ;};_gdfec :=_a .NRGBAModel .Convert (c ).(_a .NRGBA );_dcbg .setRGBA (_afeb ,_gdfec );};func (_adgd *ImageBase )copy ()ImageBase {_gdce :=*_adgd ;_gdce .Data =make ([]byte ,len (_adgd .Data ));copy (_gdce .Data ,_adgd .Data );
return _gdce ;};var _ _e .Image =&Gray4 {};type colorConverter struct{_edeg func (_effg _e .Image )(Image ,error );};var (_df =_cac ();_ace =_eea ();_eda =_dcd (););func (_fceb *Gray16 )Base ()*ImageBase {return &_fceb .ImageBase };func _gcbcb (_fedb _a .RGBA )_a .Gray {_dda :=(19595*uint32 (_fedb .R )+38470*uint32 (_fedb .G )+7471*uint32 (_fedb .B )+1<<7)>>16;
return _a .Gray {Y :uint8 (_dda )};};type NRGBA32 struct{ImageBase };func (_faae *Gray4 )Histogram ()(_cbce [256]int ){for _ccga :=0;_ccga < _faae .Width ;_ccga ++{for _cbbb :=0;_cbbb < _faae .Height ;_cbbb ++{_cbce [_faae .GrayAt (_ccga ,_cbbb ).Y ]++;
};};return _cbce ;};func (_cebe *Monochrome )Validate ()error {if len (_cebe .Data )!=_cebe .Height *_cebe .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_dffg *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_dffg .ImageBase .copy (),ModelThreshold :_dffg .ModelThreshold };
};func (_aaf *CMYK32 )Set (x ,y int ,c _a .Color ){_bgd :=4*(y *_aaf .Width +x );if _bgd +3>=len (_aaf .Data ){return ;};_eeea :=_a .CMYKModel .Convert (c ).(_a .CMYK );_aaf .Data [_bgd ]=_eeea .C ;_aaf .Data [_bgd +1]=_eeea .M ;_aaf .Data [_bgd +2]=_eeea .Y ;
_aaf .Data [_bgd +3]=_eeea .K ;};func (_acag *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_aebg :=_bbbf (uint (factor ));if !IsPowerOf2 (uint (factor )){_aebg ++;};_cded :=make ([]int ,_aebg );for _fcdc :=range _cded {_cded [_fcdc ]=4;
};_ecbe ,_fcfb :=_dae (_acag ,_cded ...);if _fcfb !=nil {return nil ,_fcfb ;};return _ecbe ,nil ;};func (_bgc *Monochrome )ColorModel ()_a .Model {return MonochromeModel (_bgc .ModelThreshold )};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray16 ,error ){_gaed :=(y *bytesPerLine /2+x )*2;
if _gaed +1>=len (data ){return _a .Gray16 {},_ed .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fbea :=uint16 (data [_gaed ])<<8|uint16 (data [_gaed +1]);if len (decode )==2{_fbea =uint16 (uint64 (LinearInterpolate (float64 (_fbea ),0,65535,decode [0],decode [1])));};return _a .Gray16 {Y :_fbea },nil ;};func _dcd ()(_dag [256]uint64 ){for _fcg :=0;
_fcg < 256;_fcg ++{if _fcg &0x01!=0{_dag [_fcg ]|=0xff;};if _fcg &0x02!=0{_dag [_fcg ]|=0xff00;};if _fcg &0x04!=0{_dag [_fcg ]|=0xff0000;};if _fcg &0x08!=0{_dag [_fcg ]|=0xff000000;};if _fcg &0x10!=0{_dag [_fcg ]|=0xff00000000;};if _fcg &0x20!=0{_dag [_fcg ]|=0xff0000000000;
};if _fcg &0x40!=0{_dag [_fcg ]|=0xff000000000000;};if _fcg &0x80!=0{_dag [_fcg ]|=0xff00000000000000;};};return _dag ;};func (_eadb *Monochrome )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_eadb .Width ,Y :_eadb .Height }};};func (_defa *Gray8 )Histogram ()(_bgcd [256]int ){for _cdbe :=0;
_cdbe < len (_defa .Data );_cdbe ++{_bgcd [_defa .Data [_cdbe ]]++;};return _bgcd ;};var _ _e .Image =&NRGBA16 {};func (_cff *NRGBA32 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA32 (x ,y ,_cff .Width ,_cff .Data ,_cff .Alpha ,_cff .Decode );
};func _bebb (_dbgcd *Monochrome ,_aeea ,_geffc int ,_edfg ,_adae int ,_gdd RasterOperator ,_ggcc *Monochrome ,_cagde ,_cgea int )error {var _bcba ,_fgfa ,_bbfg ,_agbf int ;if _aeea < 0{_cagde -=_aeea ;_edfg +=_aeea ;_aeea =0;};if _cagde < 0{_aeea -=_cagde ;
_edfg +=_cagde ;_cagde =0;};_bcba =_aeea +_edfg -_dbgcd .Width ;if _bcba > 0{_edfg -=_bcba ;};_fgfa =_cagde +_edfg -_ggcc .Width ;if _fgfa > 0{_edfg -=_fgfa ;};if _geffc < 0{_cgea -=_geffc ;_adae +=_geffc ;_geffc =0;};if _cgea < 0{_geffc -=_cgea ;_adae +=_cgea ;
_cgea =0;};_bbfg =_geffc +_adae -_dbgcd .Height ;if _bbfg > 0{_adae -=_bbfg ;};_agbf =_cgea +_adae -_ggcc .Height ;if _agbf > 0{_adae -=_agbf ;};if _edfg <=0||_adae <=0{return nil ;};var _cegbg error ;switch {case _aeea &7==0&&_cagde &7==0:_cegbg =_aeef (_dbgcd ,_aeea ,_geffc ,_edfg ,_adae ,_gdd ,_ggcc ,_cagde ,_cgea );
case _aeea &7==_cagde &7:_cegbg =_agee (_dbgcd ,_aeea ,_geffc ,_edfg ,_adae ,_gdd ,_ggcc ,_cagde ,_cgea );default:_cegbg =_cfdb (_dbgcd ,_aeea ,_geffc ,_edfg ,_adae ,_gdd ,_ggcc ,_cagde ,_cgea );};if _cegbg !=nil {return _cegbg ;};return nil ;};func (_dfe *RGBA32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_dfe .Width ,Y :_dfe .Height }};
};func (_fafe *Gray2 )Histogram ()(_acfd [256]int ){for _gfef :=0;_gfef < _fafe .Width ;_gfef ++{for _ffgb :=0;_ffgb < _fafe .Height ;_ffgb ++{_acfd [_fafe .GrayAt (_gfef ,_ffgb ).Y ]++;};};return _acfd ;};func (_gbge *NRGBA64 )At (x ,y int )_a .Color {_egaa ,_ :=_gbge .ColorAt (x ,y );
return _egaa };func _cac ()(_fgd [256]uint16 ){for _feb :=0;_feb < 256;_feb ++{if _feb &0x01!=0{_fgd [_feb ]|=0x3;};if _feb &0x02!=0{_fgd [_feb ]|=0xc;};if _feb &0x04!=0{_fgd [_feb ]|=0x30;};if _feb &0x08!=0{_fgd [_feb ]|=0xc0;};if _feb &0x10!=0{_fgd [_feb ]|=0x300;
};if _feb &0x20!=0{_fgd [_feb ]|=0xc00;};if _feb &0x40!=0{_fgd [_feb ]|=0x3000;};if _feb &0x80!=0{_fgd [_feb ]|=0xc000;};};return _fgd ;};func _dadfd (_acgf _a .Gray ,_gagg monochromeModel )_a .Gray {if _acgf .Y > uint8 (_gagg ){return _a .Gray {Y :_c .MaxUint8 };
};return _a .Gray {};};func InDelta (expected ,current ,delta float64 )bool {_dfce :=expected -current ;if _dfce <=-delta ||_dfce >=delta {return false ;};return true ;};func MonochromeModel (threshold uint8 )_a .Model {return monochromeModel (threshold )};
func (_fccd *NRGBA16 )SetNRGBA (x ,y int ,c _a .NRGBA ){_aaef :=y *_fccd .BytesPerLine +x *3/2;if _aaef +1>=len (_fccd .Data ){return ;};c =_afec (c );_fccd .setNRGBA (x ,y ,_aaef ,c );};func _ceaaf (_cgcg int ,_abb int )error {return _ed .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_cgcg ,_abb );
};func (_daff *Gray4 )Validate ()error {if len (_daff .Data )!=_daff .Height *_daff .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _eb (_ec ,_bf *Monochrome )(_ea error ){_bd :=_bf .BytesPerLine ;_de :=_ec .BytesPerLine ;var (_ef byte ;_cd uint16 ;
_eaa ,_gec ,_dcf ,_egd ,_gaf int ;);for _dcf =0;_dcf < _bf .Height ;_dcf ++{_eaa =_dcf *_bd ;_gec =2*_dcf *_de ;for _egd =0;_egd < _bd ;_egd ++{_ef =_bf .Data [_eaa +_egd ];_cd =_df [_ef ];_gaf =_gec +_egd *2;if _ec .BytesPerLine !=_bf .BytesPerLine *2&&(_egd +1)*2> _ec .BytesPerLine {_ea =_ec .setByte (_gaf ,byte (_cd >>8));
}else {_ea =_ec .setTwoBytes (_gaf ,_cd );};if _ea !=nil {return _ea ;};};for _egd =0;_egd < _de ;_egd ++{_gaf =_gec +_de +_egd ;_ef =_ec .Data [_gec +_egd ];if _ea =_ec .setByte (_gaf ,_ef );_ea !=nil {return _ea ;};};};return nil ;};func _aeef (_deea *Monochrome ,_afgc ,_befb ,_feag ,_fbceg int ,_cfac RasterOperator ,_bdbf *Monochrome ,_adab ,_fbdc int )error {var (_efcf byte ;
_aeag int ;_bdba int ;_fgde ,_edeb int ;_fcge ,_geab int ;);_gggg :=_feag >>3;_dbed :=_feag &7;if _dbed > 0{_efcf =_agcf [_dbed ];};_aeag =_bdbf .BytesPerLine *_fbdc +(_adab >>3);_bdba =_deea .BytesPerLine *_befb +(_afgc >>3);switch _cfac {case PixSrc :for _fcge =0;
_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]=_bdbf .Data [_fgde ];_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],_bdbf .Data [_fgde ],_efcf );
};};case PixNotSrc :for _fcge =0;_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]=^(_bdbf .Data [_fgde ]);_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],^_bdbf .Data [_fgde ],_efcf );
};};case PixSrcOrDst :for _fcge =0;_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]|=_bdbf .Data [_fgde ];_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],_bdbf .Data [_fgde ]|_deea .Data [_edeb ],_efcf );
};};case PixSrcAndDst :for _fcge =0;_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]&=_bdbf .Data [_fgde ];_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],_bdbf .Data [_fgde ]&_deea .Data [_edeb ],_efcf );
};};case PixSrcXorDst :for _fcge =0;_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]^=_bdbf .Data [_fgde ];_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],_bdbf .Data [_fgde ]^_deea .Data [_edeb ],_efcf );
};};case PixNotSrcOrDst :for _fcge =0;_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]|=^(_bdbf .Data [_fgde ]);_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],^(_bdbf .Data [_fgde ])|_deea .Data [_edeb ],_efcf );
};};case PixNotSrcAndDst :for _fcge =0;_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]&=^(_bdbf .Data [_fgde ]);_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],^(_bdbf .Data [_fgde ])&_deea .Data [_edeb ],_efcf );
};};case PixSrcOrNotDst :for _fcge =0;_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]=_bdbf .Data [_fgde ]|^(_deea .Data [_edeb ]);_edeb ++;
_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],_bdbf .Data [_fgde ]|^(_deea .Data [_edeb ]),_efcf );};};case PixSrcAndNotDst :for _fcge =0;_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;
for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]=_bdbf .Data [_fgde ]&^(_deea .Data [_edeb ]);_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],_bdbf .Data [_fgde ]&^(_deea .Data [_edeb ]),_efcf );};};case PixNotPixSrcOrDst :for _fcge =0;
_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]=^(_bdbf .Data [_fgde ]|_deea .Data [_edeb ]);_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],^(_bdbf .Data [_fgde ]|_deea .Data [_edeb ]),_efcf );
};};case PixNotPixSrcAndDst :for _fcge =0;_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]=^(_bdbf .Data [_fgde ]&_deea .Data [_edeb ]);
_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],^(_bdbf .Data [_fgde ]&_deea .Data [_edeb ]),_efcf );};};case PixNotPixSrcXorDst :for _fcge =0;_fcge < _fbceg ;_fcge ++{_fgde =_aeag +_fcge *_bdbf .BytesPerLine ;_edeb =_bdba +_fcge *_deea .BytesPerLine ;
for _geab =0;_geab < _gggg ;_geab ++{_deea .Data [_edeb ]=^(_bdbf .Data [_fgde ]^_deea .Data [_edeb ]);_edeb ++;_fgde ++;};if _dbed > 0{_deea .Data [_edeb ]=_cbcc (_deea .Data [_edeb ],^(_bdbf .Data [_fgde ]^_deea .Data [_edeb ]),_efcf );};};default:_b .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_cfac );
return _ge .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_ggde *Gray2 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray2BPC (x ,y ,_ggde .BytesPerLine ,_ggde .Data ,_ggde .Decode );
};var _ Image =&Gray16 {};func (_begg *ImageBase )setByte (_baed int ,_dfga byte )error {if _baed > len (_begg .Data )-1{return _ge .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_begg .Data [_baed ]=_dfga ;
return nil ;};func (_gbfc *RGBA32 )Set (x ,y int ,c _a .Color ){_dedf :=y *_gbfc .Width +x ;_bcc :=3*_dedf ;if _bcc +2>=len (_gbfc .Data ){return ;};_fgce :=_a .RGBAModel .Convert (c ).(_a .RGBA );_gbfc .setRGBA (_dedf ,_fgce );};var (MonochromeConverter =ConverterFunc (_eebfc );
Gray2Converter =ConverterFunc (_aec );Gray4Converter =ConverterFunc (_dfgg );GrayConverter =ConverterFunc (_bbba );Gray16Converter =ConverterFunc (_bbdfa );NRGBA16Converter =ConverterFunc (_gfce );NRGBAConverter =ConverterFunc (_dcfd );NRGBA64Converter =ConverterFunc (_ccbb );
RGBAConverter =ConverterFunc (_aceg );CMYKConverter =ConverterFunc (_fbe ););func _gbde (_daf _a .RGBA )_a .CMYK {_gfee ,_ebb ,_gfb ,_aga :=_a .RGBToCMYK (_daf .R ,_daf .G ,_daf .B );return _a .CMYK {C :_gfee ,M :_ebb ,Y :_gfb ,K :_aga };};var _ Gray =&Gray4 {};
func (_eeff *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_eeff .copy ()}};func (_cfc *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_ed .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _ac (_cfc ,factor );};type monochromeThresholdConverter struct{Threshold uint8 ;};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_a .RGBA ,error ){_eadg :=y *width +x ;_ffaf :=3*_eadg ;if _ffaf +2>=len (data ){return _a .RGBA {},_ed .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ddge :=uint8 (0xff);if alpha !=nil &&len (alpha )> _eadg {_ddge =alpha [_eadg ];};_adc ,_adaef ,_addc :=data [_ffaf ],data [_ffaf +1],data [_ffaf +2];if len (decode )==6{_adc =uint8 (uint32 (LinearInterpolate (float64 (_adc ),0,255,decode [0],decode [1]))&0xff);
_adaef =uint8 (uint32 (LinearInterpolate (float64 (_adaef ),0,255,decode [2],decode [3]))&0xff);_addc =uint8 (uint32 (LinearInterpolate (float64 (_addc ),0,255,decode [4],decode [5]))&0xff);};return _a .RGBA {R :_adc ,G :_adaef ,B :_addc ,A :_ddge },nil ;
};func (_acaab *NRGBA32 )SetNRGBA (x ,y int ,c _a .NRGBA ){_dgeae :=y *_acaab .Width +x ;_bfcg :=3*_dgeae ;if _bfcg +2>=len (_acaab .Data ){return ;};_acaab .setRGBA (_dgeae ,c );};func _dcfd (_cecb _e .Image )(Image ,error ){if _fbde ,_ceca :=_cecb .(*NRGBA32 );
_ceca {return _fbde .Copy (),nil ;};_fdg ,_dffeg ,_bfce :=_fgdc (_cecb ,1);_faage ,_cdee :=NewImage (_fdg .Max .X ,_fdg .Max .Y ,8,3,nil ,_bfce ,nil );if _cdee !=nil {return nil ,_cdee ;};_bebca (_cecb ,_faage ,_fdg );if len (_bfce )!=0&&!_dffeg {if _agaf :=_gaef (_bfce ,_faage );
_agaf !=nil {return nil ,_agaf ;};};return _faage ,nil ;};type NRGBA interface{NRGBAAt (_adbc ,_baafg int )_a .NRGBA ;SetNRGBA (_bcec ,_bbee int ,_eefc _a .NRGBA );};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _fcb (_bae _a .Gray )_a .RGBA {return _a .RGBA {R :_bae .Y ,G :_bae .Y ,B :_bae .Y ,A :0xff}};
func _cgg (_eceg NRGBA ,_bdc CMYK ,_fad _e .Rectangle ){for _aaee :=0;_aaee < _fad .Max .X ;_aaee ++{for _fffd :=0;_fffd < _fad .Max .Y ;_fffd ++{_beda :=_eceg .NRGBAAt (_aaee ,_fffd );_bdc .SetCMYK (_aaee ,_fffd ,_dge (_beda ));};};};func GrayHistogram (g Gray )(_gagd [256]int ){switch _abag :=g .(type ){case Histogramer :return _abag .Histogram ();
case _e .Image :_adeea :=_abag .Bounds ();for _bdg :=0;_bdg < _adeea .Max .X ;_bdg ++{for _gbfba :=0;_gbfba < _adeea .Max .Y ;_gbfba ++{_gagd [g .GrayAt (_bdg ,_gbfba ).Y ]++;};};return _gagd ;default:return [256]int {};};};func _dgga (_egdba ,_gfge RGBA ,_efdf _e .Rectangle ){for _bfbg :=0;
_bfbg < _efdf .Max .X ;_bfbg ++{for _egcea :=0;_egcea < _efdf .Max .Y ;_egcea ++{_gfge .SetRGBA (_bfbg ,_egcea ,_egdba .RGBAAt (_bfbg ,_egcea ));};};};func (_fegc *Gray8 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray8BPC (x ,y ,_fegc .BytesPerLine ,_fegc .Data ,_fegc .Decode );
};func _bdec (_cddg _e .Image ,_egdf Image ,_abeg _e .Rectangle ){switch _cfde :=_cddg .(type ){case Gray :_fbaa (_cfde ,_egdf .(Gray ),_abeg );case NRGBA :_badc (_cfde ,_egdf .(Gray ),_abeg );case CMYK :_dgeag (_cfde ,_egdf .(Gray ),_abeg );case RGBA :_gdb (_cfde ,_egdf .(Gray ),_abeg );
default:_ceff (_cddg ,_egdf ,_abeg );};};func (_cdfd *Monochrome )clearBit (_eba ,_bee int ){_cdfd .Data [_eba ]&=^(0x80>>uint (_bee &7))};func (_gdc *Gray8 )Base ()*ImageBase {return &_gdc .ImageBase };func (_cfe *ImageBase )MakeAlpha (){_cfe .newAlpha ()};
func _bbbf (_gcca uint )uint {var _aggf uint ;for _gcca !=0{_gcca >>=1;_aggf ++;};return _aggf -1;};func _dgcg (_afddd _e .Image ,_egcc Image ,_dcgf _e .Rectangle ){if _daefg ,_eddf :=_afddd .(SMasker );_eddf &&_daefg .HasAlpha (){_egcc .(SMasker ).MakeAlpha ();
};_ceff (_afddd ,_egcc ,_dcgf );};var _ NRGBA =&NRGBA32 {};func (_bdebd *Monochrome )setBit (_dbae ,_ebg int ){_bdebd .Data [_dbae +(_ebg >>3)]|=0x80>>uint (_ebg &7);};func _fd (_dgc ,_ffbg int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_dgc ,_ffbg ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func _adebf (_edca _e .Image ,_afgd uint8 )*_e .Gray {_acac :=_edca .Bounds ();_bece :=_e .NewGray (_acac );var (_gcag _a .Color ;_dfge _a .Gray ;);for _aebgc :=0;_aebgc < _acac .Max .X ;_aebgc ++{for _bdce :=0;_bdce < _acac .Max .Y ;_bdce ++{_gcag =_edca .At (_aebgc ,_bdce );
_bece .Set (_aebgc ,_bdce ,_gcag );_dfge =_bece .GrayAt (_aebgc ,_bdce );_bece .SetGray (_aebgc ,_bdce ,_a .Gray {Y :_bagd (_dfge .Y ,_afgd )});};};return _bece ;};func (_gbbf *Gray16 )SetGray (x ,y int ,g _a .Gray ){_gega :=(y *_gbbf .BytesPerLine /2+x )*2;
if _gega +1>=len (_gbbf .Data ){return ;};_gbbf .Data [_gega ]=g .Y ;_gbbf .Data [_gega +1]=g .Y ;};func (_eafgd *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _cbcd (_eafgd ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_cab *Monochrome )setGray (_ffdb int ,_gbf _a .Gray ,_fcfe int ){if _gbf .Y ==0{_cab .clearBit (_fcfe ,_ffdb );}else {_cab .setGrayBit (_fcfe ,_ffdb );};};func (_aeac *Gray4 )Base ()*ImageBase {return &_aeac .ImageBase };func _af (_ae ,_fge *Monochrome )(_ba error ){_cc :=_fge .BytesPerLine ;
_cge :=_ae .BytesPerLine ;_ag :=_fge .BytesPerLine *4-_ae .BytesPerLine ;var (_agc ,_bde byte ;_cb uint32 ;_gaa ,_fb ,_fc ,_dad ,_acf ,_ee ,_efg int ;);for _fc =0;_fc < _fge .Height ;_fc ++{_gaa =_fc *_cc ;_fb =4*_fc *_cge ;for _dad =0;_dad < _cc ;_dad ++{_agc =_fge .Data [_gaa +_dad ];
_cb =_ace [_agc ];_ee =_fb +_dad *4;if _ag !=0&&(_dad +1)*4> _ae .BytesPerLine {for _acf =_ag ;_acf > 0;_acf --{_bde =byte ((_cb >>uint (_acf *8))&0xff);_efg =_ee +(_ag -_acf );if _ba =_ae .setByte (_efg ,_bde );_ba !=nil {return _ba ;};};}else if _ba =_ae .setFourBytes (_ee ,_cb );
_ba !=nil {return _ba ;};if _ba =_ae .setFourBytes (_fb +_dad *4,_ace [_fge .Data [_gaa +_dad ]]);_ba !=nil {return _ba ;};};for _acf =1;_acf < 4;_acf ++{for _dad =0;_dad < _cge ;_dad ++{if _ba =_ae .setByte (_fb +_acf *_cge +_dad ,_ae .Data [_fb +_dad ]);
_ba !=nil {return _ba ;};};};};return nil ;};func (_bfed *Gray16 )Histogram ()(_abgd [256]int ){for _ecbf :=0;_ecbf < _bfed .Width ;_ecbf ++{for _afge :=0;_afge < _bfed .Height ;_afge ++{_abgd [_bfed .GrayAt (_ecbf ,_afge ).Y ]++;};};return _abgd ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA ,error ){_aggb :=y *width +x ;
_bbeeb :=3*_aggb ;if _bbeeb +2>=len (data ){return _a .NRGBA {},_ed .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gdfd :=uint8 (0xff);if alpha !=nil &&len (alpha )> _aggb {_gdfd =alpha [_aggb ];};_dgacd ,_aagc ,_ddea :=data [_bbeeb ],data [_bbeeb +1],data [_bbeeb +2];if len (decode )==6{_dgacd =uint8 (uint32 (LinearInterpolate (float64 (_dgacd ),0,255,decode [0],decode [1]))&0xff);
_aagc =uint8 (uint32 (LinearInterpolate (float64 (_aagc ),0,255,decode [2],decode [3]))&0xff);_ddea =uint8 (uint32 (LinearInterpolate (float64 (_ddea ),0,255,decode [4],decode [5]))&0xff);};return _a .NRGBA {R :_dgacd ,G :_aagc ,B :_ddea ,A :_gdfd },nil ;
};func _fbe (_cdbf _e .Image )(Image ,error ){if _dcc ,_dgac :=_cdbf .(*CMYK32 );_dgac {return _dcc .Copy (),nil ;};_cgef :=_cdbf .Bounds ();_ede ,_dba :=NewImage (_cgef .Max .X ,_cgef .Max .Y ,8,4,nil ,nil ,nil );if _dba !=nil {return nil ,_dba ;};switch _baf :=_cdbf .(type ){case CMYK :_ega (_baf ,_ede .(CMYK ),_cgef );
case Gray :_dbf (_baf ,_ede .(CMYK ),_cgef );case NRGBA :_cgg (_baf ,_ede .(CMYK ),_cgef );case RGBA :_ecfb (_baf ,_ede .(CMYK ),_cgef );default:_ceff (_cdbf ,_ede ,_cgef );};return _ede ,nil ;};func (_ccaa *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _gac bool ;
_eeaf :=scale ;if scale < 1{_eeaf =1/scale ;_gac =true ;};_bbb :=NextPowerOf2 (uint (_eeaf ));if InDelta (float64 (_bbb ),_eeaf ,0.001){if _gac {return _ccaa .ReduceBinary (_eeaf );};return _ccaa .ExpandBinary (int (_bbb ));};_adf :=int (_c .RoundToEven (float64 (_ccaa .Width )*scale ));
_aagg :=int (_c .RoundToEven (float64 (_ccaa .Height )*scale ));return _ccaa .ScaleLow (_adf ,_aagg );};func (_dbbba *NRGBA64 )Validate ()error {if len (_dbbba .Data )!=3*2*_dbbba .Width *_dbbba .Height {return _ge .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func (_fbec *NRGBA32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_fbec .Width ,Y :_fbec .Height }};};var _ NRGBA =&NRGBA16 {};func (_ceaad *NRGBA32 )NRGBAAt (x ,y int )_a .NRGBA {_beec ,_ :=ColorAtNRGBA32 (x ,y ,_ceaad .Width ,_ceaad .Data ,_ceaad .Alpha ,_ceaad .Decode );
return _beec ;};func (_adaa *Monochrome )SetGray (x ,y int ,g _a .Gray ){_ffbgd :=y *_adaa .BytesPerLine +x >>3;if _ffbgd > len (_adaa .Data )-1{return ;};g =_dadfd (g ,monochromeModel (_adaa .ModelThreshold ));_adaa .setGray (x ,g ,_ffbgd );};func _badc (_bfdc NRGBA ,_ebeg Gray ,_efb _e .Rectangle ){for _daba :=0;
_daba < _efb .Max .X ;_daba ++{for _gfdag :=0;_gfdag < _efb .Max .Y ;_gfdag ++{_eggc :=_ecabf (_bfdc .NRGBAAt (_daba ,_gfdag ));_ebeg .SetGray (_daba ,_gfdag ,_eggc );};};};func _eee (_eeb *Monochrome ,_deb int ,_aeg []byte )(_bef *Monochrome ,_gae error ){const _gcc ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _eeb ==nil {return nil ,_ge .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _deb < 1||_deb > 4{return nil ,_ge .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _eeb .Height <=1{return nil ,_ge .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_bef =_fd (_eeb .Width /2,_eeb .Height /2);
if _aeg ==nil {_aeg =_ecaf ();};_bc :=_ddaf (_eeb .BytesPerLine ,2*_bef .BytesPerLine );switch _deb {case 1:_gae =_dca (_eeb ,_bef ,_aeg ,_bc );case 2:_gae =_cgf (_eeb ,_bef ,_aeg ,_bc );case 3:_gae =_baa (_eeb ,_bef ,_aeg ,_bc );case 4:_gae =_ggad (_eeb ,_bef ,_aeg ,_bc );
};if _gae !=nil {return nil ,_gae ;};return _bef ,nil ;};func _dfc (_cbd _a .RGBA )_a .NRGBA {switch _cbd .A {case 0xff:return _a .NRGBA {R :_cbd .R ,G :_cbd .G ,B :_cbd .B ,A :0xff};case 0x00:return _a .NRGBA {};default:_geb ,_ccdb ,_bac ,_dcg :=_cbd .RGBA ();
_geb =(_geb *0xffff)/_dcg ;_ccdb =(_ccdb *0xffff)/_dcg ;_bac =(_bac *0xffff)/_dcg ;return _a .NRGBA {R :uint8 (_geb >>8),G :uint8 (_ccdb >>8),B :uint8 (_bac >>8),A :uint8 (_dcg >>8)};};};func _daec (_dff _a .NRGBA )_a .RGBA {_eebf ,_bgg ,_aad ,_cgbf :=_dff .RGBA ();
return _a .RGBA {R :uint8 (_eebf >>8),G :uint8 (_bgg >>8),B :uint8 (_aad >>8),A :uint8 (_cgbf >>8)};};func _daag (_bbaa CMYK ,_agbe NRGBA ,_fag _e .Rectangle ){for _egced :=0;_egced < _fag .Max .X ;_egced ++{for _gdgb :=0;_gdgb < _fag .Max .Y ;_gdgb ++{_gfff :=_bbaa .CMYKAt (_egced ,_gdgb );
_agbe .SetNRGBA (_egced ,_gdgb ,_ecde (_gfff ));};};};var _ Gray =&Gray2 {};var _ Image =&NRGBA16 {};func _cdae (_bdb _a .CMYK )_a .Gray {_ccgf ,_cbf ,_beb :=_a .CMYKToRGB (_bdb .C ,_bdb .M ,_bdb .Y ,_bdb .K );_fbd :=(19595*uint32 (_ccgf )+38470*uint32 (_cbf )+7471*uint32 (_beb )+1<<7)>>16;
return _a .Gray {Y :uint8 (_fbd )};};func _dbf (_dadc Gray ,_eded CMYK ,_ggfe _e .Rectangle ){for _eecb :=0;_eecb < _ggfe .Max .X ;_eecb ++{for _fee :=0;_fee < _ggfe .Max .Y ;_fee ++{_eafb :=_dadc .GrayAt (_eecb ,_fee );_eded .SetCMYK (_eecb ,_fee ,_cace (_eafb ));
};};};type Gray2 struct{ImageBase };func (_gbad *NRGBA16 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA16 (x ,y ,_gbad .Width ,_gbad .BytesPerLine ,_gbad .Data ,_gbad .Alpha ,_gbad .Decode );};func (_fgdg *Gray2 )ColorModel ()_a .Model {return Gray2Model };
func (_cagf *ImageBase )setEightPartlyBytes (_gbe ,_ddbe int ,_bdd uint64 )(_aggd error ){var (_gcbe byte ;_gbfe int ;);for _daffa :=1;_daffa <=_ddbe ;_daffa ++{_gbfe =64-_daffa *8;_gcbe =byte (_bdd >>uint (_gbfe )&0xff);if _aggd =_cagf .setByte (_gbe +_daffa -1,_gcbe );
_aggd !=nil {return _aggd ;};};_bgf :=_cagf .BytesPerLine *8-_cagf .Width ;if _bgf ==0{return nil ;};_gbfe -=8;_gcbe =byte (_bdd >>uint (_gbfe )&0xff)<<uint (_bgf );if _aggd =_cagf .setByte (_gbe +_ddbe ,_gcbe );_aggd !=nil {return _aggd ;};return nil ;
};var _ RGBA =&RGBA32 {};func _aacc (_aeae *_e .NYCbCrA ,_cgcfc NRGBA ,_cdgg _e .Rectangle ){for _ebcd :=0;_ebcd < _cdgg .Max .X ;_ebcd ++{for _edbbe :=0;_edbbe < _cdgg .Max .Y ;_edbbe ++{_gfeg :=_aeae .NYCbCrAAt (_ebcd ,_edbbe );_cgcfc .SetNRGBA (_ebcd ,_edbbe ,_agb (_gfeg ));
};};};func (_bceg *NRGBA16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_bceg .Width ,Y :_bceg .Height }};};func _cce (_baee _a .Gray )_a .Gray {_baee .Y >>=4;_baee .Y |=_baee .Y <<4;return _baee };func (_fcca *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_fcca .copy ()}};
func _gaef (_gedag []byte ,_dacb Image )error {_cbbd :=true ;for _ccbf :=0;_ccbf < len (_gedag );_ccbf ++{if _gedag [_ccbf ]!=0xff{_cbbd =false ;break ;};};if _cbbd {switch _daaf :=_dacb .(type ){case *NRGBA32 :_daaf .Alpha =nil ;case *NRGBA64 :_daaf .Alpha =nil ;
default:return _ed .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_dacb );
};};return nil ;};func _adbfc (_gdac *_e .Gray16 ,_facg uint8 )*_e .Gray {_dfeg :=_gdac .Bounds ();_fgec :=_e .NewGray (_dfeg );for _ecgg :=0;_ecgg < _dfeg .Dx ();_ecgg ++{for _adadc :=0;_adadc < _dfeg .Dy ();_adadc ++{_dfcb :=_gdac .Gray16At (_ecgg ,_adadc );
_fgec .SetGray (_ecgg ,_adadc ,_a .Gray {Y :_bagd (uint8 (_dfcb .Y /256),_facg )});};};return _fgec ;};func _dca (_ffbe ,_bb *Monochrome ,_ece []byte ,_ffbeb int )(_gfe error ){var (_dfd ,_egea ,_ffbf ,_acd ,_egb ,_bcb ,_bda ,_ad int ;_cdd ,_bcf uint32 ;
_eaf ,_fcf byte ;_ebc uint16 ;);_dab :=make ([]byte ,4);_bbd :=make ([]byte ,4);for _ffbf =0;_ffbf < _ffbe .Height -1;_ffbf ,_acd =_ffbf +2,_acd +1{_dfd =_ffbf *_ffbe .BytesPerLine ;_egea =_acd *_bb .BytesPerLine ;for _egb ,_bcb =0,0;_egb < _ffbeb ;_egb ,_bcb =_egb +4,_bcb +1{for _bda =0;
_bda < 4;_bda ++{_ad =_dfd +_egb +_bda ;if _ad <=len (_ffbe .Data )-1&&_ad < _dfd +_ffbe .BytesPerLine {_dab [_bda ]=_ffbe .Data [_ad ];}else {_dab [_bda ]=0x00;};_ad =_dfd +_ffbe .BytesPerLine +_egb +_bda ;if _ad <=len (_ffbe .Data )-1&&_ad < _dfd +(2*_ffbe .BytesPerLine ){_bbd [_bda ]=_ffbe .Data [_ad ];
}else {_bbd [_bda ]=0x00;};};_cdd =_d .BigEndian .Uint32 (_dab );_bcf =_d .BigEndian .Uint32 (_bbd );_bcf |=_cdd ;_bcf |=_bcf <<1;_bcf &=0xaaaaaaaa;_cdd =_bcf |(_bcf <<7);_eaf =byte (_cdd >>24);_fcf =byte ((_cdd >>8)&0xff);_ad =_egea +_bcb ;if _ad +1==len (_bb .Data )-1||_ad +1>=_egea +_bb .BytesPerLine {_bb .Data [_ad ]=_ece [_eaf ];
}else {_ebc =(uint16 (_ece [_eaf ])<<8)|uint16 (_ece [_fcf ]);if _gfe =_bb .setTwoBytes (_ad ,_ebc );_gfe !=nil {return _ed .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ad );
};_bcb ++;};};};return nil ;};func _debae (_ceedb Gray ,_aage NRGBA ,_dggff _e .Rectangle ){for _gefc :=0;_gefc < _dggff .Max .X ;_gefc ++{for _gdgc :=0;_gdgc < _dggff .Max .Y ;_gdgc ++{_dbce :=_ceedb .GrayAt (_gefc ,_gdgc );_aage .SetNRGBA (_gefc ,_gdgc ,_fdbd (_dbce ));
};};};func _fbaa (_dbgc ,_ffce Gray ,_dcde _e .Rectangle ){for _dbgb :=0;_dbgb < _dcde .Max .X ;_dbgb ++{for _ggadd :=0;_ggadd < _dcde .Max .Y ;_ggadd ++{_ffce .SetGray (_dbgb ,_ggadd ,_dbgc .GrayAt (_dbgb ,_ggadd ));};};};func ImgToGray (i _e .Image )*_e .Gray {if _bec ,_dgeab :=i .(*_e .Gray );
_dgeab {return _bec ;};_bgb :=i .Bounds ();_cgcgd :=_e .NewGray (_bgb );for _bfa :=0;_bfa < _bgb .Max .X ;_bfa ++{for _bffbc :=0;_bffbc < _bgb .Max .Y ;_bffbc ++{_cgaf :=i .At (_bfa ,_bffbc );_cgcgd .Set (_bfa ,_bffbc ,_cgaf );};};return _cgcgd ;};func _gcda (_gdee *Monochrome ,_faeb ,_gecb int ,_feab ,_bdcdb int ,_egde RasterOperator ){var (_cdaca int ;
_aecd byte ;_feebd ,_bbg int ;_aefab int ;);_dcfee :=_feab >>3;_egff :=_feab &7;if _egff > 0{_aecd =_agcf [_egff ];};_cdaca =_gdee .BytesPerLine *_gecb +(_faeb >>3);switch _egde {case PixClr :for _feebd =0;_feebd < _bdcdb ;_feebd ++{_aefab =_cdaca +_feebd *_gdee .BytesPerLine ;
for _bbg =0;_bbg < _dcfee ;_bbg ++{_gdee .Data [_aefab ]=0x0;_aefab ++;};if _egff > 0{_gdee .Data [_aefab ]=_cbcc (_gdee .Data [_aefab ],0x0,_aecd );};};case PixSet :for _feebd =0;_feebd < _bdcdb ;_feebd ++{_aefab =_cdaca +_feebd *_gdee .BytesPerLine ;
for _bbg =0;_bbg < _dcfee ;_bbg ++{_gdee .Data [_aefab ]=0xff;_aefab ++;};if _egff > 0{_gdee .Data [_aefab ]=_cbcc (_gdee .Data [_aefab ],0xff,_aecd );};};case PixNotDst :for _feebd =0;_feebd < _bdcdb ;_feebd ++{_aefab =_cdaca +_feebd *_gdee .BytesPerLine ;
for _bbg =0;_bbg < _dcfee ;_bbg ++{_gdee .Data [_aefab ]=^_gdee .Data [_aefab ];_aefab ++;};if _egff > 0{_gdee .Data [_aefab ]=_cbcc (_gdee .Data [_aefab ],^_gdee .Data [_aefab ],_aecd );};};};};func (_ecfaa *Gray8 )SetGray (x ,y int ,g _a .Gray ){_deef :=y *_ecfaa .BytesPerLine +x ;
if _deef > len (_ecfaa .Data )-1{return ;};_ecfaa .Data [_deef ]=g .Y ;};var _ _e .Image =&NRGBA64 {};func (_dfdb *CMYK32 )At (x ,y int )_a .Color {_eec ,_ :=_dfdb .ColorAt (x ,y );return _eec };var ErrInvalidImage =_ge .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_edbe *NRGBA32 )setRGBA (_abbd int ,_gdg _a .NRGBA ){_dggf :=3*_abbd ;_edbe .Data [_dggf ]=_gdg .R ;_edbe .Data [_dggf +1]=_gdg .G ;_edbe .Data [_dggf +2]=_gdg .B ;if _abbd < len (_edbe .Alpha ){_edbe .Alpha [_abbd ]=_gdg .A ;};};func _eagcf (_deefa *_e .Gray ,_ecaff uint8 )*_e .Gray {_fabe :=_deefa .Bounds ();
_fbgc :=_e .NewGray (_fabe );for _aeec :=0;_aeec < _fabe .Dx ();_aeec ++{for _cdec :=0;_cdec < _fabe .Dy ();_cdec ++{_ecfg :=_deefa .GrayAt (_aeec ,_cdec );_fbgc .SetGray (_aeec ,_cdec ,_a .Gray {Y :_bagd (_ecfg .Y ,_ecaff )});};};return _fbgc ;};func _ceff (_aef _e .Image ,_bfca Image ,_gabd _e .Rectangle ){for _aed :=0;
_aed < _gabd .Max .X ;_aed ++{for _cefb :=0;_cefb < _gabd .Max .Y ;_cefb ++{_fabd :=_aef .At (_aed ,_cefb );_bfca .Set (_aed ,_cefb ,_fabd );};};};func (_dbba *CMYK32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_dbba .Width ,Y :_dbba .Height }};
};func (_geaf *RGBA32 )Base ()*ImageBase {return &_geaf .ImageBase };type NRGBA16 struct{ImageBase };func (_agbg *Gray2 )Set (x ,y int ,c _a .Color ){if x >=_agbg .Width ||y >=_agbg .Height {return ;};_ffbb :=Gray2Model .Convert (c ).(_a .Gray );_cacd :=y *_agbg .BytesPerLine ;
_bdegc :=_cacd +(x >>2);_egdb :=_ffbb .Y >>6;_agbg .Data [_bdegc ]=(_agbg .Data [_bdegc ]&(^(0xc0>>uint (2*((x )&3)))))|(_egdb <<uint (6-2*(x &3)));};var _ Image =&RGBA32 {};type Histogramer interface{Histogram ()[256]int ;};func _ecde (_eggd _a .CMYK )_a .NRGBA {_aea ,_edd ,_cagd :=_a .CMYKToRGB (_eggd .C ,_eggd .M ,_eggd .Y ,_eggd .K );
return _a .NRGBA {R :_aea ,G :_edd ,B :_cagd ,A :0xff};};func (_gbdd *NRGBA16 )setNRGBA (_gbfeg ,_bcaef ,_aagf int ,_gggc _a .NRGBA ){if _gbfeg *3%2==0{_gbdd .Data [_aagf ]=(_gggc .R >>4)<<4|(_gggc .G >>4);_gbdd .Data [_aagf +1]=(_gggc .B >>4)<<4|(_gbdd .Data [_aagf +1]&0xf);
}else {_gbdd .Data [_aagf ]=(_gbdd .Data [_aagf ]&0xf0)|(_gggc .R >>4);_gbdd .Data [_aagf +1]=(_gggc .G >>4)<<4|(_gggc .B >>4);};if _gbdd .Alpha !=nil {_gece :=_bcaef *BytesPerLine (_gbdd .Width ,4,1);if _gece < len (_gbdd .Alpha ){if _gbfeg %2==0{_gbdd .Alpha [_gece ]=(_gggc .A >>uint (4))<<uint (4)|(_gbdd .Alpha [_aagf ]&0xf);
}else {_gbdd .Alpha [_gece ]=(_gbdd .Alpha [_gece ]&0xf0)|(_gggc .A >>uint (4));};};};};func _baa (_cdb ,_bdeg *Monochrome ,_dage []byte ,_cga int )(_cbg error ){var (_adg ,_bce ,_eef ,_bcg ,_effd ,_acgd ,_aaa ,_ged int ;_gbb ,_adb ,_dgg ,_aba uint32 ;
_ada ,_feg byte ;_gfg uint16 ;);_aae :=make ([]byte ,4);_ecada :=make ([]byte ,4);for _eef =0;_eef < _cdb .Height -1;_eef ,_bcg =_eef +2,_bcg +1{_adg =_eef *_cdb .BytesPerLine ;_bce =_bcg *_bdeg .BytesPerLine ;for _effd ,_acgd =0,0;_effd < _cga ;_effd ,_acgd =_effd +4,_acgd +1{for _aaa =0;
_aaa < 4;_aaa ++{_ged =_adg +_effd +_aaa ;if _ged <=len (_cdb .Data )-1&&_ged < _adg +_cdb .BytesPerLine {_aae [_aaa ]=_cdb .Data [_ged ];}else {_aae [_aaa ]=0x00;};_ged =_adg +_cdb .BytesPerLine +_effd +_aaa ;if _ged <=len (_cdb .Data )-1&&_ged < _adg +(2*_cdb .BytesPerLine ){_ecada [_aaa ]=_cdb .Data [_ged ];
}else {_ecada [_aaa ]=0x00;};};_gbb =_d .BigEndian .Uint32 (_aae );_adb =_d .BigEndian .Uint32 (_ecada );_dgg =_gbb &_adb ;_dgg |=_dgg <<1;_aba =_gbb |_adb ;_aba &=_aba <<1;_adb =_dgg &_aba ;_adb &=0xaaaaaaaa;_gbb =_adb |(_adb <<7);_ada =byte (_gbb >>24);
_feg =byte ((_gbb >>8)&0xff);_ged =_bce +_acgd ;if _ged +1==len (_bdeg .Data )-1||_ged +1>=_bce +_bdeg .BytesPerLine {if _cbg =_bdeg .setByte (_ged ,_dage [_ada ]);_cbg !=nil {return _ed .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ged );};
}else {_gfg =(uint16 (_dage [_ada ])<<8)|uint16 (_dage [_feg ]);if _cbg =_bdeg .setTwoBytes (_ged ,_gfg );_cbg !=nil {return _ed .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ged );
};_acgd ++;};};};return nil ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _febcd ,_cgeb ,_ecgc ,_cabf int ;for _bgab :=0;_bgab < len (histogram );_bgab ++{if histogram [_bgab ]> 0{_febcd =_bgab ;break ;};};if _febcd > 0{_febcd --;};for _gdaf :=255;
_gdaf > 0;_gdaf --{if histogram [_gdaf ]> 0{_cabf =_gdaf ;break ;};};if _cabf < 255{_cabf ++;};for _ededa :=0;_ededa < 256;_ededa ++{if histogram [_ededa ]> _cgeb {_ecgc =_ededa ;_cgeb =histogram [_ededa ];};};var _gace bool ;if (_ecgc -_febcd )< (_cabf -_ecgc ){_gace =true ;
var _cfec int ;_cdeed :=255;for _cfec < _cdeed {_bfefdg :=histogram [_cfec ];histogram [_cfec ]=histogram [_cdeed ];histogram [_cdeed ]=_bfefdg ;_cfec ++;_cdeed --;};_febcd =255-_cabf ;_ecgc =255-_ecgc ;};if _febcd ==_ecgc {return uint8 (_febcd );};_ebab :=float64 (histogram [_ecgc ]);
_dfbd :=float64 (_febcd -_ecgc );_gege :=_c .Sqrt (_ebab *_ebab +_dfbd *_dfbd );_ebab /=_gege ;_dfbd /=_gege ;_gege =_ebab *float64 (_febcd )+_dfbd *float64 (histogram [_febcd ]);_bgge :=_febcd ;var _fgefg float64 ;for _dbcf :=_febcd +1;_dbcf <=_ecgc ;
_dbcf ++{_ddcgc :=_ebab *float64 (_dbcf )+_dfbd *float64 (histogram [_dbcf ])-_gege ;if _ddcgc > _fgefg {_bgge =_dbcf ;_fgefg =_ddcgc ;};};_bgge --;if _gace {var _fagf int ;_ffaff :=255;for _fagf < _ffaff {_deceb :=histogram [_fagf ];histogram [_fagf ]=histogram [_ffaff ];
histogram [_ffaff ]=_deceb ;_fagf ++;_ffaff --;};return uint8 (255-_bgge );};return uint8 (_bgge );};func (_decf *Monochrome )AddPadding ()(_cfd error ){if _cbae :=((_decf .Width *_decf .Height )+7)>>3;len (_decf .Data )< _cbae {return _ed .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_decf .Data ),_cbae );
};_abfd :=_decf .Width %8;if _abfd ==0{return nil ;};_bdcd :=_decf .Width /8;_dffe :=_dg .NewReader (_decf .Data );_ceg :=make ([]byte ,_decf .Height *_decf .BytesPerLine );_caca :=_dg .NewWriterMSB (_ceg );_dddf :=make ([]byte ,_bdcd );var (_deed int ;
_egfc uint64 ;);for _deed =0;_deed < _decf .Height ;_deed ++{if _ ,_cfd =_dffe .Read (_dddf );_cfd !=nil {return _cfd ;};if _ ,_cfd =_caca .Write (_dddf );_cfd !=nil {return _cfd ;};if _egfc ,_cfd =_dffe .ReadBits (byte (_abfd ));_cfd !=nil {return _cfd ;
};if _cfd =_caca .WriteByte (byte (_egfc )<<uint (8-_abfd ));_cfd !=nil {return _cfd ;};};_decf .Data =_caca .Data ();return nil ;};func _cgf (_eac ,_gadg *Monochrome ,_ebfg []byte ,_efe int )(_efa error ){var (_dfg ,_cgb ,_acg ,_eae ,_ade ,_fed ,_cea ,_eebc int ;
_bbf ,_efgb ,_acga ,_ecaa uint32 ;_fgae ,_gaae byte ;_gefd uint16 ;);_gab :=make ([]byte ,4);_cca :=make ([]byte ,4);for _acg =0;_acg < _eac .Height -1;_acg ,_eae =_acg +2,_eae +1{_dfg =_acg *_eac .BytesPerLine ;_cgb =_eae *_gadg .BytesPerLine ;for _ade ,_fed =0,0;
_ade < _efe ;_ade ,_fed =_ade +4,_fed +1{for _cea =0;_cea < 4;_cea ++{_eebc =_dfg +_ade +_cea ;if _eebc <=len (_eac .Data )-1&&_eebc < _dfg +_eac .BytesPerLine {_gab [_cea ]=_eac .Data [_eebc ];}else {_gab [_cea ]=0x00;};_eebc =_dfg +_eac .BytesPerLine +_ade +_cea ;
if _eebc <=len (_eac .Data )-1&&_eebc < _dfg +(2*_eac .BytesPerLine ){_cca [_cea ]=_eac .Data [_eebc ];}else {_cca [_cea ]=0x00;};};_bbf =_d .BigEndian .Uint32 (_gab );_efgb =_d .BigEndian .Uint32 (_cca );_acga =_bbf &_efgb ;_acga |=_acga <<1;_ecaa =_bbf |_efgb ;
_ecaa &=_ecaa <<1;_efgb =_acga |_ecaa ;_efgb &=0xaaaaaaaa;_bbf =_efgb |(_efgb <<7);_fgae =byte (_bbf >>24);_gaae =byte ((_bbf >>8)&0xff);_eebc =_cgb +_fed ;if _eebc +1==len (_gadg .Data )-1||_eebc +1>=_cgb +_gadg .BytesPerLine {if _efa =_gadg .setByte (_eebc ,_ebfg [_fgae ]);
_efa !=nil {return _ed .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_eebc );};}else {_gefd =(uint16 (_ebfg [_fgae ])<<8)|uint16 (_ebfg [_gaae ]);if _efa =_gadg .setTwoBytes (_eebc ,_gefd );_efa !=nil {return _ed .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_eebc );
};_fed ++;};};};return nil ;};func _fgdc (_eacb _e .Image ,_afgf int )(_e .Rectangle ,bool ,[]byte ){_afcf :=_eacb .Bounds ();var (_dbeg bool ;_bfge []byte ;);switch _bafg :=_eacb .(type ){case SMasker :_dbeg =_bafg .HasAlpha ();case NRGBA ,RGBA ,*_e .RGBA64 ,nrgba64 ,*_e .NYCbCrA :_bfge =make ([]byte ,_afcf .Max .X *_afcf .Max .Y *_afgf );
case *_e .Paletted :var _abdeb bool ;for _ ,_dgfea :=range _bafg .Palette {_eebee ,_afcg ,_deaa ,_dbgba :=_dgfea .RGBA ();if _eebee ==0&&_afcg ==0&&_deaa ==0&&_dbgba !=0{_abdeb =true ;break ;};};if _abdeb {_bfge =make ([]byte ,_afcf .Max .X *_afcf .Max .Y *_afgf );
};};return _afcf ,_dbeg ,_bfge ;};func (_fdb *CMYK32 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtCMYK (x ,y ,_fdb .Width ,_fdb .Data ,_fdb .Decode );};var _dcgb [256]uint8 ;var _ Gray =&Monochrome {};func (_efaf *Gray8 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_efaf .Width ,Y :_efaf .Height }};
};func _gba (_gee ,_gbac int ,_dgb []byte )*Monochrome {_ab :=_fd (_gee ,_gbac );_ab .Data =_dgb ;return _ab ;};func (_acfc *Monochrome )copy ()*Monochrome {_adeb :=_fd (_acfc .Width ,_acfc .Height );_adeb .ModelThreshold =_acfc .ModelThreshold ;_adeb .Data =make ([]byte ,len (_acfc .Data ));
copy (_adeb .Data ,_acfc .Data );if len (_acfc .Decode )!=0{_adeb .Decode =make ([]float64 ,len (_acfc .Decode ));copy (_adeb .Decode ,_acfc .Decode );};if len (_acfc .Alpha )!=0{_adeb .Alpha =make ([]byte ,len (_acfc .Alpha ));copy (_adeb .Alpha ,_acfc .Alpha );
};return _adeb ;};func (_fcgdb *NRGBA64 )ColorModel ()_a .Model {return _a .NRGBA64Model };func (_ebbb *ImageBase )setEightBytes (_ffaa int ,_dcfg uint64 )error {_ffcc :=_ebbb .BytesPerLine -(_ffaa %_ebbb .BytesPerLine );if _ebbb .BytesPerLine !=_ebbb .Width >>3{_ffcc --;
};if _ffcc >=8{return _ebbb .setEightFullBytes (_ffaa ,_dcfg );};return _ebbb .setEightPartlyBytes (_ffaa ,_ffcc ,_dcfg );};func (_ddcag *NRGBA16 )ColorModel ()_a .Model {return NRGBA16Model };func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_a .CMYK ,error ){_abf :=4*(y *width +x );
if _abf +3>=len (data ){return _a .CMYK {},_ed .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_abf ]&0xff;M :=data [_abf +1]&0xff;Y :=data [_abf +2]&0xff;K :=data [_abf +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _a .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};var _ _e .Image =&RGBA32 {};func _bebca (_afede _e .Image ,_gcac Image ,_egac _e .Rectangle ){if _ffab ,_cffa :=_afede .(SMasker );
_cffa &&_ffab .HasAlpha (){_gcac .(SMasker ).MakeAlpha ();};switch _gacac :=_afede .(type ){case Gray :_debae (_gacac ,_gcac .(NRGBA ),_egac );case NRGBA :_eaffg (_gacac ,_gcac .(NRGBA ),_egac );case *_e .NYCbCrA :_aacc (_gacac ,_gcac .(NRGBA ),_egac );
case CMYK :_daag (_gacac ,_gcac .(NRGBA ),_egac );case RGBA :_efbd (_gacac ,_gcac .(NRGBA ),_egac );case nrgba64 :_gaead (_gacac ,_gcac .(NRGBA ),_egac );default:_ceff (_afede ,_gcac ,_egac );};};func _dgbf (_fec Gray ,_aafg nrgba64 ,_gbg _e .Rectangle ){for _aff :=0;
_aff < _gbg .Max .X ;_aff ++{for _fce :=0;_fce < _gbg .Max .Y ;_fce ++{_efad :=_egbb (_aafg .NRGBA64At (_aff ,_fce ));_fec .SetGray (_aff ,_fce ,_efad );};};};func (_gaba *Monochrome )IsUnpadded ()bool {return (_gaba .Width *_gaba .Height )==len (_gaba .Data )};
func (_age *Gray2 )At (x ,y int )_a .Color {_eacc ,_ :=_age .ColorAt (x ,y );return _eacc };func (_fcdd *NRGBA64 )SetNRGBA64 (x ,y int ,c _a .NRGBA64 ){_cdg :=(y *_fcdd .Width +x )*2;_aada :=_cdg *3;if _aada +5>=len (_fcdd .Data ){return ;};_fcdd .setNRGBA64 (_aada ,c ,_cdg );
};func (_cegb *Gray4 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_cegb .Width ,Y :_cegb .Height }};};type RGBA interface{RGBAAt (_gbbfe ,_bcae int )_a .RGBA ;SetRGBA (_dbea ,_ffef int ,_aeabd _a .RGBA );};type shift int ;func _aceg (_fede _e .Image )(Image ,error ){if _cbfc ,_bfefe :=_fede .(*RGBA32 );
_bfefe {return _cbfc .Copy (),nil ;};_fcbg ,_gdbb ,_ddfd :=_fgdc (_fede ,1);_cbdb :=&RGBA32 {ImageBase :NewImageBase (_fcbg .Max .X ,_fcbg .Max .Y ,8,3,nil ,_ddfd ,nil )};_ffbbf (_fede ,_cbdb ,_fcbg );if len (_ddfd )!=0&&!_gdbb {if _gfdb :=_gaef (_ddfd ,_cbdb );
_gfdb !=nil {return nil ,_gfdb ;};};return _cbdb ,nil ;};func _eea ()(_dbg [256]uint32 ){for _gf :=0;_gf < 256;_gf ++{if _gf &0x01!=0{_dbg [_gf ]|=0xf;};if _gf &0x02!=0{_dbg [_gf ]|=0xf0;};if _gf &0x04!=0{_dbg [_gf ]|=0xf00;};if _gf &0x08!=0{_dbg [_gf ]|=0xf000;
};if _gf &0x10!=0{_dbg [_gf ]|=0xf0000;};if _gf &0x20!=0{_dbg [_gf ]|=0xf00000;};if _gf &0x40!=0{_dbg [_gf ]|=0xf000000;};if _gf &0x80!=0{_dbg [_gf ]|=0xf0000000;};};return _dbg ;};func _bbba (_fadg _e .Image )(Image ,error ){if _gfba ,_bgac :=_fadg .(*Gray8 );
_bgac {return _gfba .Copy (),nil ;};_caba :=_fadg .Bounds ();_gagb ,_cead :=NewImage (_caba .Max .X ,_caba .Max .Y ,8,1,nil ,nil ,nil );if _cead !=nil {return nil ,_cead ;};_bdec (_fadg ,_gagb ,_caba );return _gagb ,nil ;};func (_aadc *ImageBase )GetAlpha ()[]byte {return _aadc .Alpha };
func (_eegg *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_eegg .copy ()}};func _egbb (_cede _a .NRGBA64 )_a .Gray {var _cag _a .NRGBA64 ;if _cede ==_cag {return _a .Gray {Y :0xff};};_agg ,_gcg ,_abad ,_ :=_cede .RGBA ();_cfa :=(19595*_agg +38470*_gcg +7471*_abad +1<<15)>>24;
return _a .Gray {Y :uint8 (_cfa )};};func (_gafg *Gray2 )GrayAt (x ,y int )_a .Gray {_badd ,_ :=ColorAtGray2BPC (x ,y ,_gafg .BytesPerLine ,_gafg .Data ,_gafg .Decode );return _badd ;};var _ Image =&NRGBA32 {};func (_ggd *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_ge .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_bea :=_fd (width ,height );_dde :=make ([]int ,height );_cdfc :=make ([]int ,width );_bagf :=float64 (_ggd .Width )/float64 (width );_afb :=float64 (_ggd .Height )/float64 (height );for _efed :=0;_efed < height ;_efed ++{_dde [_efed ]=int (_c .Min (_afb *float64 (_efed )+0.5,float64 (_ggd .Height -1)));
};for _acb :=0;_acb < width ;_acb ++{_cdfc [_acb ]=int (_c .Min (_bagf *float64 (_acb )+0.5,float64 (_ggd .Width -1)));};_afe :=-1;_dbbb :=byte (0);for _gcgc :=0;_gcgc < height ;_gcgc ++{_decb :=_dde [_gcgc ]*_ggd .BytesPerLine ;_cdac :=_gcgc *_bea .BytesPerLine ;
for _bga :=0;_bga < width ;_bga ++{_dafb :=_cdfc [_bga ];if _dafb !=_afe {_dbbb =_ggd .getBit (_decb ,_dafb );if _dbbb !=0{_bea .setBit (_cdac ,_bga );};_afe =_dafb ;}else {if _dbbb !=0{_bea .setBit (_cdac ,_bga );};};};};return _bea ,nil ;};