//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_g "errors";_f "fmt";_d "github.com/unidoc/unipdf/v3/internal/bitwise";_ec "image";_e "image/color";_ea "image/draw";_b "math";);func (_gf *CMYK32 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_gf .Width ,Y :_gf .Height }};};var _ _ec .Image =&NRGBA16 {};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_e .NRGBA64 ,error ){_gdfca :=(y *width +x )*2;_gdeba :=_gdfca *3;if _gdeba +5>=len (data ){return _e .NRGBA64 {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _dgce =0xffff;_ffc :=uint16 (_dgce );if alpha !=nil &&len (alpha )> _gdfca +1{_ffc =uint16 (alpha [_gdfca ])<<8|uint16 (alpha [_gdfca +1]);};_cdde :=uint16 (data [_gdeba ])<<8|uint16 (data [_gdeba +1]);_aacc :=uint16 (data [_gdeba +2])<<8|uint16 (data [_gdeba +3]);_fgga :=uint16 (data [_gdeba +4])<<8|uint16 (data [_gdeba +5]);if len (decode )==6{_cdde =uint16 (uint64 (LinearInterpolate (float64 (_cdde ),0,65535,decode [0],decode [1]))&_dgce );_aacc =uint16 (uint64 (LinearInterpolate (float64 (_aacc ),0,65535,decode [2],decode [3]))&_dgce );_fgga =uint16 (uint64 (LinearInterpolate (float64 (_fgga ),0,65535,decode [4],decode [5]))&_dgce );};return _e .NRGBA64 {R :_cdde ,G :_aacc ,B :_fgga ,A :_ffc },nil ;};func (_ffab *Gray16 )At (x ,y int )_e .Color {_abbc ,_ :=_ffab .ColorAt (x ,y );return _abbc };var _ _ec .Image =&Monochrome {};func _ag (_cdf _e .Gray )_e .NRGBA {return _e .NRGBA {R :_cdf .Y ,G :_cdf .Y ,B :_cdf .Y ,A :0xff}};func ImgToGray (i _ec .Image )*_ec .Gray {if _aee ,_acfb :=i .(*_ec .Gray );_acfb {return _aee ;};_fgb :=i .Bounds ();_dedb :=_ec .NewGray (_fgb );for _dddcb :=0;_dddcb < _fgb .Max .X ;_dddcb ++{for _adae :=0;_adae < _fgb .Max .Y ;_adae ++{_edba :=i .At (_dddcb ,_adae );_dedb .Set (_dddcb ,_adae ,_edba );};};return _dedb ;};func _eagg (_cdd _ec .Image )(Image ,error ){if _dfc ,_ebf :=_cdd .(*Gray16 );_ebf {return _dfc .Copy (),nil ;};_dbg :=_cdd .Bounds ();_fbac ,_aedf :=NewImage (_dbg .Max .X ,_dbg .Max .Y ,16,1,nil ,nil ,nil );if _aedf !=nil {return nil ,_aedf ;};_ebcg (_cdd ,_fbac ,_dbg );return _fbac ,nil ;};func _adcb (_eeag _ec .Image )(Image ,error ){if _dcec ,_cbefb :=_eeag .(*NRGBA16 );_cbefb {return _dcec .Copy (),nil ;};_cde :=_eeag .Bounds ();_badd ,_afc :=NewImage (_cde .Max .X ,_cde .Max .Y ,4,3,nil ,nil ,nil );if _afc !=nil {return nil ,_afc ;};_feca (_eeag ,_badd ,_cde );return _badd ,nil ;};var _ Image =&NRGBA16 {};func (_dege *NRGBA16 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_dege .Width ,Y :_dege .Height }};};func _fbae (_bffb CMYK ,_egf NRGBA ,_dedc _ec .Rectangle ){for _bbeg :=0;_bbeg < _dedc .Max .X ;_bbeg ++{for _daaf :=0;_daaf < _dedc .Max .Y ;_daaf ++{_eacg :=_bffb .CMYKAt (_bbeg ,_daaf );_egf .SetNRGBA (_bbeg ,_daaf ,_eag (_eacg ));};};};func (_fb *CMYK32 )At (x ,y int )_e .Color {_bb ,_ :=_fb .ColorAt (x ,y );return _bb };type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};var (Gray2Model =_e .ModelFunc (_dgg );Gray4Model =_e .ModelFunc (_fdca );NRGBA16Model =_e .ModelFunc (_aadg ););func (_febb *NRGBA16 )NRGBAAt (x ,y int )_e .NRGBA {_cace ,_ :=ColorAtNRGBA16 (x ,y ,_febb .Width ,_febb .BytesPerLine ,_febb .Data ,_febb .Alpha ,_febb .Decode );return _cace ;};func (_edce *Gray4 )At (x ,y int )_e .Color {_afd ,_ :=_edce .ColorAt (x ,y );return _afd };func _gbdeg (_cdba RGBA ,_bede NRGBA ,_gfcg _ec .Rectangle ){for _fac :=0;_fac < _gfcg .Max .X ;_fac ++{for _gggg :=0;_gggg < _gfcg .Max .Y ;_gggg ++{_ecdg :=_cdba .RGBAAt (_fac ,_gggg );_bede .SetNRGBA (_fac ,_gggg ,_ece (_ecdg ));};};};var _ _ec .Image =&Gray16 {};func (_bgb *Gray4 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtGray4BPC (x ,y ,_bgb .BytesPerLine ,_bgb .Data ,_bgb .Decode );};func (_bed *Monochrome )Base ()*ImageBase {return &_bed .ImageBase };func (_bcf *Gray2 )ColorModel ()_e .Model {return Gray2Model };func (_cdb colorConverter )Convert (src _ec .Image )(Image ,error ){return _cdb ._abc (src )};func _dd (_fd ,_de CMYK ,_fgg _ec .Rectangle ){for _fcf :=0;_fcf < _fgg .Max .X ;_fcf ++{for _fa :=0;_fa < _fgg .Max .Y ;_fa ++{_de .SetCMYK (_fcf ,_fa ,_fd .CMYKAt (_fcf ,_fa ));};};};func (_bea *NRGBA16 )Base ()*ImageBase {return &_bea .ImageBase };func (_aaab *Gray2 )SetGray (x ,y int ,gray _e .Gray ){_cgg :=_caf (gray );_ecf :=y *_aaab .BytesPerLine ;_ffe :=_ecf +(x >>2);if _ffe >=len (_aaab .Data ){return ;};_adg :=_cgg .Y >>6;_aaab .Data [_ffe ]=(_aaab .Data [_ffe ]&(^(0xc0>>uint (2*((x )&3)))))|(_adg <<uint (6-2*(x &3)));};func _eag (_abg _e .CMYK )_e .NRGBA {_dba ,_da ,_ae :=_e .CMYKToRGB (_abg .C ,_abg .M ,_abg .Y ,_abg .K );return _e .NRGBA {R :_dba ,G :_da ,B :_ae ,A :0xff};};func (_ggbf *NRGBA32 )SetNRGBA (x ,y int ,c _e .NRGBA ){_acd :=y *_ggbf .Width +x ;_aeb :=3*_acd ;if _aeb +2>=len (_ggbf .Data ){return ;};_ggbf .setRGBA (_acd ,c );return ;};func (_ddec *Monochrome )setBit (_cff ,_ddb int ){_ddec .Data [_cff ]|=0x80>>uint (_ddb &7)};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Gray ,error ){_gag :=y *bytesPerLine +x >>1;if _gag >=len (data ){return _e .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ggcb :=data [_gag ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_ggcb =uint8 (uint32 (LinearInterpolate (float64 (_ggcb ),0,15,decode [0],decode [1]))&0xf);};return _e .Gray {Y :_ggcb *17&0xff},nil ;};func (_bdb *NRGBA64 )Validate ()error {if len (_bdb .Data )!=3*2*_bdb .Width *_bdb .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _cg (_gfe NRGBA ,_ee CMYK ,_bcb _ec .Rectangle ){for _fdc :=0;_fdc < _bcb .Max .X ;_fdc ++{for _ga :=0;_ga < _bcb .Max .Y ;_ga ++{_bad :=_gfe .NRGBAAt (_fdc ,_ga );_ee .SetCMYK (_fdc ,_ga ,_dae (_bad ));};};};func (_cfa *Gray8 )GrayAt (x ,y int )_e .Gray {_fefc ,_ :=ColorAtGray8BPC (x ,y ,_cfa .BytesPerLine ,_cfa .Data ,_cfa .Decode );return _fefc ;};func (_cac *Gray8 )At (x ,y int )_e .Color {_aea ,_ :=_cac .ColorAt (x ,y );return _aea };func _cfc (_fc _ec .Image )(Image ,error ){if _ed ,_gb :=_fc .(*CMYK32 );_gb {return _ed .Copy (),nil ;};_cea :=_fc .Bounds ();_cd ,_ff :=NewImage (_cea .Max .X ,_cea .Max .Y ,8,4,nil ,nil ,nil );if _ff !=nil {return nil ,_ff ;};switch _bge :=_fc .(type ){case CMYK :_dd (_bge ,_cd .(CMYK ),_cea );case Gray :_ab (_bge ,_cd .(CMYK ),_cea );case NRGBA :_cg (_bge ,_cd .(CMYK ),_cea );case RGBA :_cga (_bge ,_cd .(CMYK ),_cea );default:_egd (_fc ,_cd ,_cea );};return _cd ,nil ;};func _gcb (_gdg _e .Gray )_e .Gray {_gdg .Y >>=4;_gdg .Y |=_gdg .Y <<4;return _gdg };type NRGBA interface{NRGBAAt (_cagd ,_bca int )_e .NRGBA ;SetNRGBA (_fccg ,_ggg int ,_aad _e .NRGBA );};func _dfcf (_cfd CMYK ,_gbe Gray ,_cgae _ec .Rectangle ){for _fbda :=0;_fbda < _cgae .Max .X ;_fbda ++{for _deaa :=0;_deaa < _cgae .Max .Y ;_deaa ++{_fffc :=_bdd (_cfd .CMYKAt (_fbda ,_deaa ));_gbe .SetGray (_fbda ,_deaa ,_fffc );};};};func _caf (_fdd _e .Gray )_e .Gray {_gcc :=_fdd .Y >>6;_gcc |=_gcc <<2;_fdd .Y =_gcc |_gcc <<4;return _fdd ;};func init (){_dca ()};func (_aff *NRGBA16 )SetNRGBA (x ,y int ,c _e .NRGBA ){_agfe :=y *_aff .BytesPerLine +x *3/2;if _agfe +1>=len (_aff .Data ){return ;};c =_dage (c );_aff .setNRGBA (x ,y ,_agfe ,c );};func (_gda *Gray4 )Base ()*ImageBase {return &_gda .ImageBase };func (_bae *CMYK32 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtCMYK (x ,y ,_bae .Width ,_bae .Data ,_bae .Decode );};func FromGoImage (i _ec .Image )(Image ,error ){switch _add :=i .(type ){case Image :return _add .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case CMYK :return CMYKConverter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_bc *CMYK32 )Set (x ,y int ,c _e .Color ){_eg :=4*(y *_bc .Width +x );if _eg +3>=len (_bc .Data ){return ;};_bg :=_e .CMYKModel .Convert (c ).(_e .CMYK );_bc .Data [_eg ]=_bg .C ;_bc .Data [_eg +1]=_bg .M ;_bc .Data [_eg +2]=_bg .Y ;_bc .Data [_eg +3]=_bg .K ;};var _ Image =&Monochrome {};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_ceag :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _ceag ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_adad :=width *colorComponents *bitsPerComponent ;_eeaff :=_ceag *8;_dggf :=8-(_eeaff -_adad );_bfdd :=_d .NewReader (data );_gfae :=_ceag -1;_geeg :=make ([]byte ,_gfae );_aag :=make ([]byte ,height *_ceag );_dgee :=_d .NewWriterMSB (_aag );var _efeb uint64 ;var _adc error ;for _deg :=0;_deg < height ;_deg ++{_ ,_adc =_bfdd .Read (_geeg );if _adc !=nil {return nil ,_adc ;};_ ,_adc =_dgee .Write (_geeg );if _adc !=nil {return nil ,_adc ;};_efeb ,_adc =_bfdd .ReadBits (byte (_dggf ));if _adc !=nil {return nil ,_adc ;};_ ,_adc =_dgee .WriteBits (_efeb ,_dggf );if _adc !=nil {return nil ,_adc ;};_dgee .FinishByte ();};return _aag ,nil ;};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _b .Abs (xmax -xmin )< 0.000001{return ymin ;};_fefg :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _fefg ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _abbb ,_agd ,_bgc ,_bffbd int ;for _cbb :=0;_cbb < len (histogram );_cbb ++{if histogram [_cbb ]> 0{_abbb =_cbb ;break ;};};if _abbb > 0{_abbb --;};for _gbb :=255;_gbb > 0;_gbb --{if histogram [_gbb ]> 0{_bffbd =_gbb ;break ;};};if _bffbd < 255{_bffbd ++;};for _efeg :=0;_efeg < 256;_efeg ++{if histogram [_efeg ]> _agd {_bgc =_efeg ;_agd =histogram [_efeg ];};};var _fcac bool ;if (_bgc -_abbb )< (_bffbd -_bgc ){_fcac =true ;var _egaa int ;_aadd :=255;for _egaa < _aadd {_dddc :=histogram [_egaa ];histogram [_egaa ]=histogram [_aadd ];histogram [_aadd ]=_dddc ;_egaa ++;_aadd --;};_abbb =255-_bffbd ;_bgc =255-_bgc ;};if _abbb ==_bgc {return uint8 (_abbb );};_afg :=float64 (histogram [_bgc ]);_cagb :=float64 (_abbb -_bgc );_ddab :=_b .Sqrt (_afg *_afg +_cagb *_cagb );_afg /=_ddab ;_cagb /=_ddab ;_ddab =_afg *float64 (_abbb )+_cagb *float64 (histogram [_abbb ]);_ffaf :=_abbb ;var _gcfd float64 ;for _cef :=_abbb +1;_cef <=_bgc ;_cef ++{_fafa :=_afg *float64 (_cef )+_cagb *float64 (histogram [_cef ])-_ddab ;if _fafa > _gcfd {_ffaf =_cef ;_gcfd =_fafa ;};};_ffaf --;if _fcac {var _dcg int ;_ccad :=255;for _dcg < _ccad {_bcab :=histogram [_dcg ];histogram [_dcg ]=histogram [_ccad ];histogram [_ccad ]=_bcab ;_dcg ++;_ccad --;};return uint8 (255-_ffaf );};return uint8 (_ffaf );};func (_gffb *ImageBase )GetAlpha ()[]byte {return _gffb .Alpha };func _feca (_adaa _ec .Image ,_dgd Image ,_adga _ec .Rectangle ){if _dgb ,_gcgc :=_adaa .(SMasker );_gcgc &&_dgb .HasAlpha (){_dgd .(SMasker ).MakeAlpha ();};switch _aba :=_adaa .(type ){case Gray :_fgdc (_aba ,_dgd .(NRGBA ),_adga );case NRGBA :_ccf (_aba ,_dgd .(NRGBA ),_adga );case CMYK :_fbae (_aba ,_dgd .(NRGBA ),_adga );case RGBA :_gbdeg (_aba ,_dgd .(NRGBA ),_adga );default:_egd (_adaa ,_dgd ,_adga );};};var _ _ec .Image =&Gray4 {};func (_ggbd *Gray16 )ColorModel ()_e .Model {return _e .Gray16Model };func (_dcc *Gray2 )Validate ()error {if len (_dcc .Data )!=_dcc .Height *_dcc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _fcd (_gceg _ec .Image )(Image ,error ){if _cgca ,_fca :=_gceg .(*Gray2 );_fca {return _cgca .Copy (),nil ;};_egg :=_gceg .Bounds ();_bdea ,_baa :=NewImage (_egg .Max .X ,_egg .Max .Y ,2,1,nil ,nil ,nil );if _baa !=nil {return nil ,_baa ;};_ebcg (_gceg ,_bdea ,_egg );return _bdea ,nil ;};var (MonochromeConverter =ConverterFunc (_aa );Gray2Converter =ConverterFunc (_fcd );Gray4Converter =ConverterFunc (_eebe );GrayConverter =ConverterFunc (_egee );Gray16Converter =ConverterFunc (_eagg );NRGBA16Converter =ConverterFunc (_adcb );NRGBAConverter =ConverterFunc (_aggf );NRGBA64Converter =ConverterFunc (_beba );CMYKConverter =ConverterFunc (_cfc ););func GrayHistogram (g Gray )(_dfff [256]int ){switch _afbbf :=g .(type ){case Histogramer :return _afbbf .Histogram ();case _ec .Image :_fgcf :=_afbbf .Bounds ();for _gef :=0;_gef < _fgcf .Max .X ;_gef ++{for _bbc :=0;_bbc < _fgcf .Max .Y ;_bbc ++{_dfff [g .GrayAt (_gef ,_bbc ).Y ]++;};};return _dfff ;default:return [256]int {};};};func _bde (_eac _e .RGBA )_e .CMYK {_fff ,_bfg ,_efe ,_baf :=_e .RGBToCMYK (_eac .R ,_eac .G ,_eac .B );return _e .CMYK {C :_fff ,M :_bfg ,Y :_efe ,K :_baf };};func ImgToBinary (i _ec .Image ,threshold uint8 )*_ec .Gray {switch _ccdf :=i .(type ){case *_ec .Gray :if _edbf (_ccdf ){return _ccdf ;};return _ccge (_ccdf ,threshold );case *_ec .Gray16 :return _accd (_ccdf ,threshold );default:return _fdg (_ccdf ,threshold );};};func (_gfb *Gray2 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_gfb .Width ,Y :_gfb .Height }};};func (_fbbb *Monochrome )setGray (_cca int ,_fbd _e .Gray ,_aaa int ){if _fbd .Y ==0{_fbbb .clearBit (_aaa ,_cca );}else {_fbbb .setBit (_aaa ,_cca );};};func (_dged *NRGBA64 )setNRGBA64 (_adgd int ,_gggd _e .NRGBA64 ,_fcadg int ){_dged .Data [_adgd ]=uint8 (_gggd .R >>8);_dged .Data [_adgd +1]=uint8 (_gggd .R &0xff);_dged .Data [_adgd +2]=uint8 (_gggd .G >>8);_dged .Data [_adgd +3]=uint8 (_gggd .G &0xff);_dged .Data [_adgd +4]=uint8 (_gggd .B >>8);_dged .Data [_adgd +5]=uint8 (_gggd .B &0xff);if _fcadg +1< len (_dged .Alpha ){_dged .Alpha [_fcadg ]=uint8 (_gggd .A >>8);_dged .Alpha [_fcadg +1]=uint8 (_gggd .A &0xff);};};func (_aade *NRGBA16 )setNRGBA (_eege ,_abbd ,_eadb int ,_dfcd _e .NRGBA ){if _eege *3%2==0{_aade .Data [_eadb ]=(_dfcd .R >>4)<<4|(_dfcd .G >>4);_aade .Data [_eadb +1]=(_dfcd .B >>4)<<4|(_aade .Data [_eadb +1]&0xf);}else {_aade .Data [_eadb ]=(_aade .Data [_eadb ]&0xf0)|(_dfcd .R >>4);_aade .Data [_eadb +1]=(_dfcd .G >>4)<<4|(_dfcd .B >>4);};if _aade .Alpha !=nil {_baeg :=_abbd *BytesPerLine (_aade .Width ,4,1);if _baeg < len (_aade .Alpha ){if _eege %2==0{_aade .Alpha [_baeg ]=(_dfcd .A >>uint (4))<<uint (4)|(_aade .Alpha [_eadb ]&0xf);}else {_aade .Alpha [_baeg ]=(_aade .Alpha [_baeg ]&0xf0)|(_dfcd .A >>uint (4));};};};};func (_gccf *Gray8 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_gccf .Width ,Y :_gccf .Height }};};var _ Gray =&Monochrome {};func _edbf (_babg *_ec .Gray )bool {for _fedg :=0;_fedg < len (_babg .Pix );_fedg ++{if !_gbec (_babg .Pix [_fedg ]){return false ;};};return true ;};func (_ceab *Gray16 )Validate ()error {if len (_ceab .Data )!=_ceab .Height *_ceab .BytesPerLine {return ErrInvalidImage ;};return nil ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_fegg *Monochrome )SetGray (x ,y int ,g _e .Gray ){_fec :=y *_fegg .BytesPerLine +x >>3;if _fec > len (_fegg .Data )-1{return ;};g =_fga (g ,monochromeModel (_fegg .ModelThreshold ));_fegg .setGray (x ,g ,_fec );};func (_ccc *ImageBase )MakeAlpha (){_ccc .newAlpha ()};func (_fgc *Gray8 )Histogram ()(_cbd [256]int ){for _fgda :=0;_fgda < len (_fgc .Data );_fgda ++{_cbd [_fgc .Data [_fgda ]]++;};return _cbd ;};func (_bgd *NRGBA32 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtNRGBA32 (x ,y ,_bgd .Width ,_bgd .Data ,_bgd .Alpha ,_bgd .Decode );};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Gray ,error ){_dbcf :=y *bytesPerLine +x >>2;if _dbcf >=len (data ){return _e .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_fgd :=data [_dbcf ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_fgd =uint8 (uint32 (LinearInterpolate (float64 (_fgd ),0,3.0,decode [0],decode [1]))&3);};return _e .Gray {Y :_fgd *85},nil ;};func (_eb *CMYK32 )Base ()*ImageBase {return &_eb .ImageBase };var _ Gray =&Gray4 {};func (_babb *NRGBA32 )ColorModel ()_e .Model {return _e .NRGBAModel };type NRGBA32 struct{ImageBase };type Gray interface{GrayAt (_cbe ,_eeg int )_e .Gray ;SetGray (_aeg ,_agf int ,_ded _e .Gray );};type RGBA interface{RGBAAt (_dff ,_caaf int )_e .RGBA ;SetRGBA (_dab ,_fge int ,_fcg _e .RGBA );};func (_aec *Gray4 )Histogram ()(_eeac [256]int ){for _gfc :=0;_gfc < _aec .Width ;_gfc ++{for _aegc :=0;_aegc < _aec .Height ;_aegc ++{_eeac [_aec .GrayAt (_gfc ,_aegc ).Y ]++;};};return _eeac ;};func (_dbce *NRGBA64 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtNRGBA64 (x ,y ,_dbce .Width ,_dbce .Data ,_dbce .Alpha ,_dbce .Decode );};func (_beb *Gray4 )SetGray (x ,y int ,g _e .Gray ){if x >=_beb .Width ||y >=_beb .Height {return ;};g =_gcb (g );_beb .setGray (x ,y ,g );};func (_dda *Gray8 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtGray8BPC (x ,y ,_dda .BytesPerLine ,_dda .Data ,_dda .Decode );};var _ _ec .Image =&Gray2 {};var _ NRGBA =&NRGBA32 {};type monochromeThresholdConverter struct{Threshold uint8 ;};func _ebcg (_eae _ec .Image ,_bbg Image ,_gdfe _ec .Rectangle ){switch _dfgf :=_eae .(type ){case Gray :_cad (_dfgf ,_bbg .(Gray ),_gdfe );case NRGBA :_acbb (_dfgf ,_bbg .(Gray ),_gdfe );case CMYK :_dfcf (_dfgf ,_bbg .(Gray ),_gdfe );case RGBA :_agef (_dfgf ,_bbg .(Gray ),_gdfe );default:_egd (_eae ,_bbg .(Image ),_gdfe );};};func (_gcf *Gray2 )GrayAt (x ,y int )_e .Gray {_dge ,_ :=ColorAtGray2BPC (x ,y ,_gcf .BytesPerLine ,_gcf .Data ,_gcf .Decode );return _dge ;};func (_bce *Monochrome )GrayAt (x ,y int )_e .Gray {_df ,_ :=ColorAtGray1BPC (x ,y ,_bce .BytesPerLine ,_bce .Data ,_bce .Decode );return _df ;};func _fga (_bdc _e .Gray ,_gdc monochromeModel )_e .Gray {if _bdc .Y > uint8 (_gdc ){return _e .Gray {Y :_b .MaxUint8 };};return _e .Gray {};};type Histogramer interface{Histogram ()[256]int ;};func (_agg *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_agg .copy ()}};func _fbf (_bgg _e .RGBA )_e .Gray {_bfaa :=(19595*uint32 (_bgg .R )+38470*uint32 (_bgg .G )+7471*uint32 (_bgg .B )+1<<7)>>16;return _e .Gray {Y :uint8 (_bfaa )};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Gray ,error ){_baeb :=y *bytesPerLine +x >>3;if _baeb >=len (data ){return _e .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_afb :=data [_baeb ]>>uint (7-(x &7))&1;if len (decode )==2{_afb =uint8 (LinearInterpolate (float64 (_afb ),0.0,1.0,decode [0],decode [1]))&1;};return _e .Gray {Y :_afb *255},nil ;};func (_ddef *Gray8 )Base ()*ImageBase {return &_ddef .ImageBase };func (_aab *Gray2 )Base ()*ImageBase {return &_aab .ImageBase };func (_faga *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_faga .ImageBase .copy (),ModelThreshold :_faga .ModelThreshold };};var _fcfgf [256]uint8 ;func (_agb *NRGBA64 )At (x ,y int )_e .Color {_acbf ,_ :=_agb .ColorAt (x ,y );return _acbf };func (_cbeb monochromeModel )Convert (c _e .Color )_e .Color {_ggc :=_e .GrayModel .Convert (c ).(_e .Gray );return _fga (_ggc ,_cbeb );};func (_bda *NRGBA64 )Base ()*ImageBase {return &_bda .ImageBase };func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_e .NRGBA ,error ){_ecb :=y *bytesPerLine +x *3/2;if _ecb +1>=len (data ){return _e .NRGBA {},_cfac (x ,y );};const (_caafa =0xf;_ged =uint8 (0xff););_fefe :=_ged ;if alpha !=nil {_eee :=y *BytesPerLine (width ,4,1);if _eee < len (alpha ){if x %2==0{_fefe =(alpha [_eee ]>>uint (4))&_caafa ;}else {_fefe =alpha [_eee ]&_caafa ;};_fefe |=_fefe <<4;};};var _gafb ,_fcbd ,_bag uint8 ;if x *3%2==0{_gafb =(data [_ecb ]>>uint (4))&_caafa ;_fcbd =data [_ecb ]&_caafa ;_bag =(data [_ecb +1]>>uint (4))&_caafa ;}else {_gafb =data [_ecb ]&_caafa ;_fcbd =(data [_ecb +1]>>uint (4))&_caafa ;_bag =data [_ecb +1]&_caafa ;};if len (decode )==6{_gafb =uint8 (uint32 (LinearInterpolate (float64 (_gafb ),0,15,decode [0],decode [1]))&0xf);_fcbd =uint8 (uint32 (LinearInterpolate (float64 (_fcbd ),0,15,decode [2],decode [3]))&0xf);_bag =uint8 (uint32 (LinearInterpolate (float64 (_bag ),0,15,decode [4],decode [5]))&0xf);};return _e .NRGBA {R :(_gafb <<4)|(_gafb &0xf),G :(_fcbd <<4)|(_fcbd &0xf),B :(_bag <<4)|(_bag &0xf),A :_fefe },nil ;};func _ece (_bcd _e .RGBA )_e .NRGBA {switch _bcd .A {case 0xff:return _e .NRGBA {R :_bcd .R ,G :_bcd .G ,B :_bcd .B ,A :0xff};case 0x00:return _e .NRGBA {};default:_dgf ,_dce ,_bddb ,_efdc :=_bcd .RGBA ();_dgf =(_dgf *0xffff)/_efdc ;_dce =(_dce *0xffff)/_efdc ;_bddb =(_bddb *0xffff)/_efdc ;return _e .NRGBA {R :uint8 (_dgf >>8),G :uint8 (_dce >>8),B :uint8 (_bddb >>8),A :uint8 (_efdc >>8)};};};func (_cdc *Gray2 )Set (x ,y int ,c _e .Color ){if x >=_cdc .Width ||y >=_cdc .Height {return ;};_gaf :=Gray2Model .Convert (c ).(_e .Gray );_dbd :=y *_cdc .BytesPerLine ;_abcc :=_dbd +(x >>2);_bbed :=_gaf .Y >>6;_cdc .Data [_abcc ]=(_cdc .Data [_abcc ]&(^(0xc0>>uint (2*((x )&3)))))|(_bbed <<uint (6-2*(x &3)));};func (_gbfg *Gray2 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtGray2BPC (x ,y ,_gbfg .BytesPerLine ,_gbfg .Data ,_gbfg .Decode );};var _ Image =&Gray16 {};func _accd (_abbbb *_ec .Gray16 ,_gdebf uint8 )*_ec .Gray {_fgbg :=_abbbb .Bounds ();_edg :=_ec .NewGray (_fgbg );for _gede :=0;_gede < _fgbg .Dx ();_gede ++{for _gagb :=0;_gagb < _fgbg .Dy ();_gagb ++{_febf :=_abbbb .Gray16At (_gede ,_gagb );_edg .SetGray (_gede ,_gagb ,_e .Gray {Y :_bbcb (uint8 (_febf .Y /256),_gdebf )});};};return _edg ;};func (_agfa *NRGBA32 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_agfa .Width ,Y :_agfa .Height }};};func (_bdg *NRGBA16 )At (x ,y int )_e .Color {_gdfc ,_ :=_bdg .ColorAt (x ,y );return _gdfc };func (_dbbb *Gray4 )Set (x ,y int ,c _e .Color ){if x >=_dbbb .Width ||y >=_dbbb .Height {return ;};_ecfb :=Gray4Model .Convert (c ).(_e .Gray );_dbbb .setGray (x ,y ,_ecfb );};var _ Image =&Gray2 {};func (_ebd *Gray2 )Histogram ()(_ccdb [256]int ){for _ead :=0;_ead < _ebd .Width ;_ead ++{for _ddd :=0;_ddd < _ebd .Height ;_ddd ++{_ccdb [_ebd .GrayAt (_ead ,_ddd ).Y ]++;};};return _ccdb ;};func (_eaa *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_eaa .copy ()}};var _ _ec .Image =&Gray8 {};func (_ccb *NRGBA64 )NRGBA64At (x ,y int )_e .NRGBA64 {_fede ,_ :=ColorAtNRGBA64 (x ,y ,_ccb .Width ,_ccb .Data ,_ccb .Alpha ,_ccb .Decode );return _fede ;};type NRGBA64 struct{ImageBase };func (_dga *Gray16 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtGray16BPC (x ,y ,_dga .BytesPerLine ,_dga .Data ,_dga .Decode );};func _dae (_cb _e .NRGBA )_e .CMYK {_cc ,_bee ,_ffa ,_ :=_cb .RGBA ();_ffb ,_gcg ,_dbb ,_ceee :=_e .RGBToCMYK (uint8 (_cc >>8),uint8 (_bee >>8),uint8 (_ffa >>8));return _e .CMYK {C :_ffb ,M :_gcg ,Y :_dbb ,K :_ceee };};func _bbcb (_bggd ,_gdea uint8 )uint8 {if _bggd < _gdea {return 255;};return 0;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_ecgg :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _eegg Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_eegg =&Monochrome {ImageBase :_ecgg ,ModelThreshold :0x0f};case 2:_eegg =&Gray2 {ImageBase :_ecgg };case 4:_eegg =&Gray4 {ImageBase :_ecgg };case 8:_eegg =&Gray8 {ImageBase :_ecgg };case 16:_eegg =&Gray16 {ImageBase :_ecgg };};case 3:switch bitsPerComponent {case 4:_eegg =&NRGBA16 {ImageBase :_ecgg };case 8:_eegg =&NRGBA32 {ImageBase :_ecgg };case 16:_eegg =&NRGBA64 {ImageBase :_ecgg };};case 4:_eegg =&CMYK32 {ImageBase :_ecgg };};if _eegg ==nil {return nil ,ErrInvalidImage ;};return _eegg ,nil ;};func (_dde *monochromeThresholdConverter )Convert (img _ec .Image )(Image ,error ){if _aed ,_fba :=img .(*Monochrome );_fba {return _aed .Copy (),nil ;};_gdfg :=img .Bounds ();_ggb ,_edb :=NewImage (_gdfg .Max .X ,_gdfg .Max .Y ,1,1,nil ,nil ,nil );if _edb !=nil {return nil ,_edb ;};_ggb .(*Monochrome ).ModelThreshold =_dde .Threshold ;for _fda :=0;_fda < _gdfg .Max .X ;_fda ++{for _dcb :=0;_dcb < _gdfg .Max .Y ;_dcb ++{_cgc :=img .At (_fda ,_dcb );_ggb .Set (_fda ,_dcb ,_cgc );};};return _ggb ,nil ;};func _agef (_caa RGBA ,_ace Gray ,_beeg _ec .Rectangle ){for _aecc :=0;_aecc < _beeg .Max .X ;_aecc ++{for _bef :=0;_bef < _beeg .Max .Y ;_bef ++{_fcfa :=_fbf (_caa .RGBAAt (_aecc ,_bef ));_ace .SetGray (_aecc ,_bef ,_fcfa );};};};func _bdd (_fgf _e .CMYK )_e .Gray {_bec ,_eea ,_af :=_e .CMYKToRGB (_fgf .C ,_fgf .M ,_fgf .Y ,_fgf .K );_daf :=(19595*uint32 (_bec )+38470*uint32 (_eea )+7471*uint32 (_af )+1<<7)>>16;return _e .Gray {Y :uint8 (_daf )};};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Gray16 ,error ){_cbce :=(y *bytesPerLine /2+x )*2;if _cbce +1>=len (data ){return _e .Gray16 {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_fbc :=uint16 (data [_cbce ])<<8|uint16 (data [_cbce +1]);if len (decode )==2{_fbc =uint16 (uint64 (LinearInterpolate (float64 (_fbc ),0,65535,decode [0],decode [1])));};return _e .Gray16 {Y :_fbc },nil ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_e .CMYK ,error ){_gd :=4*(y *width +x );if _gd +3>=len (data ){return _e .CMYK {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_gd ]&0xff;M :=data [_gd +1]&0xff;Y :=data [_gd +2]&0xff;K :=data [_gd +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _e .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_ggce *Gray16 )Set (x ,y int ,c _e .Color ){_cbef :=(y *_ggce .BytesPerLine /2+x )*2;if _cbef +1>=len (_ggce .Data ){return ;};_cdg :=_e .Gray16Model .Convert (c ).(_e .Gray16 );_ggce .Data [_cbef ],_ggce .Data [_cbef +1]=uint8 (_cdg .Y >>8),uint8 (_cdg .Y &0xff);};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _egd (_ega _ec .Image ,_dbc Image ,_dbeg _ec .Rectangle ){for _fag :=0;_fag < _dbeg .Max .X ;_fag ++{for _edc :=0;_edc < _dbeg .Max .Y ;_edc ++{_ca :=_ega .At (_fag ,_edc );_dbc .Set (_fag ,_edc ,_ca );};};};func (_efg *NRGBA64 )ColorModel ()_e .Model {return _e .NRGBA64Model };func _eebe (_ebcb _ec .Image )(Image ,error ){if _dbdc ,_gec :=_ebcb .(*Gray4 );_gec {return _dbdc .Copy (),nil ;};_fbbf :=_ebcb .Bounds ();_bga ,_fef :=NewImage (_fbbf .Max .X ,_fbbf .Max .Y ,4,1,nil ,nil ,nil );if _fef !=nil {return nil ,_fef ;};_ebcg (_ebcb ,_bga ,_fbbf );return _bga ,nil ;};var ErrInvalidImage =_g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");func _aadg (_geb _e .Color )_e .Color {_ede :=_e .NRGBAModel .Convert (_geb ).(_e .NRGBA );return _dage (_ede );};func (_bace *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_bace .copy ()}};func (_cab *Gray16 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_cab .Width ,Y :_cab .Height }};};func (_fbbg *Gray16 )SetGray (x ,y int ,g _e .Gray ){_cafe :=(y *_fbbg .BytesPerLine /2+x )*2;if _cafe +1>=len (_fbbg .Data ){return ;};_fbbg .Data [_cafe ]=g .Y ;_fbbg .Data [_cafe +1]=g .Y ;};var _ NRGBA =&NRGBA16 {};type colorConverter struct{_abc func (_bd _ec .Image )(Image ,error );};func (_dfge *ImageBase )newAlpha (){_fcc :=BytesPerLine (_dfge .Width ,_dfge .BitsPerComponent ,1);_dfge .Alpha =make ([]byte ,_dfge .Height *_fcc );};var _ Gray =&Gray2 {};func _dgg (_acgg _e .Color )_e .Color {_abd :=_e .GrayModel .Convert (_acgg ).(_e .Gray );return _caf (_abd )};var _ Image =&Gray4 {};func (_bac *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_bac .copy ()}};var _ Image =&Gray8 {};func (_bfag *NRGBA16 )Set (x ,y int ,c _e .Color ){_fdcaa :=y *_bfag .BytesPerLine +x *3/2;if _fdcaa +1>=len (_bfag .Data ){return ;};_bba :=NRGBA16Model .Convert (c ).(_e .NRGBA );_bfag .setNRGBA (x ,y ,_fdcaa ,_bba );};func (_ecg *Monochrome )ColorModel ()_e .Model {return MonochromeModel (_ecg .ModelThreshold )};func _dage (_ggd _e .NRGBA )_e .NRGBA {_ggd .R =_ggd .R >>4|(_ggd .R >>4)<<4;_ggd .G =_ggd .G >>4|(_ggd .G >>4)<<4;_ggd .B =_ggd .B >>4|(_ggd .B >>4)<<4;return _ggd ;};func (_afe *NRGBA32 )Base ()*ImageBase {return &_afe .ImageBase };func (_gdb *Monochrome )At (x ,y int )_e .Color {_dag ,_ :=_gdb .ColorAt (x ,y );return _dag };type NRGBA16 struct{ImageBase };var _ Image =&NRGBA64 {};func (_fe *CMYK32 )ColorModel ()_e .Model {return _e .CMYKModel };func MonochromeModel (threshold uint8 )_e .Model {return monochromeModel (threshold )};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_e .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_f .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func _cfac (_ceeeg int ,_bbff int )error {return _f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_ceeeg ,_bbff );};func _efd (_gfg _e .NRGBA )_e .Gray {_be ,_gff ,_dgc ,_ :=_gfg .RGBA ();_gde :=(19595*_be +38470*_gff +7471*_dgc +1<<15)>>24;return _e .Gray {Y :uint8 (_gde )};};func _egee (_aabc _ec .Image )(Image ,error ){if _aecg ,_gcd :=_aabc .(*Gray8 );_gcd {return _aecg .Copy (),nil ;};_ggcg :=_aabc .Bounds ();_bgeg ,_dcbd :=NewImage (_ggcg .Max .X ,_ggcg .Max .Y ,8,1,nil ,nil ,nil );if _dcbd !=nil {return nil ,_dcbd ;};_ebcg (_aabc ,_bgeg ,_ggcg );return _bgeg ,nil ;};var _ Image =&CMYK32 {};func (_bcdc *Monochrome )clearBit (_bfb ,_fabca int ){_bcdc .Data [_bfb ]&=^(0x80>>uint (_fabca &7))};func (_ddcb *Monochrome )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_ddcb .Width ,Y :_ddcb .Height }};};func (_bcbe *Gray8 )Set (x ,y int ,c _e .Color ){_gbfd :=y *_bcbe .BytesPerLine +x ;if _gbfd > len (_bcbe .Data )-1{return ;};_cge :=_e .GrayModel .Convert (c );_bcbe .Data [_gbfd ]=_cge .(_e .Gray ).Y ;};func (_febca *NRGBA32 )NRGBAAt (x ,y int )_e .NRGBA {_fgaa ,_ :=ColorAtNRGBA32 (x ,y ,_febca .Width ,_febca .Data ,_febca .Alpha ,_febca .Decode );return _fgaa ;};func (_gg *CMYK32 )CMYKAt (x ,y int )_e .CMYK {_gga ,_ :=ColorAtCMYK (x ,y ,_gg .Width ,_gg .Data ,_gg .Decode );return _gga ;};func (_gca *Gray8 )Validate ()error {if len (_gca .Data )!=_gca .Height *_gca .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_ecd *NRGBA32 )setRGBA (_efae int ,_eca _e .NRGBA ){_dbbc :=3*_efae ;_ecd .Data [_dbbc ]=_eca .R ;_ecd .Data [_dbbc +1]=_eca .G ;_ecd .Data [_dbbc +2]=_eca .B ;if _efae < len (_ecd .Alpha ){_ecd .Alpha [_efae ]=_eca .A ;};};var _ _ec .Image =&NRGBA32 {};type CMYK32 struct{ImageBase };func _eba (_fab _e .Gray )_e .CMYK {return _e .CMYK {K :0xff-_fab .Y }};func (_dfd *Gray4 )setGray (_gfa int ,_ceg int ,_fcab _e .Gray ){_ebc :=_ceg *_dfd .BytesPerLine ;_bcfb :=_ebc +(_gfa >>1);if _bcfb >=len (_dfd .Data ){return ;};_fea :=_fcab .Y >>4;_dfd .Data [_bcfb ]=(_dfd .Data [_bcfb ]&(^(0xf0>>uint (4*(_gfa &1)))))|(_fea <<uint (4-4*(_gfa &1)));};func _fdg (_dfcg _ec .Image ,_fgde uint8 )*_ec .Gray {_fgad :=_dfcg .Bounds ();_egeg :=_ec .NewGray (_fgad );var (_aecb _e .Color ;_dffe _e .Gray ;);for _cdbag :=0;_cdbag < _fgad .Max .X ;_cdbag ++{for _dbdb :=0;_dbdb < _fgad .Max .Y ;_dbdb ++{_aecb =_dfcg .At (_cdbag ,_dbdb );_egeg .Set (_cdbag ,_dbdb ,_aecb );_dffe =_egeg .GrayAt (_cdbag ,_dbdb );_egeg .SetGray (_cdbag ,_dbdb ,_e .Gray {Y :_bbcb (_dffe .Y ,_fgde )});};};return _egeg ;};func (_aac *NRGBA64 )SetNRGBA64 (x ,y int ,c _e .NRGBA64 ){_aebd :=(y *_aac .Width +x )*2;_aedfb :=_aebd *3;if _aedfb +5>=len (_aac .Data ){return ;};_aac .setNRGBA64 (_aedfb ,c ,_aebd );};func (_daa *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_daa .copy ()}};func _fdca (_acb _e .Color )_e .Color {_cafd :=_e .GrayModel .Convert (_acb ).(_e .Gray );return _gcb (_cafd )};func (_fae *Monochrome )Validate ()error {if len (_fae .Data )!=_fae .Height *_fae .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_fega *Gray16 )GrayAt (x ,y int )_e .Gray {_bfbe ,_ :=_fega .ColorAt (x ,y );return _e .Gray {Y :uint8 (_bfbe .(_e .Gray16 ).Y >>8)};};func (_ddba *NRGBA16 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtNRGBA16 (x ,y ,_ddba .Width ,_ddba .BytesPerLine ,_ddba .Data ,_ddba .Alpha ,_ddba .Decode );};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_e .NRGBA ,error ){_gfde :=y *width +x ;_ccg :=3*_gfde ;if _ccg +2>=len (data ){return _e .NRGBA {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_afba :=uint8 (0xff);if alpha !=nil &&len (alpha )> _gfde {_afba =alpha [_gfde ];};_dgac ,_gecb ,_eab :=data [_ccg ],data [_ccg +1],data [_ccg +2];if len (decode )==6{_dgac =uint8 (uint32 (LinearInterpolate (float64 (_dgac ),0,255,decode [0],decode [1]))&0xff);_gecb =uint8 (uint32 (LinearInterpolate (float64 (_gecb ),0,255,decode [2],decode [3]))&0xff);_eab =uint8 (uint32 (LinearInterpolate (float64 (_eab ),0,255,decode [4],decode [5]))&0xff);};return _e .NRGBA {R :_dgac ,G :_gecb ,B :_eab ,A :_afba },nil ;};var _ Gray =&Gray16 {};func (_cfcf *NRGBA64 )Set (x ,y int ,c _e .Color ){_faf :=(y *_cfcf .Width +x )*2;_aaae :=_faf *3;if _aaae +5>=len (_cfcf .Data ){return ;};_eed :=_e .NRGBA64Model .Convert (c ).(_e .NRGBA64 );_cfcf .setNRGBA64 (_aaae ,_eed ,_faf );};type CMYK interface{CMYKAt (_fg ,_a int )_e .CMYK ;SetCMYK (_ce ,_ba int ,_db _e .CMYK );};func (_acf *Monochrome )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtGray1BPC (x ,y ,_acf .BytesPerLine ,_acf .Data ,_acf .Decode );};func (_ccce *ImageBase )copy ()ImageBase {_fbg :=*_ccce ;_fbg .Data =make ([]byte ,len (_ccce .Data ));copy (_fbg .Data ,_ccce .Data );return _fbg ;};func (_aege *ImageBase )Pix ()[]byte {return _aege .Data };func (_fcfg *Gray16 )Base ()*ImageBase {return &_fcfg .ImageBase };func (_eagc *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_eagc .copy ()}};func (_cagg *Gray8 )ColorModel ()_e .Model {return _e .GrayModel };type Gray8 struct{ImageBase };func (_egde *NRGBA16 )Validate ()error {if len (_egde .Data )!=3*_egde .Width *_egde .Height /2{return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};var _ _ec .Image =&NRGBA64 {};func (_acg *Gray2 )At (x ,y int )_e .Color {_dfa ,_ :=_acg .ColorAt (x ,y );return _dfa };func (_gbg *Gray4 )GrayAt (x ,y int )_e .Gray {_fad ,_ :=ColorAtGray4BPC (x ,y ,_gbg .BytesPerLine ,_gbg .Data ,_gbg .Decode );return _fad ;};type Gray2 struct{ImageBase };func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Gray ,error ){_eade :=y *bytesPerLine +x ;if _eade >=len (data ){return _e .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dbf :=data [_eade ];if len (decode )==2{_dbf =uint8 (uint32 (LinearInterpolate (float64 (_dbf ),0,255,decode [0],decode [1]))&0xff);};return _e .Gray {Y :_dbf },nil ;};func (_gdd *ImageBase )HasAlpha ()bool {return _gdd .Alpha !=nil };func _ab (_gc Gray ,_dbe CMYK ,_dc _ec .Rectangle ){for _gce :=0;_gce < _dc .Max .X ;_gce ++{for _feg :=0;_feg < _dc .Max .Y ;_feg ++{_ceb :=_gc .GrayAt (_gce ,_feg );_dbe .SetCMYK (_gce ,_feg ,_eba (_ceb ));};};};var _ Image =&NRGBA32 {};func (_fdcf *Monochrome )Histogram ()(_egc [256]int ){for _ ,_ffbg :=range _fdcf .Data {_egc [0xff]+=int (_fcfgf [_fdcf .Data [_ffbg ]]);};return _egc ;};func (_fcdf *NRGBA32 )At (x ,y int )_e .Color {_afed ,_ :=_fcdf .ColorAt (x ,y );return _afed };func ConverterFunc (converterFunc func (_bf _ec .Image )(Image ,error ))ColorConverter {return colorConverter {_abc :converterFunc };};func (_dg *CMYK32 )Validate ()error {if len (_dg .Data )!=4*_dg .Width *_dg .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_gea :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_gea .Data =make ([]byte ,height *_gea .BytesPerLine );};return _gea ;};func _ccge (_ecge *_ec .Gray ,_deeg uint8 )*_ec .Gray {_dgcc :=_ecge .Bounds ();_aaf :=_ec .NewGray (_dgcc );for _gab :=0;_gab < _dgcc .Dx ();_gab ++{for _bbca :=0;_bbca < _dgcc .Dy ();_bbca ++{_bgff :=_ecge .GrayAt (_gab ,_bbca );_aaf .SetGray (_gab ,_bbca ,_e .Gray {Y :_bbcb (_bgff .Y ,_deeg )});};};return _aaf ;};func _fgdc (_ddag Gray ,_geegb NRGBA ,_cgcb _ec .Rectangle ){for _bcg :=0;_bcg < _cgcb .Max .X ;_bcg ++{for _dee :=0;_dee < _cgcb .Max .Y ;_dee ++{_fgfd :=_ddag .GrayAt (_bcg ,_dee );_geegb .SetNRGBA (_bcg ,_dee ,_ag (_fgfd ));};};};func (_cf *CMYK32 )SetCMYK (x ,y int ,c _e .CMYK ){_cee :=4*(y *_cf .Width +x );if _cee +3>=len (_cf .Data ){return ;};_cf .Data [_cee ]=c .C ;_cf .Data [_cee +1]=c .M ;_cf .Data [_cee +2]=c .Y ;_cf .Data [_cee +3]=c .K ;};type monochromeModel uint8 ;func _ccf (_acc ,_ebdd NRGBA ,_cdcg _ec .Rectangle ){for _ecaf :=0;_ecaf < _cdcg .Max .X ;_ecaf ++{for _bbee :=0;_bbee < _cdcg .Max .Y ;_bbee ++{_ebdd .SetNRGBA (_ecaf ,_bbee ,_acc .NRGBAAt (_ecaf ,_bbee ));};};};func (_egdc *Gray8 )SetGray (x ,y int ,g _e .Gray ){_cbcc :=y *_egdc .BytesPerLine +x ;if _cbcc > len (_egdc .Data )-1{return ;};_egdc .Data [_cbcc ]=g .Y ;};func (_cbcb *NRGBA32 )Set (x ,y int ,c _e .Color ){_cgd :=y *_cbcb .Width +x ;_aceb :=3*_cgd ;if _aceb +2>=len (_cbcb .Data ){return ;};_fgac :=_e .NRGBAModel .Convert (c ).(_e .NRGBA );_cbcb .setRGBA (_cgd ,_fgac );};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_f .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func (_eagd *NRGBA16 )ColorModel ()_e .Model {return NRGBA16Model };func _cga (_eccc RGBA ,_eef CMYK ,_ege _ec .Rectangle ){for _ddc :=0;_ddc < _ege .Max .X ;_ddc ++{for _ge :=0;_ge < _ege .Max .Y ;_ge ++{_cebd :=_eccc .RGBAAt (_ddc ,_ge );_eef .SetCMYK (_ddc ,_ge ,_bde (_cebd ));};};};func (_abba *NRGBA32 )Validate ()error {if len (_abba .Data )!=3*_abba .Width *_abba .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_ad *Monochrome )Set (x ,y int ,c _e .Color ){_bab :=y *_ad .BytesPerLine +x >>3;if _bab > len (_ad .Data )-1{return ;};_bfgb :=_ad .ColorModel ().Convert (c ).(_e .Gray );_ad .setGray (x ,_bfgb ,_bab );};type Gray16 struct{ImageBase };func _cad (_afbb ,_dbag Gray ,_ebg _ec .Rectangle ){for _bced :=0;_bced < _ebg .Max .X ;_bced ++{for _fgdb :=0;_fgdb < _ebg .Max .Y ;_fgdb ++{_dbag .SetGray (_bced ,_fgdb ,_afbb .GrayAt (_bced ,_fgdb ));};};};func (_egcaa *Gray4 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_egcaa .Width ,Y :_egcaa .Height }};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_e .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_f .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};func (_ffd *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ffd .copy ()}};type Gray4 struct{ImageBase };func (_bfbd *Gray4 )ColorModel ()_e .Model {return Gray4Model };type ColorConverter interface{Convert (_gbf _ec .Image )(Image ,error );};func (_dad *Gray16 )Histogram ()(_fcb [256]int ){for _febc :=0;_febc < _dad .Width ;_febc ++{for _bbf :=0;_bbf < _dad .Height ;_bbf ++{_fcb [_dad .GrayAt (_febc ,_bbf ).Y ]++;};};return _fcb ;};func _gbec (_bgca uint8 )bool {if _bgca ==0||_bgca ==255{return true ;};return false ;};func _beba (_baaa _ec .Image )(Image ,error ){if _abe ,_cfgg :=_baaa .(*NRGBA64 );_cfgg {return _abe .Copy (),nil ;};_edcg :=_baaa .Bounds ();_egae ,_bddbg :=NewImage (_edcg .Max .X ,_edcg .Max .Y ,16,3,nil ,nil ,nil );if _bddbg !=nil {return nil ,_bddbg ;};_feca (_baaa ,_egae ,_edcg );return _egae ,nil ;};func (_ada *Gray4 )Validate ()error {if len (_ada .Data )!=_ada .Height *_ada .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_cae *NRGBA64 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_cae .Width ,Y :_cae .Height }};};func _acbb (_eefc NRGBA ,_bfaad Gray ,_gbfa _ec .Rectangle ){for _cfff :=0;_cfff < _gbfa .Max .X ;_cfff ++{for _gadf :=0;_gadf < _gbfa .Max .Y ;_gadf ++{_adfg :=_efd (_eefc .NRGBAAt (_cfff ,_gadf ));_bfaad .SetGray (_cfff ,_gadf ,_adfg );};};};func _dca (){for _dgga :=0;_dgga < 256;_dgga ++{_fcfgf [_dgga ]=uint8 (_dgga &0x1)+(uint8 (_dgga >>1)&0x1)+(uint8 (_dgga >>2)&0x1)+(uint8 (_dgga >>3)&0x1)+(uint8 (_dgga >>4)&0x1)+(uint8 (_dgga >>5)&0x1)+(uint8 (_dgga >>6)&0x1)+(uint8 (_dgga >>7)&0x1);};};func _aggf (_aaaf _ec .Image )(Image ,error ){if _bedc ,_gac :=_aaaf .(*NRGBA32 );_gac {return _bedc .Copy (),nil ;};_gbde :=_aaaf .Bounds ();_dadg ,_acbd :=NewImage (_gbde .Max .X ,_gbde .Max .Y ,8,3,nil ,nil ,nil );if _acbd !=nil {return nil ,_acbd ;};_feca (_aaaf ,_dadg ,_gbde );return _dadg ,nil ;};func _aa (_fee _ec .Image )(Image ,error ){if _efea ,_ebab :=_fee .(*Monochrome );_ebab {return _efea ,nil ;};_ebe ,_gdf :=_fee .(Gray );if !_gdf {_bbe ,_eage :=GrayConverter .Convert (_fee );if _eage !=nil {return nil ,_eage ;};_ebe =_bbe .(Gray );};_cec :=_fee .Bounds ();_bfd ,_eeb :=NewImage (_cec .Max .X ,_cec .Max .Y ,1,1,nil ,nil ,nil );if _eeb !=nil {return nil ,_eeb ;};_ac :=_bfd .(*Monochrome );_abgb :=AutoThresholdTriangle (GrayHistogram (_ebe ));for _dcf :=0;_dcf < _cec .Max .X ;_dcf ++{for _bbeb :=0;_bbeb < _cec .Max .Y ;_bbeb ++{_gee :=_fga (_ebe .GrayAt (_dcf ,_bbeb ),monochromeModel (_abgb ));_ac .SetGray (_dcf ,_bbeb ,_gee );};};return _bfd ,nil ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_f .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};func (_cag *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_cag .copy ()}};type Image interface{_ea .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_eadg ,_egdb int )(_e .Color ,error );Validate ()error ;};var _ Gray =&Gray8 {};func IsGrayImgBlackAndWhite (i *_ec .Gray )bool {return _edbf (i )};