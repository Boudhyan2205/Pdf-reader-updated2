//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "bytes";_e "github.com/unidoc/unipdf/v3/common";_gf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_fd "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func (_dab *Encoder )code1 (_fdc *codingContext ,_dfg uint32 ,_dgag uint16 ,_gbf byte ){if _fdc .mps (_dfg )==1{_dab .codeMPS (_fdc ,_dfg ,_dgag ,_gbf );
}else {_dab .codeLPS (_fdc ,_dfg ,_dgag ,_gbf );};};func New ()*Encoder {_ge :=&Encoder {};_ge .Init ();return _ge };func (_fff *Encoder )EncodeOOB (proc Class )(_cfbb error ){_e .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _cfbb =_fff .encodeOOB (proc );_cfbb !=nil {return _fd .Wrap (_cfbb ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_bba *Encoder )Reset (){_bba ._ga =0x8000;_bba ._ca =0;_bba ._feg =12;_bba ._dg =-1;_bba ._dc =0;_bba ._gg =nil ;
_bba ._ff =_fgd (_gadb );};type intEncRangeS struct{_fc ,_eb int ;_fe ,_fef uint8 ;_b uint16 ;_ea uint8 ;};func (_geb *Encoder )encodeBit (_ffa *codingContext ,_dae uint32 ,_gbbb uint8 )error {const _fba ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_geb ._fge ++;if _dae >=uint32 (len (_ffa ._cc )){return _fd .Errorf (_fba ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_dae );
};_baca :=_ffa ._cc [_dae ];_efge :=_ffa .mps (_dae );_bacd :=_acg [_baca ]._cge ;_e .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_geb ._fge ,_gbbb ,_baca ,_efge ,_bacd ,_geb ._ga ,_geb ._ca ,_geb ._feg ,_geb ._dc ,_geb ._dg );
if _gbbb ==0{_geb .code0 (_ffa ,_dae ,_bacd ,_baca );}else {_geb .code1 (_ffa ,_dae ,_bacd ,_baca );};return nil ;};func (_gba *Encoder )lBlock (){if _gba ._dg >=0{_gba .emit ();};_gba ._dg ++;_gba ._dc =uint8 (_gba ._ca >>19);_gba ._ca &=0x7ffff;_gba ._feg =8;
};func (_dde *Encoder )setBits (){_bdd :=_dde ._ca +uint32 (_dde ._ga );_dde ._ca |=0xffff;if _dde ._ca >=_bdd {_dde ._ca -=0x8000;};};func (_da *codingContext )mps (_bbc uint32 )int {return int (_da ._ba [_bbc ])};func (_gadc *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _ede ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _cbae int64 ;for _cff ,_gbb :=range _gadc ._gc {_gacd ,_ffg :=w .Write (_gbb );if _ffg !=nil {return 0,_fd .Wrapf (_ffg ,_ede ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cff );
};_cbae +=int64 (_gacd );};_gadc ._fae =_gadc ._fae [:_gadc ._bae ];_adg ,_efg :=w .Write (_gadc ._fae );if _efg !=nil {return 0,_fd .Wrap (_efg ,_ede ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cbae +=int64 (_adg );
return _cbae ,nil ;};func (_dd *Encoder )encodeInteger (_ae Class ,_beg int )error {const _adgc ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _beg > 2000000000||_beg < -2000000000{return _fd .Errorf (_adgc ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_beg );
};_agb :=_dd ._baf [_ae ];_bf :=uint32 (1);var _ggc int ;for ;;_ggc ++{if _bb [_ggc ]._fc <=_beg &&_bb [_ggc ]._eb >=_beg {break ;};};if _beg < 0{_beg =-_beg ;};_beg -=int (_bb [_ggc ]._b );_ce :=_bb [_ggc ]._fe ;for _aag :=uint8 (0);_aag < _bb [_ggc ]._fef ;
_aag ++{_bfa :=_ce &1;if _cag :=_dd .encodeBit (_agb ,_bf ,_bfa );_cag !=nil {return _fd .Wrap (_cag ,_adgc ,"");};_ce >>=1;if _bf &0x100> 0{_bf =(((_bf <<1)|uint32 (_bfa ))&0x1ff)|0x100;}else {_bf =(_bf <<1)|uint32 (_bfa );};};_beg <<=32-_bb [_ggc ]._ea ;
for _ece :=uint8 (0);_ece < _bb [_ggc ]._ea ;_ece ++{_ggb :=uint8 ((uint32 (_beg )&0x80000000)>>31);if _fdd :=_dd .encodeBit (_agb ,_bf ,_ggb );_fdd !=nil {return _fd .Wrap (_fdd ,_adgc ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_beg <<=1;if _bf &0x100!=0{_bf =(((_bf <<1)|uint32 (_ggb ))&0x1ff)|0x100;}else {_bf =(_bf <<1)|uint32 (_ggb );};};return nil ;};func (_c Class )String ()string {switch _c {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};func (_a *Encoder )DataSize ()int {return _a .dataSize ()};func (_fdg *Encoder )emit (){if _fdg ._bae ==_fcf {_fdg ._gc =append (_fdg ._gc ,_fdg ._fae );_fdg ._fae =make ([]byte ,_fcf );_fdg ._bae =0;};_fdg ._fae [_fdg ._bae ]=_fdg ._dc ;_fdg ._bae ++;
};var _acg =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
const (_gadb =65536;_fcf =20*1024;);const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_ad *Encoder )Final (){_ad .flush ()};func (_feb *Encoder )Refine (iTemp ,iTarget *_gf .Bitmap ,ox ,oy int )error {for _fca :=0;
_fca < iTarget .Height ;_fca ++{var _bce int ;_ag :=_fca +oy ;var (_cba ,_ac ,_eefb ,_cce ,_ebb uint16 ;_af ,_ebe ,_ed ,_db ,_agc byte ;);if _ag >=1&&(_ag -1)< iTemp .Height {_af =iTemp .Data [(_ag -1)*iTemp .RowStride ];};if _ag >=0&&_ag < iTemp .Height {_ebe =iTemp .Data [_ag *iTemp .RowStride ];
};if _ag >=-1&&_ag +1< iTemp .Height {_ed =iTemp .Data [(_ag +1)*iTemp .RowStride ];};if _fca >=1{_db =iTarget .Data [(_fca -1)*iTarget .RowStride ];};_agc =iTarget .Data [_fca *iTarget .RowStride ];_fefa :=uint (6+ox );_cba =uint16 (_af >>_fefa );_ac =uint16 (_ebe >>_fefa );
_eefb =uint16 (_ed >>_fefa );_cce =uint16 (_db >>6);_agf :=uint (2-ox );_af <<=_agf ;_ebe <<=_agf ;_ed <<=_agf ;_db <<=2;for _bce =0;_bce < iTarget .Width ;_bce ++{_eee :=(_cba <<10)|(_ac <<7)|(_eefb <<4)|(_cce <<1)|_ebb ;_bd :=_agc >>7;_gbeg :=_feb .encodeBit (_feb ._ff ,uint32 (_eee ),_bd );
if _gbeg !=nil {return _gbeg ;};_cba <<=1;_ac <<=1;_eefb <<=1;_cce <<=1;_cba |=uint16 (_af >>7);_ac |=uint16 (_ebe >>7);_eefb |=uint16 (_ed >>7);_cce |=uint16 (_db >>7);_ebb =uint16 (_bd );_bg :=_bce %8;_ggg :=_bce /8+1;if _bg ==5+ox {_af ,_ebe ,_ed =0,0,0;
if _ggg < iTemp .RowStride &&_ag >=1&&(_ag -1)< iTemp .Height {_af =iTemp .Data [(_ag -1)*iTemp .RowStride +_ggg ];};if _ggg < iTemp .RowStride &&_ag >=0&&_ag < iTemp .Height {_ebe =iTemp .Data [_ag *iTemp .RowStride +_ggg ];};if _ggg < iTemp .RowStride &&_ag >=-1&&(_ag +1)< iTemp .Height {_ed =iTemp .Data [(_ag +1)*iTemp .RowStride +_ggg ];
};}else {_af <<=1;_ebe <<=1;_ed <<=1;};if _bg ==5&&_fca >=1{_db =0;if _ggg < iTarget .RowStride {_db =iTarget .Data [(_fca -1)*iTarget .RowStride +_ggg ];};}else {_db <<=1;};if _bg ==7{_agc =0;if _ggg < iTarget .RowStride {_agc =iTarget .Data [_fca *iTarget .RowStride +_ggg ];
};}else {_agc <<=1;};_cba &=7;_ac &=7;_eefb &=7;_cce &=7;};};return nil ;};func (_cd *Encoder )encodeIAID (_gaf ,_gab int )error {if _cd ._gg ==nil {_cd ._gg =_fgd (1<<uint (_gaf ));};_eag :=uint32 (1<<uint32 (_gaf +1))-1;_gab <<=uint (32-_gaf );_afa :=uint32 (1);
for _ccd :=0;_ccd < _gaf ;_ccd ++{_cbg :=_afa &_eag ;_cdf :=uint8 ((uint32 (_gab )&0x80000000)>>31);if _acc :=_cd .encodeBit (_cd ._gg ,_cbg ,_cdf );_acc !=nil {return _acc ;};_afa =(_afa <<1)|uint32 (_cdf );_gab <<=1;};return nil ;};func (_gef *Encoder )EncodeInteger (proc Class ,value int )(_bbf error ){_e .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _bbf =_gef .encodeInteger (proc ,value );_bbf !=nil {return _fd .Wrap (_bbf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func _fgd (_fa int )*codingContext {return &codingContext {_cc :make ([]byte ,_fa ),_ba :make ([]byte ,_fa )};
};type Class int ;func (_fabf *Encoder )rBlock (){if _fabf ._dg >=0{_fabf .emit ();};_fabf ._dg ++;_fabf ._dc =uint8 (_fabf ._ca >>20);_fabf ._ca &=0xfffff;_fabf ._feg =7;};func (_gcf *Encoder )dataSize ()int {return _fcf *len (_gcf ._gc )+_gcf ._bae };
func (_fab *Encoder )code0 (_ec *codingContext ,_bdc uint32 ,_eec uint16 ,_dga byte ){if _ec .mps (_bdc )==0{_fab .codeMPS (_ec ,_bdc ,_eec ,_dga );}else {_fab .codeLPS (_ec ,_bdc ,_eec ,_dga );};};func (_fg *codingContext )flipMps (_gb uint32 ){_fg ._ba [_gb ]=1-_fg ._ba [_gb ]};
func (_aca *Encoder )codeMPS (_bafb *codingContext ,_bga uint32 ,_cca uint16 ,_be byte ){_aca ._ga -=_cca ;if _aca ._ga &0x8000!=0{_aca ._ca +=uint32 (_cca );return ;};if _aca ._ga < _cca {_aca ._ga =_cca ;}else {_aca ._ca +=uint32 (_cca );};_bafb ._cc [_bga ]=_acg [_be ]._ab ;
_aca .renormalize ();};type state struct{_cge uint16 ;_ab ,_ccag uint8 ;_cec uint8 ;};func (_gbbg *Encoder )renormalize (){for {_gbbg ._ga <<=1;_gbbg ._ca <<=1;_gbbg ._feg --;if _gbbg ._feg ==0{_gbbg .byteOut ();};if (_gbbg ._ga &0x8000)!=0{break ;};};
};func (_ffd *Encoder )codeLPS (_fag *codingContext ,_fdab uint32 ,_ebd uint16 ,_cbc byte ){_ffd ._ga -=_ebd ;if _ffd ._ga < _ebd {_ffd ._ca +=uint32 (_ebd );}else {_ffd ._ga =_ebd ;};if _acg [_cbc ]._cec ==1{_fag .flipMps (_fdab );};_fag ._cc [_fdab ]=_acg [_cbc ]._ccag ;
_ffd .renormalize ();};func (_bab *Encoder )encodeOOB (_eeb Class )error {_gbd :=_bab ._baf [_eeb ];_gbc :=_bab .encodeBit (_gbd ,1,1);if _gbc !=nil {return _gbc ;};_gbc =_bab .encodeBit (_gbd ,3,0);if _gbc !=nil {return _gbc ;};_gbc =_bab .encodeBit (_gbd ,6,0);
if _gbc !=nil {return _gbc ;};_gbc =_bab .encodeBit (_gbd ,12,0);if _gbc !=nil {return _gbc ;};return nil ;};var _ _d .WriterTo =&Encoder {};func (_gga *Encoder )EncodeBitmap (bm *_gf .Bitmap ,duplicateLineRemoval bool )error {_e .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_cg ,_cf uint8 ;_fgg ,_gbe ,_cfb uint16 ;_bc ,_cb ,_ee byte ;_aa ,_dcg ,_faec int ;_bac ,_eab []byte ;);for _df :=0;_df < bm .Height ;_df ++{_bc ,_cb =0,0;if _df >=2{_bc =bm .Data [(_df -2)*bm .RowStride ];};if _df >=1{_cb =bm .Data [(_df -1)*bm .RowStride ];
if duplicateLineRemoval {_dcg =_df *bm .RowStride ;_bac =bm .Data [_dcg :_dcg +bm .RowStride ];_faec =(_df -1)*bm .RowStride ;_eab =bm .Data [_faec :_faec +bm .RowStride ];if _g .Equal (_bac ,_eab ){_cf =_cg ^1;_cg =1;}else {_cf =_cg ;_cg =0;};};};if duplicateLineRemoval {if _gad :=_gga .encodeBit (_gga ._ff ,_fda ,_cf );
_gad !=nil {return _gad ;};if _cg !=0{continue ;};};_ee =bm .Data [_df *bm .RowStride ];_fgg =uint16 (_bc >>5);_gbe =uint16 (_cb >>4);_bc <<=3;_cb <<=4;_cfb =0;for _aa =0;_aa < bm .Width ;_aa ++{_eef :=uint32 (_fgg <<11|_gbe <<4|_cfb );_ef :=(_ee &0x80)>>7;
_gfd :=_gga .encodeBit (_gga ._ff ,_eef ,_ef );if _gfd !=nil {return _gfd ;};_fgg <<=1;_gbe <<=1;_cfb <<=1;_fgg |=uint16 ((_bc &0x80)>>7);_gbe |=uint16 ((_cb &0x80)>>7);_cfb |=uint16 (_ef );_eg :=_aa %8;_aae :=_aa /8+1;if _eg ==4&&_df >=2{_bc =0;if _aae < bm .RowStride {_bc =bm .Data [(_df -2)*bm .RowStride +_aae ];
};}else {_bc <<=1;};if _eg ==3&&_df >=1{_cb =0;if _aae < bm .RowStride {_cb =bm .Data [(_df -1)*bm .RowStride +_aae ];};}else {_cb <<=1;};if _eg ==7{_ee =0;if _aae < bm .RowStride {_ee =bm .Data [_df *bm .RowStride +_aae ];};}else {_ee <<=1;};_fgg &=31;
_gbe &=127;_cfb &=15;};};return nil ;};func (_fb *Encoder )Flush (){_fb ._bae =0;_fb ._gc =nil ;_fb ._dg =-1};type codingContext struct{_cc []byte ;_ba []byte ;};const _fda =0x9b25;func (_bbae *Encoder )byteOut (){if _bbae ._dc ==0xff{_bbae .rBlock ();
return ;};if _bbae ._ca < 0x8000000{_bbae .lBlock ();return ;};_bbae ._dc ++;if _bbae ._dc !=0xff{_bbae .lBlock ();return ;};_bbae ._ca &=0x7ffffff;_bbae .rBlock ();};func (_faf *Encoder )Init (){_faf ._ff =_fgd (_gadb );_faf ._ga =0x8000;_faf ._ca =0;
_faf ._feg =12;_faf ._dg =-1;_faf ._dc =0;_faf ._bae =0;_faf ._fae =make ([]byte ,_fcf );for _fcd :=0;_fcd < len (_faf ._baf );_fcd ++{_faf ._baf [_fcd ]=_fgd (512);};_faf ._gg =nil ;};var _bb =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_bff *Encoder )flush (){_bff .setBits ();_bff ._ca <<=_bff ._feg ;_bff .byteOut ();_bff ._ca <<=_bff ._feg ;_bff .byteOut ();_bff .emit ();if _bff ._dc !=0xff{_bff ._dg ++;_bff ._dc =0xff;_bff .emit ();};_bff ._dg ++;_bff ._dc =0xac;_bff ._dg ++;
_bff .emit ();};func (_dca *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gac error ){_e .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gac =_dca .encodeIAID (symbolCodeLength ,value );_gac !=nil {return _fd .Wrap (_gac ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type Encoder struct{_ca uint32 ;_ga uint16 ;_feg ,_dc uint8 ;_dg int ;_fge int ;
_gc [][]byte ;_fae []byte ;_bae int ;_ff *codingContext ;_baf [13]*codingContext ;_gg *codingContext ;};