//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_d "bytes";_c "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_dg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_aga *Encoder )Flush (){_aga ._dbf =0;_aga ._af =nil ;
_aga ._db =-1};func (_ead *Encoder )dataSize ()int {return _aef *len (_ead ._af )+_ead ._dbf };func New ()*Encoder {_gef :=&Encoder {};_gef .Init ();return _gef };func (_deg *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _dgd ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _gca int64 ;for _gfbg ,_cff :=range _deg ._af {_afa ,_cdede :=w .Write (_cff );if _cdede !=nil {return 0,_dg .Wrapf (_cdede ,_dgd ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_gfbg );
};_gca +=int64 (_afa );};_deg ._ge =_deg ._ge [:_deg ._dbf ];_dgcf ,_eaf :=w .Write (_deg ._ge );if _eaf !=nil {return 0,_dg .Wrap (_eaf ,_dgd ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_gca +=int64 (_dgcf );
return _gca ,nil ;};func (_bgff *Encoder )encodeOOB (_dfbd Class )error {_dff :=_bgff ._bfb [_dfbd ];_abba :=_bgff .encodeBit (_dff ,1,1);if _abba !=nil {return _abba ;};_abba =_bgff .encodeBit (_dff ,3,0);if _abba !=nil {return _abba ;};_abba =_bgff .encodeBit (_dff ,6,0);
if _abba !=nil {return _abba ;};_abba =_bgff .encodeBit (_dff ,12,0);if _abba !=nil {return _abba ;};return nil ;};var _ _e .WriterTo =&Encoder {};const _bae =0x9b25;func (_bff *Encoder )EncodeInteger (proc Class ,value int )(_aaf error ){_c .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _aaf =_bff .encodeInteger (proc ,value );_aaf !=nil {return _dg .Wrap (_aaf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_dbb *Encoder )Refine (iTemp ,iTarget *_b .Bitmap ,ox ,oy int )error {for _gc :=0;
_gc < iTarget .Height ;_gc ++{var _dd int ;_gf :=_gc +oy ;var (_cbg ,_dbba ,_fgc ,_aeg ,_fd uint16 ;_dfe ,_ad ,_fdg ,_cfb ,_gfb byte ;);if _gf >=1&&(_gf -1)< iTemp .Height {_dfe =iTemp .Data [(_gf -1)*iTemp .RowStride ];};if _gf >=0&&_gf < iTemp .Height {_ad =iTemp .Data [_gf *iTemp .RowStride ];
};if _gf >=-1&&_gf +1< iTemp .Height {_fdg =iTemp .Data [(_gf +1)*iTemp .RowStride ];};if _gc >=1{_cfb =iTarget .Data [(_gc -1)*iTarget .RowStride ];};_gfb =iTarget .Data [_gc *iTarget .RowStride ];_bcf :=uint (6+ox );_cbg =uint16 (_dfe >>_bcf );_dbba =uint16 (_ad >>_bcf );
_fgc =uint16 (_fdg >>_bcf );_aeg =uint16 (_cfb >>6);_bebb :=uint (2-ox );_dfe <<=_bebb ;_ad <<=_bebb ;_fdg <<=_bebb ;_cfb <<=2;for _dd =0;_dd < iTarget .Width ;_dd ++{_gad :=(_cbg <<10)|(_dbba <<7)|(_fgc <<4)|(_aeg <<1)|_fd ;_bd :=_gfb >>7;_bec :=_dbb .encodeBit (_dbb ._dbff ,uint32 (_gad ),_bd );
if _bec !=nil {return _bec ;};_cbg <<=1;_dbba <<=1;_fgc <<=1;_aeg <<=1;_cbg |=uint16 (_dfe >>7);_dbba |=uint16 (_ad >>7);_fgc |=uint16 (_fdg >>7);_aeg |=uint16 (_cfb >>7);_fd =uint16 (_bd );_efe :=_dd %8;_de :=_dd /8+1;if _efe ==5+ox {_dfe ,_ad ,_fdg =0,0,0;
if _de < iTemp .RowStride &&_gf >=1&&(_gf -1)< iTemp .Height {_dfe =iTemp .Data [(_gf -1)*iTemp .RowStride +_de ];};if _de < iTemp .RowStride &&_gf >=0&&_gf < iTemp .Height {_ad =iTemp .Data [_gf *iTemp .RowStride +_de ];};if _de < iTemp .RowStride &&_gf >=-1&&(_gf +1)< iTemp .Height {_fdg =iTemp .Data [(_gf +1)*iTemp .RowStride +_de ];
};}else {_dfe <<=1;_ad <<=1;_fdg <<=1;};if _efe ==5&&_gc >=1{_cfb =0;if _de < iTarget .RowStride {_cfb =iTarget .Data [(_gc -1)*iTarget .RowStride +_de ];};}else {_cfb <<=1;};if _efe ==7{_gfb =0;if _de < iTarget .RowStride {_gfb =iTarget .Data [_gc *iTarget .RowStride +_de ];
};}else {_gfb <<=1;};_cbg &=7;_dbba &=7;_fgc &=7;_aeg &=7;};};return nil ;};func (_acd *Encoder )byteOut (){if _acd ._bg ==0xff{_acd .rBlock ();return ;};if _acd ._cc < 0x8000000{_acd .lBlock ();return ;};_acd ._bg ++;if _acd ._bg !=0xff{_acd .lBlock ();
return ;};_acd ._cc &=0x7ffffff;_acd .rBlock ();};func (_fc *Encoder )Init (){_fc ._dbff =_ef (_bffa );_fc ._eb =0x8000;_fc ._cc =0;_fc ._cb =12;_fc ._db =-1;_fc ._bg =0;_fc ._dbf =0;_fc ._ge =make ([]byte ,_aef );for _bgc :=0;_bgc < len (_fc ._bfb );_bgc ++{_fc ._bfb [_bgc ]=_ef (512);
};_fc ._dbfd =nil ;};func (_efed *Encoder )code0 (_bfc *codingContext ,_fcg uint32 ,_dea uint16 ,_bgf byte ){if _bfc .mps (_fcg )==0{_efed .codeMPS (_bfc ,_fcg ,_dea ,_bgf );}else {_efed .codeLPS (_bfc ,_fcg ,_dea ,_bgf );};};func (_ebfa *Encoder )encodeBit (_agad *codingContext ,_cee uint32 ,_dba uint8 )error {const _ddb ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_ebfa ._dge ++;if _cee >=uint32 (len (_agad ._fg )){return _dg .Errorf (_ddb ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_cee );
};_cbd :=_agad ._fg [_cee ];_gg :=_agad .mps (_cee );_cbb :=_cbbe [_cbd ]._cab ;_c .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_ebfa ._dge ,_dba ,_cbd ,_gg ,_cbb ,_ebfa ._eb ,_ebfa ._cc ,_ebfa ._cb ,_ebfa ._bg ,_ebfa ._db );
if _dba ==0{_ebfa .code0 (_agad ,_cee ,_cbb ,_cbd );}else {_ebfa .code1 (_agad ,_cee ,_cbb ,_cbd );};return nil ;};func (_bab *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ab error ){_c .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ab =_bab .encodeIAID (symbolCodeLength ,value );_ab !=nil {return _dg .Wrap (_ab ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_cg *Encoder )lBlock (){if _cg ._db >=0{_cg .emit ();};_cg ._db ++;_cg ._bg =uint8 (_cg ._cc >>19);
_cg ._cc &=0x7ffff;_cg ._cb =8;};func (_aa Class )String ()string {switch _aa {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_gbc *Encoder )encodeInteger (_gbe Class ,_ggb int )error {const _cag ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _ggb > 2000000000||_ggb < -2000000000{return _dg .Errorf (_cag ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_ggb );
};_fe :=_gbc ._bfb [_gbe ];_fged :=uint32 (1);var _dag int ;for ;;_dag ++{if _g [_dag ]._eg <=_ggb &&_g [_dag ]._be >=_ggb {break ;};};if _ggb < 0{_ggb =-_ggb ;};_ggb -=int (_g [_dag ]._ea );_gfc :=_g [_dag ]._f ;for _dbd :=uint8 (0);_dbd < _g [_dag ]._ff ;
_dbd ++{_gbff :=_gfc &1;if _abb :=_gbc .encodeBit (_fe ,_fged ,_gbff );_abb !=nil {return _dg .Wrap (_abb ,_cag ,"");};_gfc >>=1;if _fged &0x100> 0{_fged =(((_fged <<1)|uint32 (_gbff ))&0x1ff)|0x100;}else {_fged =(_fged <<1)|uint32 (_gbff );};};_ggb <<=32-_g [_dag ]._ca ;
for _fgg :=uint8 (0);_fgg < _g [_dag ]._ca ;_fgg ++{_geg :=uint8 ((uint32 (_ggb )&0x80000000)>>31);if _dbg :=_gbc .encodeBit (_fe ,_fged ,_geg );_dbg !=nil {return _dg .Wrap (_dbg ,_cag ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_ggb <<=1;if _fged &0x100!=0{_fged =(((_fged <<1)|uint32 (_geg ))&0x1ff)|0x100;}else {_fged =(_fged <<1)|uint32 (_geg );};};return nil ;};func (_gff *Encoder )setBits (){_eff :=_gff ._cc +uint32 (_gff ._eb );_gff ._cc |=0xffff;if _gff ._cc >=_eff {_gff ._cc -=0x8000;
};};func (_ba *codingContext )mps (_ce uint32 )int {return int (_ba ._gb [_ce ])};func (_cfbg *Encoder )emit (){if _cfbg ._dbf ==_aef {_cfbg ._af =append (_cfbg ._af ,_cfbg ._ge );_cfbg ._ge =make ([]byte ,_aef );_cfbg ._dbf =0;};_cfbg ._ge [_cfbg ._dbf ]=_cfbg ._bg ;
_cfbg ._dbf ++;};func (_cd *codingContext )flipMps (_ae uint32 ){_cd ._gb [_ae ]=1-_cd ._gb [_ae ]};func (_ecf *Encoder )codeMPS (_eef *codingContext ,_fb uint32 ,_dfb uint16 ,_gbf byte ){_ecf ._eb -=_dfb ;if _ecf ._eb &0x8000!=0{_ecf ._cc +=uint32 (_dfb );
return ;};if _ecf ._eb < _dfb {_ecf ._eb =_dfb ;}else {_ecf ._cc +=uint32 (_dfb );};_eef ._fg [_fb ]=_cbbe [_gbf ]._gbg ;_ecf .renormalize ();};func (_cfd *Encoder )rBlock (){if _cfd ._db >=0{_cfd .emit ();};_cfd ._db ++;_cfd ._bg =uint8 (_cfd ._cc >>20);
_cfd ._cc &=0xfffff;_cfd ._cb =7;};var _g =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_df *Encoder )EncodeBitmap (bm *_b .Bitmap ,duplicateLineRemoval bool )error {_c .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_ceb ,_ee uint8 ;
_gea ,_cdc ,_ga uint16 ;_fcd ,_ebc ,_cdeb byte ;_ac ,_egg ,_cded int ;_ccd ,_beb []byte ;);for _eed :=0;_eed < bm .Height ;_eed ++{_fcd ,_ebc =0,0;if _eed >=2{_fcd =bm .Data [(_eed -2)*bm .RowStride ];};if _eed >=1{_ebc =bm .Data [(_eed -1)*bm .RowStride ];
if duplicateLineRemoval {_egg =_eed *bm .RowStride ;_ccd =bm .Data [_egg :_egg +bm .RowStride ];_cded =(_eed -1)*bm .RowStride ;_beb =bm .Data [_cded :_cded +bm .RowStride ];if _d .Equal (_ccd ,_beb ){_ee =_ceb ^1;_ceb =1;}else {_ee =_ceb ;_ceb =0;};};
};if duplicateLineRemoval {if _ebf :=_df .encodeBit (_df ._dbff ,_bae ,_ee );_ebf !=nil {return _ebf ;};if _ceb !=0{continue ;};};_cdeb =bm .Data [_eed *bm .RowStride ];_gea =uint16 (_fcd >>5);_cdc =uint16 (_ebc >>4);_fcd <<=3;_ebc <<=4;_ga =0;for _ac =0;
_ac < bm .Width ;_ac ++{_dgc :=uint32 (_gea <<11|_cdc <<4|_ga );_cf :=(_cdeb &0x80)>>7;_dc :=_df .encodeBit (_df ._dbff ,_dgc ,_cf );if _dc !=nil {return _dc ;};_gea <<=1;_cdc <<=1;_ga <<=1;_gea |=uint16 ((_fcd &0x80)>>7);_cdc |=uint16 ((_ebc &0x80)>>7);
_ga |=uint16 (_cf );_bc :=_ac %8;_ec :=_ac /8+1;if _bc ==4&&_eed >=2{_fcd =0;if _ec < bm .RowStride {_fcd =bm .Data [(_eed -2)*bm .RowStride +_ec ];};}else {_fcd <<=1;};if _bc ==3&&_eed >=1{_ebc =0;if _ec < bm .RowStride {_ebc =bm .Data [(_eed -1)*bm .RowStride +_ec ];
};}else {_ebc <<=1;};if _bc ==7{_cdeb =0;if _ec < bm .RowStride {_cdeb =bm .Data [_eed *bm .RowStride +_ec ];};}else {_cdeb <<=1;};_gea &=31;_cdc &=127;_ga &=15;};};return nil ;};func (_ag *Encoder )EncodeOOB (proc Class )(_da error ){_c .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _da =_ag .encodeOOB (proc );_da !=nil {return _dg .Wrap (_da ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_dab *Encoder )codeLPS (_cdd *codingContext ,_dga uint32 ,_adb uint16 ,_ade byte ){_dab ._eb -=_adb ;if _dab ._eb < _adb {_dab ._cc +=uint32 (_adb );
}else {_dab ._eb =_adb ;};if _cbbe [_ade ]._gd ==1{_cdd .flipMps (_dga );};_cdd ._fg [_dga ]=_cbbe [_ade ]._fgd ;_dab .renormalize ();};type codingContext struct{_fg []byte ;_gb []byte ;};type state struct{_cab uint16 ;_gbg ,_fgd uint8 ;_gd uint8 ;};func (_cde *Encoder )DataSize ()int {return _cde .dataSize ()};
type Class int ;func (_fdb *Encoder )code1 (_fge *codingContext ,_eca uint32 ,_ccdg uint16 ,_geb byte ){if _fge .mps (_eca )==1{_fdb .codeMPS (_fge ,_eca ,_ccdg ,_geb );}else {_fdb .codeLPS (_fge ,_eca ,_ccdg ,_geb );};};type Encoder struct{_cc uint32 ;
_eb uint16 ;_cb ,_bg uint8 ;_db int ;_dge int ;_af [][]byte ;_ge []byte ;_dbf int ;_dbff *codingContext ;_bfb [13]*codingContext ;_dbfd *codingContext ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;
);func (_cae *Encoder )encodeIAID (_gade ,_gacc int )error {if _cae ._dbfd ==nil {_cae ._dbfd =_ef (1<<uint (_gade ));};_dgcg :=uint32 (1<<uint32 (_gade +1))-1;_gacc <<=uint (32-_gade );_cec :=uint32 (1);for _bgcf :=0;_bgcf < _gade ;_bgcf ++{_aaa :=_cec &_dgcg ;
_cffb :=uint8 ((uint32 (_gacc )&0x80000000)>>31);if _fba :=_cae .encodeBit (_cae ._dbfd ,_aaa ,_cffb );_fba !=nil {return _fba ;};_cec =(_cec <<1)|uint32 (_cffb );_gacc <<=1;};return nil ;};func (_bag *Encoder )Final (){_bag .flush ()};func (_gac *Encoder )Reset (){_gac ._eb =0x8000;
_gac ._cc =0;_gac ._cb =12;_gac ._db =-1;_gac ._bg =0;_gac ._dbfd =nil ;_gac ._dbff =_ef (_bffa );};type intEncRangeS struct{_eg ,_be int ;_f ,_ff uint8 ;_ea uint16 ;_ca uint8 ;};const (_bffa =65536;_aef =20*1024;);func (_daf *Encoder )flush (){_daf .setBits ();
_daf ._cc <<=_daf ._cb ;_daf .byteOut ();_daf ._cc <<=_daf ._cb ;_daf .byteOut ();_daf .emit ();if _daf ._bg !=0xff{_daf ._db ++;_daf ._bg =0xff;_daf .emit ();};_daf ._db ++;_daf ._bg =0xac;_daf ._db ++;_daf .emit ();};var _cbbe =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func _ef (_bf int )*codingContext {return &codingContext {_fg :make ([]byte ,_bf ),_gb :make ([]byte ,_bf )};};func (_ffe *Encoder )renormalize (){for {_ffe ._eb <<=1;_ffe ._cc <<=1;_ffe ._cb --;if _ffe ._cb ==0{_ffe .byteOut ();};if (_ffe ._eb &0x8000)!=0{break ;
};};};