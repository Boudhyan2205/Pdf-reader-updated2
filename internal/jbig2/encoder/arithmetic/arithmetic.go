//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_af "bytes";_d "github.com/unidoc/unipdf/v3/common";_f "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_g "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_aa "io";);func (_edeb *Encoder )Reset (){_edeb ._fc =0x8000;_edeb ._dc =0;
_edeb ._ee =12;_edeb ._ec =-1;_edeb ._gb =0;_edeb ._ff =nil ;_edeb ._efc =_bb (_cab );};func (_baaf *Encoder )rBlock (){if _baaf ._ec >=0{_baaf .emit ();};_baaf ._ec ++;_baaf ._gb =uint8 (_baaf ._dc >>20);_baaf ._dc &=0xfffff;_baaf ._ee =7;};const (_cab =65536;
_geb =20*1024;);func (_gae *Encoder )renormalize (){for {_gae ._fc <<=1;_gae ._dc <<=1;_gae ._ee --;if _gae ._ee ==0{_gae .byteOut ();};if (_gae ._fc &0x8000)!=0{break ;};};};type intEncRangeS struct{_e ,_da int ;_fb ,_gg uint8 ;_ga uint16 ;_fg uint8 ;
};func (_eca *Encoder )setBits (){_fafe :=_eca ._dc +uint32 (_eca ._fc );_eca ._dc |=0xffff;if _eca ._dc >=_fafe {_eca ._dc -=0x8000;};};func (_efcd *Encoder )emit (){if _efcd ._ed ==_geb {_efcd ._bf =append (_efcd ._bf ,_efcd ._bd );_efcd ._bd =make ([]byte ,_geb );
_efcd ._ed =0;};_efcd ._bd [_efcd ._ed ]=_efcd ._gb ;_efcd ._ed ++;};func (_eb *Encoder )DataSize ()int {return _eb .dataSize ()};func (_efcb *Encoder )Refine (iTemp ,iTarget *_f .Bitmap ,ox ,oy int )error {for _cc :=0;_cc < iTarget .Height ;_cc ++{var _gfe int ;
_ecf :=_cc +oy ;var (_gfeg ,_ca ,_aad ,_gfed ,_dfd uint16 ;_bdf ,_cca ,_ebf ,_cdd ,_dgg byte ;);if _ecf >=1&&(_ecf -1)< iTemp .Height {_bdf =iTemp .Data [(_ecf -1)*iTemp .RowStride ];};if _ecf >=0&&_ecf < iTemp .Height {_cca =iTemp .Data [_ecf *iTemp .RowStride ];
};if _ecf >=-1&&_ecf +1< iTemp .Height {_ebf =iTemp .Data [(_ecf +1)*iTemp .RowStride ];};if _cc >=1{_cdd =iTarget .Data [(_cc -1)*iTarget .RowStride ];};_dgg =iTarget .Data [_cc *iTarget .RowStride ];_cge :=uint (6+ox );_gfeg =uint16 (_bdf >>_cge );_ca =uint16 (_cca >>_cge );
_aad =uint16 (_ebf >>_cge );_gfed =uint16 (_cdd >>6);_cdb :=uint (2-ox );_bdf <<=_cdb ;_cca <<=_cdb ;_ebf <<=_cdb ;_cdd <<=2;for _gfe =0;_gfe < iTarget .Width ;_gfe ++{_dcg :=(_gfeg <<10)|(_ca <<7)|(_aad <<4)|(_gfed <<1)|_dfd ;_fce :=_dgg >>7;_ede :=_efcb .encodeBit (_efcb ._efc ,uint32 (_dcg ),_fce );
if _ede !=nil {return _ede ;};_gfeg <<=1;_ca <<=1;_aad <<=1;_gfed <<=1;_gfeg |=uint16 (_bdf >>7);_ca |=uint16 (_cca >>7);_aad |=uint16 (_ebf >>7);_gfed |=uint16 (_cdd >>7);_dfd =uint16 (_fce );_cdg :=_gfe %8;_bc :=_gfe /8+1;if _cdg ==5+ox {_bdf ,_cca ,_ebf =0,0,0;
if _bc < iTemp .RowStride &&_ecf >=1&&(_ecf -1)< iTemp .Height {_bdf =iTemp .Data [(_ecf -1)*iTemp .RowStride +_bc ];};if _bc < iTemp .RowStride &&_ecf >=0&&_ecf < iTemp .Height {_cca =iTemp .Data [_ecf *iTemp .RowStride +_bc ];};if _bc < iTemp .RowStride &&_ecf >=-1&&(_ecf +1)< iTemp .Height {_ebf =iTemp .Data [(_ecf +1)*iTemp .RowStride +_bc ];
};}else {_bdf <<=1;_cca <<=1;_ebf <<=1;};if _cdg ==5&&_cc >=1{_cdd =0;if _bc < iTarget .RowStride {_cdd =iTarget .Data [(_cc -1)*iTarget .RowStride +_bc ];};}else {_cdd <<=1;};if _cdg ==7{_dgg =0;if _bc < iTarget .RowStride {_dgg =iTarget .Data [_cc *iTarget .RowStride +_bc ];
};}else {_dgg <<=1;};_gfeg &=7;_ca &=7;_aad &=7;_gfed &=7;};};return nil ;};func (_gd *codingContext )mps (_gf uint32 )int {return int (_gd ._b [_gf ])};var _ _aa .WriterTo =&Encoder {};func (_caee *Encoder )encodeInteger (_dbd Class ,_gaab int )error {const _afg ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _gaab > 2000000000||_gaab < -2000000000{return _g .Errorf (_afg ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gaab );
};_afgb :=_caee ._gc [_dbd ];_ccab :=uint32 (1);var _fbbc int ;for ;;_fbbc ++{if _cf [_fbbc ]._e <=_gaab &&_cf [_fbbc ]._da >=_gaab {break ;};};if _gaab < 0{_gaab =-_gaab ;};_gaab -=int (_cf [_fbbc ]._ga );_ebc :=_cf [_fbbc ]._fb ;for _deb :=uint8 (0);
_deb < _cf [_fbbc ]._gg ;_deb ++{_ddac :=_ebc &1;if _ccf :=_caee .encodeBit (_afgb ,_ccab ,_ddac );_ccf !=nil {return _g .Wrap (_ccf ,_afg ,"");};_ebc >>=1;if _ccab &0x100> 0{_ccab =(((_ccab <<1)|uint32 (_ddac ))&0x1ff)|0x100;}else {_ccab =(_ccab <<1)|uint32 (_ddac );
};};_gaab <<=32-_cf [_fbbc ]._fg ;for _ggf :=uint8 (0);_ggf < _cf [_fbbc ]._fg ;_ggf ++{_ggb :=uint8 ((uint32 (_gaab )&0x80000000)>>31);if _eaag :=_caee .encodeBit (_afgb ,_ccab ,_ggb );_eaag !=nil {return _g .Wrap (_eaag ,_afg ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_gaab <<=1;if _ccab &0x100!=0{_ccab =(((_ccab <<1)|uint32 (_ggb ))&0x1ff)|0x100;}else {_ccab =(_ccab <<1)|uint32 (_ggb );};};return nil ;};func (_c Class )String ()string {switch _c {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};func (_ag *Encoder )dataSize ()int {return _geb *len (_ag ._bf )+_ag ._ed };const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);type codingContext struct{_ef []byte ;_b []byte ;};type Encoder struct{_dc uint32 ;
_fc uint16 ;_ee ,_gb uint8 ;_ec int ;_ea int ;_bf [][]byte ;_bd []byte ;_ed int ;_efc *codingContext ;_gc [13]*codingContext ;_ff *codingContext ;};func (_gaa *Encoder )Final (){_gaa .flush ()};func (_cce *Encoder )lBlock (){if _cce ._ec >=0{_cce .emit ();
};_cce ._ec ++;_cce ._gb =uint8 (_cce ._dc >>19);_cce ._dc &=0x7ffff;_cce ._ee =8;};func New ()*Encoder {_ae :=&Encoder {};_ae .Init ();return _ae };func (_faf *Encoder )Flush (){_faf ._ed =0;_faf ._bf =nil ;_faf ._ec =-1};func (_baa *Encoder )WriteTo (w _aa .Writer )(int64 ,error ){const _afb ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _ge int64 ;for _eda ,_ddg :=range _baa ._bf {_ecfb ,_ad :=w .Write (_ddg );if _ad !=nil {return 0,_g .Wrapf (_ad ,_afb ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_eda );
};_ge +=int64 (_ecfb );};_baa ._bd =_baa ._bd [:_baa ._ed ];_cae ,_eae :=w .Write (_baa ._bd );if _eae !=nil {return 0,_g .Wrap (_eae ,_afb ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_ge +=int64 (_cae );return _ge ,nil ;
};type Class int ;type state struct{_gbbd uint16 ;_abf ,_bdg uint8 ;_gbba uint8 ;};func (_fe *Encoder )EncodeInteger (proc Class ,value int )(_cfb error ){_d .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _cfb =_fe .encodeInteger (proc ,value );_cfb !=nil {return _g .Wrap (_cfb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_cgab *Encoder )codeMPS (_bfg *codingContext ,_dga uint32 ,_acd uint16 ,_gba byte ){_cgab ._fc -=_acd ;
if _cgab ._fc &0x8000!=0{_cgab ._dc +=uint32 (_acd );return ;};if _cgab ._fc < _acd {_cgab ._fc =_acd ;}else {_cgab ._dc +=uint32 (_acd );};_bfg ._ef [_dga ]=_gaca [_gba ]._abf ;_cgab .renormalize ();};func (_ffe *Encoder )encodeBit (_daa *codingContext ,_fbbd uint32 ,_aaf uint8 )error {const _aee ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_ffe ._ea ++;if _fbbd >=uint32 (len (_daa ._ef )){return _g .Errorf (_aee ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fbbd );
};_eaa :=_daa ._ef [_fbbd ];_cdgf :=_daa .mps (_fbbd );_edee :=_gaca [_eaa ]._gbbd ;_d .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_ffe ._ea ,_aaf ,_eaa ,_cdgf ,_edee ,_ffe ._fc ,_ffe ._dc ,_ffe ._ee ,_ffe ._gb ,_ffe ._ec );
if _aaf ==0{_ffe .code0 (_daa ,_fbbd ,_edee ,_eaa );}else {_ffe .code1 (_daa ,_fbbd ,_edee ,_eaa );};return nil ;};func (_efca *Encoder )encodeIAID (_gbbe ,_dfe int )error {if _efca ._ff ==nil {_efca ._ff =_bb (1<<uint (_gbbe ));};_faa :=uint32 (1<<uint32 (_gbbe +1))-1;
_dfe <<=uint (32-_gbbe );_bg :=uint32 (1);for _fcc :=0;_fcc < _gbbe ;_fcc ++{_ffg :=_bg &_faa ;_gfd :=uint8 ((uint32 (_dfe )&0x80000000)>>31);if _dbdg :=_efca .encodeBit (_efca ._ff ,_ffg ,_gfd );_dbdg !=nil {return _dbdg ;};_bg =(_bg <<1)|uint32 (_gfd );
_dfe <<=1;};return nil ;};func (_edf *Encoder )flush (){_edf .setBits ();_edf ._dc <<=_edf ._ee ;_edf .byteOut ();_edf ._dc <<=_edf ._ee ;_edf .byteOut ();_edf .emit ();if _edf ._gb !=0xff{_edf ._ec ++;_edf ._gb =0xff;_edf .emit ();};_edf ._ec ++;_edf ._gb =0xac;
_edf ._ec ++;_edf .emit ();};func (_cga *Encoder )code1 (_fbf *codingContext ,_ceg uint32 ,_aef uint16 ,_fee byte ){if _fbf .mps (_ceg )==1{_cga .codeMPS (_fbf ,_ceg ,_aef ,_fee );}else {_cga .codeLPS (_fbf ,_ceg ,_aef ,_fee );};};func (_db *codingContext )flipMps (_ac uint32 ){_db ._b [_ac ]=1-_db ._b [_ac ]};
func (_bdfc *Encoder )encodeOOB (_gcf Class )error {_afc :=_bdfc ._gc [_gcf ];_ade :=_bdfc .encodeBit (_afc ,1,1);if _ade !=nil {return _ade ;};_ade =_bdfc .encodeBit (_afc ,3,0);if _ade !=nil {return _ade ;};_ade =_bdfc .encodeBit (_afc ,6,0);if _ade !=nil {return _ade ;
};_ade =_bdfc .encodeBit (_afc ,12,0);if _ade !=nil {return _ade ;};return nil ;};func (_dda *Encoder )EncodeOOB (proc Class )(_aff error ){_d .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _aff =_dda .encodeOOB (proc );_aff !=nil {return _g .Wrap (_aff ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};var _gaca =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_eg *Encoder )Init (){_eg ._efc =_bb (_cab );_eg ._fc =0x8000;_eg ._dc =0;_eg ._ee =12;_eg ._ec =-1;_eg ._gb =0;_eg ._ed =0;_eg ._bd =make ([]byte ,_geb );for _fa :=0;_fa < len (_eg ._gc );_fa ++{_eg ._gc [_fa ]=_bb (512);};_eg ._ff =nil ;};var _cf =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func _bb (_ab int )*codingContext {return &codingContext {_ef :make ([]byte ,_ab ),_b :make ([]byte ,_ab )};};func (_cdf *Encoder )codeLPS (_gbb *codingContext ,_affb uint32 ,_edd uint16 ,_fbb byte ){_cdf ._fc -=_edd ;if _cdf ._fc < _edd {_cdf ._dc +=uint32 (_edd );
}else {_cdf ._fc =_edd ;};if _gaca [_fbb ]._gbba ==1{_gbb .flipMps (_affb );};_gbb ._ef [_affb ]=_gaca [_fbb ]._bdg ;_cdf .renormalize ();};func (_fdaa *Encoder )code0 (_fgb *codingContext ,_bfe uint32 ,_gfa uint16 ,_abc byte ){if _fgb .mps (_bfe )==0{_fdaa .codeMPS (_fgb ,_bfe ,_gfa ,_abc );
}else {_fdaa .codeLPS (_fgb ,_bfe ,_gfa ,_abc );};};const _de =0x9b25;func (_fcd *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ba error ){_d .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ba =_fcd .encodeIAID (symbolCodeLength ,value );_ba !=nil {return _g .Wrap (_ba ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_gef *Encoder )byteOut (){if _gef ._gb ==0xff{_gef .rBlock ();return ;};if _gef ._dc < 0x8000000{_gef .lBlock ();
return ;};_gef ._gb ++;if _gef ._gb !=0xff{_gef .lBlock ();return ;};_gef ._dc &=0x7ffffff;_gef .rBlock ();};func (_gga *Encoder )EncodeBitmap (bm *_f .Bitmap ,duplicateLineRemoval bool )error {_d .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_aea ,_be uint8 ;_cg ,_dd ,_fbd uint16 ;_gbg ,_eee ,_cb byte ;_ffb ,_cd ,_ce int ;_dbc ,_dg []byte ;);for _df :=0;_df < bm .Height ;_df ++{_gbg ,_eee =0,0;if _df >=2{_gbg =bm .Data [(_df -2)*bm .RowStride ];};if _df >=1{_eee =bm .Data [(_df -1)*bm .RowStride ];
if duplicateLineRemoval {_cd =_df *bm .RowStride ;_dbc =bm .Data [_cd :_cd +bm .RowStride ];_ce =(_df -1)*bm .RowStride ;_dg =bm .Data [_ce :_ce +bm .RowStride ];if _af .Equal (_dbc ,_dg ){_be =_aea ^1;_aea =1;}else {_be =_aea ;_aea =0;};};};if duplicateLineRemoval {if _dgd :=_gga .encodeBit (_gga ._efc ,_de ,_be );
_dgd !=nil {return _dgd ;};if _aea !=0{continue ;};};_cb =bm .Data [_df *bm .RowStride ];_cg =uint16 (_gbg >>5);_dd =uint16 (_eee >>4);_gbg <<=3;_eee <<=4;_fbd =0;for _ffb =0;_ffb < bm .Width ;_ffb ++{_fd :=uint32 (_cg <<11|_dd <<4|_fbd );_ddc :=(_cb &0x80)>>7;
_gac :=_gga .encodeBit (_gga ._efc ,_fd ,_ddc );if _gac !=nil {return _gac ;};_cg <<=1;_dd <<=1;_fbd <<=1;_cg |=uint16 ((_gbg &0x80)>>7);_dd |=uint16 ((_eee &0x80)>>7);_fbd |=uint16 (_ddc );_fda :=_ffb %8;_dad :=_ffb /8+1;if _fda ==4&&_df >=2{_gbg =0;if _dad < bm .RowStride {_gbg =bm .Data [(_df -2)*bm .RowStride +_dad ];
};}else {_gbg <<=1;};if _fda ==3&&_df >=1{_eee =0;if _dad < bm .RowStride {_eee =bm .Data [(_df -1)*bm .RowStride +_dad ];};}else {_eee <<=1;};if _fda ==7{_cb =0;if _dad < bm .RowStride {_cb =bm .Data [_df *bm .RowStride +_dad ];};}else {_cb <<=1;};_cg &=31;
_dd &=127;_fbd &=15;};};return nil ;};