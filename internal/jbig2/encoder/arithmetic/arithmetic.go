//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "bytes";_d "github.com/unidoc/unipdf/v3/common";_c "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_bf "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_dag *Encoder )Reset (){_dag ._ee =0x8000;_dag ._bd =0;
_dag ._fa =12;_dag ._fd =-1;_dag ._ce =0;_dag ._gf =nil ;_dag ._ca =_e (_afeb );};type Encoder struct{_bd uint32 ;_ee uint16 ;_fa ,_ce uint8 ;_fd int ;_fad int ;_dec [][]byte ;_feg []byte ;_ea int ;_ca *codingContext ;_cef [13]*codingContext ;_gf *codingContext ;
};func (_fae *Encoder )DataSize ()int {return _fae .dataSize ()};func (_bb *Encoder )EncodeBitmap (bm *_c .Bitmap ,duplicateLineRemoval bool )error {_d .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_cefg ,_gfa uint8 ;_eg ,_eab ,_dgb uint16 ;_gdb ,_dc ,_fc byte ;_cbf ,_aac ,_fcc int ;_dd ,_dbe []byte ;);for _bg :=0;_bg < bm .Height ;_bg ++{_gdb ,_dc =0,0;if _bg >=2{_gdb =bm .Data [(_bg -2)*bm .RowStride ];};if _bg >=1{_dc =bm .Data [(_bg -1)*bm .RowStride ];
if duplicateLineRemoval {_aac =_bg *bm .RowStride ;_dd =bm .Data [_aac :_aac +bm .RowStride ];_fcc =(_bg -1)*bm .RowStride ;_dbe =bm .Data [_fcc :_fcc +bm .RowStride ];if _g .Equal (_dd ,_dbe ){_gfa =_cefg ^1;_cefg =1;}else {_gfa =_cefg ;_cefg =0;};};};
if duplicateLineRemoval {if _age :=_bb .encodeBit (_bb ._ca ,_gb ,_gfa );_age !=nil {return _age ;};if _cefg !=0{continue ;};};_fc =bm .Data [_bg *bm .RowStride ];_eg =uint16 (_gdb >>5);_eab =uint16 (_dc >>4);_gdb <<=3;_dc <<=4;_dgb =0;for _cbf =0;_cbf < bm .Width ;
_cbf ++{_aae :=uint32 (_eg <<11|_eab <<4|_dgb );_ed :=(_fc &0x80)>>7;_cbe :=_bb .encodeBit (_bb ._ca ,_aae ,_ed );if _cbe !=nil {return _cbe ;};_eg <<=1;_eab <<=1;_dgb <<=1;_eg |=uint16 ((_gdb &0x80)>>7);_eab |=uint16 ((_dc &0x80)>>7);_dgb |=uint16 (_ed );
_ead :=_cbf %8;_eeb :=_cbf /8+1;if _ead ==4&&_bg >=2{_gdb =0;if _eeb < bm .RowStride {_gdb =bm .Data [(_bg -2)*bm .RowStride +_eeb ];};}else {_gdb <<=1;};if _ead ==3&&_bg >=1{_dc =0;if _eeb < bm .RowStride {_dc =bm .Data [(_bg -1)*bm .RowStride +_eeb ];
};}else {_dc <<=1;};if _ead ==7{_fc =0;if _eeb < bm .RowStride {_fc =bm .Data [_bg *bm .RowStride +_eeb ];};}else {_fc <<=1;};_eg &=31;_eab &=127;_dgb &=15;};};return nil ;};func (_af *Encoder )EncodeIAID (symbolCodeLength ,value int )(_aeg error ){_d .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _aeg =_af .encodeIAID (symbolCodeLength ,value );_aeg !=nil {return _bf .Wrap (_aeg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};var _ _b .WriterTo =&Encoder {};func (_gec *Encoder )WriteTo (w _b .Writer )(int64 ,error ){const _efe ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _deff int64 ;for _ga ,_fb :=range _gec ._dec {_eaf ,_ddc :=w .Write (_fb );if _ddc !=nil {return 0,_bf .Wrapf (_ddc ,_efe ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ga );
};_deff +=int64 (_eaf );};_gec ._feg =_gec ._feg [:_gec ._ea ];_beb ,_eb :=w .Write (_gec ._feg );if _eb !=nil {return 0,_bf .Wrap (_eb ,_efe ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_deff +=int64 (_beb );return _deff ,nil ;
};type codingContext struct{_dg []byte ;_cb []byte ;};func _e (_def int )*codingContext {return &codingContext {_dg :make ([]byte ,_def ),_cb :make ([]byte ,_def )};};func (_ffg *Encoder )Final (){_ffg .flush ()};func (_eef *Encoder )setBits (){_ccf :=_eef ._bd +uint32 (_eef ._ee );
_eef ._bd |=0xffff;if _eef ._bd >=_ccf {_eef ._bd -=0x8000;};};func (_fg *Encoder )Init (){_fg ._ca =_e (_afeb );_fg ._ee =0x8000;_fg ._bd =0;_fg ._fa =12;_fg ._fd =-1;_fg ._ce =0;_fg ._ea =0;_fg ._feg =make ([]byte ,_gbc );for _ef :=0;_ef < len (_fg ._cef );
_ef ++{_fg ._cef [_ef ]=_e (512);};_fg ._gf =nil ;};var _ag =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func New ()*Encoder {_bde :=&Encoder {};_bde .Init ();return _bde };func (_f Class )String ()string {switch _f {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_ccd *Encoder )encodeBit (_feb *codingContext ,_fbc uint32 ,_baa uint8 )error {const _bcf ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_ccd ._fad ++;if _fbc >=uint32 (len (_feb ._dg )){return _bf .Errorf (_bcf ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fbc );
};_agc :=_feb ._dg [_fbc ];_cgca :=_feb .mps (_fbc );_ec :=_ecb [_agc ]._ggb ;_d .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_ccd ._fad ,_baa ,_agc ,_cgca ,_ec ,_ccd ._ee ,_ccd ._bd ,_ccd ._fa ,_ccd ._ce ,_ccd ._fd );
if _baa ==0{_ccd .code0 (_feb ,_fbc ,_ec ,_agc );}else {_ccd .code1 (_feb ,_fbc ,_ec ,_agc );};return nil ;};func (_bc *Encoder )codeLPS (_ddd *codingContext ,_eba uint32 ,_fbg uint16 ,_efd byte ){_bc ._ee -=_fbg ;if _bc ._ee < _fbg {_bc ._bd +=uint32 (_fbg );
}else {_bc ._ee =_fbg ;};if _ecb [_efd ]._agd ==1{_ddd .flipMps (_eba );};_ddd ._dg [_eba ]=_ecb [_efd ]._gad ;_bc .renormalize ();};func (_fec *Encoder )byteOut (){if _fec ._ce ==0xff{_fec .rBlock ();return ;};if _fec ._bd < 0x8000000{_fec .lBlock ();
return ;};_fec ._ce ++;if _fec ._ce !=0xff{_fec .lBlock ();return ;};_fec ._bd &=0x7ffffff;_fec .rBlock ();};func (_cd *Encoder )Refine (iTemp ,iTarget *_c .Bitmap ,ox ,oy int )error {for _fee :=0;_fee < iTarget .Height ;_fee ++{var _eed int ;_agf :=_fee +oy ;
var (_ba ,_ab ,_fegc ,_gdfb ,_aag uint16 ;_cea ,_eff ,_geb ,_bdeb ,_agb byte ;);if _agf >=1&&(_agf -1)< iTemp .Height {_cea =iTemp .Data [(_agf -1)*iTemp .RowStride ];};if _agf >=0&&_agf < iTemp .Height {_eff =iTemp .Data [_agf *iTemp .RowStride ];};if _agf >=-1&&_agf +1< iTemp .Height {_geb =iTemp .Data [(_agf +1)*iTemp .RowStride ];
};if _fee >=1{_bdeb =iTarget .Data [(_fee -1)*iTarget .RowStride ];};_agb =iTarget .Data [_fee *iTarget .RowStride ];_aaga :=uint (6+ox );_ba =uint16 (_cea >>_aaga );_ab =uint16 (_eff >>_aaga );_fegc =uint16 (_geb >>_aaga );_gdfb =uint16 (_bdeb >>6);_bac :=uint (2-ox );
_cea <<=_bac ;_eff <<=_bac ;_geb <<=_bac ;_bdeb <<=2;for _eed =0;_eed < iTarget .Width ;_eed ++{_cc :=(_ba <<10)|(_ab <<7)|(_fegc <<4)|(_gdfb <<1)|_aag ;_ddg :=_agb >>7;_da :=_cd .encodeBit (_cd ._ca ,uint32 (_cc ),_ddg );if _da !=nil {return _da ;};_ba <<=1;
_ab <<=1;_fegc <<=1;_gdfb <<=1;_ba |=uint16 (_cea >>7);_ab |=uint16 (_eff >>7);_fegc |=uint16 (_geb >>7);_gdfb |=uint16 (_bdeb >>7);_aag =uint16 (_ddg );_ggd :=_eed %8;_be :=_eed /8+1;if _ggd ==5+ox {_cea ,_eff ,_geb =0,0,0;if _be < iTemp .RowStride &&_agf >=1&&(_agf -1)< iTemp .Height {_cea =iTemp .Data [(_agf -1)*iTemp .RowStride +_be ];
};if _be < iTemp .RowStride &&_agf >=0&&_agf < iTemp .Height {_eff =iTemp .Data [_agf *iTemp .RowStride +_be ];};if _be < iTemp .RowStride &&_agf >=-1&&(_agf +1)< iTemp .Height {_geb =iTemp .Data [(_agf +1)*iTemp .RowStride +_be ];};}else {_cea <<=1;_eff <<=1;
_geb <<=1;};if _ggd ==5&&_fee >=1{_bdeb =0;if _be < iTarget .RowStride {_bdeb =iTarget .Data [(_fee -1)*iTarget .RowStride +_be ];};}else {_bdeb <<=1;};if _ggd ==7{_agb =0;if _be < iTarget .RowStride {_agb =iTarget .Data [_fee *iTarget .RowStride +_be ];
};}else {_agb <<=1;};_ba &=7;_ab &=7;_fegc &=7;_gdfb &=7;};};return nil ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_aab *Encoder )renormalize (){for {_aab ._ee <<=1;_aab ._bd <<=1;_aab ._fa --;
if _aab ._fa ==0{_aab .byteOut ();};if (_aab ._ee &0x8000)!=0{break ;};};};func (_db *codingContext )flipMps (_gg uint32 ){_db ._cb [_gg ]=1-_db ._cb [_gg ]};func (_ge *codingContext )mps (_gd uint32 )int {return int (_ge ._cb [_gd ])};func (_efg *Encoder )flush (){_efg .setBits ();
_efg ._bd <<=_efg ._fa ;_efg .byteOut ();_efg ._bd <<=_efg ._fa ;_efg .byteOut ();_efg .emit ();if _efg ._ce !=0xff{_efg ._fd ++;_efg ._ce =0xff;_efg .emit ();};_efg ._fd ++;_efg ._ce =0xac;_efg ._fd ++;_efg .emit ();};type Class int ;func (_fga *Encoder )code0 (_cg *codingContext ,_fgg uint32 ,_cfd uint16 ,_gece byte ){if _cg .mps (_fgg )==0{_fga .codeMPS (_cg ,_fgg ,_cfd ,_gece );
}else {_fga .codeLPS (_cg ,_fgg ,_cfd ,_gece );};};func (_bdf *Encoder )encodeIAID (_gea ,_fbb int )error {if _bdf ._gf ==nil {_bdf ._gf =_e (1<<uint (_gea ));};_dcc :=uint32 (1<<uint32 (_gea +1))-1;_fbb <<=uint (32-_gea );_dgc :=uint32 (1);for _bbe :=0;
_bbe < _gea ;_bbe ++{_dae :=_dgc &_dcc ;_bcb :=uint8 ((uint32 (_fbb )&0x80000000)>>31);if _fdd :=_bdf .encodeBit (_bdf ._gf ,_dae ,_bcb );_fdd !=nil {return _fdd ;};_dgc =(_dgc <<1)|uint32 (_bcb );_fbb <<=1;};return nil ;};type intEncRangeS struct{_ae ,_ff int ;
_de ,_cf uint8 ;_fe uint16 ;_aa uint8 ;};func (_bbg *Encoder )encodeOOB (_bfc Class )error {_gge :=_bbg ._cef [_bfc ];_eebdd :=_bbg .encodeBit (_gge ,1,1);if _eebdd !=nil {return _eebdd ;};_eebdd =_bbg .encodeBit (_gge ,3,0);if _eebdd !=nil {return _eebdd ;
};_eebdd =_bbg .encodeBit (_gge ,6,0);if _eebdd !=nil {return _eebdd ;};_eebdd =_bbg .encodeBit (_gge ,12,0);if _eebdd !=nil {return _eebdd ;};return nil ;};func (_cbc *Encoder )Flush (){_cbc ._ea =0;_cbc ._dec =nil ;_cbc ._fd =-1};var _ecb =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
const _gb =0x9b25;func (_daf *Encoder )codeMPS (_cac *codingContext ,_bfd uint32 ,_dcf uint16 ,_aea byte ){_daf ._ee -=_dcf ;if _daf ._ee &0x8000!=0{_daf ._bd +=uint32 (_dcf );return ;};if _daf ._ee < _dcf {_daf ._ee =_dcf ;}else {_daf ._bd +=uint32 (_dcf );
};_cac ._dg [_bfd ]=_ecb [_aea ]._ffa ;_daf .renormalize ();};const (_afeb =65536;_gbc =20*1024;);func (_cgc *Encoder )code1 (_gdff *codingContext ,_gdba uint32 ,_gdd uint16 ,_fdc byte ){if _gdff .mps (_gdba )==1{_cgc .codeMPS (_gdff ,_gdba ,_gdd ,_fdc );
}else {_cgc .codeLPS (_gdff ,_gdba ,_gdd ,_fdc );};};type state struct{_ggb uint16 ;_ffa ,_gad uint8 ;_agd uint8 ;};func (_fef *Encoder )encodeInteger (_daga Class ,_gae int )error {const _fgaa ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _gae > 2000000000||_gae < -2000000000{return _bf .Errorf (_fgaa ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gae );
};_dge :=_fef ._cef [_daga ];_bae :=uint32 (1);var _ggf int ;for ;;_ggf ++{if _ag [_ggf ]._ae <=_gae &&_ag [_ggf ]._ff >=_gae {break ;};};if _gae < 0{_gae =-_gae ;};_gae -=int (_ag [_ggf ]._fe );_cdc :=_ag [_ggf ]._de ;for _dbeg :=uint8 (0);_dbeg < _ag [_ggf ]._cf ;
_dbeg ++{_ebf :=_cdc &1;if _dgf :=_fef .encodeBit (_dge ,_bae ,_ebf );_dgf !=nil {return _bf .Wrap (_dgf ,_fgaa ,"");};_cdc >>=1;if _bae &0x100> 0{_bae =(((_bae <<1)|uint32 (_ebf ))&0x1ff)|0x100;}else {_bae =(_bae <<1)|uint32 (_ebf );};};_gae <<=32-_ag [_ggf ]._aa ;
for _ddb :=uint8 (0);_ddb < _ag [_ggf ]._aa ;_ddb ++{_ffgg :=uint8 ((uint32 (_gae )&0x80000000)>>31);if _eebd :=_fef .encodeBit (_dge ,_bae ,_ffgg );_eebd !=nil {return _bf .Wrap (_eebd ,_fgaa ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_gae <<=1;if _bae &0x100!=0{_bae =(((_bae <<1)|uint32 (_ffgg ))&0x1ff)|0x100;}else {_bae =(_bae <<1)|uint32 (_ffgg );};};return nil ;};func (_cfde *Encoder )lBlock (){if _cfde ._fd >=0{_cfde .emit ();};_cfde ._fd ++;_cfde ._ce =uint8 (_cfde ._bd >>19);
_cfde ._bd &=0x7ffff;_cfde ._fa =8;};func (_gdf *Encoder )EncodeOOB (proc Class )(_eea error ){_d .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _eea =_gdf .encodeOOB (proc );_eea !=nil {return _bf .Wrap (_eea ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_gfe *Encoder )emit (){if _gfe ._ea ==_gbc {_gfe ._dec =append (_gfe ._dec ,_gfe ._feg );_gfe ._feg =make ([]byte ,_gbc );
_gfe ._ea =0;};_gfe ._feg [_gfe ._ea ]=_gfe ._ce ;_gfe ._ea ++;};func (_cfb *Encoder )dataSize ()int {return _gbc *len (_cfb ._dec )+_cfb ._ea };func (_afe *Encoder )EncodeInteger (proc Class ,value int )(_bgd error ){_d .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _bgd =_afe .encodeInteger (proc ,value );_bgd !=nil {return _bf .Wrap (_bgd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_afb *Encoder )rBlock (){if _afb ._fd >=0{_afb .emit ();};_afb ._fd ++;
_afb ._ce =uint8 (_afb ._bd >>20);_afb ._bd &=0xfffff;_afb ._fa =7;};