//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_eb "bytes";_f "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_a "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_fc Class )String ()string {switch _fc {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_fcg *Encoder )Flush (){_fcg ._ef =0;_fcg ._gdc =nil ;_fcg ._gb =-1};func (_bcd *Encoder )codeLPS (_fdd *codingContext ,_ccf uint32 ,_egg uint16 ,_bdc byte ){_bcd ._fa -=_egg ;if _bcd ._fa < _egg {_bcd ._cd +=uint32 (_egg );}else {_bcd ._fa =_egg ;};if _afa [_bdc ]._aee ==1{_fdd .flipMps (_ccf );};_fdd ._bb [_ccf ]=_afa [_bdc ]._dfa ;_bcd .renormalize ();};func (_fag *Encoder )Init (){_fag ._dc =_ce (_gdff );_fag ._fa =0x8000;_fag ._cd =0;_fag ._bga =12;_fag ._gb =-1;_fag ._fd =0;_fag ._ef =0;_fag ._cee =make ([]byte ,_cbe );for _ega :=0;_ega < len (_fag ._ee );_ega ++{_fag ._ee [_ega ]=_ce (512);};_fag ._eed =nil ;};func (_bca *Encoder )flush (){_bca .setBits ();_bca ._cd <<=_bca ._bga ;_bca .byteOut ();_bca ._cd <<=_bca ._bga ;_bca .byteOut ();_bca .emit ();if _bca ._fd !=0xff{_bca ._gb ++;_bca ._fd =0xff;_bca .emit ();};_bca ._gb ++;_bca ._fd =0xac;_bca ._gb ++;_bca .emit ();};func (_dca *Encoder )WriteTo (w _c .Writer )(int64 ,error ){const _ffc ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _fagf int64 ;for _cc ,_ebb :=range _dca ._gdc {_fde ,_gfb :=w .Write (_ebb );if _gfb !=nil {return 0,_a .Wrapf (_gfb ,_ffc ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cc );};_fagf +=int64 (_fde );};_dca ._cee =_dca ._cee [:_dca ._ef ];_gc ,_gbgf :=w .Write (_dca ._cee );if _gbgf !=nil {return 0,_a .Wrap (_gbgf ,_ffc ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_fagf +=int64 (_gc );return _fagf ,nil ;};var _ _c .WriterTo =&Encoder {};func (_gbce *Encoder )rBlock (){if _gbce ._gb >=0{_gbce .emit ();};_gbce ._gb ++;_gbce ._fd =uint8 (_gbce ._cd >>20);_gbce ._cd &=0xfffff;_gbce ._bga =7;};func (_dad *Encoder )Reset (){_dad ._fa =0x8000;_dad ._cd =0;_dad ._bga =12;_dad ._gb =-1;_dad ._fd =0;_dad ._eed =nil ;_dad ._dc =_ce (_gdff );};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_cdb *Encoder )code0 (_fbf *codingContext ,_fab uint32 ,_fff uint16 ,_cf byte ){if _fbf .mps (_fab )==0{_cdb .codeMPS (_fbf ,_fab ,_fff ,_cf );}else {_cdb .codeLPS (_fbf ,_fab ,_fff ,_cf );};};type intEncRangeS struct{_g ,_bf int ;_ebf ,_bg uint8 ;_fcb uint16 ;_eg uint8 ;};func New ()*Encoder {_ff :=&Encoder {};_ff .Init ();return _ff };func (_feg *Encoder )dataSize ()int {return _cbe *len (_feg ._gdc )+_feg ._ef };var _afa =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_ab *Encoder )code1 (_cde *codingContext ,_dag uint32 ,_aed uint16 ,_feb byte ){if _cde .mps (_dag )==1{_ab .codeMPS (_cde ,_dag ,_aed ,_feb );}else {_ab .codeLPS (_cde ,_dag ,_aed ,_feb );};};func (_gag *Encoder )EncodeOOB (proc Class )(_ece error ){_f .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _ece =_gag .encodeOOB (proc );_ece !=nil {return _a .Wrap (_ece ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};type Class int ;func (_fbcad *Encoder )encodeBit (_fae *codingContext ,_ca uint32 ,_bcde uint8 )error {const _af ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_fbcad ._ga ++;if _ca >=uint32 (len (_fae ._bb )){return _a .Errorf (_af ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_ca );};_bbga :=_fae ._bb [_ca ];_gfg :=_fae .mps (_ca );_ccfa :=_afa [_bbga ]._cbc ;_f .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_fbcad ._ga ,_bcde ,_bbga ,_gfg ,_ccfa ,_fbcad ._fa ,_fbcad ._cd ,_fbcad ._bga ,_fbcad ._fd ,_fbcad ._gb );if _bcde ==0{_fbcad .code0 (_fae ,_ca ,_ccfa ,_bbga );}else {_fbcad .code1 (_fae ,_ca ,_ccfa ,_bbga );};return nil ;};func (_fda *Encoder )EncodeInteger (proc Class ,value int )(_gbe error ){_f .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _gbe =_fda .encodeInteger (proc ,value );_gbe !=nil {return _a .Wrap (_gbe ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type Encoder struct{_cd uint32 ;_fa uint16 ;_bga ,_fd uint8 ;_gb int ;_ga int ;_gdc [][]byte ;_cee []byte ;_ef int ;_dc *codingContext ;_ee [13]*codingContext ;_eed *codingContext ;};func (_fca *codingContext )flipMps (_gg uint32 ){_fca ._d [_gg ]=1-_fca ._d [_gg ]};func (_fce *Encoder )renormalize (){for {_fce ._fa <<=1;_fce ._cd <<=1;_fce ._bga --;if _fce ._bga ==0{_fce .byteOut ();};if (_fce ._fa &0x8000)!=0{break ;};};};func (_ag *Encoder )Refine (iTemp ,iTarget *_b .Bitmap ,ox ,oy int )error {for _ceb :=0;_ceb < iTarget .Height ;_ceb ++{var _bff int ;_gaf :=_ceb +oy ;var (_eag ,_fbc ,_fg ,_ecg ,_bdd uint16 ;_bce ,_fgb ,_agc ,_dga ,_bbb byte ;);if _gaf >=1&&(_gaf -1)< iTemp .Height {_bce =iTemp .Data [(_gaf -1)*iTemp .RowStride ];};if _gaf >=0&&_gaf < iTemp .Height {_fgb =iTemp .Data [_gaf *iTemp .RowStride ];};if _gaf >=-1&&_gaf +1< iTemp .Height {_agc =iTemp .Data [(_gaf +1)*iTemp .RowStride ];};if _ceb >=1{_dga =iTarget .Data [(_ceb -1)*iTarget .RowStride ];};_bbb =iTarget .Data [_ceb *iTarget .RowStride ];_gage :=uint (6+ox );_eag =uint16 (_bce >>_gage );_fbc =uint16 (_fgb >>_gage );_fg =uint16 (_agc >>_gage );_ecg =uint16 (_dga >>6);_df :=uint (2-ox );_bce <<=_df ;_fgb <<=_df ;_agc <<=_df ;_dga <<=2;for _bff =0;_bff < iTarget .Width ;_bff ++{_fbe :=(_eag <<10)|(_fbc <<7)|(_fg <<4)|(_ecg <<1)|_bdd ;_fef :=_bbb >>7;_cb :=_ag .encodeBit (_ag ._dc ,uint32 (_fbe ),_fef );if _cb !=nil {return _cb ;};_eag <<=1;_fbc <<=1;_fg <<=1;_ecg <<=1;_eag |=uint16 (_bce >>7);_fbc |=uint16 (_fgb >>7);_fg |=uint16 (_agc >>7);_ecg |=uint16 (_dga >>7);_bdd =uint16 (_fef );_fea :=_bff %8;_fba :=_bff /8+1;if _fea ==5+ox {_bce ,_fgb ,_agc =0,0,0;if _fba < iTemp .RowStride &&_gaf >=1&&(_gaf -1)< iTemp .Height {_bce =iTemp .Data [(_gaf -1)*iTemp .RowStride +_fba ];};if _fba < iTemp .RowStride &&_gaf >=0&&_gaf < iTemp .Height {_fgb =iTemp .Data [_gaf *iTemp .RowStride +_fba ];};if _fba < iTemp .RowStride &&_gaf >=-1&&(_gaf +1)< iTemp .Height {_agc =iTemp .Data [(_gaf +1)*iTemp .RowStride +_fba ];};}else {_bce <<=1;_fgb <<=1;_agc <<=1;};if _fea ==5&&_ceb >=1{_dga =0;if _fba < iTarget .RowStride {_dga =iTarget .Data [(_ceb -1)*iTarget .RowStride +_fba ];};}else {_dga <<=1;};if _fea ==7{_bbb =0;if _fba < iTarget .RowStride {_bbb =iTarget .Data [_ceb *iTarget .RowStride +_fba ];};}else {_bbb <<=1;};_eag &=7;_fbc &=7;_fg &=7;_ecg &=7;};};return nil ;};type codingContext struct{_bb []byte ;_d []byte ;};func (_fb *Encoder )EncodeBitmap (bm *_b .Bitmap ,duplicateLineRemoval bool )error {_f .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_fe ,_bdb uint8 ;_ec ,_ffd ,_ad uint16 ;_bc ,_ea ,_eea byte ;_ged ,_gba ,_da int ;_daa ,_ecf []byte ;);for _gdf :=0;_gdf < bm .Height ;_gdf ++{_bc ,_ea =0,0;if _gdf >=2{_bc =bm .Data [(_gdf -2)*bm .RowStride ];};if _gdf >=1{_ea =bm .Data [(_gdf -1)*bm .RowStride ];if duplicateLineRemoval {_gba =_gdf *bm .RowStride ;_daa =bm .Data [_gba :_gba +bm .RowStride ];_da =(_gdf -1)*bm .RowStride ;_ecf =bm .Data [_da :_da +bm .RowStride ];if _eb .Equal (_daa ,_ecf ){_bdb =_fe ^1;_fe =1;}else {_bdb =_fe ;_fe =0;};};};if duplicateLineRemoval {if _ae :=_fb .encodeBit (_fb ._dc ,_egd ,_bdb );_ae !=nil {return _ae ;};if _fe !=0{continue ;};};_eea =bm .Data [_gdf *bm .RowStride ];_ec =uint16 (_bc >>5);_ffd =uint16 (_ea >>4);_bc <<=3;_ea <<=4;_ad =0;for _ged =0;_ged < bm .Width ;_ged ++{_gbg :=uint32 (_ec <<11|_ffd <<4|_ad );_ed :=(_eea &0x80)>>7;_bcb :=_fb .encodeBit (_fb ._dc ,_gbg ,_ed );if _bcb !=nil {return _bcb ;};_ec <<=1;_ffd <<=1;_ad <<=1;_ec |=uint16 ((_bc &0x80)>>7);_ffd |=uint16 ((_ea &0x80)>>7);_ad |=uint16 (_ed );_ggg :=_ged %8;_eab :=_ged /8+1;if _ggg ==4&&_gdf >=2{_bc =0;if _eab < bm .RowStride {_bc =bm .Data [(_gdf -2)*bm .RowStride +_eab ];};}else {_bc <<=1;};if _ggg ==3&&_gdf >=1{_ea =0;if _eab < bm .RowStride {_ea =bm .Data [(_gdf -1)*bm .RowStride +_eab ];};}else {_ea <<=1;};if _ggg ==7{_eea =0;if _eab < bm .RowStride {_eea =bm .Data [_gdf *bm .RowStride +_eab ];};}else {_eea <<=1;};_ec &=31;_ffd &=127;_ad &=15;};};return nil ;};var _gd =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func _ce (_bd int )*codingContext {return &codingContext {_bb :make ([]byte ,_bd ),_d :make ([]byte ,_bd )};};func (_gfe *Encoder )lBlock (){if _gfe ._gb >=0{_gfe .emit ();};_gfe ._gb ++;_gfe ._fd =uint8 (_gfe ._cd >>19);_gfe ._cd &=0x7ffff;_gfe ._bga =8;};func (_cdc *Encoder )emit (){if _cdc ._ef ==_cbe {_cdc ._gdc =append (_cdc ._gdc ,_cdc ._cee );_cdc ._cee =make ([]byte ,_cbe );_cdc ._ef =0;};_cdc ._cee [_cdc ._ef ]=_cdc ._fd ;_cdc ._ef ++;};func (_dagb *Encoder )codeMPS (_ffa *codingContext ,_ffaf uint32 ,_fbca uint16 ,_dcb byte ){_dagb ._fa -=_fbca ;if _dagb ._fa &0x8000!=0{_dagb ._cd +=uint32 (_fbca );return ;};if _dagb ._fa < _fbca {_dagb ._fa =_fbca ;}else {_dagb ._cd +=uint32 (_fbca );};_ffa ._bb [_ffaf ]=_afa [_dcb ]._edb ;_dagb .renormalize ();};func (_bbg *codingContext )mps (_ge uint32 )int {return int (_bbg ._d [_ge ])};func (_cg *Encoder )encodeInteger (_cbb Class ,_bcda int )error {const _dd ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _bcda > 2000000000||_bcda < -2000000000{return _a .Errorf (_dd ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_bcda );};_bdbb :=_cg ._ee [_cbb ];_ecc :=uint32 (1);var _dfd int ;for ;;_dfd ++{if _gd [_dfd ]._g <=_bcda &&_gd [_dfd ]._bf >=_bcda {break ;};};if _bcda < 0{_bcda =-_bcda ;};_bcda -=int (_gd [_dfd ]._fcb );_ac :=_gd [_dfd ]._ebf ;for _ba :=uint8 (0);_ba < _gd [_dfd ]._bg ;_ba ++{_bae :=_ac &1;if _aa :=_cg .encodeBit (_bdbb ,_ecc ,_bae );_aa !=nil {return _a .Wrap (_aa ,_dd ,"");};_ac >>=1;if _ecc &0x100> 0{_ecc =(((_ecc <<1)|uint32 (_bae ))&0x1ff)|0x100;}else {_ecc =(_ecc <<1)|uint32 (_bae );};};_bcda <<=32-_gd [_dfd ]._eg ;for _fac :=uint8 (0);_fac < _gd [_dfd ]._eg ;_fac ++{_db :=uint8 ((uint32 (_bcda )&0x80000000)>>31);if _bfa :=_cg .encodeBit (_bdbb ,_ecc ,_db );_bfa !=nil {return _a .Wrap (_bfa ,_dd ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_bcda <<=1;if _ecc &0x100!=0{_ecc =(((_ecc <<1)|uint32 (_db ))&0x1ff)|0x100;}else {_ecc =(_ecc <<1)|uint32 (_db );};};return nil ;};func (_de *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gbc error ){_f .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _gbc =_de .encodeIAID (symbolCodeLength ,value );_gbc !=nil {return _a .Wrap (_gbc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};const (_gdff =65536;_cbe =20*1024;);func (_bbbd *Encoder )encodeIAID (_bfe ,_gdcb int )error {if _bbbd ._eed ==nil {_bbbd ._eed =_ce (1<<uint (_bfe ));};_gagf :=uint32 (1<<uint32 (_bfe +1))-1;_gdcb <<=uint (32-_bfe );_cfc :=uint32 (1);for _eae :=0;_eae < _bfe ;_eae ++{_aad :=_cfc &_gagf ;_fcbb :=uint8 ((uint32 (_gdcb )&0x80000000)>>31);if _fec :=_bbbd .encodeBit (_bbbd ._eed ,_aad ,_fcbb );_fec !=nil {return _fec ;};_cfc =(_cfc <<1)|uint32 (_fcbb );_gdcb <<=1;};return nil ;};func (_dge *Encoder )setBits (){_fbee :=_dge ._cd +uint32 (_dge ._fa );_dge ._cd |=0xffff;if _dge ._cd >=_fbee {_dge ._cd -=0x8000;};};func (_dae *Encoder )byteOut (){if _dae ._fd ==0xff{_dae .rBlock ();return ;};if _dae ._cd < 0x8000000{_dae .lBlock ();return ;};_dae ._fd ++;if _dae ._fd !=0xff{_dae .lBlock ();return ;};_dae ._cd &=0x7ffffff;_dae .rBlock ();};type state struct{_cbc uint16 ;_edb ,_dfa uint8 ;_aee uint8 ;};const _egd =0x9b25;func (_dg *Encoder )DataSize ()int {return _dg .dataSize ()};func (_be *Encoder )encodeOOB (_bddf Class )error {_ded :=_be ._ee [_bddf ];_bcf :=_be .encodeBit (_ded ,1,1);if _bcf !=nil {return _bcf ;};_bcf =_be .encodeBit (_ded ,3,0);if _bcf !=nil {return _bcf ;};_bcf =_be .encodeBit (_ded ,6,0);if _bcf !=nil {return _bcf ;};_bcf =_be .encodeBit (_ded ,12,0);if _bcf !=nil {return _bcf ;};return nil ;};func (_gf *Encoder )Final (){_gf .flush ()};