//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_b "errors";_a "fmt";_f "github.com/unidoc/unipdf/v3/common";_eg "github.com/unidoc/unipdf/v3/internal/bitwise";_g "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_c "io";);func (_cabe *Decoder )uncompress2d (_bcc *runData ,_dffc []int ,_fde int ,_fba []int ,_beg int )(int ,error ){var (_dgb int ;
_dacc int ;_gec int ;_dad =true ;_eac error ;_ecg *code ;);_dffc [_fde ]=_beg ;_dffc [_fde +1]=_beg ;_dffc [_fde +2]=_beg +1;_dffc [_fde +3]=_beg +1;_cbb :for _gec < _beg {_ecg ,_eac =_bcc .uncompressGetCode (_cabe ._dac );if _eac !=nil {return EOL ,nil ;
};if _ecg ==nil {_bcc ._dgf ++;break _cbb ;};_bcc ._dgf +=_ecg ._be ;switch mmrCode (_ecg ._gb ){case _fg :_gec =_dffc [_dgb ];case _d :_gec =_dffc [_dgb ]+1;case _df :_gec =_dffc [_dgb ]-1;case _fc :for {var _fec []*code ;if _dad {_fec =_cabe ._cc ;}else {_fec =_cabe ._fa ;
};_ecg ,_eac =_bcc .uncompressGetCode (_fec );if _eac !=nil {return 0,_eac ;};if _ecg ==nil {break _cbb ;};_bcc ._dgf +=_ecg ._be ;if _ecg ._gb < 64{if _ecg ._gb < 0{_fba [_dacc ]=_gec ;_dacc ++;_ecg =nil ;break _cbb ;};_gec +=_ecg ._gb ;_fba [_dacc ]=_gec ;
_dacc ++;break ;};_gec +=_ecg ._gb ;};_dd :=_gec ;_egb :for {var _ecd []*code ;if !_dad {_ecd =_cabe ._cc ;}else {_ecd =_cabe ._fa ;};_ecg ,_eac =_bcc .uncompressGetCode (_ecd );if _eac !=nil {return 0,_eac ;};if _ecg ==nil {break _cbb ;};_bcc ._dgf +=_ecg ._be ;
if _ecg ._gb < 64{if _ecg ._gb < 0{_fba [_dacc ]=_gec ;_dacc ++;break _cbb ;};_gec +=_ecg ._gb ;if _gec < _beg ||_gec !=_dd {_fba [_dacc ]=_gec ;_dacc ++;};break _egb ;};_gec +=_ecg ._gb ;};for _gec < _beg &&_dffc [_dgb ]<=_gec {_dgb +=2;};continue _cbb ;
case _af :_dgb ++;_gec =_dffc [_dgb ];_dgb ++;continue _cbb ;case _da :_gec =_dffc [_dgb ]+2;case _dff :_gec =_dffc [_dgb ]-2;case _cg :_gec =_dffc [_dgb ]+3;case _bd :_gec =_dffc [_dgb ]-3;default:if _bcc ._dgf ==12&&_ecg ._gb ==EOL {_bcc ._dgf =0;if _ ,_eac =_cabe .uncompress1d (_bcc ,_dffc ,_beg );
_eac !=nil {return 0,_eac ;};_bcc ._dgf ++;if _ ,_eac =_cabe .uncompress1d (_bcc ,_fba ,_beg );_eac !=nil {return 0,_eac ;};_aa ,_abb :=_cabe .uncompress1d (_bcc ,_dffc ,_beg );if _abb !=nil {return EOF ,_abb ;};_bcc ._dgf ++;return _aa ,nil ;};_gec =_beg ;
continue _cbb ;};if _gec <=_beg {_dad =!_dad ;_fba [_dacc ]=_gec ;_dacc ++;if _dgb > 0{_dgb --;}else {_dgb ++;};for _gec < _beg &&_dffc [_dgb ]<=_gec {_dgb +=2;};};};if _fba [_dacc ]!=_beg {_fba [_dacc ]=_beg ;};if _ecg ==nil {return EOL ,nil ;};return _dacc ,nil ;
};func _fb (_bb [3]int )*code {return &code {_be :_bb [0],_ee :_bb [1],_gb :_bb [2]}};type runData struct{_dcb *_eg .SubstreamReader ;_dgf int ;_bgg int ;_abd int ;_fbg []byte ;_cce int ;_eec int ;};func _bg (_ed ,_ef int )int {if _ed > _ef {return _ef ;
};return _ed ;};type Decoder struct{_cf ,_ea int ;_cfa *runData ;_cc []*code ;_fa []*code ;_dac []*code ;};func (_adb *runData )uncompressGetCodeLittleEndian (_dgfb []*code )(*code ,error ){_ede ,_efad :=_adb .uncompressGetNextCodeLittleEndian ();if _efad !=nil {_f .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_efad );
return nil ,_efad ;};_ede &=0xffffff;_ac :=_ede >>(_fecc -_ec );_db :=_dgfb [_ac ];if _db !=nil &&_db ._ab {_ac =(_ede >>(_fecc -_ec -_caf ))&_ega ;_db =_db ._ca [_ac ];};return _db ,nil ;};const (_af mmrCode =iota ;_fc ;_fg ;_d ;_da ;_cg ;_df ;_dff ;_bd ;
_edb ;_ff ;);func (_ba *Decoder )UncompressMMR ()(_gf *_g .Bitmap ,_eb error ){_gf =_g .New (_ba ._cf ,_ba ._ea );_bdc :=make ([]int ,_gf .Width +5);_ebf :=make ([]int ,_gf .Width +5);_ebf [0]=_gf .Width ;_dc :=1;var _cbe int ;for _dag :=0;_dag < _gf .Height ;
_dag ++{_cbe ,_eb =_ba .uncompress2d (_ba ._cfa ,_ebf ,_dc ,_bdc ,_gf .Width );if _eb !=nil {return nil ,_eb ;};if _cbe ==EOF {break ;};if _cbe > 0{_eb =_ba .fillBitmap (_gf ,_dag ,_bdc ,_cbe );if _eb !=nil {return nil ,_eb ;};};_ebf ,_bdc =_bdc ,_ebf ;
_dc =_cbe ;};if _eb =_ba .detectAndSkipEOL ();_eb !=nil {return nil ,_eb ;};_ba ._cfa .align ();return _gf ,nil ;};func (_bbe *Decoder )initTables ()(_edf error ){if _bbe ._cc ==nil {_bbe ._cc ,_edf =_bbe .createLittleEndianTable (_ge );if _edf !=nil {return ;
};_bbe ._fa ,_edf =_bbe .createLittleEndianTable (_bbfa );if _edf !=nil {return ;};_bbe ._dac ,_edf =_bbe .createLittleEndianTable (_gbc );if _edf !=nil {return ;};};return nil ;};func New (r _eg .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_fbe :=&Decoder {_cf :width ,_ea :height };
_efa ,_ag :=_eg .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _ag !=nil {return nil ,_ag ;};_bee ,_ag :=_cfaf (_efa );if _ag !=nil {return nil ,_ag ;};_fbe ._cfa =_bee ;if _cb :=_fbe .initTables ();_cb !=nil {return nil ,_cb ;};
return _fbe ,nil ;};func (_fge *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_dca :=_fge ._dgf -_fge ._bgg ;if _dca < 0||_dca > 24{_add :=(_fge ._dgf >>3)-_fge ._cce ;if _add >=_fge ._eec {_add +=_fge ._cce ;if _ffg :=_fge .fillBuffer (_add );
_ffg !=nil {return 0,_ffg ;};_add -=_fge ._cce ;};_abe :=(uint32 (_fge ._fbg [_add ]&0xFF)<<16)|(uint32 (_fge ._fbg [_add +1]&0xFF)<<8)|(uint32 (_fge ._fbg [_add +2]&0xFF));_fae :=uint32 (_fge ._dgf &7);_abe <<=_fae ;_fge ._abd =int (_abe );}else {_fbga :=_fge ._bgg &7;
_dfb :=7-_fbga ;if _dca <=_dfb {_fge ._abd <<=uint (_dca );}else {_gga :=(_fge ._bgg >>3)+3-_fge ._cce ;if _gga >=_fge ._eec {_gga +=_fge ._cce ;if _bda :=_fge .fillBuffer (_gga );_bda !=nil {return 0,_bda ;};_gga -=_fge ._cce ;};_fbga =8-_fbga ;for {_fge ._abd <<=uint (_fbga );
_fge ._abd |=int (uint (_fge ._fbg [_gga ])&0xFF);_dca -=_fbga ;_gga ++;_fbga =8;if !(_dca >=8){break ;};};_fge ._abd <<=uint (_dca );};};_fge ._bgg =_fge ._dgf ;return _fge ._abd ,nil ;};func (_fe *Decoder )detectAndSkipEOL ()error {for {_afa ,_bba :=_fe ._cfa .uncompressGetCode (_fe ._dac );
if _bba !=nil {return _bba ;};if _afa !=nil &&_afa ._gb ==EOL {_fe ._cfa ._dgf +=_afa ._be ;}else {return nil ;};};};const (EOF =-3;_adc =-2;EOL =-1;_ec =8;_bec =(1<<_ec )-1;_caf =5;_ega =(1<<_caf )-1;);func (_gef *Decoder )fillBitmap (_gfg *_g .Bitmap ,_agf int ,_agfa []int ,_cac int )error {var _bf byte ;
_dagb :=0;_gff :=_gfg .GetByteIndex (_dagb ,_agf );for _ced :=0;_ced < _cac ;_ced ++{_cbeg :=byte (1);_cab :=_agfa [_ced ];if (_ced &1)==0{_cbeg =0;};for _dagb < _cab {_bf =(_bf <<1)|_cbeg ;_dagb ++;if (_dagb &7)==0{if _cbd :=_gfg .SetByte (_gff ,_bf );
_cbd !=nil {return _cbd ;};_gff ++;_bf =0;};};};if (_dagb &7)!=0{_bf <<=uint (8-(_dagb &7));if _fgb :=_gfg .SetByte (_gff ,_bf );_fgb !=nil {return _fgb ;};};return nil ;};func (_gd *runData )fillBuffer (_fcef int )error {_gd ._cce =_fcef ;_ ,_efd :=_gd ._dcb .Seek (int64 (_fcef ),_c .SeekStart );
if _efd !=nil {if _efd ==_c .EOF {_f .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_gd ._eec =-1;}else {return _efd ;};};if _efd ==nil {_gd ._eec ,_efd =_gd ._dcb .Read (_gd ._fbg );if _efd !=nil {if _efd ==_c .EOF {_f .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");
_gd ._eec =-1;}else {return _efd ;};};};if _gd ._eec > -1&&_gd ._eec < 3{for _gd ._eec < 3{_bdae ,_eadd :=_gd ._dcb .ReadByte ();if _eadd !=nil {if _eadd ==_c .EOF {_gd ._fbg [_gd ._eec ]=0;}else {return _eadd ;};}else {_gd ._fbg [_gd ._eec ]=_bdae &0xFF;
};_gd ._eec ++;};};_gd ._eec -=3;if _gd ._eec < 0{_gd ._fbg =make ([]byte ,len (_gd ._fbg ));_gd ._eec =len (_gd ._fbg )-3;};return nil ;};func (_cde *runData )align (){_cde ._dgf =((_cde ._dgf +7)>>3)<<3};func _ce (_bbf ,_ad int )int {if _bbf < _ad {return _ad ;
};return _bbf ;};func _cfaf (_bdb *_eg .SubstreamReader )(*runData ,error ){_dfc :=&runData {_dcb :_bdb ,_dgf :0,_bgg :1};_cbed :=_bg (_ce (_gge ,int (_bdb .Length ())),_aeg );_dfc ._fbg =make ([]byte ,_cbed );if _cbdb :=_dfc .fillBuffer (0);_cbdb !=nil {if _cbdb ==_c .EOF {_dfc ._fbg =make ([]byte ,10);
_f .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_cbdb );}else {return nil ,_cbdb ;};};return _dfc ,nil ;};func (_ae *Decoder )createLittleEndianTable (_ebb [][3]int )([]*code ,error ){_eed :=make ([]*code ,_bec +1);
for _dg :=0;_dg < len (_ebb );_dg ++{_faf :=_fb (_ebb [_dg ]);if _faf ._be <=_ec {_dacb :=_ec -_faf ._be ;_cd :=_faf ._ee <<uint (_dacb );for _fgf :=(1<<uint (_dacb ))-1;_fgf >=0;_fgf --{_eag :=_cd |_fgf ;_eed [_eag ]=_faf ;};}else {_dab :=_faf ._ee >>uint (_faf ._be -_ec );
if _eed [_dab ]==nil {var _fd =_fb ([3]int {});_fd ._ca =make ([]*code ,_ega +1);_eed [_dab ]=_fd ;};if _faf ._be <=_ec +_caf {_eaa :=_ec +_caf -_faf ._be ;_eagg :=(_faf ._ee <<uint (_eaa ))&_ega ;_eed [_dab ]._ab =true ;for _bbb :=(1<<uint (_eaa ))-1;
_bbb >=0;_bbb --{_eed [_dab ]._ca [_eagg |_bbb ]=_faf ;};}else {return nil ,_b .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _eed ,nil ;};type mmrCode int ;func (_abdc *runData )uncompressGetCode (_fca []*code )(*code ,error ){return _abdc .uncompressGetCodeLittleEndian (_fca );};func (_gg *code )String ()string {return _a .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_gg ._be ,_gg ._ee ,_gg ._gb );
};const (_aeg int =1024<<7;_gge int =3;_fecc uint =24;);type code struct{_be int ;_ee int ;_gb int ;_ca []*code ;_ab bool ;};var (_gbc =[][3]int {{4,0x1,int (_af )},{3,0x1,int (_fc )},{1,0x1,int (_fg )},{3,0x3,int (_d )},{6,0x3,int (_da )},{7,0x3,int (_cg )},{3,0x2,int (_df )},{6,0x2,int (_dff )},{7,0x2,int (_bd )},{10,0xf,int (_edb )},{12,0xf,int (_ff )},{12,0x1,int (EOL )}};
_ge =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_adc },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_adc },{11,0x01,_adc },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_bbfa =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_adc },{9,0x18,15},{10,0x01,_adc },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_adc },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func (_egaf *Decoder )uncompress1d (_dfg *runData ,_bc []int ,_cbc int )(int ,error ){var (_fce =true ;_feb int ;_cfb *code ;_ccd int ;_dfff error ;);_gc :for _feb < _cbc {_eea :for {if _fce {_cfb ,_dfff =_dfg .uncompressGetCode (_egaf ._cc );if _dfff !=nil {return 0,_dfff ;
};}else {_cfb ,_dfff =_dfg .uncompressGetCode (_egaf ._fa );if _dfff !=nil {return 0,_dfff ;};};_dfg ._dgf +=_cfb ._be ;if _cfb ._gb < 0{break _gc ;};_feb +=_cfb ._gb ;if _cfb ._gb < 64{_fce =!_fce ;_bc [_ccd ]=_feb ;_ccd ++;break _eea ;};};};if _bc [_ccd ]!=_cbc {_bc [_ccd ]=_cbc ;
};_fab :=EOL ;if _cfb !=nil &&_cfb ._gb !=EOL {_fab =_ccd ;};return _fab ,nil ;};