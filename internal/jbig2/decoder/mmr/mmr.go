//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_b "errors";_g "fmt";_ca "github.com/unidoc/unipdf/v3/common";_dg "github.com/unidoc/unipdf/v3/internal/bitwise";_e "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_c "io";);func New (r *_dg .Reader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_fe :=&Decoder {_ae :width ,_de :height };
_cg ,_ecg :=r .NewPartialReader (int (dataOffset ),int (dataLength ),false );if _ecg !=nil {return nil ,_ecg ;};_fg ,_ecg :=_gegd (_cg );if _ecg !=nil {return nil ,_ecg ;};_ ,_ecg =r .Seek (_cg .RelativePosition (),_c .SeekCurrent );if _ecg !=nil {return nil ,_ecg ;
};_fe ._gd =_fg ;if _fbg :=_fe .initTables ();_fbg !=nil {return nil ,_fbg ;};return _fe ,nil ;};const (EOF =-3;_bb =-2;EOL =-1;_gc =8;_efg =(1<<_gc )-1;_fb =5;_ge =(1<<_fb )-1;);var (_ab =[][3]int {{4,0x1,int (_aa )},{3,0x1,int (_efb )},{1,0x1,int (_fc )},{3,0x3,int (_dc )},{6,0x3,int (_bd )},{7,0x3,int (_cbg )},{3,0x2,int (_ecf )},{6,0x2,int (_gfa )},{7,0x2,int (_db )},{10,0xf,int (_ga )},{12,0xf,int (_eg )},{12,0x1,int (EOL )}};
_gag =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_bb },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_bb },{11,0x01,_bb },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_gfe =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_bb },{9,0x18,15},{10,0x01,_bb },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_bb },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func _gegd (_fd *_dg .Reader )(*runData ,error ){_cca :=&runData {_dea :_fd ,_cacg :0,_edea :1};_aed :=_ag (_ed (_cfg ,int (_fd .Length ())),_faf );_cca ._ega =make ([]byte ,_aed );if _fdc :=_cca .fillBuffer (0);_fdc !=nil {if _fdc ==_c .EOF {_cca ._ega =make ([]byte ,10);
_ca .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_fdc );}else {return nil ,_fdc ;};};return _cca ,nil ;};func (_caa *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_bbc :=_caa ._cacg -_caa ._edea ;
if _bbc < 0||_bbc > 24{_dcb :=(_caa ._cacg >>3)-_caa ._cdac ;if _dcb >=_caa ._dccc {_dcb +=_caa ._cdac ;if _cab :=_caa .fillBuffer (_dcb );_cab !=nil {return 0,_cab ;};_dcb -=_caa ._cdac ;};_fee :=(uint32 (_caa ._ega [_dcb ]&0xFF)<<16)|(uint32 (_caa ._ega [_dcb +1]&0xFF)<<8)|(uint32 (_caa ._ega [_dcb +2]&0xFF));
_ccfe :=uint32 (_caa ._cacg &7);_fee <<=_ccfe ;_caa ._efc =int (_fee );}else {_egc :=_caa ._edea &7;_ac :=7-_egc ;if _bbc <=_ac {_caa ._efc <<=uint (_bbc );}else {_fbe :=(_caa ._edea >>3)+3-_caa ._cdac ;if _fbe >=_caa ._dccc {_fbe +=_caa ._cdac ;if _cccc :=_caa .fillBuffer (_fbe );
_cccc !=nil {return 0,_cccc ;};_fbe -=_caa ._cdac ;};_egc =8-_egc ;for {_caa ._efc <<=uint (_egc );_caa ._efc |=int (uint (_caa ._ega [_fbe ])&0xFF);_bbc -=_egc ;_fbe ++;_egc =8;if !(_bbc >=8){break ;};};_caa ._efc <<=uint (_bbc );};};_caa ._edea =_caa ._cacg ;
return _caa ._efc ,nil ;};func _ed (_ee ,_gf int )int {if _ee < _gf {return _gf ;};return _ee ;};func (_dfe *Decoder )initTables ()(_da error ){if _dfe ._cc ==nil {_dfe ._cc ,_da =_dfe .createLittleEndianTable (_gag );if _da !=nil {return ;};_dfe ._eb ,_da =_dfe .createLittleEndianTable (_gfe );
if _da !=nil {return ;};_dfe ._ff ,_da =_dfe .createLittleEndianTable (_ab );if _da !=nil {return ;};};return nil ;};func (_gfc *Decoder )createLittleEndianTable (_fbb [][3]int )([]*code ,error ){_ccd :=make ([]*code ,_efg +1);for _ebf :=0;_ebf < len (_fbb );
_ebf ++{_gee :=_ad (_fbb [_ebf ]);if _gee ._cb <=_gc {_fcd :=_gc -_gee ._cb ;_dgc :=_gee ._ec <<uint (_fcd );for _be :=(1<<uint (_fcd ))-1;_be >=0;_be --{_df :=_dgc |_be ;_ccd [_df ]=_gee ;};}else {_cae :=_gee ._ec >>uint (_gee ._cb -_gc );if _ccd [_cae ]==nil {var _ede =_ad ([3]int {});
_ede ._ea =make ([]*code ,_ge +1);_ccd [_cae ]=_ede ;};if _gee ._cb <=_gc +_fb {_fa :=_gc +_fb -_gee ._cb ;_gea :=(_gee ._ec <<uint (_fa ))&_ge ;_ccd [_cae ]._af =true ;for _ece :=(1<<uint (_fa ))-1;_ece >=0;_ece --{_ccd [_cae ]._ea [_gea |_ece ]=_gee ;
};}else {return nil ,_b .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");};};};return _ccd ,nil ;};func (_dbd *runData )fillBuffer (_eae int )error {_dbd ._cdac =_eae ;
_ ,_gbb :=_dbd ._dea .Seek (int64 (_eae ),_c .SeekStart );if _gbb !=nil {if _gbb ==_c .EOF {_ca .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_dbd ._dccc =-1;}else {return _gbb ;};};if _gbb ==nil {_dbd ._dccc ,_gbb =_dbd ._dea .Read (_dbd ._ega );
if _gbb !=nil {if _gbb ==_c .EOF {_ca .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_dbd ._dccc =-1;}else {return _gbb ;};};};if _dbd ._dccc > -1&&_dbd ._dccc < 3{for _dbd ._dccc < 3{_fec ,_fdg :=_dbd ._dea .ReadByte ();if _fdg !=nil {if _fdg ==_c .EOF {_dbd ._ega [_dbd ._dccc ]=0;
}else {return _fdg ;};}else {_dbd ._ega [_dbd ._dccc ]=_fec &0xFF;};_dbd ._dccc ++;};};_dbd ._dccc -=3;if _dbd ._dccc < 0{_dbd ._ega =make ([]byte ,len (_dbd ._ega ));_dbd ._dccc =len (_dbd ._ega )-3;};return nil ;};const (_faf int =1024<<7;_cfg int =3;
_ebd uint =24;);type mmrCode int ;func (_cac *Decoder )uncompress1d (_eaa *runData ,_cba []int ,_beg int )(int ,error ){var (_fad =true ;_geaf int ;_cbf *code ;_dce int ;_fcdf error ;);_fbbd :for _geaf < _beg {_ba :for {if _fad {_cbf ,_fcdf =_eaa .uncompressGetCode (_cac ._cc );
if _fcdf !=nil {return 0,_fcdf ;};}else {_cbf ,_fcdf =_eaa .uncompressGetCode (_cac ._eb );if _fcdf !=nil {return 0,_fcdf ;};};_eaa ._cacg +=_cbf ._cb ;if _cbf ._a < 0{break _fbbd ;};_geaf +=_cbf ._a ;if _cbf ._a < 64{_fad =!_fad ;_cba [_dce ]=_geaf ;_dce ++;
break _ba ;};};};if _cba [_dce ]!=_beg {_cba [_dce ]=_beg ;};_gfb :=EOL ;if _cbf !=nil &&_cbf ._a !=EOL {_gfb =_dce ;};return _gfb ,nil ;};func (_dcc *Decoder )detectAndSkipEOL ()error {for {_ce ,_bc :=_dcc ._gd .uncompressGetCode (_dcc ._ff );if _bc !=nil {return _bc ;
};if _ce !=nil &&_ce ._a ==EOL {_dcc ._gd ._cacg +=_ce ._cb ;}else {return nil ;};};};func (_agb *Decoder )uncompress2d (_afe *runData ,_afa []int ,_ddb int ,_bfc []int ,_agba int )(int ,error ){var (_ddg int ;_dge int ;_fcf int ;_fadb =true ;_fcc error ;
_abe *code ;);_afa [_ddb ]=_agba ;_afa [_ddb +1]=_agba ;_afa [_ddb +2]=_agba +1;_afa [_ddb +3]=_agba +1;_bfd :for _fcf < _agba {_abe ,_fcc =_afe .uncompressGetCode (_agb ._ff );if _fcc !=nil {return EOL ,nil ;};if _abe ==nil {_afe ._cacg ++;break _bfd ;
};_afe ._cacg +=_abe ._cb ;switch mmrCode (_abe ._a ){case _fc :_fcf =_afa [_ddg ];case _dc :_fcf =_afa [_ddg ]+1;case _ecf :_fcf =_afa [_ddg ]-1;case _efb :for {var _geg []*code ;if _fadb {_geg =_agb ._cc ;}else {_geg =_agb ._eb ;};_abe ,_fcc =_afe .uncompressGetCode (_geg );
if _fcc !=nil {return 0,_fcc ;};if _abe ==nil {break _bfd ;};_afe ._cacg +=_abe ._cb ;if _abe ._a < 64{if _abe ._a < 0{_bfc [_dge ]=_fcf ;_dge ++;_abe =nil ;break _bfd ;};_fcf +=_abe ._a ;_bfc [_dge ]=_fcf ;_dge ++;break ;};_fcf +=_abe ._a ;};_gcb :=_fcf ;
_geed :for {var _gca []*code ;if !_fadb {_gca =_agb ._cc ;}else {_gca =_agb ._eb ;};_abe ,_fcc =_afe .uncompressGetCode (_gca );if _fcc !=nil {return 0,_fcc ;};if _abe ==nil {break _bfd ;};_afe ._cacg +=_abe ._cb ;if _abe ._a < 64{if _abe ._a < 0{_bfc [_dge ]=_fcf ;
_dge ++;break _bfd ;};_fcf +=_abe ._a ;if _fcf < _agba ||_fcf !=_gcb {_bfc [_dge ]=_fcf ;_dge ++;};break _geed ;};_fcf +=_abe ._a ;};for _fcf < _agba &&_afa [_ddg ]<=_fcf {_ddg +=2;};continue _bfd ;case _aa :_ddg ++;_fcf =_afa [_ddg ];_ddg ++;continue _bfd ;
case _bd :_fcf =_afa [_ddg ]+2;case _gfa :_fcf =_afa [_ddg ]-2;case _cbg :_fcf =_afa [_ddg ]+3;case _db :_fcf =_afa [_ddg ]-3;default:if _afe ._cacg ==12&&_abe ._a ==EOL {_afe ._cacg =0;if _ ,_fcc =_agb .uncompress1d (_afe ,_afa ,_agba );_fcc !=nil {return 0,_fcc ;
};_afe ._cacg ++;if _ ,_fcc =_agb .uncompress1d (_afe ,_bfc ,_agba );_fcc !=nil {return 0,_fcc ;};_cda ,_efbd :=_agb .uncompress1d (_afe ,_afa ,_agba );if _efbd !=nil {return EOF ,_efbd ;};_afe ._cacg ++;return _cda ,nil ;};_fcf =_agba ;continue _bfd ;
};if _fcf <=_agba {_fadb =!_fadb ;_bfc [_dge ]=_fcf ;_dge ++;if _ddg > 0{_ddg --;}else {_ddg ++;};for _fcf < _agba &&_afa [_ddg ]<=_fcf {_ddg +=2;};};};if _bfc [_dge ]!=_agba {_bfc [_dge ]=_agba ;};if _abe ==nil {return EOL ,nil ;};return _dge ,nil ;};
func _ad (_dd [3]int )*code {return &code {_cb :_dd [0],_ec :_dd [1],_a :_dd [2]}};func (_fef *Decoder )fillBitmap (_gfaa *_e .Bitmap ,_bf int ,_cd []int ,_egg int )error {var _gff byte ;_gdc :=0;_dec :=_gfaa .GetByteIndex (_gdc ,_bf );for _cf :=0;_cf < _egg ;
_cf ++{_cgb :=byte (1);_bed :=_cd [_cf ];if (_cf &1)==0{_cgb =0;};for _gdc < _bed {_gff =(_gff <<1)|_cgb ;_gdc ++;if (_gdc &7)==0{if _ccf :=_gfaa .SetByte (_dec ,_gff );_ccf !=nil {return _ccf ;};_dec ++;_gff =0;};};};if (_gdc &7)!=0{_gff <<=uint (8-(_gdc &7));
if _gab :=_gfaa .SetByte (_dec ,_gff );_gab !=nil {return _gab ;};};return nil ;};func (_cdf *runData )align (){_cdf ._cacg =((_cdf ._cacg +7)>>3)<<3};func (_eag *runData )uncompressGetCode (_fcdd []*code )(*code ,error ){return _eag .uncompressGetCodeLittleEndian (_fcdd );
};type Decoder struct{_ae ,_de int ;_gd *runData ;_cc []*code ;_eb []*code ;_ff []*code ;};func (_ccc *runData )uncompressGetCodeLittleEndian (_cacgd []*code )(*code ,error ){_bg ,_gbd :=_ccc .uncompressGetNextCodeLittleEndian ();if _gbd !=nil {_ca .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_gbd );
return nil ,_gbd ;};_bg &=0xffffff;_abg :=_bg >>(_ebd -_gc );_ebfd :=_cacgd [_abg ];if _ebfd !=nil &&_ebfd ._af {_abg =(_bg >>(_ebd -_gc -_fb ))&_ge ;_ebfd =_ebfd ._ea [_abg ];};return _ebfd ,nil ;};type runData struct{_dea *_dg .Reader ;_cacg int ;_edea int ;
_efc int ;_ega []byte ;_cdac int ;_dccc int ;};type code struct{_cb int ;_ec int ;_a int ;_ea []*code ;_af bool ;};const (_aa mmrCode =iota ;_efb ;_fc ;_dc ;_bd ;_cbg ;_ecf ;_gfa ;_db ;_ga ;_eg ;);func (_ef *code )String ()string {return _g .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_ef ._cb ,_ef ._ec ,_ef ._a );
};func (_ecgg *Decoder )UncompressMMR ()(_ffc *_e .Bitmap ,_cbd error ){_ffc =_e .New (_ecgg ._ae ,_ecgg ._de );_gg :=make ([]int ,_ffc .Width +5);_eed :=make ([]int ,_ffc .Width +5);_eed [0]=_ffc .Width ;_bbd :=1;var _ffce int ;for _gb :=0;_gb < _ffc .Height ;
_gb ++{_ffce ,_cbd =_ecgg .uncompress2d (_ecgg ._gd ,_eed ,_bbd ,_gg ,_ffc .Width );if _cbd !=nil {return nil ,_cbd ;};if _ffce ==EOF {break ;};if _ffce > 0{_cbd =_ecgg .fillBitmap (_ffc ,_gb ,_gg ,_ffce );if _cbd !=nil {return nil ,_cbd ;};};_eed ,_gg =_gg ,_eed ;
_bbd =_ffce ;};if _cbd =_ecgg .detectAndSkipEOL ();_cbd !=nil {return nil ,_cbd ;};_ecgg ._gd .align ();return _ffc ,nil ;};func _ag (_f ,_edf int )int {if _f > _edf {return _edf ;};return _f ;};