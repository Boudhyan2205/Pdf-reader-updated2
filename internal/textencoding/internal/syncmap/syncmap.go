//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _a "sync";func (_ac *RuneByteMap )Read (r rune )(byte ,bool ){_ac ._gd .RLock ();defer _ac ._gd .RUnlock ();_ad ,_ff :=_ac ._g [r ];return _ad ,_ff ;};func (_b *ByteRuneMap )Write (b byte ,r rune ){_b ._ef .Lock ();defer _b ._ef .Unlock ();
_b ._aa [b ]=r };func (_fce *RuneSet )Length ()int {_fce ._cc .RLock ();defer _fce ._cc .RUnlock ();return len (_fce ._dea )};func (_eb *RuneStringMap )Read (r rune )(string ,bool ){_eb ._ab .RLock ();defer _eb ._ab .RUnlock ();_gc ,_bcc :=_eb ._cdb [r ];
return _gc ,_bcc ;};type StringRuneMap struct{_ce map[string ]rune ;_ee _a .RWMutex ;};type StringsTuple struct{Key ,Value string ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_cdb :m }};func (_efe *ByteRuneMap )Range (f func (_d byte ,_af rune )(_f bool )){_efe ._ef .RLock ();
defer _efe ._ef .RUnlock ();for _df ,_cg :=range _efe ._aa {if f (_df ,_cg ){break ;};};};func (_fff *RuneUint16Map )Write (r rune ,g uint16 ){_fff ._cb .Lock ();defer _fff ._cb .Unlock ();_fff ._efcb [r ]=g ;};func (_db *RuneSet )Write (r rune ){_db ._cc .Lock ();
defer _db ._cc .Unlock ();_db ._dea [r ]=struct{}{}};func (_adc *StringsMap )Range (f func (_fda ,_cae string )(_bcg bool )){_adc ._cdd .RLock ();defer _adc ._cdd .RUnlock ();for _cec ,_efd :=range _adc ._dgf {if f (_cec ,_efd ){break ;};};};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_efcb :make (map[rune ]uint16 ,length )};
};func (_gb *StringsMap )Read (g string )(string ,bool ){_gb ._cdd .RLock ();defer _gb ._cdd .RUnlock ();_ceb ,_ebe :=_gb ._dgf [g ];return _ceb ,_ebe ;};func (_gdb *RuneStringMap )Write (r rune ,s string ){_gdb ._ab .Lock ();defer _gdb ._ab .Unlock ();
_gdb ._cdb [r ]=s ;};func (_gf *RuneStringMap )Length ()int {_gf ._ab .RLock ();defer _gf ._ab .RUnlock ();return len (_gf ._cdb );};func (_bd *RuneByteMap )Range (f func (_de rune ,_ge byte )(_dd bool )){_bd ._gd .RLock ();defer _bd ._gd .RUnlock ();for _ba ,_be :=range _bd ._g {if f (_ba ,_be ){break ;
};};};func (_cd *ByteRuneMap )Length ()int {_cd ._ef .RLock ();defer _cd ._ef .RUnlock ();return len (_cd ._aa )};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_ce :m }};type RuneStringMap struct{_cdb map[rune ]string ;
_ab _a .RWMutex ;};func (_gg *StringRuneMap )Range (f func (_fdg string ,_bg rune )(_egf bool )){_gg ._ee .RLock ();defer _gg ._ee .RUnlock ();for _egfc ,_agf :=range _gg ._ce {if f (_egfc ,_agf ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_aa :make (map[byte ]rune ,length )}};
type RuneSet struct{_dea map[rune ]struct{};_cc _a .RWMutex ;};func (_ca *RuneSet )Exists (r rune )bool {_ca ._cc .RLock ();defer _ca ._cc .RUnlock ();_ ,_ag :=_ca ._dea [r ];return _ag ;};type RuneByteMap struct{_g map[rune ]byte ;_gd _a .RWMutex ;};type RuneUint16Map struct{_efcb map[rune ]uint16 ;
_cb _a .RWMutex ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_dea :make (map[rune ]struct{},length )}};func (_c *ByteRuneMap )Read (b byte )(rune ,bool ){_c ._ef .RLock ();defer _c ._ef .RUnlock ();_eff ,_eg :=_c ._aa [b ];return _eff ,_eg ;
};func (_aag *RuneSet )Range (f func (_efc rune )(_def bool )){_aag ._cc .RLock ();defer _aag ._cc .RUnlock ();for _gec :=range _aag ._dea {if f (_gec ){break ;};};};func (_dbg *RuneUint16Map )Read (r rune )(uint16 ,bool ){_dbg ._cb .RLock ();defer _dbg ._cb .RUnlock ();
_ga ,_fa :=_dbg ._efcb [r ];return _ga ,_fa ;};func MakeRuneByteMap (length int )*RuneByteMap {_bc :=make (map[rune ]byte ,length );return &RuneByteMap {_g :_bc };};func (_dg *RuneByteMap )Write (r rune ,b byte ){_dg ._gd .Lock ();defer _dg ._gd .Unlock ();
_dg ._g [r ]=b };func (_cga *StringsMap )Write (g1 ,g2 string ){_cga ._cdd .Lock ();defer _cga ._cdd .Unlock ();_cga ._dgf [g1 ]=g2 ;};func (_fc *RuneByteMap )Length ()int {_fc ._gd .RLock ();defer _fc ._gd .RUnlock ();return len (_fc ._g )};func (_bbf *StringsMap )Copy ()*StringsMap {_bbf ._cdd .RLock ();
defer _bbf ._cdd .RUnlock ();_da :=map[string ]string {};for _fac ,_ecc :=range _bbf ._dgf {_da [_fac ]=_ecc ;};return &StringsMap {_dgf :_da };};func NewStringsMap (tuples []StringsTuple )*StringsMap {_dbag :=map[string ]string {};for _ ,_agb :=range tuples {_dbag [_agb .Key ]=_agb .Value ;
};return &StringsMap {_dgf :_dbag };};func (_fdc *StringRuneMap )Write (g string ,r rune ){_fdc ._ee .Lock ();defer _fdc ._ee .Unlock ();_fdc ._ce [g ]=r ;};func (_ae *RuneStringMap )Range (f func (_fd rune ,_cca string )(_effg bool )){_ae ._ab .RLock ();
defer _ae ._ab .RUnlock ();for _dee ,_dge :=range _ae ._cdb {if f (_dee ,_dge ){break ;};};};func (_ddbd *StringRuneMap )Read (g string )(rune ,bool ){_ddbd ._ee .RLock ();defer _ddbd ._ee .RUnlock ();_bab ,_bbb :=_ddbd ._ce [g ];return _bab ,_bbb ;};func (_gac *StringRuneMap )Length ()int {_gac ._ee .RLock ();
defer _gac ._ee .RUnlock ();return len (_gac ._ce );};type StringsMap struct{_dgf map[string ]string ;_cdd _a .RWMutex ;};func (_dgd *RuneUint16Map )RangeDelete (f func (_eag rune ,_dba uint16 )(_ec bool ,_defg bool )){_dgd ._cb .Lock ();defer _dgd ._cb .Unlock ();
for _gde ,_cbd :=range _dgd ._efcb {_ed ,_bb :=f (_gde ,_cbd );if _ed {delete (_dgd ._efcb ,_gde );};if _bb {break ;};};};func (_fg *RuneUint16Map )Range (f func (_ea rune ,_aaf uint16 )(_gcc bool )){_fg ._cb .RLock ();defer _fg ._cb .RUnlock ();for _fdf ,_fde :=range _fg ._efcb {if f (_fdf ,_fde ){break ;
};};};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_aa :m }};func (_dfe *RuneUint16Map )Delete (r rune ){_dfe ._cb .Lock ();defer _dfe ._cb .Unlock ();delete (_dfe ._efcb ,r );};func (_ddb *RuneUint16Map )Length ()int {_ddb ._cb .RLock ();
defer _ddb ._cb .RUnlock ();return len (_ddb ._efcb );};type ByteRuneMap struct{_aa map[byte ]rune ;_ef _a .RWMutex ;};