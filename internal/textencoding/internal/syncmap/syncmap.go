//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func (_eeg *RuneStringMap )Write (r rune ,s string ){_eeg ._cfc .Lock ();defer _eeg ._cfc .Unlock ();_eeg ._acg [r ]=s ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_b :m }};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_b :make (map[byte ]rune ,length )}};
type ByteRuneMap struct{_b map[byte ]rune ;_e _c .RWMutex ;};func (_caef *RuneStringMap )Read (r rune )(string ,bool ){_caef ._cfc .RLock ();defer _caef ._cfc .RUnlock ();_bc ,_gcc :=_caef ._acg [r ];return _bc ,_gcc ;};func (_adb *StringsMap )Write (g1 ,g2 string ){_adb ._df .Lock ();
defer _adb ._df .Unlock ();_adb ._eef [g1 ]=g2 ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ga :make (map[rune ]uint16 ,length )};};func (_bdf *RuneUint16Map )Delete (r rune ){_bdf ._ab .Lock ();defer _bdf ._ab .Unlock ();
delete (_bdf ._ga ,r );};func (_gf *RuneByteMap )Read (r rune )(byte ,bool ){_gf ._ag .RLock ();defer _gf ._ag .RUnlock ();_gc ,_da :=_gf ._db [r ];return _gc ,_da ;};func (_cf *RuneByteMap )Length ()int {_cf ._ag .RLock ();defer _cf ._ag .RUnlock ();return len (_cf ._db )};
func (_dg *RuneByteMap )Range (f func (_gbb rune ,_ec byte )(_eeb bool )){_dg ._ag .RLock ();defer _dg ._ag .RUnlock ();for _de ,_fc :=range _dg ._db {if f (_de ,_fc ){break ;};};};type RuneUint16Map struct{_ga map[rune ]uint16 ;_ab _c .RWMutex ;};type RuneSet struct{_ff map[rune ]struct{};
_fb _c .RWMutex ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_acg :m }};func (_ggd *StringRuneMap )Read (g string )(rune ,bool ){_ggd ._bg .RLock ();defer _ggd ._bg .RUnlock ();_fbc ,_ea :=_ggd ._cac [g ];return _fbc ,_ea ;
};func (_be *RuneStringMap )Range (f func (_dbc rune ,_eb string )(_acgb bool )){_be ._cfc .RLock ();defer _be ._cfc .RUnlock ();for _dd ,_ddf :=range _be ._acg {if f (_dd ,_ddf ){break ;};};};func NewStringsMap (tuples []StringsTuple )*StringsMap {_dcd :=map[string ]string {};
for _ ,_gec :=range tuples {_dcd [_gec .Key ]=_gec .Value ;};return &StringsMap {_eef :_dcd };};func (_fec *RuneUint16Map )Read (r rune )(uint16 ,bool ){_fec ._ab .RLock ();defer _fec ._ab .RUnlock ();_ef ,_af :=_fec ._ga [r ];return _ef ,_af ;};type RuneByteMap struct{_db map[rune ]byte ;
_ag _c .RWMutex ;};func (_ac *RuneSet )Exists (r rune )bool {_ac ._fb .RLock ();defer _ac ._fb .RUnlock ();_ ,_cae :=_ac ._ff [r ];return _cae ;};func (_cd *StringsMap )Read (g string )(string ,bool ){_cd ._df .RLock ();defer _cd ._df .RUnlock ();_cga ,_cacf :=_cd ._eef [g ];
return _cga ,_cacf ;};func (_edg *RuneSet )Length ()int {_edg ._fb .RLock ();defer _edg ._fb .RUnlock ();return len (_edg ._ff )};func (_agf *RuneByteMap )Write (r rune ,b byte ){_agf ._ag .Lock ();defer _agf ._ag .Unlock ();_agf ._db [r ]=b ;};func (_cg *RuneStringMap )Length ()int {_cg ._cfc .RLock ();
defer _cg ._cfc .RUnlock ();return len (_cg ._acg );};func (_acb *RuneUint16Map )RangeDelete (f func (_fbg rune ,_ggc uint16 )(_cgc bool ,_fbe bool )){_acb ._ab .Lock ();defer _acb ._ab .Unlock ();for _ddbd ,_ddba :=range _acb ._ga {_adg ,_ffa :=f (_ddbd ,_ddba );
if _adg {delete (_acb ._ga ,_ddbd );};if _ffa {break ;};};};func (_a *ByteRuneMap )Length ()int {_a ._e .RLock ();defer _a ._e .RUnlock ();return len (_a ._b )};func (_fe *ByteRuneMap )Write (b byte ,r rune ){_fe ._e .Lock ();defer _fe ._e .Unlock ();_fe ._b [b ]=r };
func (_edgc *StringRuneMap )Write (g string ,r rune ){_edgc ._bg .Lock ();defer _edgc ._bg .Unlock ();_edgc ._cac [g ]=r ;};func (_bd *RuneSet )Write (r rune ){_bd ._fb .Lock ();defer _bd ._fb .Unlock ();_bd ._ff [r ]=struct{}{}};func (_g *ByteRuneMap )Read (b byte )(rune ,bool ){_g ._e .RLock ();
defer _g ._e .RUnlock ();_gb ,_f :=_g ._b [b ];return _gb ,_f ;};func (_daf *StringsMap )Copy ()*StringsMap {_daf ._df .RLock ();defer _daf ._df .RUnlock ();_abca :=map[string ]string {};for _afc ,_ade :=range _daf ._eef {_abca [_afc ]=_ade ;};return &StringsMap {_eef :_abca };
};func (_aa *StringRuneMap )Range (f func (_fgg string ,_eea rune )(_ecf bool )){_aa ._bg .RLock ();defer _aa ._bg .RUnlock ();for _dc ,_fa :=range _aa ._cac {if f (_dc ,_fa ){break ;};};};func (_ddc *StringsMap )Range (f func (_cdd ,_fag string )(_ddce bool )){_ddc ._df .RLock ();
defer _ddc ._df .RUnlock ();for _cff ,_fbgf :=range _ddc ._eef {if f (_cff ,_fbgf ){break ;};};};func (_bf *RuneSet )Range (f func (_gbd rune )(_ae bool )){_bf ._fb .RLock ();defer _bf ._fb .RUnlock ();for _ed :=range _bf ._ff {if f (_ed ){break ;};};};
type StringsMap struct{_eef map[string ]string ;_df _c .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_cac :m }};func (_fef *StringRuneMap )Length ()int {_fef ._bg .RLock ();defer _fef ._bg .RUnlock ();return len (_fef ._cac );
};func MakeRuneByteMap (length int )*RuneByteMap {_ba :=make (map[rune ]byte ,length );return &RuneByteMap {_db :_ba };};func (_ddb *RuneUint16Map )Write (r rune ,g uint16 ){_ddb ._ab .Lock ();defer _ddb ._ab .Unlock ();_ddb ._ga [r ]=g ;};func (_fg *RuneUint16Map )Length ()int {_fg ._ab .RLock ();
defer _fg ._ab .RUnlock ();return len (_fg ._ga )};type StringsTuple struct{Key ,Value string ;};type StringRuneMap struct{_cac map[string ]rune ;_bg _c .RWMutex ;};func (_abc *RuneUint16Map )Range (f func (_beg rune ,_ad uint16 )(_gdd bool )){_abc ._ab .RLock ();
defer _abc ._ab .RUnlock ();for _bec ,_bb :=range _abc ._ga {if f (_bec ,_bb ){break ;};};};func (_ca *ByteRuneMap )Range (f func (_gd byte ,_ge rune )(_gda bool )){_ca ._e .RLock ();defer _ca ._e .RUnlock ();for _ee ,_gg :=range _ca ._b {if f (_ee ,_gg ){break ;
};};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ff :make (map[rune ]struct{},length )}};type RuneStringMap struct{_acg map[rune ]string ;_cfc _c .RWMutex ;};