//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _f "sync";func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_c :make (map[byte ]rune ,length )}};func (_aab *StringsMap )Read (g string )(string ,bool ){_aab ._ed .RLock ();defer _aab ._ed .RUnlock ();_adf ,_acf :=_aab ._gacb [g ];
return _adf ,_acf ;};type StringRuneMap struct{_df map[string ]rune ;_ecb _f .RWMutex ;};func (_fde *StringRuneMap )Read (g string )(rune ,bool ){_fde ._ecb .RLock ();defer _fde ._ecb .RUnlock ();_dfa ,_aba :=_fde ._df [g ];return _dfa ,_aba ;};func (_db *RuneStringMap )Write (r rune ,s string ){_db ._ea .Lock ();
defer _db ._ea .Unlock ();_db ._ggb [r ]=s ;};func (_gba *RuneSet )Exists (r rune )bool {_gba ._ff .RLock ();defer _gba ._ff .RUnlock ();_ ,_feb :=_gba ._ba [r ];return _feb ;};func (_gce *StringsMap )Range (f func (_ggf ,_ccec string )(_dcc bool )){_gce ._ed .RLock ();
defer _gce ._ed .RUnlock ();for _eae ,_dfg :=range _gce ._gacb {if f (_eae ,_dfg ){break ;};};};func (_eb *RuneUint16Map )RangeDelete (f func (_beb rune ,_bc uint16 )(_ffa bool ,_fb bool )){_eb ._gaa .Lock ();defer _eb ._gaa .Unlock ();for _adg ,_gbf :=range _eb ._de {_fbb ,_dac :=f (_adg ,_gbf );
if _fbb {delete (_eb ._de ,_adg );};if _dac {break ;};};};type RuneSet struct{_ba map[rune ]struct{};_ff _f .RWMutex ;};func (_fcf *StringRuneMap )Write (g string ,r rune ){_fcf ._ecb .Lock ();defer _fcf ._ecb .Unlock ();_fcf ._df [g ]=r ;};func (_ef *ByteRuneMap )Read (b byte )(rune ,bool ){_ef ._cg .RLock ();
defer _ef ._cg .RUnlock ();_cd ,_a :=_ef ._c [b ];return _cd ,_a ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ac :=map[string ]string {};for _ ,_efgb :=range tuples {_ac [_efgb .Key ]=_efgb .Value ;};return &StringsMap {_gacb :_ac };};func (_daa *RuneSet )Length ()int {_daa ._ff .RLock ();
defer _daa ._ff .RUnlock ();return len (_daa ._ba )};func (_aa *ByteRuneMap )Length ()int {_aa ._cg .RLock ();defer _aa ._cg .RUnlock ();return len (_aa ._c )};func (_ggc *RuneStringMap )Read (r rune )(string ,bool ){_ggc ._ea .RLock ();defer _ggc ._ea .RUnlock ();
_ee ,_be :=_ggc ._ggb [r ];return _ee ,_be ;};func (_ecf *RuneUint16Map )Read (r rune )(uint16 ,bool ){_ecf ._gaa .RLock ();defer _ecf ._gaa .RUnlock ();_gcb ,_gad :=_ecf ._de [r ];return _gcb ,_gad ;};func (_g *ByteRuneMap )Range (f func (_ca byte ,_ad rune )(_ec bool )){_g ._cg .RLock ();
defer _g ._cg .RUnlock ();for _cf ,_b :=range _g ._c {if f (_cf ,_b ){break ;};};};type ByteRuneMap struct{_c map[byte ]rune ;_cg _f .RWMutex ;};func (_fg *RuneUint16Map )Range (f func (_fa rune ,_gee uint16 )(_cce bool )){_fg ._gaa .RLock ();defer _fg ._gaa .RUnlock ();
for _cdg ,_febd :=range _fg ._de {if f (_cdg ,_febd ){break ;};};};type RuneStringMap struct{_ggb map[rune ]string ;_ea _f .RWMutex ;};func (_dbd *StringRuneMap )Length ()int {_dbd ._ecb .RLock ();defer _dbd ._ecb .RUnlock ();return len (_dbd ._df );};
func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_de :make (map[rune ]uint16 ,length )};};func (_gb *RuneByteMap )Write (r rune ,b byte ){_gb ._d .Lock ();defer _gb ._d .Unlock ();_gb ._bg [r ]=b };func (_aca *StringsMap )Copy ()*StringsMap {_aca ._ed .RLock ();
defer _aca ._ed .RUnlock ();_ecbf :=map[string ]string {};for _bacf ,_gf :=range _aca ._gacb {_ecbf [_bacf ]=_gf ;};return &StringsMap {_gacb :_ecbf };};func (_ce *ByteRuneMap )Write (b byte ,r rune ){_ce ._cg .Lock ();defer _ce ._cg .Unlock ();_ce ._c [b ]=r };
type RuneByteMap struct{_bg map[rune ]byte ;_d _f .RWMutex ;};func (_da *RuneByteMap )Read (r rune )(byte ,bool ){_da ._d .RLock ();defer _da ._d .RUnlock ();_fe ,_cc :=_da ._bg [r ];return _fe ,_cc ;};func (_gac *RuneStringMap )Length ()int {_gac ._ea .RLock ();
defer _gac ._ea .RUnlock ();return len (_gac ._ggb );};type RuneUint16Map struct{_de map[rune ]uint16 ;_gaa _f .RWMutex ;};type StringsTuple struct{Key ,Value string ;};func (_cge *StringRuneMap )Range (f func (_gcbd string ,_gd rune )(_ead bool )){_cge ._ecb .RLock ();
defer _cge ._ecb .RUnlock ();for _fgb ,_bac :=range _cge ._df {if f (_fgb ,_bac ){break ;};};};func (_fc *RuneStringMap )Range (f func (_ae rune ,_afd string )(_ceg bool )){_fc ._ea .RLock ();defer _fc ._ea .RUnlock ();for _cb ,_fd :=range _fc ._ggb {if f (_cb ,_fd ){break ;
};};};func MakeRuneByteMap (length int )*RuneByteMap {_ab :=make (map[rune ]byte ,length );return &RuneByteMap {_bg :_ab };};type StringsMap struct{_gacb map[string ]string ;_ed _f .RWMutex ;};func (_ge *RuneUint16Map )Write (r rune ,g uint16 ){_ge ._gaa .Lock ();
defer _ge ._gaa .Unlock ();_ge ._de [r ]=g ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_df :m }};func (_eg *RuneSet )Write (r rune ){_eg ._ff .Lock ();defer _eg ._ff .Unlock ();_eg ._ba [r ]=struct{}{}};func (_adc *RuneByteMap )Range (f func (_ga rune ,_gg byte )(_efg bool )){_adc ._d .RLock ();
defer _adc ._d .RUnlock ();for _cec ,_af :=range _adc ._bg {if f (_cec ,_af ){break ;};};};func (_abe *RuneSet )Range (f func (_aad rune )(_add bool )){_abe ._ff .RLock ();defer _abe ._ff .RUnlock ();for _fec :=range _abe ._ba {if f (_fec ){break ;};};
};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ba :make (map[rune ]struct{},length )}};func (_gc *RuneByteMap )Length ()int {_gc ._d .RLock ();defer _gc ._d .RUnlock ();return len (_gc ._bg )};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ggb :m }};
func (_ccg *RuneUint16Map )Length ()int {_ccg ._gaa .RLock ();defer _ccg ._gaa .RUnlock ();return len (_ccg ._de );};func (_cdc *StringsMap )Write (g1 ,g2 string ){_cdc ._ed .Lock ();defer _cdc ._ed .Unlock ();_cdc ._gacb [g1 ]=g2 ;};func (_ecfa *RuneUint16Map )Delete (r rune ){_ecfa ._gaa .Lock ();
defer _ecfa ._gaa .Unlock ();delete (_ecfa ._de ,r );};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_c :m }};