//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _b "sync";type RuneStringMap struct{_adg map[rune ]string ;_ada _b .RWMutex ;};func (_d *ByteRuneMap )Range (f func (_ad byte ,_ef rune )(_af bool )){_d ._c .RLock ();defer _d ._c .RUnlock ();for _ac ,_cc :=range _d ._e {if f (_ac ,_cc ){break ;
};};};func (_fgg *RuneUint16Map )Range (f func (_cg rune ,_bgc uint16 )(_cdg bool )){_fgg ._gbf .RLock ();defer _fgg ._gbf .RUnlock ();for _fge ,_dg :=range _fgg ._bbf {if f (_fge ,_dg ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_e :make (map[byte ]rune ,length )}};
func (_adf *StringsMap )Write (g1 ,g2 string ){_adf ._aed .Lock ();defer _adf ._aed .Unlock ();_adf ._dbg [g1 ]=g2 ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_cd :make (map[rune ]struct{},length )}};func (_ce *RuneSet )Range (f func (_ace rune )(_acg bool )){_ce ._aff .RLock ();
defer _ce ._aff .RUnlock ();for _be :=range _ce ._cd {if f (_be ){break ;};};};func (_ge *RuneStringMap )Length ()int {_ge ._ada .RLock ();defer _ge ._ada .RUnlock ();return len (_ge ._adg );};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_e :m }};
func (_eb *RuneByteMap )Write (r rune ,b byte ){_eb ._gf .Lock ();defer _eb ._gf .Unlock ();_eb ._ae [r ]=b };func (_aba *RuneUint16Map )Write (r rune ,g uint16 ){_aba ._gbf .Lock ();defer _aba ._gbf .Unlock ();_aba ._bbf [r ]=g ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_acdf :m }};
type ByteRuneMap struct{_e map[byte ]rune ;_c _b .RWMutex ;};func (_ea *RuneSet )Write (r rune ){_ea ._aff .Lock ();defer _ea ._aff .Unlock ();_ea ._cd [r ]=struct{}{}};func (_fg *RuneStringMap )Range (f func (_gb rune ,_adaf string )(_gac bool )){_fg ._ada .RLock ();
defer _fg ._ada .RUnlock ();for _gd ,_de :=range _fg ._adg {if f (_gd ,_de ){break ;};};};func (_fba *StringsMap )Range (f func (_egc ,_fdc string )(_bbe bool )){_fba ._aed .RLock ();defer _fba ._aed .RUnlock ();for _fbc ,_efe :=range _fba ._dbg {if f (_fbc ,_efe ){break ;
};};};func (_bb *ByteRuneMap )Write (b byte ,r rune ){_bb ._c .Lock ();defer _bb ._c .Unlock ();_bb ._e [b ]=r };func (_eeg *RuneStringMap )Write (r rune ,s string ){_eeg ._ada .Lock ();defer _eeg ._ada .Unlock ();_eeg ._adg [r ]=s ;};func (_gbg *StringRuneMap )Write (g string ,r rune ){_gbg ._bgf .Lock ();
defer _gbg ._bgf .Unlock ();_gbg ._acdf [g ]=r ;};type RuneByteMap struct{_ae map[rune ]byte ;_gf _b .RWMutex ;};func (_db *RuneUint16Map )Delete (r rune ){_db ._gbf .Lock ();defer _db ._gbf .Unlock ();delete (_db ._bbf ,r );};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_adg :m }};
type StringsMap struct{_dbg map[string ]string ;_aed _b .RWMutex ;};func (_da *RuneByteMap )Range (f func (_ec rune ,_fc byte )(_fb bool )){_da ._gf .RLock ();defer _da ._gf .RUnlock ();for _aeg ,_ee :=range _da ._ae {if f (_aeg ,_ee ){break ;};};};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ebf :=map[string ]string {};
for _ ,_gacf :=range tuples {_ebf [_gacf .Key ]=_gacf .Value ;};return &StringsMap {_dbg :_ebf };};func (_ff *RuneUint16Map )Length ()int {_ff ._gbf .RLock ();defer _ff ._gbf .RUnlock ();return len (_ff ._bbf );};type StringRuneMap struct{_acdf map[string ]rune ;
_bgf _b .RWMutex ;};func (_g *ByteRuneMap )Length ()int {_g ._c .RLock ();defer _g ._c .RUnlock ();return len (_g ._e )};func (_fbga *StringsMap )Copy ()*StringsMap {_fbga ._aed .RLock ();defer _fbga ._aed .RUnlock ();_egf :=map[string ]string {};for _fgd ,_bde :=range _fbga ._dbg {_egf [_fgd ]=_bde ;
};return &StringsMap {_dbg :_egf };};type RuneUint16Map struct{_bbf map[rune ]uint16 ;_gbf _b .RWMutex ;};type RuneSet struct{_cd map[rune ]struct{};_aff _b .RWMutex ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_bbf :make (map[rune ]uint16 ,length )};
};func (_beb *RuneUint16Map )RangeDelete (f func (_ecf rune ,_gde uint16 )(_cdb bool ,_dgg bool )){_beb ._gbf .Lock ();defer _beb ._gbf .Unlock ();for _fde ,_ddg :=range _beb ._bbf {_eg ,_eef :=f (_fde ,_ddg );if _eg {delete (_beb ._bbf ,_fde );};if _eef {break ;
};};};func (_fda *StringRuneMap )Range (f func (_dgb string ,_ega rune )(_ged bool )){_fda ._bgf .RLock ();defer _fda ._bgf .RUnlock ();for _bc ,_ggb :=range _fda ._acdf {if f (_bc ,_ggb ){break ;};};};func MakeRuneByteMap (length int )*RuneByteMap {_bg :=make (map[rune ]byte ,length );
return &RuneByteMap {_ae :_bg };};func (_cb *RuneUint16Map )Read (r rune )(uint16 ,bool ){_cb ._gbf .RLock ();defer _cb ._gbf .RUnlock ();_dde ,_fe :=_cb ._bbf [r ];return _dde ,_fe ;};func (_cf *RuneByteMap )Length ()int {_cf ._gf .RLock ();defer _cf ._gf .RUnlock ();
return len (_cf ._ae )};func (_ed *StringsMap )Read (g string )(string ,bool ){_ed ._aed .RLock ();defer _ed ._aed .RUnlock ();_abb ,_bf :=_ed ._dbg [g ];return _abb ,_bf ;};func (_df *RuneByteMap )Read (r rune )(byte ,bool ){_df ._gf .RLock ();defer _df ._gf .RUnlock ();
_ga ,_aa :=_df ._ae [r ];return _ga ,_aa ;};func (_f *ByteRuneMap )Read (b byte )(rune ,bool ){_f ._c .RLock ();defer _f ._c .RUnlock ();_fd ,_bd :=_f ._e [b ];return _fd ,_bd ;};type StringsTuple struct{Key ,Value string ;};func (_eeb *RuneStringMap )Read (r rune )(string ,bool ){_eeb ._ada .RLock ();
defer _eeb ._ada .RUnlock ();_dag ,_afb :=_eeb ._adg [r ];return _dag ,_afb ;};func (_ag *StringRuneMap )Length ()int {_ag ._bgf .RLock ();defer _ag ._bgf .RUnlock ();return len (_ag ._acdf );};func (_acd *RuneSet )Length ()int {_acd ._aff .RLock ();defer _acd ._aff .RUnlock ();
return len (_acd ._cd )};func (_acc *StringRuneMap )Read (g string )(rune ,bool ){_acc ._bgf .RLock ();defer _acc ._bgf .RUnlock ();_aaf ,_fbg :=_acc ._acdf [g ];return _aaf ,_fbg ;};func (_gg *RuneSet )Exists (r rune )bool {_gg ._aff .RLock ();defer _gg ._aff .RUnlock ();
_ ,_ab :=_gg ._cd [r ];return _ab ;};