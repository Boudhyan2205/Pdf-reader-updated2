//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package pdfa provides abstraction to optimize and verify documents with respect to the PDF/A standards.
// NOTE: This implementation is in experimental development state.
// 	Keep in mind that it might change in the subsequent minor versions.
package pdfa ;import (_da "errors";_gf "fmt";_b "github.com/adrg/sysfont";_f "github.com/unidoc/unipdf/v3/common";_d "github.com/unidoc/unipdf/v3/core";_bf "github.com/unidoc/unipdf/v3/internal/imageutil";_ba "github.com/unidoc/unipdf/v3/internal/uuid";
_bc "github.com/unidoc/unipdf/v3/internal/xmp";_c "github.com/unidoc/unipdf/v3/model";_eg "github.com/unidoc/unipdf/v3/model/internal/colorprofile";_baf "github.com/unidoc/unipdf/v3/model/internal/docutil";_e "time";);func _abd (_ddcf *_baf .Document ,_bda func ()_e .Time )error {_afed ,_ced :=_c .NewPdfInfoFromObject (_ddcf .Info );
if _ced !=nil {return _ced ;};if _caa :=_gda (_afed ,_bda );_caa !=nil {return _caa ;};_ddcf .Info =_afed .ToPdfObject ();return nil ;};func _ddeg (_ebe *_c .DetailedPdfReader )bool {return _ebe .ParserMetadata ().HeaderPosition ()==0};func _fdbeg (_cgaf *_c .DetailedPdfReader )bool {return true };
func _cab (_adf *_c .DetailedPdfReader )bool {return true };func _dbbc (_badf *_c .DetailedPdfReader )bool {return true };func _dba (_def *_c .DetailedPdfReader )bool {_acf ,_gfcd :=_def .PdfReader .GetTrailer ();if _gfcd !=nil {_f .Log .Error ("\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_gfcd );
return false ;};return _acf .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074")==nil ;};func _dgaa (_bfbg *_c .DetailedPdfReader )bool {return true };func _afdf (_cafb *_baf .Document ,_gfe standardType ,_ddaa *_baf .OutputIntents )error {var (_deg *_c .PdfOutputIntent ;
_cff error ;);if _cafb .Version .Minor <=4{_deg ,_cff =_eg .NewSRGBv2OutputIntent (_gfe .outputIntentSubtype ());}else {_deg ,_cff =_eg .NewSRGBv4OutputIntent (_gfe .outputIntentSubtype ());};if _cff !=nil {return _cff ;};if _cff =_ddaa .Add (_deg .ToPdfObject ());
_cff !=nil {return _cff ;};return nil ;};type pageImageOptimizeFunc func (_ebfg *_baf .Document ,_bae *_baf .Page ,_ggd []*_baf .Image )error ;func _ddcd (_fbed *_c .DetailedPdfReader )bool {return true };func _dab ()standardType {return standardType {_a :1,_eb :"\u0041"}};
func _efa (_aca *Profile1Options ){if _aca .Now ==nil {_aca .Now =_e .Now ;};if _aca .UUIDGenerator ==nil {_aca .UUIDGenerator =NewUUID ;};};

// NewProfile1A creates a new Profile1A with given options.
func NewProfile1A (options *Profile1Options )*Profile1A {if options ==nil {options =DefaultProfile1Options ();};_efa (options );return &Profile1A {profile1 {_cfgb :*options ,_fbg :_dab ()}};};func _dc ()standardType {return standardType {_a :2,_eb :"\u0041"}};


// Conformance gets the PDF/A conformance.
func (_dfe *profile1 )Conformance ()string {return _dfe ._fbg ._eb };

// StandardName gets the name of the standard.
func (_faa *profile1 )StandardName ()string {return _gf .Sprintf ("\u0050D\u0046\u002f\u0041\u002d\u0031\u0025s",_faa ._fbg ._eb );};func _dee (_cgf standardType ,_gbd *_baf .OutputIntents )error {_fea ,_gcdd :=_eg .NewEciCMYKOutputIntent (_cgf .outputIntentSubtype ());
if _gcdd !=nil {return _gcdd ;};if _gcdd =_gbd .Add (_fea .ToPdfObject ());_gcdd !=nil {return _gcdd ;};return nil ;};func _beae (_fafg *_c .DetailedPdfReader )bool {return true };

// Profile is the model.StandardApplier enhanced by the information about the profile conformance level.
type Profile interface{_c .Standard ;Conformance ()string ;Part ()int ;};type imageModifications struct{_fdf *colorspaceModification ;_aaff _d .StreamEncoder ;};func _fcce (_gfea *_c .DetailedPdfReader )bool {return true };func _aa (_df []_d .PdfObject )(*documentImages ,error ){_gb :=_d .PdfObjectName ("\u0053u\u0062\u0074\u0079\u0070\u0065");
_fg :=make (map[*_d .PdfObjectStream ]struct{});_dcg :=make (map[_d .PdfObject ]struct{});var (_ad ,_bgf ,_bd bool ;_af []*imageInfo ;_gd error ;);for _ ,_dg :=range _df {_fb ,_bb :=_d .GetStream (_dg );if !_bb {continue ;};if _ ,_fe :=_fg [_fb ];_fe {continue ;
};_fg [_fb ]=struct{}{};_dda :=_fb .PdfObjectDictionary .Get (_gb );_ge ,_bb :=_d .GetName (_dda );if !_bb ||string (*_ge )!="\u0049\u006d\u0061g\u0065"{continue ;};if _gg :=_fb .PdfObjectDictionary .Get ("\u0053\u004d\u0061s\u006b");_gg !=nil {_dcg [_gg ]=struct{}{};
};_cb :=imageInfo {BitsPerComponent :8,Stream :_fb };_cb .ColorSpace ,_gd =_c .DetermineColorspaceNameFromPdfObject (_fb .PdfObjectDictionary .Get ("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065"));if _gd !=nil {return nil ,_gd ;};if _ca ,_ggg :=_d .GetIntVal (_fb .PdfObjectDictionary .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
_ggg {_cb .BitsPerComponent =_ca ;};if _gea ,_ga :=_d .GetIntVal (_fb .PdfObjectDictionary .Get ("\u0057\u0069\u0064t\u0068"));_ga {_cb .Width =_gea ;};if _ccd ,_bafc :=_d .GetIntVal (_fb .PdfObjectDictionary .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));
_bafc {_cb .Height =_ccd ;};switch _cb .ColorSpace {case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":_bd =true ;_cb .ColorComponents =1;case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":_ad =true ;_cb .ColorComponents =3;case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":_bgf =true ;
_cb .ColorComponents =4;default:_cb ._ag =true ;};_af =append (_af ,&_cb );};if len (_dcg )> 0{if len (_dcg )==len (_af ){_af =nil ;}else {_aaf :=make ([]*imageInfo ,len (_af )-len (_dcg ));var _ddc int ;for _ ,_bfa :=range _af {if _ ,_gaf :=_dcg [_bfa .Stream ];
_gaf {continue ;};_aaf [_ddc ]=_bfa ;_ddc ++;};_af =_aaf ;};};return &documentImages {_dcf :_ad ,_ec :_bgf ,_cd :_bd ,_dd :_dcg ,_cf :_af },nil ;};func _baff (_ebec *_c .DetailedPdfReader )bool {return true };func _gda (_ebfd *_c .PdfInfo ,_gfg func ()_e .Time )error {var _bec *_c .PdfDate ;
if _ebfd .CreationDate ==nil {_abag ,_eab :=_c .NewPdfDateFromTime (_gfg ());if _eab !=nil {return _eab ;};_bec =&_abag ;_ebfd .CreationDate =_bec ;};if _ebfd .ModifiedDate ==nil {if _bec !=nil {_dde ,_gege :=_c .NewPdfDateFromTime (_gfg ());if _gege !=nil {return _gege ;
};_bec =&_dde ;};_ebfd .ModifiedDate =_bec ;};return nil ;};

// NewProfile1B creates a new Profile1B with the given options.
func NewProfile1B (options *Profile1Options )*Profile1B {if options ==nil {options =DefaultProfile1Options ();};_efa (options );return &Profile1B {profile1 {_cfgb :*options ,_fbg :_be ()}};};func _acd (_aba *_baf .Document ,_gcf int ){if _aba .Version .Major ==0{_aba .Version .Major =1;
};if _aba .Version .Minor < _gcf {_aba .Version .Minor =_gcf ;};};func _eff (_cga *_c .DetailedPdfReader )bool {_cfad :=_cga .ParserMetadata ().HeaderCommentBytes ();return _cfad [0]> 127&&_cfad [1]> 127&&_cfad [2]> 127&&_cfad [3]> 127;};func _afd (_agcb *_baf .Document )error {_fc ,_gdd :=_agcb .GetPages ();
if !_gdd {return nil ;};for _ ,_ef :=range _fc {_add ,_ea :=_ef .GetResources ();if !_ea {continue ;};_ege ,_db :=_d .GetDict (_add .Get ("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e"));if !_db {return nil ;};_ddg :=_ege .Keys ();for _ ,_faf :=range _ddg {_de ,_egc :=_d .GetDict (_ege .Get (_faf ));
if !_egc {continue ;};if _abg :=_de .Get ("\u0053\u004d\u0061s\u006b");_abg !=nil {_de .Set ("\u0053\u004d\u0061s\u006b",_d .MakeName ("\u004e\u006f\u006e\u0065"));};_bgfc :=_de .Get ("\u0043\u0041");if _bgfc !=nil {_efc ,_cfc :=_d .GetNumberAsFloat (_bgfc );
if _cfc !=nil {_f .Log .Debug ("\u0045x\u0074\u0047S\u0074\u0061\u0074\u0065 \u006f\u0062\u006ae\u0063\u0074\u0020\u0043\u0041\u0020\u0076\u0061\u006cue\u0020\u0069\u0073 \u006e\u006ft\u0020\u0061\u0020\u0066\u006c\u006fa\u0074\u003a \u0025\u0076",_cfc );
_efc =0;};if _efc !=1.0{_de .Set ("\u0043\u0041",_d .MakeFloat (1.0));};};_bgfc =_de .Get ("\u0063\u0061");if _bgfc !=nil {_abe ,_fdbe :=_d .GetNumberAsFloat (_bgfc );if _fdbe !=nil {_f .Log .Debug ("\u0045\u0078t\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0027\u0063\u0061\u0027\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0066\u006c\u006f\u0061\u0074\u003a\u0020\u0025\u0076",_fdbe );
_abe =0;};if _abe !=1.0{_de .Set ("\u0063\u0061",_d .MakeFloat (1.0));};};_dgc :=_de .Get ("\u0042\u004d");if _dgc !=nil {_cea ,_ede :=_d .GetName (_dgc );if _ede {_f .Log .Debug ("E\u0078\u0074\u0047\u0053\u0074\u0061t\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0027\u0042\u004d\u0027\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061m\u0065");
_cea =_d .MakeName ("");};_afea :=_cea .String ();switch _afea {case "\u004e\u006f\u0072\u006d\u0061\u006c","\u0043\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u006c\u0065":default:_de .Set ("\u0042\u004d",_d .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));
};};};};return nil ;};

// Part gets the PDF/A version level.
func (_cee *profile1 )Part ()int {return _cee ._fbg ._a };

// DefaultProfile1Options are the default options for the Profile1.
func DefaultProfile1Options ()*Profile1Options {return &Profile1Options {Now :_e .Now }};var _ Profile =(*Profile1B )(nil );type imageInfo struct{ColorSpace _d .PdfObjectName ;BitsPerComponent int ;ColorComponents int ;Width int ;Height int ;Stream *_d .PdfObjectStream ;
_ag bool ;};func _gbf (_cfag *_c .DetailedPdfReader )bool {return true };type documentImageOptimizeFunc func (_dfge *_baf .Document ,_eef []*_baf .Image )error ;func _cc ()standardType {return standardType {_a :2,_eb :"\u0042"}};func _cagb (_abbc *_c .DetailedPdfReader )bool {return true };
func _fbc (_agce *_c .DetailedPdfReader )bool {return true };type profile1 struct{_fbg standardType ;_cfgb Profile1Options ;};func _dac (_bgb *_c .DetailedPdfReader )bool {return true };func _bgg (_eeb bool ,_caff standardType )(pageImageOptimizeFunc ,documentImageOptimizeFunc ){var _bfdb ,_gdef ,_cfb bool ;
_ffe :=func (_cag *_baf .Document ,_ffg *_baf .Page ,_gdg []*_baf .Image )error {for _ ,_fccc :=range _gdg {switch _fccc .Colorspace {case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":_gdef =true ;case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":_bfdb =true ;
case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":_cfb =true ;};};return nil ;};_egeb :=func (_geec *_baf .Document ,_cdgf []*_baf .Image )error {_dgfa ,_bbb :=_geec .FindCatalog ();if !_bbb {return nil ;};_aag ,_bbb :=_dgfa .GetOutputIntents ();
if _bbb &&_aag .Len ()> 0{return nil ;};if !_bbb {_aag =_dgfa .NewOutputIntents ();};if !(_bfdb ||_cfb ||_gdef ){return nil ;};defer _dgfa .SetOutputIntents (_aag );if _bfdb &&!_cfb &&!_gdef {return _afdf (_geec ,_caff ,_aag );};if _cfb &&!_bfdb &&!_gdef {return _dee (_caff ,_aag );
};if _gdef &&!_bfdb &&!_cfb {return _bef (_caff ,_aag );};if _bfdb &&_cfb {if _bgd :=_fdb (_cdgf ,_eeb );_bgd !=nil {return _bgd ;};if _eeb {return _dee (_caff ,_aag );};return _afdf (_geec ,_caff ,_aag );};return nil ;};return _ffe ,_egeb ;};func _fgf (_gfd *_c .DetailedPdfReader )bool {return true };
func _deec (_fbe *_c .DetailedPdfReader )bool {return true };

// UUIDGenerator is the generator for the UUID.
type UUIDGenerator func ()UUID ;

// NewUUID is the UUIDGenerator function used for determining new UUID value.
func NewUUID ()UUID {return UUID (_ba .MustUUID ())};

// UUID is the unique universe identifier.
// It is used to generate XMP document uuid identifier.
type UUID [16]byte ;func _cceg (_ceec *_c .DetailedPdfReader )bool {return _ceec .ParserMetadata ().HasDataAfterEOF ()};

// Profile1B is the implementation of the PDF/A-1B standard profile.
// Implements model.Standard, Profile interfaces.
type Profile1B struct{profile1 };func _fdb (_dge []*_baf .Image ,_abb bool )error {_edg :=_d .PdfObjectName ("\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B");if _abb {_edg ="\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b";};for _ ,_geg :=range _dge {if _geg .Colorspace ==_edg {continue ;
};_ee ,_cad :=_c .NewXObjectImageFromStream (_geg .Stream );if _cad !=nil {return _cad ;};_ff ,_cad :=_ee .ToImage ();if _cad !=nil {return _cad ;};_egd ,_cad :=_ff .ToGoImage ();if _cad !=nil {return _cad ;};var _gde _c .PdfColorspace ;if _abb {_gde =_c .NewPdfColorspaceDeviceCMYK ();
_egd ,_cad =_bf .CMYKConverter .Convert (_egd );}else {_gde =_c .NewPdfColorspaceDeviceRGB ();_egd ,_cad =_bf .NRGBAConverter .Convert (_egd );};if _cad !=nil {return _cad ;};_ecc ,_egf :=_egd .(_bf .Image );if !_egf {return _da .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074 \u0069\u006d\u0070\u006c\u0065\u006de\u006e\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u0075\u0074\u0069\u006c\u002eI\u006d\u0061\u0067\u0065");
};_acb :=_ecc .Base ();_gc :=&_c .Image {Width :int64 (_acb .Width ),Height :int64 (_acb .Height ),BitsPerComponent :int64 (_acb .BitsPerComponent ),ColorComponents :_acb .ColorComponents ,Data :_acb .Data };_gc .SetDecode (_acb .Decode );_gc .SetAlpha (_acb .Alpha );
if _cad =_ee .SetImage (_gc ,_gde );_cad !=nil {return _cad ;};_ee .ToPdfObject ();_geg .ColorComponents =_acb .ColorComponents ;_geg .Colorspace =_edg ;};return nil ;};func _fgg (_abf *_c .DetailedPdfReader )bool {return true };func _fdg (_bfda *_c .DetailedPdfReader )bool {return true };
func _ebfb (_edc *_c .DetailedPdfReader )bool {_cbg ,_ada :=_edc .PdfReader .GetTrailer ();if _ada !=nil {_f .Log .Error ("\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ada );
return false ;};return _cbg .Get ("\u0049\u0044")!=nil ;};type colorspaceModification struct{_ce _bf .ColorConverter ;_gae _c .PdfColorspace ;};type standardType struct{_a int ;_eb string ;};func _ggge (_cde *_c .DetailedPdfReader )bool {return true };
func (_bg *documentImages )hasOnlyDeviceRGB ()bool {return _bg ._dcf &&!_bg ._ec &&!_bg ._cd };func _fbbf (_gfcf *_c .DetailedPdfReader )bool {return true };func _be ()standardType {return standardType {_a :1,_eb :"\u0042"}};func _fbb (_fdbfb *_baf .Document ,_fad []pageImageOptimizeFunc ,_fce []documentImageOptimizeFunc )error {_ace ,_feb :=_fdbfb .GetPages ();
if !_feb {return nil ;};var _dfd []*_baf .Image ;for _edga ,_ded :=range _ace {_fab ,_efcc :=_ded .FindXObjectImages ();if _efcc !=nil {return _efcc ;};if len (_fab )==0{continue ;};for _ ,_cdcf :=range _fad {if _efcc =_cdcf (_fdbfb ,&_ace [_edga ],_fab );
_efcc !=nil {return _efcc ;};};_dfd =append (_dfd ,_fab ...);};for _ ,_ccg :=range _fce {if _egg :=_ccg (_fdbfb ,_dfd );_egg !=nil {return _egg ;};};return nil ;};func _edf (_fccgd *_c .DetailedPdfReader )bool {return true };

// Profile1A is the implementation of the PDF/A-1A standard profile.
// Implements model.Standard, Profile interfaces.
type Profile1A struct{profile1 };func _cfa (_fcd *_baf .Document ,_aaffa standardType ,_fdbf UUIDGenerator )error {_egdc ,_bfd :=_fcd .FindCatalog ();if !_bfd {return nil ;};if _egdc .HasMetadata (){return nil ;};_dga ,_dfgc :=_bc .NewMetadataFromPdfInfo (_fcd .Info );
if _dfgc !=nil {return nil ;};_dga .PDFVersion =_gf .Sprintf ("\u0025\u0064\u002e%\u0064",_fcd .Version .Major ,_fcd .Version .Minor );if _dga .DocumentID ==_ba .Nil {_dga .DocumentID =_ba .UUID (_fdbf ());};if !_dga .ModifyDate .IsZero (){_dga .MetadataDate =_dga .ModifyDate ;
};_dga .PdfA =&_bc .PdfA {Part :_aaffa ._a ,Conformance :_aaffa ._eb };if _cdc :=_egdc .SetMetadata (_dga );_cdc !=nil {return _cdc ;};return nil ;};func _gffa (_adfe *_c .DetailedPdfReader )bool {return true };func _ddag (_eee *_baf .Document ){if _eee .ID [0]!=""&&_eee .ID [1]!=""{return ;
};_eee .UseHashBasedID =true ;};

// ValidateStandard checks if provided input DetailedPdfReader matches rules that conforms PDF/A-1 standard.
func (_fee *profile1 )ValidateStandard (r *_c .DetailedPdfReader )error {return nil };func _bfb (_ebg *_baf .Document ,_gaff *_baf .Page ,_bbe []*_baf .Image )error {for _ ,_bea :=range _bbe {if _bea .SMask ==nil {continue ;};_ffaf ,_fccg :=_c .NewXObjectImageFromStream (_bea .Stream );
if _fccg !=nil {return _fccg ;};_afeb ,_fccg :=_ffaf .ToImage ();if _fccg !=nil {return _fccg ;};_cdd ,_fccg :=_afeb .ToGoImage ();if _fccg !=nil {return _fccg ;};_bbc ,_fccg :=_bf .RGBAConverter .Convert (_cdd );if _fccg !=nil {return _fccg ;};_ggdb :=_bbc .Base ();
_bge :=&_c .Image {Width :int64 (_ggdb .Width ),Height :int64 (_ggdb .Height ),BitsPerComponent :int64 (_ggdb .BitsPerComponent ),ColorComponents :_ggdb .ColorComponents ,Data :_ggdb .Data };_bge .SetDecode (_ggdb .Decode );_bge .SetAlpha (_ggdb .Alpha );
if _fccg =_ffaf .SetImage (_bge ,nil );_fccg !=nil {return _fccg ;};_ffaf .SMask =_d .MakeNull ();var _deeb _d .PdfObject ;_dbb :=-1;for _dbb ,_deeb =range _ebg .Objects {if _deeb ==_bea .SMask .Stream {break ;};};if _dbb !=-1{_ebg .Objects =append (_ebg .Objects [:_dbb ],_ebg .Objects [_dbb +1:]...);
};_bea .SMask =nil ;_ffaf .ToPdfObject ();};return nil ;};

// Profile1Options are the options that changes the way how optimizer may try to adapt document into PDF/A standard.
type Profile1Options struct{

// CMYKDefaultColorSpace is an option that refers PDF/A-1
CMYKDefaultColorSpace bool ;

// Now is a function that returns current time.
Now func ()_e .Time ;

// UUIDGenerator is the generator function of the document UUID.
UUIDGenerator UUIDGenerator ;};func _fcb (_eeg *_baf .Document )error {_egfb ,_cg :=_eeg .FindCatalog ();if !_cg {return _da .New ("\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};_egfb .SetVersion ();
return nil ;};func _aef (_gac *_c .DetailedPdfReader )bool {return true };func (_gff standardType )outputIntentSubtype ()_c .PdfOutputIntentType {switch _gff ._a {case 1:return _c .PdfOutputIntentTypeA1 ;case 2:return _c .PdfOutputIntentTypeA2 ;case 3:return _c .PdfOutputIntentTypeA3 ;
case 4:return _c .PdfOutputIntentTypeA4 ;default:return 0;};};func (_fd *documentImages )hasOnlyDeviceCMYK ()bool {return _fd ._ec &&!_fd ._dcf &&!_fd ._cd };func (_ac *documentImages )hasUncalibratedImages ()bool {return _ac ._dcf ||_ac ._ec ||_ac ._cd };
func _bad (_ab *_c .XObjectImage ,_caf imageModifications )error {_ed ,_cfg :=_ab .ToImage ();if _cfg !=nil {return _cfg ;};if _caf ._aaff !=nil {_ab .Filter =_caf ._aaff ;};_agc :=_d .MakeDict ();_agc .Set ("\u0051u\u0061\u006c\u0069\u0074\u0079",_d .MakeInteger (100));
_agc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",_d .MakeInteger (1));_ab .Decode =nil ;if _cfg =_ab .SetImage (_ed ,nil );_cfg !=nil {return _cfg ;};_ab .ToPdfObject ();return nil ;};func (_dag *documentImages )hasOnlyDeviceGray ()bool {return _dag ._cd &&!_dag ._dcf &&!_dag ._ec };
func _cfd (_fac *_baf .Document )error {_gead :=map[string ]*_d .PdfObjectDictionary {};_gfc :=_b .NewFinder (&_b .FinderOpts {Extensions :[]string {"\u002e\u0074\u0074\u0066"}});_fcc :=map[_d .PdfObject ]struct{}{};_fef :=map[_d .PdfObject ]struct{}{};
for _ ,_ae :=range _fac .Objects {_dbd ,_dbg :=_d .GetDict (_ae );if !_dbg {continue ;};_gcd :=_dbd .Get ("\u0054\u0079\u0070\u0065");if _gcd ==nil {continue ;};if _bdd ,_fgb :=_d .GetName (_gcd );_fgb &&_bdd .String ()!="\u0046\u006f\u006e\u0074"{continue ;
};if _ ,_dfg :=_fcc [_ae ];_dfg {continue ;};_fdad ,_ggf :=_c .NewPdfFontFromPdfObject (_dbd );if _ggf !=nil {_f .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006fn\u0074\u0020\u0066\u0072\u006fm\u0020\u006fb\u006a\u0065\u0063\u0074");
return _ggf ;};_acc ,_ggf :=_fdad .GetFontDescriptor ();if _ggf !=nil {return _ggf ;};if _acc !=nil &&(_acc .FontFile !=nil ||_acc .FontFile2 !=nil ||_acc .FontFile3 !=nil ){continue ;};_ade :=_fdad .BaseFont ();if _ade ==""{return _gf .Errorf ("\u006f\u006e\u0065\u0020\u006f\u0066\u0020\u0074\u0068\u0065\u0020\u0066\u006f\u006e\u0074\u0020\u006f\u0062\u006a\u0065c\u0074\u0073\u0020\u0073\u0079\u006e\u0074\u0061\u0078\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0076\u0061\u006c\u0069d\u0020\u002d\u0020\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074\u0020\u0075\u006ed\u0065\u0066\u0069n\u0065\u0064\u003a\u0020\u0025\u0073",_dbd .String ());
};_dfc ,_agd :=_gead [_ade ];if !_agd {if len (_ade )> 7&&_ade [6]=='+'{_ade =_ade [7:];};_afg :=[]string {_ade ,"\u0054i\u006de\u0073\u0020\u004e\u0065\u0077\u0020\u0052\u006f\u006d\u0061\u006e","\u0041\u0072\u0069a\u006c","D\u0065\u006a\u0061\u0056\u0075\u0020\u0053\u0061\u006e\u0073"};
for _ ,_eba :=range _afg {_f .Log .Debug ("\u0044\u0045\u0042\u0055\u0047\u003a \u0073\u0065\u0061\u0072\u0063\u0068\u0069\u006e\u0067\u0020\u0073\u0079\u0073t\u0065\u006d\u0020\u0066\u006f\u006e\u0074 \u0060\u0025\u0073\u0060",_eba );if _dfc ,_agd =_gead [_eba ];
_agd {break ;};_ega :=_gfc .Match (_eba );if _ega ==nil {_f .Log .Debug ("c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0066\u0069\u006e\u0064\u0020\u0066\u006fn\u0074\u0020\u0066i\u006ce\u0020\u0025\u0073",_eba );continue ;};_egcb ,_abc :=_c .NewPdfFontFromTTFFile (_ega .Filename );
if _abc !=nil {return _abc ;};_gab :=_egcb .FontDescriptor ();if _gab .FontFile !=nil {if _ ,_agd =_fef [_gab .FontFile ];!_agd {_fac .Objects =append (_fac .Objects ,_gab .FontFile );_fef [_gab .FontFile ]=struct{}{};};};if _gab .FontFile2 !=nil {if _ ,_agd =_fef [_gab .FontFile2 ];
!_agd {_fac .Objects =append (_fac .Objects ,_gab .FontFile2 );_fef [_gab .FontFile2 ]=struct{}{};};};if _gab .FontFile3 !=nil {if _ ,_agd =_fef [_gab .FontFile3 ];!_agd {_fac .Objects =append (_fac .Objects ,_gab .FontFile3 );_fef [_gab .FontFile3 ]=struct{}{};
};};_adb ,_ebf :=_egcb .ToPdfObject ().(*_d .PdfIndirectObject );if !_ebf {_f .Log .Debug ("\u0066\u006f\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
continue ;};_cce ,_ebf :=_adb .PdfObject .(*_d .PdfObjectDictionary );if !_ebf {_f .Log .Debug ("\u0046\u006fn\u0074\u0020\u0074\u0079p\u0065\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
continue ;};_gead [_eba ]=_cce ;_dfc =_cce ;break ;};if _dfc ==nil {_f .Log .Debug ("\u004e\u006f\u0020\u006d\u0061\u0074\u0063\u0068\u0069\u006eg\u0020\u0066\u006f\u006e\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u0066\u006f\u0072\u003a\u0020\u0025\u0073",_fdad .BaseFont ());
return _da .New ("\u006e\u006f m\u0061\u0074\u0063h\u0069\u006e\u0067\u0020fon\u0074 f\u006f\u0075\u006e\u0064\u0020\u0069\u006e t\u0068\u0065\u0020\u0073\u0079\u0073\u0074e\u006d");};};for _ ,_dgf :=range _dfc .Keys (){_dbd .Set (_dgf ,_dfc .Get (_dgf ));
};_bde :=_dfc .Get ("\u0057\u0069\u0064\u0074\u0068\u0073");if _bde !=nil {if _ ,_agd =_fef [_bde ];!_agd {_fac .Objects =append (_fac .Objects ,_bde );_fef [_bde ]=struct{}{};};};_fcc [_ae ]=struct{}{};_bdb :=_dbd .Get ("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072");
if _bdb !=nil {_fac .Objects =append (_fac .Objects ,_bdb );_fef [_bdb ]=struct{}{};};};return nil ;};func _dbe (_gaa *_c .DetailedPdfReader )bool {return true };func _bef (_dgeb standardType ,_facc *_baf .OutputIntents )error {_gcfb ,_ffa :=_eg .NewISOCoatedV2Gray1CBasOutputIntent (_dgeb .outputIntentSubtype ());
if _ffa !=nil {return _ffa ;};if _ffa =_facc .Add (_gcfb .ToPdfObject ());_ffa !=nil {return _ffa ;};return nil ;};func _ddaf (_eec *_c .DetailedPdfReader )bool {return true };type documentImages struct{_dcf ,_ec ,_cd bool ;_dd map[_d .PdfObject ]struct{};
_cf []*imageInfo ;};func _ece (_efac *_c .DetailedPdfReader )bool {return true };var _ Profile =(*Profile1A )(nil );

// ApplyStandard tries to change the content of the writer to match the PDF/A-1 standard.
// Implements model.StandardApplier.
func (_gga *profile1 )ApplyStandard (document *_baf .Document )(_bbf error ){_acd (document ,4);if _bbf =_abd (document ,_gga ._cfgb .Now );_bbf !=nil {return _bbf ;};if _bbf =_fcb (document );_bbf !=nil {return _bbf ;};_ceea ,_bfba :=_bgg (_gga ._cfgb .CMYKDefaultColorSpace ,_gga ._fbg );
_bbf =_fbb (document ,[]pageImageOptimizeFunc {_bfb ,_ceea },[]documentImageOptimizeFunc {_bfba });if _bbf !=nil {return _bbf ;};_ddag (document );if _bbf =_afd (document );_bbf !=nil {return _bbf ;};if _bbf =_cfd (document );_bbf !=nil {return _bbf ;};
if _egb :=_cfa (document ,_gga ._fbg ,_gga ._cfgb .UUIDGenerator );_egb !=nil {return _egb ;};return nil ;};