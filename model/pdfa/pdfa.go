//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package pdfa provides abstraction to optimize and verify documents with respect to the PDF/A standards.
// NOTE: This implementation is in experimental development state.
// 	Keep in mind that it might change in the subsequent minor versions.
package pdfa ;import (_cg "errors";_ff "fmt";_b "github.com/adrg/sysfont";_fb "github.com/unidoc/unipdf/v3/common";_ab "github.com/unidoc/unipdf/v3/core";_c "github.com/unidoc/unipdf/v3/internal/imageutil";_ga "github.com/unidoc/unipdf/v3/internal/uuid";
_a "github.com/unidoc/unipdf/v3/internal/xmp";_g "github.com/unidoc/unipdf/v3/model";_ac "github.com/unidoc/unipdf/v3/model/colorprofile";_gf "github.com/unidoc/unipdf/v3/model/internal/docutil";_d "time";);type documentImages struct{_dc ,_bd ,_gb bool ;
_eg map[_ab .PdfObject ]struct{};_fd []*imageInfo ;};func (_fgg standardType )outputIntentSubtype ()_g .PdfOutputIntentType {switch _fgg ._fg {case 1:return _g .PdfOutputIntentTypeA1 ;case 2:return _g .PdfOutputIntentTypeA2 ;case 3:return _g .PdfOutputIntentTypeA3 ;
case 4:return _g .PdfOutputIntentTypeA4 ;default:return 0;};};var _ Profile =(*Profile1B )(nil );

// Profile1Options are the options that changes the way how optimizer may try to adapt document into PDF/A standard.
type Profile1Options struct{

// CMYKDefaultColorSpace is an option that refers PDF/A-1
CMYKDefaultColorSpace bool ;

// Now is a function that returns current time.
Now func ()_d .Time ;

// UUIDGenerator is the generator function of the document UUID.
UUIDGenerator UUIDGenerator ;};func _agfd (_ddca *_g .DetailedPdfReader )bool {return true };func _cac (_ffe *_g .DetailedPdfReader )bool {return true };

// Profile1B is the implementation of the PDF/A-1B standard profile.
// Implements model.PdfAOptimizer, model.PdfAValidator.
type Profile1B struct{profile1 };type documentImageOptimizeFunc func (_ebc *_gf .Document ,_aec []*_gf .Image )error ;func _abd (_ede *_g .DetailedPdfReader )bool {return _ede .ParserMetadata ().HasDataAfterEOF ()};func _fa (_dee *_gf .Document ){if _dee .ID [0]!=""&&_dee .ID [1]!=""{return ;
};_dee .UseHashBasedID =true ;};func _ebe (_gce *_gf .Document )error {_cge :=map[string ]*_ab .PdfObjectDictionary {};_fgf :=_b .NewFinder (&_b .FinderOpts {Extensions :[]string {"\u002e\u0074\u0074\u0066","\u002e\u0074\u0074\u0063"}});_fdc :=map[_ab .PdfObject ]struct{}{};
_cfgc :=map[_ab .PdfObject ]struct{}{};for _ ,_gcg :=range _gce .Objects {_adff ,_caf :=_ab .GetDict (_gcg );if !_caf {continue ;};_dgc :=_adff .Get ("\u0054\u0079\u0070\u0065");if _dgc ==nil {continue ;};if _bfa ,_fgca :=_ab .GetName (_dgc );_fgca &&_bfa .String ()!="\u0046\u006f\u006e\u0074"{continue ;
};if _ ,_ega :=_fdc [_gcg ];_ega {continue ;};_agb ,_bge :=_g .NewPdfFontFromPdfObject (_adff );if _bge !=nil {_fb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006fn\u0074\u0020\u0066\u0072\u006fm\u0020\u006fb\u006a\u0065\u0063\u0074");
return _bge ;};_gdb ,_bge :=_agb .GetFontDescriptor ();if _bge !=nil {return _bge ;};if _gdb !=nil &&(_gdb .FontFile !=nil ||_gdb .FontFile2 !=nil ||_gdb .FontFile3 !=nil ){continue ;};_fgb :=_agb .BaseFont ();if _fgb ==""{return _ff .Errorf ("\u006f\u006e\u0065\u0020\u006f\u0066\u0020\u0074\u0068\u0065\u0020\u0066\u006f\u006e\u0074\u0020\u006f\u0062\u006a\u0065c\u0074\u0073\u0020\u0073\u0079\u006e\u0074\u0061\u0078\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0076\u0061\u006c\u0069d\u0020\u002d\u0020\u0042\u0061\u0073\u0065\u0046\u006f\u006e\u0074\u0020\u0075\u006ed\u0065\u0066\u0069n\u0065\u0064\u003a\u0020\u0025\u0073",_adff .String ());
};_aaa ,_aeg :=_cge [_fgb ];if !_aeg {if len (_fgb )> 7&&_fgb [6]=='+'{_fgb =_fgb [7:];};_adg :=[]string {_fgb ,"\u0054i\u006de\u0073\u0020\u004e\u0065\u0077\u0020\u0052\u006f\u006d\u0061\u006e","\u0041\u0072\u0069a\u006c","D\u0065\u006a\u0061\u0056\u0075\u0020\u0053\u0061\u006e\u0073"};
for _ ,_gdbd :=range _adg {_fb .Log .Debug ("\u0044\u0045\u0042\u0055\u0047\u003a \u0073\u0065\u0061\u0072\u0063\u0068\u0069\u006e\u0067\u0020\u0073\u0079\u0073t\u0065\u006d\u0020\u0066\u006f\u006e\u0074 \u0060\u0025\u0073\u0060",_gdbd );if _aaa ,_aeg =_cge [_gdbd ];
_aeg {break ;};_dce :=_fgf .Match (_gdbd );if _dce ==nil {_fb .Log .Debug ("c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0066\u0069\u006e\u0064\u0020\u0066\u006fn\u0074\u0020\u0066i\u006ce\u0020\u0025\u0073",_gdbd );continue ;};_eae ,_ge :=_g .NewPdfFontFromTTFFile (_dce .Filename );
if _ge !=nil {return _ge ;};_ggc :=_eae .FontDescriptor ();if _ggc .FontFile !=nil {if _ ,_aeg =_cfgc [_ggc .FontFile ];!_aeg {_gce .Objects =append (_gce .Objects ,_ggc .FontFile );_cfgc [_ggc .FontFile ]=struct{}{};};};if _ggc .FontFile2 !=nil {if _ ,_aeg =_cfgc [_ggc .FontFile2 ];
!_aeg {_gce .Objects =append (_gce .Objects ,_ggc .FontFile2 );_cfgc [_ggc .FontFile2 ]=struct{}{};};};if _ggc .FontFile3 !=nil {if _ ,_aeg =_cfgc [_ggc .FontFile3 ];!_aeg {_gce .Objects =append (_gce .Objects ,_ggc .FontFile3 );_cfgc [_ggc .FontFile3 ]=struct{}{};
};};_dgcc ,_ddf :=_eae .ToPdfObject ().(*_ab .PdfIndirectObject );if !_ddf {_fb .Log .Debug ("\u0066\u006f\u006e\u0074\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
continue ;};_ada ,_ddf :=_dgcc .PdfObject .(*_ab .PdfObjectDictionary );if !_ddf {_fb .Log .Debug ("\u0046\u006fn\u0074\u0020\u0074\u0079p\u0065\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u006e \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
continue ;};_cge [_gdbd ]=_ada ;_aaa =_ada ;break ;};if _aaa ==nil {_fb .Log .Debug ("\u004e\u006f\u0020\u006d\u0061\u0074\u0063\u0068\u0069\u006eg\u0020\u0066\u006f\u006e\u0074\u0020\u0066o\u0075\u006e\u0064\u0020\u0066\u006f\u0072\u003a\u0020\u0025\u0073",_agb .BaseFont ());
return _cg .New ("\u006e\u006f m\u0061\u0074\u0063h\u0069\u006e\u0067\u0020fon\u0074 f\u006f\u0075\u006e\u0064\u0020\u0069\u006e t\u0068\u0065\u0020\u0073\u0079\u0073\u0074e\u006d");};};for _ ,_cgb :=range _aaa .Keys (){_adff .Set (_cgb ,_aaa .Get (_cgb ));
};_fdf :=_aaa .Get ("\u0057\u0069\u0064\u0074\u0068\u0073");if _fdf !=nil {if _ ,_aeg =_cfgc [_fdf ];!_aeg {_gce .Objects =append (_gce .Objects ,_fdf );_cfgc [_fdf ]=struct{}{};};};_fdc [_gcg ]=struct{}{};_aff :=_adff .Get ("\u0046\u006f\u006e\u0074\u0044\u0065\u0073\u0063\u0072i\u0070\u0074\u006f\u0072");
if _aff !=nil {_gce .Objects =append (_gce .Objects ,_aff );_cfgc [_aff ]=struct{}{};};};return nil ;};var _ Profile =(*Profile1A )(nil );func _fgc (_fcd []_ab .PdfObject )(*documentImages ,error ){_dd :=_ab .PdfObjectName ("\u0053u\u0062\u0074\u0079\u0070\u0065");
_bdf :=make (map[*_ab .PdfObjectStream ]struct{});_abg :=make (map[_ab .PdfObject ]struct{});var (_cd ,_cb ,_bba bool ;_gc []*imageInfo ;_db error ;);for _ ,_gcf :=range _fcd {_ad ,_aa :=_ab .GetStream (_gcf );if !_aa {continue ;};if _ ,_bg :=_bdf [_ad ];
_bg {continue ;};_bdf [_ad ]=struct{}{};_bf :=_ad .PdfObjectDictionary .Get (_dd );_cc ,_aa :=_ab .GetName (_bf );if !_aa ||string (*_cc )!="\u0049\u006d\u0061g\u0065"{continue ;};if _fe :=_ad .PdfObjectDictionary .Get ("\u0053\u004d\u0061s\u006b");_fe !=nil {_abg [_fe ]=struct{}{};
};_abgc :=imageInfo {BitsPerComponent :8,Stream :_ad };_abgc .ColorSpace ,_db =_g .DetermineColorspaceNameFromPdfObject (_ad .PdfObjectDictionary .Get ("\u0043\u006f\u006c\u006f\u0072\u0053\u0070\u0061\u0063\u0065"));if _db !=nil {return nil ,_db ;};if _gff ,_be :=_ab .GetIntVal (_ad .PdfObjectDictionary .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
_be {_abgc .BitsPerComponent =_gff ;};if _bdd ,_eaa :=_ab .GetIntVal (_ad .PdfObjectDictionary .Get ("\u0057\u0069\u0064t\u0068"));_eaa {_abgc .Width =_bdd ;};if _bddb ,_de :=_ab .GetIntVal (_ad .PdfObjectDictionary .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));
_de {_abgc .Height =_bddb ;};switch _abgc .ColorSpace {case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":_bba =true ;_abgc .ColorComponents =1;case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":_cd =true ;_abgc .ColorComponents =3;case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":_cb =true ;
_abgc .ColorComponents =4;default:_abgc ._fba =true ;};_gc =append (_gc ,&_abgc );};if len (_abg )> 0{if len (_abg )==len (_gc ){_gc =nil ;}else {_cf :=make ([]*imageInfo ,len (_gc )-len (_abg ));var _dcb int ;for _ ,_bce :=range _gc {if _ ,_dbf :=_abg [_bce .Stream ];
_dbf {continue ;};_cf [_dcb ]=_bce ;_dcb ++;};_gc =_cf ;};};return &documentImages {_dc :_cd ,_bd :_cb ,_gb :_bba ,_eg :_abg ,_fd :_gc },nil ;};

// DefaultProfile1Options are the default options for the Profile1.
func DefaultProfile1Options ()*Profile1Options {return &Profile1Options {Now :_d .Now }};func _eedc (_aegeb *_g .DetailedPdfReader )bool {return true };type profile1 struct{_gad standardType ;_gcge Profile1Options ;};func _bedd (_bcc *_g .DetailedPdfReader )bool {return true };
func _ggb (_gea *_gf .Document ,_bfde standardType ,_aaf *_gf .OutputIntents )error {var (_ced *_g .PdfOutputIntent ;_cad error ;);if _gea .Version .Minor <=4{_ced ,_cad =_ac .NewSRGBv2OutputIntent (_bfde .outputIntentSubtype ());}else {_ced ,_cad =_ac .NewSRGBv4OutputIntent (_bfde .outputIntentSubtype ());
};if _cad !=nil {return _cad ;};if _cad =_aaf .Add (_ced .ToPdfObject ());_cad !=nil {return _cad ;};return nil ;};func _efg (_dfbf *_g .DetailedPdfReader )bool {return true };func _fc ()standardType {return standardType {_fg :1,_df :"\u0041"}};func _fgcg (_ecec *_g .DetailedPdfReader )bool {return true };
func _fbga (_fgfg standardType ,_efaf *_gf .OutputIntents )error {_gcac ,_cabf :=_ac .NewEciCMYKOutputIntent (_fgfg .outputIntentSubtype ());if _cabf !=nil {return _cabf ;};if _cabf =_efaf .Add (_gcac .ToPdfObject ());_cabf !=nil {return _cabf ;};return nil ;
};type imageInfo struct{ColorSpace _ab .PdfObjectName ;BitsPerComponent int ;ColorComponents int ;Width int ;Height int ;Stream *_ab .PdfObjectStream ;_fba bool ;};func _gge (_adfg *_g .DetailedPdfReader )bool {return true };func _cdcc (_fea *_g .DetailedPdfReader )bool {return true };
func _gba (_dfef *_g .DetailedPdfReader )bool {return true };func _fef (_dba *_g .DetailedPdfReader )bool {return true };

// Validate checks if provider PdfAReader matches rules that conforms PDF/A-1 standard.
// Implements model.PdfAValidator.
func (_bbad *profile1 )Validate (r *_g .DetailedPdfReader )error {return nil };func (_bb *documentImages )hasOnlyDeviceGray ()bool {return _bb ._gb &&!_bb ._dc &&!_bb ._bd };func _fgfa (_gac *Profile1Options ){if _gac .Now ==nil {_gac .Now =_d .Now ;};
if _gac .UUIDGenerator ==nil {_gac .UUIDGenerator =NewUUID ;};};type imageModifications struct{_eb *colorspaceModification ;_dff _ab .StreamEncoder ;};func _fee (_bda *_g .DetailedPdfReader )bool {return _bda .ParserMetadata ().HeaderPosition ()==0};type colorspaceModification struct{_gcc _c .ColorConverter ;
_ag _g .PdfColorspace ;};func (_af *documentImages )hasUncalibratedImages ()bool {return _af ._dc ||_af ._bd ||_af ._gb };

// Part gets the PDF/A version level.
func (_fbaa *profile1 )Part ()int {return _fbaa ._gad ._fg };func _gaa (_dde *_gf .Document ,_bfc standardType ,_gcd UUIDGenerator )error {_aag ,_aba :=_dde .FindCatalog ();if !_aba {return nil ;};if _aag .HasMetadata (){return nil ;};_ccg :=&_g .PdfInfo {};
if _ddc :=_ccg .FromPdfObject (_dde .Info );_ddc !=nil {return _ddc ;};_ffb :=_ccg .ToXMPMetadata ();_ffb .PDFVersion =_ff .Sprintf ("\u0025\u0064\u002e%\u0064",_dde .Version .Major ,_dde .Version .Minor );if _ffb .DocumentID ==_ga .Nil {_ffb .DocumentID =_ga .UUID (_gcd ());
};if !_ffb .ModifyDate .IsZero (){_ffb .MetadataDate =_ffb .ModifyDate ;};_ffb .PdfA =&_a .PdfA {Part :_bfc ._fg ,Conformance :_bfc ._df };if _agf :=_aag .SetMetadata (_ffb );_agf !=nil {return _agf ;};return nil ;};func _bedb (_cdd *_g .DetailedPdfReader )bool {return true };
func (_dcc *documentImages )hasOnlyDeviceCMYK ()bool {return _dcc ._bd &&!_dcc ._dc &&!_dcc ._gb };func _deda (_efad *_g .DetailedPdfReader )bool {_bef ,_fcbf :=_efad .PdfReader .GetTrailer ();if _fcbf !=nil {_fb .Log .Error ("\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fcbf );
return false ;};return _bef .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074")==nil ;};

// NewProfile1B creates a new Profile1B with the given options.
func NewProfile1B (options *Profile1Options )*Profile1B {if options ==nil {options =DefaultProfile1Options ();};_fgfa (options );return &Profile1B {profile1 {_gcge :*options ,_gad :_e ()}};};func _dga (_gfag *_g .DetailedPdfReader )bool {return true };
func _abge (_gd *_g .XObjectImage ,_dfa imageModifications )error {_cab ,_adf :=_gd .ToImage ();if _adf !=nil {return _adf ;};if _dfa ._dff !=nil {_gd .Filter =_dfa ._dff ;};_gfe :=_ab .MakeDict ();_gfe .Set ("\u0051u\u0061\u006c\u0069\u0074\u0079",_ab .MakeInteger (100));
_gfe .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",_ab .MakeInteger (1));_gd .Decode =nil ;if _adf =_gd .SetImage (_cab ,nil );_adf !=nil {return _adf ;};_gd .ToPdfObject ();return nil ;};

// NewUUID is the UUIDGenerator function used for determining new UUID value.
func NewUUID ()UUID {return UUID (_ga .MustUUID ())};func _fbb (_efe *_g .DetailedPdfReader )bool {_gccd ,_afbc :=_efe .PdfReader .GetTrailer ();if _afbc !=nil {_fb .Log .Error ("\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_afbc );
return false ;};return _gccd .Get ("\u0049\u0044")!=nil ;};

// Profile1A is the implementation of the PDF/A-1A standard profile.
// Implements model.DocumentOptimizer.
type Profile1A struct{profile1 };func _e ()standardType {return standardType {_fg :1,_df :"\u0042"}};func _faef (_cfc *_g .DetailedPdfReader )bool {return true };func _cgbd (_fabb *_g .DetailedPdfReader )bool {return true };func _age (_ddfd *_g .DetailedPdfReader )bool {return true };
func (_acf *documentImages )hasOnlyDeviceRGB ()bool {return _acf ._dc &&!_acf ._bd &&!_acf ._gb };func _fbg (_agd *_gf .Document ,_eba int ){if _agd .Version .Major ==0{_agd .Version .Major =1;};if _agd .Version .Minor < _eba {_agd .Version .Minor =_eba ;
};};func _affe (_bdb *_g .PdfInfo ,_dac func ()_d .Time )error {var _beg *_g .PdfDate ;if _bdb .CreationDate ==nil {_gee ,_aaac :=_g .NewPdfDateFromTime (_dac ());if _aaac !=nil {return _aaac ;};_beg =&_gee ;_bdb .CreationDate =_beg ;};if _bdb .ModifiedDate ==nil {if _beg !=nil {_dfee ,_afg :=_g .NewPdfDateFromTime (_dac ());
if _afg !=nil {return _afg ;};_beg =&_dfee ;};_bdb .ModifiedDate =_beg ;};return nil ;};func _ecc (_egd *_gf .Document )error {_dbb ,_gg :=_egd .GetPages ();if !_gg {return nil ;};for _ ,_afd :=range _dbb {_cbd ,_bfd :=_afd .GetResources ();if !_bfd {continue ;
};_debf ,_cfgg :=_ab .GetDict (_cbd .Get ("\u0045x\u0074\u0047\u0053\u0074\u0061\u0074e"));if !_cfgg {return nil ;};_dda :=_debf .Keys ();for _ ,_fcb :=range _dda {_dccg ,_ece :=_ab .GetDict (_debf .Get (_fcb ));if !_ece {continue ;};if _efd :=_dccg .Get ("\u0053\u004d\u0061s\u006b");
_efd !=nil {_dccg .Set ("\u0053\u004d\u0061s\u006b",_ab .MakeName ("\u004e\u006f\u006e\u0065"));};_dg :=_dccg .Get ("\u0043\u0041");if _dg !=nil {_dfed ,_fca :=_ab .GetNumberAsFloat (_dg );if _fca !=nil {_fb .Log .Debug ("\u0045x\u0074\u0047S\u0074\u0061\u0074\u0065 \u006f\u0062\u006ae\u0063\u0074\u0020\u0043\u0041\u0020\u0076\u0061\u006cue\u0020\u0069\u0073 \u006e\u006ft\u0020\u0061\u0020\u0066\u006c\u006fa\u0074\u003a \u0025\u0076",_fca );
_dfed =0;};if _dfed !=1.0{_dccg .Set ("\u0043\u0041",_ab .MakeFloat (1.0));};};_dg =_dccg .Get ("\u0063\u0061");if _dg !=nil {_bced ,_fbf :=_ab .GetNumberAsFloat (_dg );if _fbf !=nil {_fb .Log .Debug ("\u0045\u0078t\u0047\u0053\u0074\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0027\u0063\u0061\u0027\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0066\u006c\u006f\u0061\u0074\u003a\u0020\u0025\u0076",_fbf );
_bced =0;};if _bced !=1.0{_dccg .Set ("\u0063\u0061",_ab .MakeFloat (1.0));};};_efa :=_dccg .Get ("\u0042\u004d");if _efa !=nil {_ae ,_bcg :=_ab .GetName (_efa );if _bcg {_fb .Log .Debug ("E\u0078\u0074\u0047\u0053\u0074\u0061t\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0027\u0042\u004d\u0027\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061m\u0065");
_ae =_ab .MakeName ("");};_edf :=_ae .String ();switch _edf {case "\u004e\u006f\u0072\u006d\u0061\u006c","\u0043\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u006c\u0065":default:_dccg .Set ("\u0042\u004d",_ab .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));
};};};};return nil ;};

// UUID is the unique universe identifier.
// It is used to generate XMP document uuid identifier.
type UUID [16]byte ;func _fcg (_dfc *_gf .Document )error {_abf ,_ba :=_dfc .FindCatalog ();if !_ba {return _cg .New ("\u0063\u0061\u0074\u0061\u006c\u006f\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};_abf .SetVersion ();return nil ;
};func _eeb (_gfeaf *_g .DetailedPdfReader )bool {return true };type pageImageOptimizeFunc func (_dbd *_gf .Document ,_bac *_gf .Page ,_aae []*_gf .Image )error ;func _bdc (_bbag *_g .DetailedPdfReader )bool {return true };func _bc ()standardType {return standardType {_fg :2,_df :"\u0041"}};


// UUIDGenerator is the generator for the UUID.
type UUIDGenerator func ()UUID ;func _cdf (_adfc *_gf .Document ,_fab *_gf .Page ,_fed []*_gf .Image )error {for _ ,_fbad :=range _fed {if _fbad .SMask ==nil {continue ;};_gfea ,_eaag :=_g .NewXObjectImageFromStream (_fbad .Stream );if _eaag !=nil {return _eaag ;
};_bed ,_eaag :=_gfea .ToImage ();if _eaag !=nil {return _eaag ;};_fac ,_eaag :=_bed .ToGoImage ();if _eaag !=nil {return _eaag ;};_dab ,_eaag :=_c .RGBAConverter .Convert (_fac );if _eaag !=nil {return _eaag ;};_eea :=_dab .Base ();_bea :=&_g .Image {Width :int64 (_eea .Width ),Height :int64 (_eea .Height ),BitsPerComponent :int64 (_eea .BitsPerComponent ),ColorComponents :_eea .ColorComponents ,Data :_eea .Data };
_bea .SetDecode (_eea .Decode );_bea .SetAlpha (_eea .Alpha );if _eaag =_gfea .SetImage (_bea ,nil );_eaag !=nil {return _eaag ;};_gfea .SMask =_ab .MakeNull ();var _ebg _ab .PdfObject ;_gfa :=-1;for _gfa ,_ebg =range _adfc .Objects {if _ebg ==_fbad .SMask .Stream {break ;
};};if _gfa !=-1{_adfc .Objects =append (_adfc .Objects [:_gfa ],_adfc .Objects [_gfa +1:]...);};_fbad .SMask =nil ;_gfea .ToPdfObject ();};return nil ;};

// Conformance gets the PDF/A conformance.
func (_abc *profile1 )Conformance ()string {return _abc ._gad ._df };func _ded (_ce []*_gf .Image ,_adc bool )error {_ec :=_ab .PdfObjectName ("\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B");if _adc {_ec ="\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b";
};for _ ,_cbe :=range _ce {if _cbe .Colorspace ==_ec {continue ;};_agc ,_ee :=_g .NewXObjectImageFromStream (_cbe .Stream );if _ee !=nil {return _ee ;};_aab ,_ee :=_agc .ToImage ();if _ee !=nil {return _ee ;};_eed ,_ee :=_aab .ToGoImage ();if _ee !=nil {return _ee ;
};var _fce _g .PdfColorspace ;if _adc {_fce =_g .NewPdfColorspaceDeviceCMYK ();_eed ,_ee =_c .CMYKConverter .Convert (_eed );}else {_fce =_g .NewPdfColorspaceDeviceRGB ();_eed ,_ee =_c .NRGBAConverter .Convert (_eed );};if _ee !=nil {return _ee ;};_deb ,_cfg :=_eed .(_c .Image );
if !_cfg {return _cg .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074 \u0069\u006d\u0070\u006c\u0065\u006de\u006e\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u0075\u0074\u0069\u006c\u002eI\u006d\u0061\u0067\u0065");};
_ef :=_deb .Base ();_eee :=&_g .Image {Width :int64 (_ef .Width ),Height :int64 (_ef .Height ),BitsPerComponent :int64 (_ef .BitsPerComponent ),ColorComponents :_ef .ColorComponents ,Data :_ef .Data };_eee .SetDecode (_ef .Decode );_eee .SetAlpha (_ef .Alpha );
if _ee =_agc .SetImage (_eee ,_fce );_ee !=nil {return _ee ;};_agc .ToPdfObject ();_cbe .ColorComponents =_ef .ColorComponents ;_cbe .Colorspace =_ec ;};return nil ;};func _gceb (_gagc *_g .DetailedPdfReader )bool {return true };func _gca (_adfb bool ,_gag standardType )(pageImageOptimizeFunc ,documentImageOptimizeFunc ){var _bag ,_deff ,_gbf bool ;
_agbf :=func (_aac *_gf .Document ,_ace *_gf .Page ,_acc []*_gf .Image )error {for _ ,_cbf :=range _acc {switch _cbf .Colorspace {case "\u0044\u0065\u0076\u0069\u0063\u0065\u0047\u0072\u0061\u0079":_deff =true ;case "\u0044e\u0076\u0069\u0063\u0065\u0052\u0047B":_bag =true ;
case "\u0044\u0065\u0076\u0069\u0063\u0065\u0043\u004d\u0059\u004b":_gbf =true ;};};return nil ;};_eff :=func (_bdfe *_gf .Document ,_gae []*_gf .Image )error {_aege ,_bagb :=_bdfe .FindCatalog ();if !_bagb {return nil ;};_cfdg ,_bagb :=_aege .GetOutputIntents ();
if _bagb &&_cfdg .Len ()> 0{return nil ;};if !_bagb {_cfdg =_aege .NewOutputIntents ();};if !(_bag ||_gbf ||_deff ){return nil ;};defer _aege .SetOutputIntents (_cfdg );if _bag &&!_gbf &&!_deff {return _ggb (_bdfe ,_gag ,_cfdg );};if _gbf &&!_bag &&!_deff {return _fbga (_gag ,_cfdg );
};if _deff &&!_bag &&!_gbf {return _aea (_gag ,_cfdg );};if _bag &&_gbf {if _abfa :=_ded (_gae ,_adfb );_abfa !=nil {return _abfa ;};if _adfb {return _fbga (_gag ,_cfdg );};return _ggb (_bdfe ,_gag ,_cfdg );};return nil ;};return _agbf ,_eff ;};func _def (_efb *_gf .Document ,_faa []pageImageOptimizeFunc ,_cca []documentImageOptimizeFunc )error {_baa ,_daa :=_efb .GetPages ();
if !_daa {return nil ;};var _ecg []*_gf .Image ;for _bab ,_gdf :=range _baa {_ade ,_dbdf :=_gdf .FindXObjectImages ();if _dbdf !=nil {return _dbdf ;};if len (_ade )==0{continue ;};for _ ,_bdeg :=range _faa {if _dbdf =_bdeg (_efb ,&_baa [_bab ],_ade );_dbdf !=nil {return _dbdf ;
};};_ecg =append (_ecg ,_ade ...);};for _ ,_cbb :=range _cca {if _dbfg :=_cbb (_efb ,_ecg );_dbfg !=nil {return _dbfg ;};};return nil ;};

// Optimize tries to change the content of the writer to match the PDF/A-1 standard.
// Implements model.PdfAOptimizer.
func (_cdfg *profile1 )Optimize (document *_gf .Document )(_fbd error ){_fbg (document ,4);if _fbd =_cgf (document ,_cdfg ._gcge .Now );_fbd !=nil {return _fbd ;};if _fbd =_fcg (document );_fbd !=nil {return _fbd ;};_fae ,_deee :=_gca (_cdfg ._gcge .CMYKDefaultColorSpace ,_cdfg ._gad );
_fbd =_def (document ,[]pageImageOptimizeFunc {_cdf ,_fae },[]documentImageOptimizeFunc {_deee });if _fbd !=nil {return _fbd ;};_fa (document );if _fbd =_ecc (document );_fbd !=nil {return _fbd ;};if _fbd =_ebe (document );_fbd !=nil {return _fbd ;};if _dge :=_gaa (document ,_cdfg ._gad ,_cdfg ._gcge .UUIDGenerator );
_dge !=nil {return _dge ;};return nil ;};

// NewProfile1A creates a new Profile1A with given options.
func NewProfile1A (options *Profile1Options )*Profile1A {if options ==nil {options =DefaultProfile1Options ();};_fgfa (options );return &Profile1A {profile1 {_gcge :*options ,_gad :_fc ()}};};func _ebae (_fcge *_g .DetailedPdfReader )bool {return true };
func _daba (_ebed *_g .DetailedPdfReader )bool {return true };func _aea (_fbgf standardType ,_ffa *_gf .OutputIntents )error {_fggf ,_dcbg :=_ac .NewISOCoatedV2Gray1CBasOutputIntent (_fbgf .outputIntentSubtype ());if _dcbg !=nil {return _dcbg ;};if _dcbg =_ffa .Add (_fggf .ToPdfObject ());
_dcbg !=nil {return _dcbg ;};return nil ;};

// Profile is the model.DocumentOptimizer enhanced by the information about the profile conformance level.
type Profile interface{_g .DocumentOptimizer ;Conformance ()string ;Part ()int ;};type standardType struct{_fg int ;_df string ;};func _cgf (_gdd *_gf .Document ,_da func ()_d .Time )error {_dfb :=&_g .PdfInfo {};if _ggf :=_dfb .FromPdfObject (_gdd .Info );
_ggf !=nil {return _ggf ;};if _cfd :=_affe (_dfb ,_da );_cfd !=nil {return _cfd ;};_gdd .Info =_dfb .ToPdfObject ();return nil ;};func _ggfe (_ebb *_g .DetailedPdfReader )bool {return true };func _bedc (_cae *_g .DetailedPdfReader )bool {return true };
func _dgeb (_dbg *_g .DetailedPdfReader )bool {return true };func _ddcb (_bgc *_g .DetailedPdfReader )bool {return true };func _cce (_gda *_g .DetailedPdfReader )bool {_gdg :=_gda .ParserMetadata ().HeaderCommentBytes ();return _gdg [0]> 127&&_gdg [1]> 127&&_gdg [2]> 127&&_gdg [3]> 127;
};func _ed ()standardType {return standardType {_fg :2,_df :"\u0042"}};