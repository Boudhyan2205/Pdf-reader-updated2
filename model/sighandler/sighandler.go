//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_e "bytes";_fe "crypto";_ef "crypto/rand";_gf "crypto/rsa";_ed "crypto/x509";_be "crypto/x509/pkix";_eg "encoding/asn1";_fg "errors";_fab "fmt";_aa "github.com/unidoc/pkcs7";_ad "github.com/unidoc/timestamp";_d "github.com/unidoc/unipdf/v3/core";_c "github.com/unidoc/unipdf/v3/model";_g "hash";_ec "io";_fa "io/ioutil";_f "net/http";_a "time";);

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_c .SignatureHandler ,error ){return &adobePKCS7Detached {_eda :true ,_gb :signatureLen },nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// The timestampServerURL parameter can be empty string for the signature validation.
// The hashAlgorithm parameter can be crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _fe .Hash )(_c .SignatureHandler ,error ){return &docTimeStamp {_def :timestampServerURL ,_bgf :hashAlgorithm },nil ;};type docTimeStamp struct{_def string ;_bgf _fe .Hash ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_gf .PrivateKey ,certificate *_ed .Certificate )(_c .SignatureHandler ,error ){return &adobePKCS7Detached {_de :certificate ,_cg :privateKey },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_febd *adobeX509RSASHA1 )Sign (sig *_c .PdfSignature ,digest _c .Hasher )error {var _bd []byte ;var _ggc error ;if _febd ._aff !=nil {_bd ,_ggc =_febd ._aff (sig ,digest );if _ggc !=nil {return _ggc ;};}else {_eb ,_ffb :=digest .(_g .Hash );if !_ffb {return _fg .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ge ,_ :=_df (_febd ._ega .SignatureAlgorithm );_bd ,_ggc =_gf .SignPKCS1v15 (_ef .Reader ,_febd ._cgc ,_ge ,_eb .Sum (nil ));if _ggc !=nil {return _ggc ;};};_bd ,_ggc =_eg .Marshal (_bd );if _ggc !=nil {return _ggc ;};sig .Contents =_d .MakeHexString (string (_bd ));return nil ;};func (_aaf *adobePKCS7Detached )getCertificate (_ga *_c .PdfSignature )(*_ed .Certificate ,error ){if _aaf ._de !=nil {return _aaf ._de ,nil ;};var _ca []byte ;switch _ff :=_ga .Cert .(type ){case *_d .PdfObjectString :_ca =_ff .Bytes ();case *_d .PdfObjectArray :if _ff .Len ()==0{return nil ,_fg .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_ffc :=range _ff .Elements (){_bb ,_gag :=_d .GetString (_ffc );if !_gag {return nil ,_fab .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_ffc );};_ca =append (_ca ,_bb .Bytes ()...);};default:return nil ,_fab .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_ff );};_bc ,_ac :=_ed .ParseCertificates (_ca );if _ac !=nil {return nil ,_ac ;};return _bc [0],nil ;};func (_bbd *docTimeStamp )getCertificate (_fbd *_c .PdfSignature )(*_ed .Certificate ,error ){var _bfe []byte ;switch _faa :=_fbd .Cert .(type ){case *_d .PdfObjectString :_bfe =_faa .Bytes ();case *_d .PdfObjectArray :if _faa .Len ()==0{return nil ,_fg .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_dd :=range _faa .Elements (){_gbc ,_gab :=_d .GetString (_dd );if !_gab {return nil ,_fab .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_dd );};_bfe =append (_bfe ,_gbc .Bytes ()...);};default:return nil ,_fab .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_faa );};_cfd ,_ffa :=_ed .ParseCertificates (_bfe );if _ffa !=nil {return nil ,_ffa ;};return _cfd [0],nil ;};

// NewDigest creates a new digest.
func (_caf *docTimeStamp )NewDigest (sig *_c .PdfSignature )(_c .Hasher ,error ){return _e .NewBuffer (nil ),nil ;};

// InitSignature initialises the PdfSignature.
func (_ggb *adobeX509RSASHA1 )InitSignature (sig *_c .PdfSignature )error {if _ggb ._ega ==nil {return _fg .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _ggb ._cgc ==nil &&_ggb ._aff ==nil {return _fg .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_ba :=*_ggb ;sig .Handler =&_ba ;sig .Filter =_d .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_d .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_d .MakeString (string (_ba ._ega .Raw ));sig .Reference =nil ;_gbe ,_bg :=_ba .NewDigest (sig );if _bg !=nil {return _bg ;};_gbe .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _ba .Sign (sig ,_gbe );};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_gf .PrivateKey ,certificate *_ed .Certificate )(_c .SignatureHandler ,error ){return &adobeX509RSASHA1 {_ega :certificate ,_cgc :privateKey },nil ;};func _ebd (_ged _eg .ObjectIdentifier )(_fe .Hash ,error ){switch {case _ged .Equal (_aa .OIDDigestAlgorithmSHA1 ),_ged .Equal (_aa .OIDDigestAlgorithmECDSASHA1 ),_ged .Equal (_aa .OIDDigestAlgorithmDSA ),_ged .Equal (_aa .OIDDigestAlgorithmDSASHA1 ),_ged .Equal (_aa .OIDEncryptionAlgorithmRSA ):return _fe .SHA1 ,nil ;case _ged .Equal (_aa .OIDDigestAlgorithmSHA256 ),_ged .Equal (_aa .OIDDigestAlgorithmECDSASHA256 ):return _fe .SHA256 ,nil ;case _ged .Equal (_aa .OIDDigestAlgorithmSHA384 ),_ged .Equal (_aa .OIDDigestAlgorithmECDSASHA384 ):return _fe .SHA384 ,nil ;case _ged .Equal (_aa .OIDDigestAlgorithmSHA512 ),_ged .Equal (_aa .OIDDigestAlgorithmECDSASHA512 ):return _fe .SHA512 ,nil ;};return _fe .Hash (0),_aa .ErrUnsupportedAlgorithm ;};

// InitSignature initialises the PdfSignature.
func (_cb *adobePKCS7Detached )InitSignature (sig *_c .PdfSignature )error {if !_cb ._eda {if _cb ._de ==nil {return _fg .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _cb ._cg ==nil {return _fg .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_ae :=*_cb ;sig .Handler =&_ae ;sig .Filter =_d .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_d .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_ee ,_gbd :=_ae .NewDigest (sig );if _gbd !=nil {return _gbd ;};_ee .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _ae .Sign (sig ,_ee );};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bdb *adobeX509RSASHA1 )IsApplicable (sig *_c .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_beg *_c .PdfSignature ,_bea _c .Hasher )([]byte ,error );

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler
// with a custom signing function. Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1Custom (certificate *_ed .Certificate ,signFunc SignFunc )(_c .SignatureHandler ,error ){return &adobeX509RSASHA1 {_ega :certificate ,_aff :signFunc },nil ;};type adobePKCS7Detached struct{_cg *_gf .PrivateKey ;_de *_ed .Certificate ;_eda bool ;_gb int ;};

// Validate validates PdfSignature.
func (_dgb *adobeX509RSASHA1 )Validate (sig *_c .PdfSignature ,digest _c .Hasher )(_c .SignatureValidationResult ,error ){_fd ,_eeb :=_dgb .getCertificate (sig );if _eeb !=nil {return _c .SignatureValidationResult {},_eeb ;};_gd :=sig .Contents .Bytes ();var _efg []byte ;if _ ,_afd :=_eg .Unmarshal (_gd ,&_efg );_afd !=nil {return _c .SignatureValidationResult {},_afd ;};_gdf ,_gbeg :=digest .(_g .Hash );if !_gbeg {return _c .SignatureValidationResult {},_fg .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fec ,_ :=_df (_fd .SignatureAlgorithm );if _deg :=_gf .VerifyPKCS1v15 (_fd .PublicKey .(*_gf .PublicKey ),_fec ,_gdf .Sum (nil ),_efg );_deg !=nil {return _c .SignatureValidationResult {},_deg ;};return _c .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};func (_fcg *adobeX509RSASHA1 )getCertificate (_fcc *_c .PdfSignature )(*_ed .Certificate ,error ){if _fcg ._ega !=nil {return _fcg ._ega ,nil ;};var _cec []byte ;switch _gad :=_fcc .Cert .(type ){case *_d .PdfObjectString :_cec =_gad .Bytes ();case *_d .PdfObjectArray :if _gad .Len ()==0{return nil ,_fg .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_acc :=range _gad .Elements (){_afc ,_edb :=_d .GetString (_acc );if !_edb {return nil ,_fab .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_acc );};_cec =append (_cec ,_afc .Bytes ()...);};default:return nil ,_fab .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_gad );};_ccc ,_cae :=_ed .ParseCertificates (_cec );if _cae !=nil {return nil ,_cae ;};return _ccc [0],nil ;};

// InitSignature initialises the PdfSignature.
func (_fcd *docTimeStamp )InitSignature (sig *_c .PdfSignature )error {_ffd :=*_fcd ;sig .Handler =&_ffd ;sig .Filter =_d .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_d .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;_ebe ,_aae :=_fcd .NewDigest (sig );if _aae !=nil {return _aae ;};_ebe .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _ffd .Sign (sig ,_ebe );};

// Sign sets the Contents fields.
func (_cc *adobePKCS7Detached )Sign (sig *_c .PdfSignature ,digest _c .Hasher )error {if _cc ._eda {_ce :=_cc ._gb ;if _ce <=0{_ce =8192;};sig .Contents =_d .MakeHexString (string (make ([]byte ,_ce )));return nil ;};_fc :=digest .(*_e .Buffer );_bf ,_cf :=_aa .NewSignedData (_fc .Bytes ());if _cf !=nil {return _cf ;};if _feb :=_bf .AddSigner (_cc ._de ,_cc ._cg ,_aa .SignerInfoConfig {});_feb !=nil {return _feb ;};_bf .Detach ();_fgdf ,_cf :=_bf .Finish ();if _cf !=nil {return _cf ;};_feg :=make ([]byte ,8192);copy (_feg ,_fgdf );sig .Contents =_d .MakeHexString (string (_feg ));return nil ;};func _df (_ecg _ed .SignatureAlgorithm )(_fe .Hash ,bool ){return _fe .SHA1 ,true };

// Validate validates PdfSignature.
func (_da *docTimeStamp )Validate (sig *_c .PdfSignature ,digest _c .Hasher )(_c .SignatureValidationResult ,error ){_fcdg :=sig .Contents .Bytes ();_bfef ,_cba :=_aa .Parse (_fcdg );if _cba !=nil {return _c .SignatureValidationResult {},_cba ;};if _cba =_bfef .Verify ();_cba !=nil {return _c .SignatureValidationResult {},_cba ;};var _gabd timestampInfo ;_ ,_cba =_eg .Unmarshal (_bfef .Content ,&_gabd );if _cba !=nil {return _c .SignatureValidationResult {},_cba ;};_bde ,_cba :=_ebd (_gabd .MessageImprint .HashAlgorithm .Algorithm );if _cba !=nil {return _c .SignatureValidationResult {},_cba ;};_edg :=_bde .New ();_bag :=digest .(*_e .Buffer );_edg .Write (_bag .Bytes ());_acg :=_edg .Sum (nil );_deec :=_c .SignatureValidationResult {IsSigned :true ,IsVerified :_e .Equal (_acg ,_gabd .MessageImprint .HashedMessage ),GeneralizedTime :_gabd .GeneralizedTime };return _deec ,nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_af *adobePKCS7Detached )IsApplicable (sig *_c .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};type adobeX509RSASHA1 struct{_cgc *_gf .PrivateKey ;_ega *_ed .Certificate ;_aff SignFunc ;};type timestampInfo struct{Version int ;Policy _eg .RawValue ;MessageImprint struct{HashAlgorithm _be .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _eg .RawValue ;GeneralizedTime _a .Time ;};

// Validate validates PdfSignature.
func (_fgd *adobePKCS7Detached )Validate (sig *_c .PdfSignature ,digest _c .Hasher )(_c .SignatureValidationResult ,error ){_cd :=sig .Contents .Bytes ();_gg ,_adg :=_aa .Parse (_cd );if _adg !=nil {return _c .SignatureValidationResult {},_adg ;};_fb :=digest .(*_e .Buffer );_gg .Content =_fb .Bytes ();if _adg =_gg .Verify ();_adg !=nil {return _c .SignatureValidationResult {},_adg ;};return _c .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewDigest creates a new digest.
func (_ab *adobePKCS7Detached )NewDigest (sig *_c .PdfSignature )(_c .Hasher ,error ){return _e .NewBuffer (nil ),nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_cea *docTimeStamp )IsApplicable (sig *_c .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};

// Sign sets the Contents fields for the PdfSignature.
func (_gff *docTimeStamp )Sign (sig *_c .PdfSignature ,digest _c .Hasher )error {_efgb :=digest .(*_e .Buffer );_dde :=_gff ._bgf .New ();if _ ,_bdbf :=_ec .Copy (_dde ,_efgb );_bdbf !=nil {return _bdbf ;};_add :=_dde .Sum (nil );_bee :=_ad .Request {HashAlgorithm :_gff ._bgf ,HashedMessage :_add ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_efc ,_gbb :=_bee .Marshal ();if _gbb !=nil {return _gbb ;};_gdb ,_gbb :=_f .Post (_gff ._def ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_e .NewBuffer (_efc ));if _gbb !=nil {return _gbb ;};defer _gdb .Body .Close ();_bff ,_gbb :=_fa .ReadAll (_gdb .Body );if _gbb !=nil {return _gbb ;};if _gdb .StatusCode !=_f .StatusOK {return _fab .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_gdb .StatusCode );};var _fff struct{Version _eg .RawValue ;Content _eg .RawValue ;};_ ,_gbb =_eg .Unmarshal (_bff ,&_fff );if _gbb !=nil {return _gbb ;};sig .Contents =_d .MakeHexString (string (_fff .Content .FullBytes ));return nil ;};

// NewDigest creates a new digest.
func (_dg *adobeX509RSASHA1 )NewDigest (sig *_c .PdfSignature )(_c .Hasher ,error ){_dc ,_aef :=_dg .getCertificate (sig );if _aef !=nil {return nil ,_aef ;};_aac ,_ :=_df (_dc .SignatureAlgorithm );return _aac .New (),nil ;};