//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_df "bytes";_a "crypto";_fa "crypto/rand";_ec "crypto/rsa";_cg "crypto/x509";_eb "crypto/x509/pkix";_g "encoding/asn1";_db "encoding/hex";_c "errors";_eg "fmt";_fab "github.com/unidoc/pkcs7";_bf "github.com/unidoc/timestamp";
_dg "github.com/unidoc/unipdf/v3/common";_gb "github.com/unidoc/unipdf/v3/core";_gc "github.com/unidoc/unipdf/v3/model";_ad "github.com/unidoc/unipdf/v3/model/mdp";_ff "github.com/unidoc/unipdf/v3/model/sigutil";_b "hash";_f "math/big";_bg "strings";_d "time";
);

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _a .Hash )(_gc .SignatureHandler ,error ){return &docTimeStamp {_acb :timestampServerURL ,_gac :hashAlgorithm },nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_cg .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_gc .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_fag :certificate ,_bed :signFunc ,_aed :opts .EstimateSize ,_gadg :opts .Algorithm },nil ;
};type etsiPAdES struct{_acg *_ec .PrivateKey ;_efd *_cg .Certificate ;_eca bool ;_dbb bool ;_bga *_cg .Certificate ;_bce string ;

// CertClient is the client used to retrieve certificates.
CertClient *_ff .CertClient ;

// OCSPClient is the client used to retrieve OCSP validation information.
OCSPClient *_ff .OCSPClient ;

// CRLClient is the client used to retrieve CRL validation information.
CRLClient *_ff .CRLClient ;_dfa *_gc .PdfAppender ;_gga *_gc .DSS ;};

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct{Crl []_g .RawValue `asn1:"explicit,tag:0,optional"`;Ocsp []_g .RawValue `asn1:"explicit,tag:1,optional"`;OtherRevInfo []_g .RawValue `asn1:"explicit,tag:2,optional"`;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_gcb *_gc .PdfSignature ,_gag _gc .Hasher )([]byte ,error );

// Sign sets the Contents fields for the PdfSignature.
func (_bcb *etsiPAdES )Sign (sig *_gc .PdfSignature ,digest _gc .Hasher )error {_eef ,_cfe :=digest .(*_df .Buffer );if !_cfe {return _eg .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_abg ,_dgg :=_fab .NewSignedData (_eef .Bytes ());
if _dgg !=nil {return _dgg ;};_abg .SetDigestAlgorithm (_fab .OIDDigestAlgorithmSHA256 );_cgc :=_fab .SignerInfoConfig {};_def :=_a .SHA256 .New ();_def .Write (_bcb ._efd .Raw );var _efc struct{Seq struct{Seq struct{Value []byte ;};};};_efc .Seq .Seq .Value =_def .Sum (nil );
var _ggb []*_cg .Certificate ;var _acda []*_cg .Certificate ;if _bcb ._bga !=nil {_acda =[]*_cg .Certificate {_bcb ._bga };};_cdd :=RevocationInfoArchival {Crl :[]_g .RawValue {},Ocsp :[]_g .RawValue {},OtherRevInfo :[]_g .RawValue {}};_acdg :=0;if _bcb ._dfa !=nil &&len (_bcb ._bce )> 0{_fbb ,_bee :=_bcb .makeTimestampRequest (_bcb ._bce ,([]byte )(""));
if _bee !=nil {return _bee ;};_cda ,_bee :=_bf .Parse (_fbb .FullBytes );if _bee !=nil {return _bee ;};_ggb =append (_ggb ,_cda .Certificates ...);};if _bcb ._dfa !=nil {_daef ,_baf :=_bcb .addDss ([]*_cg .Certificate {_bcb ._efd },_acda ,&_cdd );if _baf !=nil {return _baf ;
};_acdg +=_daef ;if len (_ggb )> 0{_daef ,_baf =_bcb .addDss (_ggb ,nil ,&_cdd );if _baf !=nil {return _baf ;};_acdg +=_daef ;};if !_bcb ._dbb {_bcb ._dfa .SetDSS (_bcb ._gga );};};_cgc .ExtraSignedAttributes =append (_cgc .ExtraSignedAttributes ,_fab .Attribute {Type :_fab .OIDAttributeSigningCertificateV2 ,Value :_efc },_fab .Attribute {Type :_fab .OIDAttributeAdobeRevocation ,Value :_cdd });
if _acaa :=_abg .AddSignerChainPAdES (_bcb ._efd ,_bcb ._acg ,_acda ,_cgc );_acaa !=nil {return _acaa ;};_abg .Detach ();if len (_bcb ._bce )> 0{_dbgd :=_abg .GetSignedData ().SignerInfos [0].EncryptedDigest ;_aaa ,_gdf :=_bcb .makeTimestampRequest (_bcb ._bce ,_dbgd );
if _gdf !=nil {return _gdf ;};_gdf =_abg .AddTimestampTokenToSigner (0,_aaa .FullBytes );if _gdf !=nil {return _gdf ;};};_dabf ,_dgg :=_abg .Finish ();if _dgg !=nil {return _dgg ;};_dd :=make ([]byte ,len (_dabf )+1024*2+_acdg );copy (_dd ,_dabf );sig .Contents =_gb .MakeHexString (string (_dd ));
if !_bcb ._dbb &&_bcb ._gga !=nil {_def =_a .SHA1 .New ();_def .Write (_dd );_bfe :=_bg .ToUpper (_db .EncodeToString (_def .Sum (nil )));if _bfe !=""{_bcb ._gga .VRI [_bfe ]=&_gc .VRI {Cert :_bcb ._gga .Certs ,OCSP :_bcb ._gga .OCSPs ,CRL :_bcb ._gga .CRLs };
};_bcb ._dfa .SetDSS (_bcb ._gga );};return nil ;};

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT (privateKey *_ec .PrivateKey ,certificate *_cg .Certificate ,caCert *_cg .Certificate ,certificateTimestampServerURL string )(_gc .SignatureHandler ,error ){return &etsiPAdES {_efd :certificate ,_acg :privateKey ,_bga :caCert ,_bce :certificateTimestampServerURL },nil ;
};

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB (privateKey *_ec .PrivateKey ,certificate *_cg .Certificate ,caCert *_cg .Certificate )(_gc .SignatureHandler ,error ){return &etsiPAdES {_efd :certificate ,_acg :privateKey ,_bga :caCert },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_daeg *adobeX509RSASHA1 )IsApplicable (sig *_gc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _a .Hash ;};func (_gca *adobeX509RSASHA1 )sign (_daf *_gc .PdfSignature ,_eab _gc .Hasher ,_cdg bool )error {if !_cdg {return _gca .Sign (_daf ,_eab );};_cddb ,_eceg :=_gca ._fag .PublicKey .(*_ec .PublicKey );if !_eceg {return _eg .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_cddb );
};_dfea ,_aegg :=_g .Marshal (make ([]byte ,_cddb .Size ()));if _aegg !=nil {return _aegg ;};_daf .Contents =_gb .MakeHexString (string (_dfea ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_ccb *etsiPAdES )InitSignature (sig *_gc .PdfSignature )error {if !_ccb ._eca {if _ccb ._efd ==nil {return _c .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _ccb ._acg ==nil {return _c .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_bde :=*_ccb ;sig .Handler =&_bde ;sig .Filter =_gb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_gb .MakeName ("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_daa ,_eba :=_bde .NewDigest (sig );if _eba !=nil {return _eba ;};_ ,_eba =_daa .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _eba !=nil {return _eba ;};_bde ._dbb =true ;_eba =_bde .Sign (sig ,_daa );_bde ._dbb =false ;return _eba ;};

// Sign sets the Contents fields for the PdfSignature.
func (_agde *adobeX509RSASHA1 )Sign (sig *_gc .PdfSignature ,digest _gc .Hasher )error {var _gcfg []byte ;var _eeg error ;if _agde ._bed !=nil {_gcfg ,_eeg =_agde ._bed (sig ,digest );if _eeg !=nil {return _eeg ;};}else {_ecf ,_bcg :=digest .(_b .Hash );
if !_bcg {return _c .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_gdd :=_fea ;if _agde ._gadg !=0{_gdd =_agde ._gadg ;};_gcfg ,_eeg =_ec .SignPKCS1v15 (_fa .Reader ,_agde ._bgba ,_gdd ,_ecf .Sum (nil ));if _eeg !=nil {return _eeg ;
};};_gcfg ,_eeg =_g .Marshal (_gcfg );if _eeg !=nil {return _eeg ;};sig .Contents =_gb .MakeHexString (string (_gcfg ));return nil ;};

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT (privateKey *_ec .PrivateKey ,certificate *_cg .Certificate ,caCert *_cg .Certificate ,certificateTimestampServerURL string ,appender *_gc .PdfAppender )(_gc .SignatureHandler ,error ){_ggd :=appender .Reader .DSS ;if _ggd ==nil {_ggd =_gc .NewDSS ();
};if _dcb :=_ggd .GenerateHashMaps ();_dcb !=nil {return nil ,_dcb ;};return &etsiPAdES {_efd :certificate ,_acg :privateKey ,_bga :caCert ,_bce :certificateTimestampServerURL ,CertClient :_ff .NewCertClient (),OCSPClient :_ff .NewOCSPClient (),CRLClient :_ff .NewCRLClient (),_dfa :appender ,_gga :_ggd },nil ;
};

// Validate validates PdfSignature.
func (_gfb *adobeX509RSASHA1 )Validate (sig *_gc .PdfSignature ,digest _gc .Hasher )(_gc .SignatureValidationResult ,error ){_gdg ,_agf :=_gfb .getCertificate (sig );if _agf !=nil {return _gc .SignatureValidationResult {},_agf ;};_gfe :=sig .Contents .Bytes ();
var _fcag []byte ;if _ ,_bbf :=_g .Unmarshal (_gfe ,&_fcag );_bbf !=nil {return _gc .SignatureValidationResult {},_bbf ;};_adda ,_fbd :=digest .(_b .Hash );if !_fbd {return _gc .SignatureValidationResult {},_c .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_aab ,_ :=_gfb .getHashAlgorithm (sig );if _aab ==0{_aab =_fea ;};if _dfg :=_ec .VerifyPKCS1v15 (_gdg .PublicKey .(*_ec .PublicKey ),_aab ,_adda .Sum (nil ),_fcag );_dfg !=nil {return _gc .SignatureValidationResult {},_dfg ;};return _gc .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// InitSignature initialises the PdfSignature.
func (_ecab *adobeX509RSASHA1 )InitSignature (sig *_gc .PdfSignature )error {if _ecab ._fag ==nil {return _c .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _ecab ._bgba ==nil &&_ecab ._bed ==nil {return _c .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_adbb :=*_ecab ;sig .Handler =&_adbb ;sig .Filter =_gb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_gb .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_gb .MakeString (string (_adbb ._fag .Raw ));sig .Reference =nil ;_eaa ,_gfa :=_adbb .NewDigest (sig );if _gfa !=nil {return _gfa ;};_eaa .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _adbb .sign (sig ,_eaa ,_ecab ._aed );};func (_dae *etsiPAdES )buildCertChain (_fbc ,_be []*_cg .Certificate )([]*_cg .Certificate ,map[string ]*_cg .Certificate ,error ){_cag :=map[string ]*_cg .Certificate {};for _ ,_bcc :=range _fbc {_cag [_bcc .Subject .CommonName ]=_bcc ;
};_gfd :=_fbc ;for _ ,_gaf :=range _be {_adf :=_gaf .Subject .CommonName ;if _ ,_eaed :=_cag [_adf ];_eaed {continue ;};_cag [_adf ]=_gaf ;_gfd =append (_gfd ,_gaf );};if len (_gfd )==0{return nil ,nil ,_gc .ErrSignNoCertificates ;};var _aca error ;for _eed :=_gfd [0];
_eed !=nil &&!_dae .CertClient .IsCA (_eed );{var _bgg *_cg .Certificate ;_ ,_gae :=_cag [_eed .Issuer .CommonName ];if !_gae {if _bgg ,_aca =_dae .CertClient .GetIssuer (_eed );_aca !=nil {_dg .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076",_aca );
break ;};_cag [_eed .Issuer .CommonName ]=_bgg ;_gfd =append (_gfd ,_bgg );}else {break ;};_eed =_bgg ;};return _gfd ,_cag ,nil ;};func (_cga *adobePKCS7Detached )getCertificate (_caa *_gc .PdfSignature )(*_cg .Certificate ,error ){if _cga ._agg !=nil {return _cga ._agg ,nil ;
};_egd ,_abf :=_caa .GetCerts ();if _abf !=nil {return nil ,_abf ;};return _egd [0],nil ;};func (_ecb *etsiPAdES )getCerts (_ede []*_cg .Certificate )([][]byte ,error ){_cfc :=make ([][]byte ,0,len (_ede ));for _ ,_fe :=range _ede {_cfc =append (_cfc ,_fe .Raw );
};return _cfc ,nil ;};func (_abb *etsiPAdES )addDss (_ffcg ,_agb []*_cg .Certificate ,_cfa *RevocationInfoArchival )(int ,error ){_add ,_fabf ,_bfb :=_abb .buildCertChain (_ffcg ,_agb );if _bfb !=nil {return 0,_bfb ;};_dfbg ,_bfb :=_abb .getCerts (_add );
if _bfb !=nil {return 0,_bfb ;};var _ddc ,_dec [][]byte ;if _abb .OCSPClient !=nil {_ddc ,_bfb =_abb .getOCSPs (_add ,_fabf );if _bfb !=nil {return 0,_bfb ;};};if _abb .CRLClient !=nil {_dec ,_bfb =_abb .getCRLs (_add );if _bfb !=nil {return 0,_bfb ;};
};if !_abb ._dbb {_ ,_bfb =_abb ._gga .AddCerts (_dfbg );if _bfb !=nil {return 0,_bfb ;};_ ,_bfb =_abb ._gga .AddOCSPs (_ddc );if _bfb !=nil {return 0,_bfb ;};_ ,_bfb =_abb ._gga .AddCRLs (_dec );if _bfb !=nil {return 0,_bfb ;};};_caf :=0;for _ ,_ddf :=range _dec {_caf +=len (_ddf );
_cfa .Crl =append (_cfa .Crl ,_g .RawValue {FullBytes :_ddf });};for _ ,_ffaf :=range _ddc {_caf +=len (_ffaf );_cfa .Ocsp =append (_cfa .Ocsp ,_g .RawValue {FullBytes :_ffaf });};return _caf ,nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bgd *etsiPAdES )IsApplicable (sig *_gc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_ec .PrivateKey ,certificate *_cg .Certificate )(_gc .SignatureHandler ,error ){return &adobeX509RSASHA1 {_fag :certificate ,_bgba :privateKey },nil ;};func (_bfeb *adobeX509RSASHA1 )getCertificate (_dba *_gc .PdfSignature )(*_cg .Certificate ,error ){if _bfeb ._fag !=nil {return _bfeb ._fag ,nil ;
};_bfg ,_dbe :=_dba .GetCerts ();if _dbe !=nil {return nil ,_dbe ;};return _bfg [0],nil ;};

// NewDigest creates a new digest.
func (_bgb *adobePKCS7Detached )NewDigest (sig *_gc .PdfSignature )(_gc .Hasher ,error ){return _df .NewBuffer (nil ),nil ;};

// NewDigest creates a new digest.
func (_cdde *docTimeStamp )NewDigest (sig *_gc .PdfSignature )(_gc .Hasher ,error ){return _df .NewBuffer (nil ),nil ;};type adobeX509RSASHA1 struct{_bgba *_ec .PrivateKey ;_fag *_cg .Certificate ;_bed SignFunc ;_aed bool ;_gadg _a .Hash ;};

// NewDigest creates a new digest.
func (_de *DocMDPHandler )NewDigest (sig *_gc .PdfSignature )(_gc .Hasher ,error ){return _de ._ca .NewDigest (sig );};

// Sign sets the Contents fields.
func (_bfd *adobePKCS7Detached )Sign (sig *_gc .PdfSignature ,digest _gc .Hasher )error {if _bfd ._gbd {_edebc :=_bfd ._fff ;if _edebc <=0{_edebc =8192;};sig .Contents =_gb .MakeHexString (string (make ([]byte ,_edebc )));return nil ;};_cge ,_ebb :=digest .(*_df .Buffer );
if !_ebb {return _eg .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_bac ,_gad :=_fab .NewSignedData (_cge .Bytes ());if _gad !=nil {return _gad ;};if _egg :=_bac .AddSigner (_bfd ._agg ,_bfd ._efcd ,_fab .SignerInfoConfig {});
_egg !=nil {return _egg ;};_bac .Detach ();_ceb ,_gad :=_bac .Finish ();if _gad !=nil {return _gad ;};_bgf :=make ([]byte ,8192);copy (_bgf ,_ceb );sig .Contents =_gb .MakeHexString (string (_bgf ));return nil ;};func (_gf *etsiPAdES )makeTimestampRequest (_bb string ,_gde []byte )(_g .RawValue ,error ){_fcce :=_a .SHA512 .New ();
_fcce .Write (_gde );_gdea :=_fcce .Sum (nil );_dfb :=_bf .Request {HashAlgorithm :_a .SHA512 ,HashedMessage :_gdea ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_fg :=_ff .NewTimestampClient ();_bge ,_dab :=_fg .GetEncodedToken (_bb ,&_dfb );
if _dab !=nil {return _g .NullRawValue ,_dab ;};return _g .RawValue {FullBytes :_bge },nil ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_ff .TimestampClient ;};const _fea =_a .SHA1 ;func (_abcg *docTimeStamp )getCertificate (_acf *_gc .PdfSignature )(*_cg .Certificate ,error ){_eeff ,_aeb :=_acf .GetCerts ();if _aeb !=nil {return nil ,_aeb ;};return _eeff [0],nil ;};

// NewDigest creates a new digest.
func (_af *adobeX509RSASHA1 )NewDigest (sig *_gc .PdfSignature )(_gc .Hasher ,error ){if _bad ,_eefb :=_af .getHashAlgorithm (sig );_bad !=0&&_eefb ==nil {return _bad .New (),nil ;};return _fea .New (),nil ;};

// NewDigest creates a new digest.
func (_ecbe *etsiPAdES )NewDigest (_ *_gc .PdfSignature )(_gc .Hasher ,error ){return _df .NewBuffer (nil ),nil ;};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_bca *DocMDPHandler )Validate (sig *_gc .PdfSignature ,digest _gc .Hasher )(_gc .SignatureValidationResult ,error ){return _gc .SignatureValidationResult {},_c .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};func (_fdd *adobeX509RSASHA1 )getHashAlgorithm (_dgcg *_gc .PdfSignature )(_a .Hash ,error ){_gbc ,_bgdf :=_fdd .getCertificate (_dgcg );if _bgdf !=nil {if _fdd ._gadg !=0{return _fdd ._gadg ,nil ;};return _fea ,_bgdf ;};if _dgcg .Contents !=nil {_cdc :=_dgcg .Contents .Bytes ();
var _cad []byte ;if _ ,_aeg :=_g .Unmarshal (_cdc ,&_cad );_aeg ==nil {_cagd :=_gafg (_gbc .PublicKey .(*_ec .PublicKey ),_cad );if _cagd > 0{return _cagd ,nil ;};};};if _fdd ._gadg !=0{return _fdd ._gadg ,nil ;};return _fea ,nil ;};type adobePKCS7Detached struct{_efcd *_ec .PrivateKey ;
_agg *_cg .Certificate ;_gbd bool ;_fff int ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_gc .SignatureHandler ,error ){return &adobePKCS7Detached {_gbd :true ,_fff :signatureLen },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_fcae *adobePKCS7Detached )IsApplicable (sig *_gc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _a .Hash ,opts *DocTimeStampOpts )(_gc .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_acb :timestampServerURL ,_gac :hashAlgorithm ,_afa :opts .SignatureSize ,_bda :opts .Client },nil ;
};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_ca _gc .SignatureHandler ;Permission _ad .DocMDPPermission ;};func _dda (_bgdfa _g .ObjectIdentifier )(_a .Hash ,error ){switch {case _bgdfa .Equal (_fab .OIDDigestAlgorithmSHA1 ),_bgdfa .Equal (_fab .OIDDigestAlgorithmECDSASHA1 ),_bgdfa .Equal (_fab .OIDDigestAlgorithmDSA ),_bgdfa .Equal (_fab .OIDDigestAlgorithmDSASHA1 ),_bgdfa .Equal (_fab .OIDEncryptionAlgorithmRSA ):return _a .SHA1 ,nil ;
case _bgdfa .Equal (_fab .OIDDigestAlgorithmSHA256 ),_bgdfa .Equal (_fab .OIDDigestAlgorithmECDSASHA256 ):return _a .SHA256 ,nil ;case _bgdfa .Equal (_fab .OIDDigestAlgorithmSHA384 ),_bgdfa .Equal (_fab .OIDDigestAlgorithmECDSASHA384 ):return _a .SHA384 ,nil ;
case _bgdfa .Equal (_fab .OIDDigestAlgorithmSHA512 ),_bgdfa .Equal (_fab .OIDDigestAlgorithmECDSASHA512 ):return _a .SHA512 ,nil ;};return _a .Hash (0),_fab .ErrUnsupportedAlgorithm ;};func _aga (_feg []byte ,_fcd int )(_agfg []byte ){_geb :=len (_feg );
if _geb > _fcd {_geb =_fcd ;};_agfg =make ([]byte ,_fcd );copy (_agfg [len (_agfg )-_geb :],_feg );return ;};

// Sign sets the Contents fields for the PdfSignature.
func (_dcc *docTimeStamp )Sign (sig *_gc .PdfSignature ,digest _gc .Hasher )error {_egef ,_efe :=_ff .NewTimestampRequest (digest .(*_df .Buffer ),&_bf .RequestOptions {Hash :_dcc ._gac ,Certificates :true });if _efe !=nil {return _efe ;};_beec :=_dcc ._bda ;
if _beec ==nil {_beec =_ff .NewTimestampClient ();};_eaf ,_efe :=_beec .GetEncodedToken (_dcc ._acb ,_egef );if _efe !=nil {return _efe ;};_aegcg :=len (_eaf );if _dcc ._afa > 0&&_aegcg > _dcc ._afa {return _gc .ErrSignNotEnoughSpace ;};if _aegcg > 0{_dcc ._afa =_aegcg +128;
};if sig .Contents !=nil {_aad :=sig .Contents .Bytes ();copy (_aad ,_eaf );_eaf =_aad ;};sig .Contents =_gb .MakeHexString (string (_eaf ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_agbd *docTimeStamp )IsApplicable (sig *_gc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};func (_cb *etsiPAdES )getOCSPs (_cea []*_cg .Certificate ,_fd map[string ]*_cg .Certificate )([][]byte ,error ){_ea :=make ([][]byte ,0,len (_cea ));for _ ,_bbc :=range _cea {for _ ,_ecc :=range _bbc .OCSPServer {if _cb .CertClient .IsCA (_bbc ){continue ;
};_gdc ,_ae :=_fd [_bbc .Issuer .CommonName ];if !_ae {_dg .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
continue ;};_ ,_ee ,_dfd :=_cb .OCSPClient .MakeRequest (_ecc ,_bbc ,_gdc );if _dfd !=nil {_dg .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076",_dfd );
continue ;};_ea =append (_ea ,_ee );};};return _ea ,nil ;};type timestampInfo struct{Version int ;Policy _g .RawValue ;MessageImprint struct{HashAlgorithm _eb .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _g .RawValue ;GeneralizedTime _d .Time ;
};

// Validate validates PdfSignature.
func (_fbdb *docTimeStamp )Validate (sig *_gc .PdfSignature ,digest _gc .Hasher )(_gc .SignatureValidationResult ,error ){_dbcf :=sig .Contents .Bytes ();_dcbg ,_gcd :=_fab .Parse (_dbcf );if _gcd !=nil {return _gc .SignatureValidationResult {},_gcd ;};
if _gcd =_dcbg .Verify ();_gcd !=nil {return _gc .SignatureValidationResult {},_gcd ;};var _ebg timestampInfo ;_ ,_gcd =_g .Unmarshal (_dcbg .Content ,&_ebg );if _gcd !=nil {return _gc .SignatureValidationResult {},_gcd ;};_dgb ,_gcd :=_dda (_ebg .MessageImprint .HashAlgorithm .Algorithm );
if _gcd !=nil {return _gc .SignatureValidationResult {},_gcd ;};_gcfe :=_dgb .New ();_bdf ,_gec :=digest .(*_df .Buffer );if !_gec {return _gc .SignatureValidationResult {},_eg .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");
};_gcfe .Write (_bdf .Bytes ());_gdgg :=_gcfe .Sum (nil );_edb :=_gc .SignatureValidationResult {IsSigned :true ,IsVerified :_df .Equal (_gdgg ,_ebg .MessageImprint .HashedMessage ),GeneralizedTime :_ebg .GeneralizedTime };return _edb ,nil ;};func _gafg (_dfdc *_ec .PublicKey ,_cebg []byte )_a .Hash {_gdb :=_dfdc .Size ();
if _gdb !=len (_cebg ){return 0;};_bfeg :=func (_cdda *_f .Int ,_cgg *_ec .PublicKey ,_cgbb *_f .Int )*_f .Int {_gcg :=_f .NewInt (int64 (_cgg .E ));_cdda .Exp (_cgbb ,_gcg ,_cgg .N );return _cdda ;};_fgf :=new (_f .Int ).SetBytes (_cebg );_egea :=_bfeg (new (_f .Int ),_dfdc ,_fgf );
_eec :=_aga (_egea .Bytes (),_gdb );if _eec [0]!=0||_eec [1]!=1{return 0;};_dfgc :=[]struct{Hash _a .Hash ;Prefix []byte ;}{{Hash :_a .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_a .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_a .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_a .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_a .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_cdf :=range _dfgc {_fce :=_cdf .Hash .Size ();_gddf :=len (_cdf .Prefix )+_fce ;if _df .Equal (_eec [_gdb -_gddf :_gdb -_fce ],_cdf .Prefix ){return _cdf .Hash ;};};return 0;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_ag *DocMDPHandler )ValidateWithOpts (sig *_gc .PdfSignature ,digest _gc .Hasher ,params _gc .SignatureHandlerDocMDPParams )(_gc .SignatureValidationResult ,error ){_gd ,_ce :=_ag ._ca .Validate (sig ,digest );if _ce !=nil {return _gd ,_ce ;};_ffc :=params .Parser ;
if _ffc ==nil {return _gc .SignatureValidationResult {},_c .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_gd .IsVerified {return _gd ,nil ;};_da :=params .DiffPolicy ;if _da ==nil {_da =_ad .NewDefaultDiffPolicy ();
};for _fcc :=0;_fcc <=_ffc .GetRevisionNumber ();_fcc ++{_dc ,_bgc :=_ffc .GetRevision (_fcc );if _bgc !=nil {return _gc .SignatureValidationResult {},_bgc ;};_dga :=_dc .GetTrailer ();if _dga ==nil {return _gc .SignatureValidationResult {},_c .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_bd ,_cc :=_gb .GetDict (_dga .Get ("\u0052\u006f\u006f\u0074"));if !_cc {return _gc .SignatureValidationResult {},_c .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");};
_ga ,_cc :=_gb .GetDict (_bd .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_cc {continue ;};_ge ,_cc :=_gb .GetArray (_ga .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_cc {continue ;};for _ ,_cae :=range _ge .Elements (){_ed ,_agd :=_gb .GetDict (_cae );
if !_agd {continue ;};_eda ,_agd :=_gb .GetDict (_ed .Get ("\u0056"));if !_agd {continue ;};if _gb .EqualObjects (_eda .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_gd .DiffResults ,_bgc =_da .ReviewFile (_dc ,_ffc ,&_ad .MDPParameters {DocMDPLevel :_ag .Permission });
if _bgc !=nil {return _gc .SignatureValidationResult {},_bgc ;};_gd .IsVerified =_gd .DiffResults .IsPermitted ();return _gd ,nil ;};};};return _gc .SignatureValidationResult {},_c .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};

// InitSignature initialization of the DocMDP signature.
func (_cgd *DocMDPHandler )InitSignature (sig *_gc .PdfSignature )error {_gcf :=_cgd ._ca .InitSignature (sig );if _gcf !=nil {return _gcf ;};sig .Handler =_cgd ;if sig .Reference ==nil {sig .Reference =_gb .MakeArray ();};sig .Reference .Append (_gc .NewPdfSignatureReferenceDocMDP (_gc .NewPdfTransformParamsDocMDP (_cgd .Permission )).ToPdfObject ());
return nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_ec .PrivateKey ,certificate *_cg .Certificate )(_gc .SignatureHandler ,error ){return &adobePKCS7Detached {_agg :certificate ,_efcd :privateKey },nil ;};

// InitSignature initialises the PdfSignature.
func (_aegc *docTimeStamp )InitSignature (sig *_gc .PdfSignature )error {_fabe :=*_aegc ;sig .Type =_gb .MakeName ("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070");sig .Handler =&_fabe ;sig .Filter =_gb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_gb .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _aegc ._afa > 0{sig .Contents =_gb .MakeHexString (string (make ([]byte ,_aegc ._afa )));}else {_gce ,_aec :=_aegc .NewDigest (sig );
if _aec !=nil {return _aec ;};_gce .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _aec =_fabe .Sign (sig ,_gce );
_aec !=nil {return _aec ;};_aegc ._afa =_fabe ._afa ;};return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_egc *DocMDPHandler )IsApplicable (sig *_gc .PdfSignature )bool {_gg :=false ;for _ ,_ac :=range sig .Reference .Elements (){if _ba ,_acd :=_gb .GetDict (_ac );_acd {if _ab ,_bc :=_gb .GetNameVal (_ba .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_bc {if _ab !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _fb ,_fc :=_gb .GetDict (_ba .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_fc {_ ,_ffa :=_gb .GetNumberAsInt64 (_fb .Get ("\u0050"));if _ffa !=nil {return false ;
};_gg =true ;break ;};};};};return _gg &&_egc ._ca .IsApplicable (sig );};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _gc .SignatureHandler ,permission _ad .DocMDPPermission )(_gc .SignatureHandler ,error ){return &DocMDPHandler {_ca :handler ,Permission :permission },nil ;};

// Validate validates PdfSignature.
func (_fcaf *etsiPAdES )Validate (sig *_gc .PdfSignature ,digest _gc .Hasher )(_gc .SignatureValidationResult ,error ){_cfec :=sig .Contents .Bytes ();_ffcf ,_ebf :=_fab .Parse (_cfec );if _ebf !=nil {return _gc .SignatureValidationResult {},_ebf ;};_bfbd ,_ece :=digest .(*_df .Buffer );
if !_ece {return _gc .SignatureValidationResult {},_eg .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_ffcf .Content =_bfbd .Bytes ();if _ebf =_ffcf .Verify ();_ebf !=nil {return _gc .SignatureValidationResult {},_ebf ;
};_agbf :=false ;_dfe :=false ;var _abc _d .Time ;for _ ,_ega :=range _ffcf .Signers {_fac :=_ega .EncryptedDigest ;var _abgc RevocationInfoArchival ;_ebf =_ffcf .UnmarshalSignedAttribute (_fab .OIDAttributeAdobeRevocation ,&_abgc );if _ebf ==nil {if len (_abgc .Crl )> 0{_dfe =true ;
};if len (_abgc .Ocsp )> 0{_agbf =true ;};};for _ ,_dce :=range _ega .UnauthenticatedAttributes {if _dce .Type .Equal (_fab .OIDAttributeTimeStampToken ){_eff ,_age :=_bf .Parse (_dce .Value .Bytes );if _age !=nil {return _gc .SignatureValidationResult {},_age ;
};_abc =_eff .Time ;_dff :=_eff .HashAlgorithm .New ();_dff .Write (_fac );if !_df .Equal (_dff .Sum (nil ),_eff .HashedMessage ){return _gc .SignatureValidationResult {},_eg .Errorf ("\u0048\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037");
};break ;};};};_cac :=_gc .SignatureValidationResult {IsSigned :true ,IsVerified :true ,IsCrlFound :_dfe ,IsOcspFound :_agbf ,GeneralizedTime :_abc };return _cac ,nil ;};

// Sign adds a new reference to signature's references array.
func (_ef *DocMDPHandler )Sign (sig *_gc .PdfSignature ,digest _gc .Hasher )error {return _ef ._ca .Sign (sig ,digest );};func (_dfag *etsiPAdES )getCRLs (_aa []*_cg .Certificate )([][]byte ,error ){_cef :=make ([][]byte ,0,len (_aa ));for _ ,_dbc :=range _aa {for _ ,_bab :=range _dbc .CRLDistributionPoints {if _dfag .CertClient .IsCA (_dbc ){continue ;
};_cd ,_dgc :=_dfag .CRLClient .MakeRequest (_bab ,_dbc );if _dgc !=nil {_dg .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076",_dgc );continue ;};_cef =append (_cef ,_cd );
};};return _cef ,nil ;};

// InitSignature initialises the PdfSignature.
func (_dgdf *adobePKCS7Detached )InitSignature (sig *_gc .PdfSignature )error {if !_dgdf ._gbd {if _dgdf ._agg ==nil {return _c .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _dgdf ._efcd ==nil {return _c .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_daed :=*_dgdf ;sig .Handler =&_daed ;sig .Filter =_gb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_gb .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_edeb ,_ege :=_daed .NewDigest (sig );if _ege !=nil {return _ege ;};_edeb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _daed .Sign (sig ,_edeb );};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_cg .Certificate ,signFunc SignFunc )(_gc .SignatureHandler ,error ){return &adobeX509RSASHA1 {_fag :certificate ,_bed :signFunc },nil ;};type docTimeStamp struct{_acb string ;_gac _a .Hash ;_afa int ;_bda *_ff .TimestampClient ;
};

// Validate validates PdfSignature.
func (_dceg *adobePKCS7Detached )Validate (sig *_gc .PdfSignature ,digest _gc .Hasher )(_gc .SignatureValidationResult ,error ){_babd :=sig .Contents .Bytes ();_bdd ,_adb :=_fab .Parse (_babd );if _adb !=nil {return _gc .SignatureValidationResult {},_adb ;
};_ceee ,_bdea :=digest .(*_df .Buffer );if !_bdea {return _gc .SignatureValidationResult {},_eg .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_bdd .Content =_ceee .Bytes ();if _adb =_bdd .Verify ();
_adb !=nil {return _gc .SignatureValidationResult {},_adb ;};return _gc .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};