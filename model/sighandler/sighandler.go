//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_dg "bytes";_ae "crypto";_cg "crypto/rand";_c "crypto/rsa";_gb "crypto/x509";_ff "crypto/x509/pkix";_gd "encoding/asn1";_ga "encoding/hex";_d "errors";_g "fmt";_db "github.com/unidoc/pkcs7";_ab "github.com/unidoc/timestamp";
_aa "github.com/unidoc/unipdf/v3/common";_gc "github.com/unidoc/unipdf/v3/core";_ac "github.com/unidoc/unipdf/v3/model";_cb "github.com/unidoc/unipdf/v3/model/mdp";_ge "github.com/unidoc/unipdf/v3/model/sigutil";_be "hash";_b "math/big";_bg "strings";_a "time";
);

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _ae .Hash ,opts *DocTimeStampOpts )(_ac .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_fca :timestampServerURL ,_dfd :hashAlgorithm ,_gfgc :opts .SignatureSize ,_geg :opts .Client },nil ;
};type adobePKCS7Detached struct{_cad *_c .PrivateKey ;_gfg *_gb .Certificate ;_gbed bool ;_dbcb int ;};func (_bgac *etsiPAdES )makeTimestampRequest (_aca string ,_baf []byte )(_gd .RawValue ,error ){_gaef :=_ae .SHA512 .New ();_gaef .Write (_baf );_dbe :=_gaef .Sum (nil );
_gcd :=_ab .Request {HashAlgorithm :_ae .SHA512 ,HashedMessage :_dbe ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_cgc :=_ge .NewTimestampClient ();_ede ,_ef :=_cgc .GetEncodedToken (_aca ,&_gcd );if _ef !=nil {return _gd .NullRawValue ,_ef ;
};return _gd .RawValue {FullBytes :_ede },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_faa *etsiPAdES )IsApplicable (sig *_ac .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// Sign sets the Contents fields for the PdfSignature.
func (_bef *adobeX509RSASHA1 )Sign (sig *_ac .PdfSignature ,digest _ac .Hasher )error {var _gbg []byte ;var _eae error ;if _bef ._cbfd !=nil {_gbg ,_eae =_bef ._cbfd (sig ,digest );if _eae !=nil {return _eae ;};}else {_deee ,_gdg :=digest .(_be .Hash );
if !_gdg {return _d .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_gefg :=_cbed ;if _bef ._gbb !=0{_gefg =_bef ._gbb ;};_gbg ,_eae =_c .SignPKCS1v15 (_cg .Reader ,_bef ._efd ,_gefg ,_deee .Sum (nil ));if _eae !=nil {return _eae ;
};};_gbg ,_eae =_gd .Marshal (_gbg );if _eae !=nil {return _eae ;};sig .Contents =_gc .MakeHexString (string (_gbg ));return nil ;};

// InitSignature initialization of the DocMDP signature.
func (_gcb *DocMDPHandler )InitSignature (sig *_ac .PdfSignature )error {_fcf :=_gcb ._gbf .InitSignature (sig );if _fcf !=nil {return _fcf ;};sig .Handler =_gcb ;if sig .Reference ==nil {sig .Reference =_gc .MakeArray ();};sig .Reference .Append (_ac .NewPdfSignatureReferenceDocMDP (_ac .NewPdfTransformParamsDocMDP (_gcb .Permission )).ToPdfObject ());
return nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _ae .Hash )(_ac .SignatureHandler ,error ){return &docTimeStamp {_fca :timestampServerURL ,_dfd :hashAlgorithm },nil ;};

// NewDigest creates a new digest.
func (_dca *DocMDPHandler )NewDigest (sig *_ac .PdfSignature )(_ac .Hasher ,error ){return _dca ._gbf .NewDigest (sig );};func (_aac *etsiPAdES )getCRLs (_ebfd []*_gb .Certificate )([][]byte ,error ){_fcfe :=make ([][]byte ,0,len (_ebfd ));for _ ,_abd :=range _ebfd {for _ ,_abdg :=range _abd .CRLDistributionPoints {if _aac .CertClient .IsCA (_abd ){continue ;
};_daf ,_aeda :=_aac .CRLClient .MakeRequest (_abdg ,_abd );if _aeda !=nil {_aa .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076",_aeda );continue ;};
_fcfe =append (_fcfe ,_daf );};};return _fcfe ,nil ;};

// InitSignature initialises the PdfSignature.
func (_ddd *adobePKCS7Detached )InitSignature (sig *_ac .PdfSignature )error {if !_ddd ._gbed {if _ddd ._gfg ==nil {return _d .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _ddd ._cad ==nil {return _d .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_dede :=*_ddd ;sig .Handler =&_dede ;sig .Filter =_gc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_gc .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_daaf ,_bac :=_dede .NewDigest (sig );if _bac !=nil {return _bac ;};_daaf .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _dede .Sign (sig ,_daaf );};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_cbf *adobePKCS7Detached )IsApplicable (sig *_ac .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};func _aegb (_dded []byte ,_agbb int )(_ggaf []byte ){_bdf :=len (_dded );if _bdf > _agbb {_bdf =_agbb ;};_ggaf =make ([]byte ,_agbb );copy (_ggaf [len (_ggaf )-_bdf :],_dded );return ;};

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT (privateKey *_c .PrivateKey ,certificate *_gb .Certificate ,caCert *_gb .Certificate ,certificateTimestampServerURL string ,appender *_ac .PdfAppender )(_ac .SignatureHandler ,error ){_fe :=appender .Reader .DSS ;if _fe ==nil {_fe =_ac .NewDSS ();
};if _dde :=_fe .GenerateHashMaps ();_dde !=nil {return nil ,_dde ;};return &etsiPAdES {_dgca :certificate ,_cf :privateKey ,_gg :caCert ,_dfa :certificateTimestampServerURL ,CertClient :_ge .NewCertClient (),OCSPClient :_ge .NewOCSPClient (),CRLClient :_ge .NewCRLClient (),_gae :appender ,_bgf :_fe },nil ;
};func (_ccd *adobePKCS7Detached )getCertificate (_eef *_ac .PdfSignature )(*_gb .Certificate ,error ){if _ccd ._gfg !=nil {return _ccd ._gfg ,nil ;};_abb ,_fff :=_eef .GetCerts ();if _fff !=nil {return nil ,_fff ;};return _abb [0],nil ;};

// InitSignature initialises the PdfSignature.
func (_ggg *etsiPAdES )InitSignature (sig *_ac .PdfSignature )error {if !_ggg ._ed {if _ggg ._dgca ==nil {return _d .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _ggg ._cf ==nil {return _d .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_gf :=*_ggg ;sig .Handler =&_gf ;sig .Filter =_gc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_gc .MakeName ("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_af ,_eeg :=_gf .NewDigest (sig );if _eeg !=nil {return _eeg ;};_ ,_eeg =_af .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _eeg !=nil {return _eeg ;};_gf ._cbe =true ;_eeg =_gf .Sign (sig ,_af );_gf ._cbe =false ;return _eeg ;};func (_cada *adobeX509RSASHA1 )getCertificate (_fabf *_ac .PdfSignature )(*_gb .Certificate ,error ){if _cada ._cdef !=nil {return _cada ._cdef ,nil ;
};_gdfe ,_fecc :=_fabf .GetCerts ();if _fecc !=nil {return nil ,_fecc ;};return _gdfe [0],nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_cgd *DocMDPHandler )IsApplicable (sig *_ac .PdfSignature )bool {_gdf :=false ;for _ ,_dd :=range sig .Reference .Elements (){if _abg ,_bgc :=_gc .GetDict (_dd );_bgc {if _de ,_cc :=_gc .GetNameVal (_abg .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_cc {if _de !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _fg ,_ba :=_gc .GetDict (_abg .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_ba {_ ,_dc :=_gc .GetNumberAsInt64 (_fg .Get ("\u0050"));if _dc !=nil {return false ;
};_gdf =true ;break ;};};};};return _gdf &&_cgd ._gbf .IsApplicable (sig );};

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct{Crl []_gd .RawValue `asn1:"explicit,tag:0,optional"`;Ocsp []_gd .RawValue `asn1:"explicit,tag:1,optional"`;OtherRevInfo []_gd .RawValue `asn1:"explicit,tag:2,optional"`;};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_gbf _ac .SignatureHandler ;Permission _cb .DocMDPPermission ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_c .PrivateKey ,certificate *_gb .Certificate )(_ac .SignatureHandler ,error ){return &adobePKCS7Detached {_gfg :certificate ,_cad :privateKey },nil ;};func (_agc *etsiPAdES )buildCertChain (_gcc ,_eg []*_gb .Certificate )([]*_gb .Certificate ,map[string ]*_gb .Certificate ,error ){_egg :=map[string ]*_gb .Certificate {};
for _ ,_gac :=range _gcc {_egg [_gac .Subject .CommonName ]=_gac ;};_ffd :=_gcc ;for _ ,_ddec :=range _eg {_afe :=_ddec .Subject .CommonName ;if _ ,_cbb :=_egg [_afe ];_cbb {continue ;};_egg [_afe ]=_ddec ;_ffd =append (_ffd ,_ddec );};if len (_ffd )==0{return nil ,nil ,_ac .ErrSignNoCertificates ;
};var _ffdb error ;for _abe :=_ffd [0];_abe !=nil &&!_agc .CertClient .IsCA (_abe );{var _cbc *_gb .Certificate ;_ ,_ebga :=_egg [_abe .Issuer .CommonName ];if !_ebga {if _cbc ,_ffdb =_agc .CertClient .GetIssuer (_abe );_ffdb !=nil {_aa .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076",_ffdb );
break ;};_egg [_abe .Issuer .CommonName ]=_cbc ;_ffd =append (_ffd ,_cbc );}else {break ;};_abe =_cbc ;};return _ffd ,_egg ,nil ;};func (_cfc *etsiPAdES )getCerts (_aacc []*_gb .Certificate )([][]byte ,error ){_dcab :=make ([][]byte ,0,len (_aacc ));for _ ,_ec :=range _aacc {_dcab =append (_dcab ,_ec .Raw );
};return _dcab ,nil ;};const _cbed =_ae .SHA1 ;

// Sign sets the Contents fields for the PdfSignature.
func (_caf *etsiPAdES )Sign (sig *_ac .PdfSignature ,digest _ac .Hasher )error {_gef ,_gga :=digest .(*_dg .Buffer );if !_gga {return _g .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_dbg ,_fa :=_db .NewSignedData (_gef .Bytes ());
if _fa !=nil {return _fa ;};_dbg .SetDigestAlgorithm (_db .OIDDigestAlgorithmSHA256 );_dff :=_db .SignerInfoConfig {};_adb :=_ae .SHA256 .New ();_adb .Write (_caf ._dgca .Raw );var _dad struct{Seq struct{Seq struct{Value []byte ;};};};_dad .Seq .Seq .Value =_adb .Sum (nil );
var _aaf []*_gb .Certificate ;var _cde []*_gb .Certificate ;if _caf ._gg !=nil {_cde =[]*_gb .Certificate {_caf ._gg };};_ddg :=RevocationInfoArchival {Crl :[]_gd .RawValue {},Ocsp :[]_gd .RawValue {},OtherRevInfo :[]_gd .RawValue {}};_dae :=0;if _caf ._gae !=nil &&len (_caf ._dfa )> 0{_ce ,_gbea :=_caf .makeTimestampRequest (_caf ._dfa ,([]byte )(""));
if _gbea !=nil {return _gbea ;};_abdc ,_gbea :=_ab .Parse (_ce .FullBytes );if _gbea !=nil {return _gbea ;};_aaf =append (_aaf ,_abdc .Certificates ...);};if _caf ._gae !=nil {_acb ,_ecc :=_caf .addDss ([]*_gb .Certificate {_caf ._dgca },_cde ,&_ddg );
if _ecc !=nil {return _ecc ;};_dae +=_acb ;if len (_aaf )> 0{_acb ,_ecc =_caf .addDss (_aaf ,nil ,&_ddg );if _ecc !=nil {return _ecc ;};_dae +=_acb ;};if !_caf ._cbe {_caf ._gae .SetDSS (_caf ._bgf );};};_dff .ExtraSignedAttributes =append (_dff .ExtraSignedAttributes ,_db .Attribute {Type :_db .OIDAttributeSigningCertificateV2 ,Value :_dad },_db .Attribute {Type :_db .OIDAttributeAdobeRevocation ,Value :_ddg });
if _aeg :=_dbg .AddSignerChainPAdES (_caf ._dgca ,_caf ._cf ,_cde ,_dff );_aeg !=nil {return _aeg ;};_dbg .Detach ();if len (_caf ._dfa )> 0{_cddb :=_dbg .GetSignedData ().SignerInfos [0].EncryptedDigest ;_agb ,_daa :=_caf .makeTimestampRequest (_caf ._dfa ,_cddb );
if _daa !=nil {return _daa ;};_daa =_dbg .AddTimestampTokenToSigner (0,_agb .FullBytes );if _daa !=nil {return _daa ;};};_dgd ,_fa :=_dbg .Finish ();if _fa !=nil {return _fa ;};_edee :=make ([]byte ,len (_dgd )+1024*2+_dae );copy (_edee ,_dgd );sig .Contents =_gc .MakeHexString (string (_edee ));
if !_caf ._cbe &&_caf ._bgf !=nil {_adb =_ae .SHA1 .New ();_adb .Write (_edee );_abc :=_bg .ToUpper (_ga .EncodeToString (_adb .Sum (nil )));if _abc !=""{_caf ._bgf .VRI [_abc ]=&_ac .VRI {Cert :_caf ._bgf .Certs ,OCSP :_caf ._bgf .OCSPs ,CRL :_caf ._bgf .CRLs };
};_caf ._gae .SetDSS (_caf ._bgf );};return nil ;};

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT (privateKey *_c .PrivateKey ,certificate *_gb .Certificate ,caCert *_gb .Certificate ,certificateTimestampServerURL string )(_ac .SignatureHandler ,error ){return &etsiPAdES {_dgca :certificate ,_cf :privateKey ,_gg :caCert ,_dfa :certificateTimestampServerURL },nil ;
};

// Validate validates PdfSignature.
func (_fdab *adobePKCS7Detached )Validate (sig *_ac .PdfSignature ,digest _ac .Hasher )(_ac .SignatureValidationResult ,error ){_add :=sig .Contents .Bytes ();_ced ,_cca :=_db .Parse (_add );if _cca !=nil {return _ac .SignatureValidationResult {},_cca ;
};_bad ,_ecg :=digest .(*_dg .Buffer );if !_ecg {return _ac .SignatureValidationResult {},_g .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_ced .Content =_bad .Bytes ();if _cca =_ced .Verify ();
_cca !=nil {return _ac .SignatureValidationResult {},_cca ;};return _ac .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// Sign sets the Contents fields.
func (_aedc *adobePKCS7Detached )Sign (sig *_ac .PdfSignature ,digest _ac .Hasher )error {if _aedc ._gbed {_cbbd :=_aedc ._dbcb ;if _cbbd <=0{_cbbd =8192;};sig .Contents =_gc .MakeHexString (string (make ([]byte ,_cbbd )));return nil ;};_bbd ,_aegg :=digest .(*_dg .Buffer );
if !_aegg {return _g .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_adg ,_eac :=_db .NewSignedData (_bbd .Bytes ());if _eac !=nil {return _eac ;};if _edf :=_adg .AddSigner (_aedc ._gfg ,_aedc ._cad ,_db .SignerInfoConfig {});
_edf !=nil {return _edf ;};_adg .Detach ();_cge ,_eac :=_adg .Finish ();if _eac !=nil {return _eac ;};_fab :=make ([]byte ,8192);copy (_fab ,_cge );sig .Contents =_gc .MakeHexString (string (_fab ));return nil ;};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_cdf *DocMDPHandler )Validate (sig *_ac .PdfSignature ,digest _ac .Hasher )(_ac .SignatureValidationResult ,error ){return _ac .SignatureValidationResult {},_d .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};func (_deec *adobeX509RSASHA1 )sign (_aadg *_ac .PdfSignature ,_gfggg _ac .Hasher ,_fdc bool )error {if !_fdc {return _deec .Sign (_aadg ,_gfggg );};_efa ,_bbgg :=_deec ._cdef .PublicKey .(*_c .PublicKey );if !_bbgg {return _g .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_efa );
};_cafg ,_cgcb :=_gd .Marshal (make ([]byte ,_efa .Size ()));if _cgcb !=nil {return _cgcb ;};_aadg .Contents =_gc .MakeHexString (string (_cafg ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_afee *docTimeStamp )InitSignature (sig *_ac .PdfSignature )error {_fdf :=*_afee ;sig .Type =_gc .MakeName ("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070");sig .Handler =&_fdf ;sig .Filter =_gc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_gc .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _afee ._gfgc > 0{sig .Contents =_gc .MakeHexString (string (make ([]byte ,_afee ._gfgc )));}else {_fbgb ,_cce :=_afee .NewDigest (sig );
if _cce !=nil {return _cce ;};_fbgb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _cce =_fdf .Sign (sig ,_fbgb );
_cce !=nil {return _cce ;};_afee ._gfgc =_fdf ._gfgc ;};return nil ;};type etsiPAdES struct{_cf *_c .PrivateKey ;_dgca *_gb .Certificate ;_ed bool ;_cbe bool ;_gg *_gb .Certificate ;_dfa string ;

// CertClient is the client used to retrieve certificates.
CertClient *_ge .CertClient ;

// OCSPClient is the client used to retrieve OCSP validation information.
OCSPClient *_ge .OCSPClient ;

// CRLClient is the client used to retrieve CRL validation information.
CRLClient *_ge .CRLClient ;_gae *_ac .PdfAppender ;_bgf *_ac .DSS ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_c .PrivateKey ,certificate *_gb .Certificate )(_ac .SignatureHandler ,error ){return &adobeX509RSASHA1 {_cdef :certificate ,_efd :privateKey },nil ;};func (_eegb *adobeX509RSASHA1 )getHashAlgorithm (_fae *_ac .PdfSignature )(_ae .Hash ,error ){_fgb ,_gaefd :=_eegb .getCertificate (_fae );
if _gaefd !=nil {if _eegb ._gbb !=0{return _eegb ._gbb ,nil ;};return _cbed ,_gaefd ;};if _fae .Contents !=nil {_bade :=_fae .Contents .Bytes ();var _fdd []byte ;if _ ,_fcd :=_gd .Unmarshal (_bade ,&_fdd );_fcd ==nil {_ecce :=_bae (_fgb .PublicKey .(*_c .PublicKey ),_fdd );
if _ecce > 0{return _ecce ,nil ;};};};if _eegb ._gbb !=0{return _eegb ._gbb ,nil ;};return _cbed ,nil ;};

// NewDigest creates a new digest.
func (_ffc *etsiPAdES )NewDigest (_ *_ac .PdfSignature )(_ac .Hasher ,error ){return _dg .NewBuffer (nil ),nil ;};func _bae (_gde *_c .PublicKey ,_dfb []byte )_ae .Hash {_ddb :=_gde .Size ();if _ddb !=len (_dfb ){return 0;};_bffb :=func (_efee *_b .Int ,_gead *_c .PublicKey ,_cfca *_b .Int )*_b .Int {_gaf :=_b .NewInt (int64 (_gead .E ));
_efee .Exp (_cfca ,_gaf ,_gead .N );return _efee ;};_cee :=new (_b .Int ).SetBytes (_dfb );_dgg :=_bffb (new (_b .Int ),_gde ,_cee );_dbge :=_aegb (_dgg .Bytes (),_ddb );if _dbge [0]!=0||_dbge [1]!=1{return 0;};_cdea :=[]struct{Hash _ae .Hash ;Prefix []byte ;
}{{Hash :_ae .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_ae .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_ae .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_ae .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_ae .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_ebgc :=range _cdea {_ggcc :=_ebgc .Hash .Size ();_edd :=len (_ebgc .Prefix )+_ggcc ;if _dg .Equal (_dbge [_ddb -_edd :_ddb -_ggcc ],_ebgc .Prefix ){return _ebgc .Hash ;};};return 0;};

// Validate validates PdfSignature.
func (_bgfb *etsiPAdES )Validate (sig *_ac .PdfSignature ,digest _ac .Hasher )(_ac .SignatureValidationResult ,error ){_gfd :=sig .Contents .Bytes ();_ggc ,_bcg :=_db .Parse (_gfd );if _bcg !=nil {return _ac .SignatureValidationResult {},_bcg ;};_aad ,_efg :=digest .(*_dg .Buffer );
if !_efg {return _ac .SignatureValidationResult {},_g .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_ggc .Content =_aad .Bytes ();if _bcg =_ggc .Verify ();_bcg !=nil {return _ac .SignatureValidationResult {},_bcg ;
};_fec :=false ;_fcb :=false ;var _ccc _a .Time ;for _ ,_fcfc :=range _ggc .Signers {_bgff :=_fcfc .EncryptedDigest ;var _bgcf RevocationInfoArchival ;_bcg =_ggc .UnmarshalSignedAttribute (_db .OIDAttributeAdobeRevocation ,&_bgcf );if _bcg ==nil {if len (_bgcf .Crl )> 0{_fcb =true ;
};if len (_bgcf .Ocsp )> 0{_fec =true ;};};for _ ,_efe :=range _fcfc .UnauthenticatedAttributes {if _efe .Type .Equal (_db .OIDAttributeTimeStampToken ){_abee ,_ffb :=_ab .Parse (_efe .Value .Bytes );if _ffb !=nil {return _ac .SignatureValidationResult {},_ffb ;
};_ccc =_abee .Time ;_dbc :=_abee .HashAlgorithm .New ();_dbc .Write (_bgff );if !_dg .Equal (_dbc .Sum (nil ),_abee .HashedMessage ){return _ac .SignatureValidationResult {},_g .Errorf ("\u0048\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037");
};break ;};};};_bdd :=_ac .SignatureValidationResult {IsSigned :true ,IsVerified :true ,IsCrlFound :_fcb ,IsOcspFound :_fec ,GeneralizedTime :_ccc };return _bdd ,nil ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_ge .TimestampClient ;};

// Validate validates PdfSignature.
func (_dga *adobeX509RSASHA1 )Validate (sig *_ac .PdfSignature ,digest _ac .Hasher )(_ac .SignatureValidationResult ,error ){_gbef ,_gab :=_dga .getCertificate (sig );if _gab !=nil {return _ac .SignatureValidationResult {},_gab ;};_faad :=sig .Contents .Bytes ();
var _edeb []byte ;if _ ,_aabb :=_gd .Unmarshal (_faad ,&_edeb );_aabb !=nil {return _ac .SignatureValidationResult {},_aabb ;};_bff ,_dfc :=digest .(_be .Hash );if !_dfc {return _ac .SignatureValidationResult {},_d .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gea ,_ :=_dga .getHashAlgorithm (sig );if _gea ==0{_gea =_cbed ;};if _adgd :=_c .VerifyPKCS1v15 (_gbef .PublicKey .(*_c .PublicKey ),_gea ,_bff .Sum (nil ),_edeb );_adgd !=nil {return _ac .SignatureValidationResult {},_adgd ;};return _ac .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_gb .Certificate ,signFunc SignFunc )(_ac .SignatureHandler ,error ){return &adobeX509RSASHA1 {_cdef :certificate ,_cbfd :signFunc },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_fdef *docTimeStamp )Sign (sig *_ac .PdfSignature ,digest _ac .Hasher )error {_bffc ,_ecd :=_ge .NewTimestampRequest (digest .(*_dg .Buffer ),&_ab .RequestOptions {Hash :_fdef ._dfd ,Certificates :true });if _ecd !=nil {return _ecd ;};_cgda :=_fdef ._geg ;
if _cgda ==nil {_cgda =_ge .NewTimestampClient ();};_ceec ,_ecd :=_cgda .GetEncodedToken (_fdef ._fca ,_bffc );if _ecd !=nil {return _ecd ;};_ebd :=len (_ceec );if _fdef ._gfgc > 0&&_ebd > _fdef ._gfgc {return _ac .ErrSignNotEnoughSpace ;};if _ebd > 0{_fdef ._gfgc =_ebd +128;
};if sig .Contents !=nil {_cbd :=sig .Contents .Bytes ();copy (_cbd ,_ceec );_ceec =_cbd ;};sig .Contents =_gc .MakeHexString (string (_ceec ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_eeb *adobeX509RSASHA1 )InitSignature (sig *_ac .PdfSignature )error {if _eeb ._cdef ==nil {return _d .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _eeb ._efd ==nil &&_eeb ._cbfd ==nil {return _d .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_bdbc :=*_eeb ;sig .Handler =&_bdbc ;sig .Filter =_gc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_gc .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_gc .MakeString (string (_bdbc ._cdef .Raw ));sig .Reference =nil ;_bee ,_egf :=_bdbc .NewDigest (sig );if _egf !=nil {return _egf ;};_bee .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _bdbc .sign (sig ,_bee ,_eeb ._bbg );};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _ac .SignatureHandler ,permission _cb .DocMDPPermission )(_ac .SignatureHandler ,error ){return &DocMDPHandler {_gbf :handler ,Permission :permission },nil ;};

// NewDigest creates a new digest.
func (_bbc *adobeX509RSASHA1 )NewDigest (sig *_ac .PdfSignature )(_ac .Hasher ,error ){if _bec ,_dfg :=_bbc .getHashAlgorithm (sig );_bec !=0&&_dfg ==nil {return _bec .New (),nil ;};return _cbed .New (),nil ;};func (_daaa *docTimeStamp )getCertificate (_adc *_ac .PdfSignature )(*_gb .Certificate ,error ){_afa ,_ege :=_adc .GetCerts ();
if _ege !=nil {return nil ,_ege ;};return _afa [0],nil ;};

// Validate validates PdfSignature.
func (_gfe *docTimeStamp )Validate (sig *_ac .PdfSignature ,digest _ac .Hasher )(_ac .SignatureValidationResult ,error ){_bbe :=sig .Contents .Bytes ();_fgff ,_faag :=_db .Parse (_bbe );if _faag !=nil {return _ac .SignatureValidationResult {},_faag ;};
if _faag =_fgff .Verify ();_faag !=nil {return _ac .SignatureValidationResult {},_faag ;};var _adcb timestampInfo ;_ ,_faag =_gd .Unmarshal (_fgff .Content ,&_adcb );if _faag !=nil {return _ac .SignatureValidationResult {},_faag ;};_cbea ,_faag :=_eefe (_adcb .MessageImprint .HashAlgorithm .Algorithm );
if _faag !=nil {return _ac .SignatureValidationResult {},_faag ;};_adge :=_cbea .New ();_ffdg ,_fecf :=digest .(*_dg .Buffer );if !_fecf {return _ac .SignatureValidationResult {},_g .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");
};_adge .Write (_ffdg .Bytes ());_bfa :=_adge .Sum (nil );_dge :=_ac .SignatureValidationResult {IsSigned :true ,IsVerified :_dg .Equal (_bfa ,_adcb .MessageImprint .HashedMessage ),GeneralizedTime :_adcb .GeneralizedTime };return _dge ,nil ;};type timestampInfo struct{Version int ;
Policy _gd .RawValue ;MessageImprint struct{HashAlgorithm _ff .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _gd .RawValue ;GeneralizedTime _a .Time ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_gb .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_ac .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_cdef :certificate ,_cbfd :signFunc ,_bbg :opts .EstimateSize ,_gbb :opts .Algorithm },nil ;
};func (_aaa *etsiPAdES )addDss (_aab ,_dada []*_gb .Certificate ,_gee *RevocationInfoArchival )(int ,error ){_dda ,_bb ,_fgf :=_aaa .buildCertChain (_aab ,_dada );if _fgf !=nil {return 0,_fgf ;};_dba ,_fgf :=_aaa .getCerts (_dda );if _fgf !=nil {return 0,_fgf ;
};var _cdc ,_abca [][]byte ;if _aaa .OCSPClient !=nil {_cdc ,_fgf =_aaa .getOCSPs (_dda ,_bb );if _fgf !=nil {return 0,_fgf ;};};if _aaa .CRLClient !=nil {_abca ,_fgf =_aaa .getCRLs (_dda );if _fgf !=nil {return 0,_fgf ;};};if !_aaa ._cbe {_ ,_fgf =_aaa ._bgf .AddCerts (_dba );
if _fgf !=nil {return 0,_fgf ;};_ ,_fgf =_aaa ._bgf .AddOCSPs (_cdc );if _fgf !=nil {return 0,_fgf ;};_ ,_fgf =_aaa ._bgf .AddCRLs (_abca );if _fgf !=nil {return 0,_fgf ;};};_cgdb :=0;for _ ,_dcb :=range _abca {_cgdb +=len (_dcb );_gee .Crl =append (_gee .Crl ,_gd .RawValue {FullBytes :_dcb });
};for _ ,_eee :=range _cdc {_cgdb +=len (_eee );_gee .Ocsp =append (_gee .Ocsp ,_gd .RawValue {FullBytes :_eee });};return _cgdb ,nil ;};

// NewDigest creates a new digest.
func (_dadb *docTimeStamp )NewDigest (sig *_ac .PdfSignature )(_ac .Hasher ,error ){return _dg .NewBuffer (nil ),nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_efgg *docTimeStamp )IsApplicable (sig *_ac .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};func (_ded *etsiPAdES )getOCSPs (_bgb []*_gb .Certificate ,_ace map[string ]*_gb .Certificate )([][]byte ,error ){_ca :=make ([][]byte ,0,len (_bgb ));for _ ,_cfb :=range _bgb {for _ ,_ebg :=range _cfb .OCSPServer {if _ded .CertClient .IsCA (_cfb ){continue ;
};_aeb ,_beb :=_ace [_cfb .Issuer .CommonName ];if !_beb {_aa .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
continue ;};_ ,_ccg ,_ea :=_ded .OCSPClient .MakeRequest (_ebg ,_cfb ,_aeb );if _ea !=nil {_aa .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076",_ea );
continue ;};_ca =append (_ca ,_ccg );};};return _ca ,nil ;};type adobeX509RSASHA1 struct{_efd *_c .PrivateKey ;_cdef *_gb .Certificate ;_cbfd SignFunc ;_bbg bool ;_gbb _ae .Hash ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _ae .Hash ;};

// NewDigest creates a new digest.
func (_ggga *adobePKCS7Detached )NewDigest (sig *_ac .PdfSignature )(_ac .Hasher ,error ){return _dg .NewBuffer (nil ),nil ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_ac .SignatureHandler ,error ){return &adobePKCS7Detached {_gbed :true ,_dbcb :signatureLen },nil ;};func _eefe (_efc _gd .ObjectIdentifier )(_ae .Hash ,error ){switch {case _efc .Equal (_db .OIDDigestAlgorithmSHA1 ),_efc .Equal (_db .OIDDigestAlgorithmECDSASHA1 ),_efc .Equal (_db .OIDDigestAlgorithmDSA ),_efc .Equal (_db .OIDDigestAlgorithmDSASHA1 ),_efc .Equal (_db .OIDEncryptionAlgorithmRSA ):return _ae .SHA1 ,nil ;
case _efc .Equal (_db .OIDDigestAlgorithmSHA256 ),_efc .Equal (_db .OIDDigestAlgorithmECDSASHA256 ):return _ae .SHA256 ,nil ;case _efc .Equal (_db .OIDDigestAlgorithmSHA384 ),_efc .Equal (_db .OIDDigestAlgorithmECDSASHA384 ):return _ae .SHA384 ,nil ;case _efc .Equal (_db .OIDDigestAlgorithmSHA512 ),_efc .Equal (_db .OIDDigestAlgorithmECDSASHA512 ):return _ae .SHA512 ,nil ;
};return _ae .Hash (0),_db .ErrUnsupportedAlgorithm ;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_deg *DocMDPHandler )ValidateWithOpts (sig *_ac .PdfSignature ,digest _ac .Hasher ,params _ac .SignatureHandlerDocMDPParams )(_ac .SignatureValidationResult ,error ){_da ,_df :=_deg ._gbf .Validate (sig ,digest );if _df !=nil {return _da ,_df ;};
_ged :=params .Parser ;if _ged ==nil {return _ac .SignatureValidationResult {},_d .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_da .IsVerified {return _da ,nil ;};_cdd :=params .DiffPolicy ;
if _cdd ==nil {_cdd =_cb .NewDefaultDiffPolicy ();};for _dac :=0;_dac <=_ged .GetRevisionNumber ();_dac ++{_gbe ,_ag :=_ged .GetRevision (_dac );if _ag !=nil {return _ac .SignatureValidationResult {},_ag ;};_bga :=_gbe .GetTrailer ();if _bga ==nil {return _ac .SignatureValidationResult {},_d .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_e ,_eb :=_gc .GetDict (_bga .Get ("\u0052\u006f\u006f\u0074"));if !_eb {return _ac .SignatureValidationResult {},_d .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");};_ee ,_eb :=_gc .GetDict (_e .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));
if !_eb {continue ;};_ebf ,_eb :=_gc .GetArray (_ee .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_eb {continue ;};for _ ,_dfe :=range _ebf .Elements (){_dee ,_ad :=_gc .GetDict (_dfe );if !_ad {continue ;};_bc ,_ad :=_gc .GetDict (_dee .Get ("\u0056"));
if !_ad {continue ;};if _gc .EqualObjects (_bc .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_da .DiffResults ,_ag =_cdd .ReviewFile (_gbe ,_ged ,&_cb .MDPParameters {DocMDPLevel :_deg .Permission });if _ag !=nil {return _ac .SignatureValidationResult {},_ag ;
};_da .IsVerified =_da .DiffResults .IsPermitted ();return _da ,nil ;};};};return _ac .SignatureValidationResult {},_d .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};type docTimeStamp struct{_fca string ;_dfd _ae .Hash ;_gfgc int ;_geg *_ge .TimestampClient ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fde *adobeX509RSASHA1 )IsApplicable (sig *_ac .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};

// Sign adds a new reference to signature's references array.
func (_dgc *DocMDPHandler )Sign (sig *_ac .PdfSignature ,digest _ac .Hasher )error {return _dgc ._gbf .Sign (sig ,digest );};

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB (privateKey *_c .PrivateKey ,certificate *_gb .Certificate ,caCert *_gb .Certificate )(_ac .SignatureHandler ,error ){return &etsiPAdES {_dgca :certificate ,_cf :privateKey ,_gg :caCert },nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_gfgg *_ac .PdfSignature ,_dbee _ac .Hasher )([]byte ,error );