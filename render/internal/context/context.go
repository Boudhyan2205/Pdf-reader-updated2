//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package context ;import (_f "errors";_be "github.com/golang/freetype/truetype";_fg "github.com/unidoc/unipdf/v3/core";_g "github.com/unidoc/unipdf/v3/internal/textencoding";_a "github.com/unidoc/unipdf/v3/internal/transform";_gd "github.com/unidoc/unipdf/v3/model";_d "golang.org/x/image/font";_ee "image";_e "image/color";);type LineJoin int ;type Pattern interface{ColorAt (_bd ,_gg int )_e .Color ;};func (_ega *TextState )ProcTD (tx ,ty float64 ){_ega .Tl =-ty ;_ega .ProcTd (tx ,ty )};type Gradient interface{Pattern ;AddColorStop (_db float64 ,_ge _e .Color );};func (_gbc *TextFont )GetCharMetrics (code _g .CharCode )(float64 ,float64 ,bool ){if _dfcc ,_bde :=_gbc .Font .GetCharMetrics (code );_bde &&_dfcc .Wx !=0{return _dfcc .Wx ,_dfcc .Wy ,_bde ;};if _gbc ._ea ==nil {return 0,0,false ;};_edf ,_fgb :=_gbc ._ea .GetCharMetrics (code );return _edf .Wx ,_edf .Wy ,_fgb &&_edf .Wx !=0;};const (LineCapRound LineCap =iota ;LineCapButt ;LineCapSquare ;);func (_acb *TextState )Reset (){_acb .Tm =_a .IdentityMatrix ();_acb .Tlm =_a .IdentityMatrix ()};func (_fba *TextState )ProcTm (a ,b ,c ,d ,e ,f float64 ){_fba .Tm =_a .NewMatrix (a ,b ,c ,d ,e ,-f );_fba .Tlm =_fba .Tm .Clone ();};func (_fa *TextFont )CharcodesToUnicode (charcodes []_g .CharCode )[]rune {if _fa ._ea !=nil {return _fa ._ea .CharcodesToUnicode (charcodes );};return _fa .Font .CharcodesToUnicode (charcodes );};type TextState struct{Tc float64 ;Tw float64 ;Th float64 ;Tl float64 ;Tf *TextFont ;Ts float64 ;Tm _a .Matrix ;Tlm _a .Matrix ;};func (_agd *TextFont )WithSize (size float64 ,originalFont *_gd .PdfFont )*TextFont {if size <=1{size =10;};return &TextFont {Font :_agd .Font ,Face :_be .NewFace (_agd ._fe ,&_be .Options {Size :size }),Size :size ,_fe :_agd ._fe ,_ea :originalFont };};type FillRule int ;func (_bcf *TextFont )BytesToCharcodes (data []byte )[]_g .CharCode {if _bcf ._ea !=nil {return _bcf ._ea .BytesToCharcodes (data );};return _bcf .Font .BytesToCharcodes (data );};func (_bb *TextFont )GetRuneMetrics (r rune )(float64 ,float64 ,bool ){if _faa ,_ffb :=_bb .Font .GetRuneMetrics (r );_ffb &&_faa .Wx !=0{return _faa .Wx ,_faa .Wy ,_ffb ;};if _bb ._ea ==nil {return 0,0,false ;};_cga ,_bcaa :=_bb ._ea .GetRuneMetrics (r );return _cga .Wx ,_cga .Wy ,_bcaa &&_cga .Wx !=0;};func (_fbf *TextState )ProcTd (tx ,ty float64 ){_fbf .Tlm .Concat (_a .TranslationMatrix (tx ,-ty ));_fbf .Tm =_fbf .Tlm .Clone ();};type Context interface{Push ();Pop ();Matrix ()_a .Matrix ;SetMatrix (_dd _a .Matrix );Translate (_fb ,_ddf float64 );Scale (_fgd ,_ab float64 );Rotate (_ddd float64 );MoveTo (_dc ,_ff float64 );LineTo (_df ,_ba float64 );CubicTo (_dbc ,_gc ,_ac ,_c ,_ef ,_gga float64 );QuadraticTo (_bg ,_bf ,_ae ,_bc float64 );NewSubPath ();ClosePath ();ClearPath ();Clip ();ClipPreserve ();ResetClip ();LineWidth ()float64 ;SetLineWidth (_de float64 );SetLineCap (_ag LineCap );SetLineJoin (_bec LineJoin );SetDash (_fbd ...float64 );SetDashOffset (_bca float64 );Fill ();FillPreserve ();Stroke ();StrokePreserve ();SetRGBA (_dcd ,_gdd ,_dg ,_cb float64 );SetFillRGBA (_ca ,_aca ,_ga ,_eg float64 );SetFillStyle (_bcc Pattern );SetFillRule (_geb FillRule );SetStrokeRGBA (_cg ,_gge ,_fbc ,_agc float64 );SetStrokeStyle (_agcg Pattern );TextState ()*TextState ;DrawString (_dfc string ,_gf ,_ege float64 );MeasureString (_dff string )(_fd ,_gcd float64 );DrawRectangle (_dge ,_gdf ,_dfe ,_gebc float64 );DrawImage (_dga _ee .Image ,_ec ,_ce int );DrawImageAnchored (_ed _ee .Image ,_dba ,_eb int ,_gab ,_eee float64 );Height ()int ;Width ()int ;};func (_eaa *TextState )ProcTj (data []byte ,ctx Context ){_eeb :=_eaa .Tf .Size ;_gbcc :=_eaa .Th /100.0;_cbf :=_a .NewMatrix (_eeb *_gbcc ,0,0,_eeb ,0,_eaa .Ts );_aedg :=_eaa .Tf .CharcodesToUnicode (_eaa .Tf .BytesToCharcodes (data ));for _ ,_ffc :=range _aedg {if _ffc =='\x00'{continue ;};_dcb :=_eaa .Tm .Clone ();_eaa .Tm .Concat (_cbf );_fga ,_fae :=_eaa .Tm .Transform (0,0);ctx .Scale (1,-1);ctx .DrawString (string (_ffc ),_fga ,_fae );ctx .Scale (1,-1);_beb :=0.0;if _ffc ==' '{_beb =_eaa .Tw ;};var _fc float64 ;if _dfb ,_ ,_cc :=_eaa .Tf .GetRuneMetrics (_ffc );_cc {_fc =_dfb *0.001*_eeb ;}else {_fc ,_ =ctx .MeasureString (string (_ffc ));};_gde :=(_fc +_eaa .Tc +_beb )*_gbcc ;_eaa .Tm =_a .TranslationMatrix (_gde ,0).Mult (_dcb );};};const (LineJoinRound LineJoin =iota ;LineJoinBevel ;);func (_cca *TextState )ProcQ (data []byte ,ctx Context ){_cca .ProcTStar ();_cca .ProcTj (data ,ctx )};func (_bga *TextState )ProcTf (font *TextFont ){_bga .Tf =font };func (_dde *TextState )ProcDQ (data []byte ,aw ,ac float64 ,ctx Context ){_dde .Tw =aw ;_dde .Tc =ac ;_dde .ProcQ (data ,ctx );};func (_ecd *TextState )ProcTStar (){_ecd .ProcTd (0,-_ecd .Tl )};type LineCap int ;func NewTextFont (font *_gd .PdfFont ,size float64 )(*TextFont ,error ){_cad :=font .FontDescriptor ();if _cad ==nil {return nil ,_f .New ("\u0063\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069pt\u006f\u0072");};_gb ,_cef :=_fg .GetStream (_cad .FontFile2 );if !_cef {return nil ,_f .New ("\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020f\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_bab ,_aed :=_fg .DecodeStream (_gb );if _aed !=nil {return nil ,_aed ;};_fgg ,_aed :=_be .Parse (_bab );if _aed !=nil {return nil ,_aed ;};if size <=1{size =10;};return &TextFont {Font :font ,Face :_be .NewFace (_fgg ,&_be .Options {Size :size }),Size :size ,_fe :_fgg },nil ;};const (FillRuleWinding FillRule =iota ;FillRuleEvenOdd ;);func NewTextState ()*TextState {return &TextState {Th :100,Tm :_a .IdentityMatrix (),Tlm :_a .IdentityMatrix ()};};type TextFont struct{Font *_gd .PdfFont ;Face _d .Face ;Size float64 ;_fe *_be .Font ;_ea *_gd .PdfFont ;};func (_cbd *TextState )Translate (tx ,ty float64 ){_cbd .Tm =_a .TranslationMatrix (tx ,ty ).Mult (_cbd .Tm );};func NewTextFontFromPath (filePath string ,size float64 )(*TextFont ,error ){_bcb ,_bfc :=_gd .NewPdfFontFromTTFFile (filePath );if _bfc !=nil {return nil ,_bfc ;};return NewTextFont (_bcb ,size );};