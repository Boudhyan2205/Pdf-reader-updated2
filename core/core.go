//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_ga "bufio";_bf "bytes";_gf "compress/lzw";_eb "compress/zlib";_ef "crypto/md5";_gd "crypto/rand";_c "encoding/hex";_fd "errors";_cb "fmt";_eg "github.com/unidoc/unipdf/v3/common";_dc "github.com/unidoc/unipdf/v3/core/security";_ad "github.com/unidoc/unipdf/v3/core/security/crypt";_af "github.com/unidoc/unipdf/v3/internal/ccittfax";_efb "github.com/unidoc/unipdf/v3/internal/imageutil";_ab "github.com/unidoc/unipdf/v3/internal/jbig2";_eab "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_bbe "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_db "github.com/unidoc/unipdf/v3/internal/jbig2/document";_ebc "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_bb "github.com/unidoc/unipdf/v3/internal/strutils";_aa "golang.org/x/image/tiff/lzw";_fa "image";_gb "image/color";_a "image/jpeg";_b "io";_fb "os";_d "reflect";_dd "regexp";_g "sort";_e "strconv";_bd "strings";_ea "time";);

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_cebd :=&PdfObjectArray {};_cebd ._gbbe =[]PdfObject {};for _ ,_dffca :=range objects {_cebd ._gbbe =append (_cebd ._gbbe ,_dffca );};return _cebd ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_aeeb *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fcba :=encoded ;var _ddae error ;for _ ,_cdef :=range _aeeb ._cgae {_eg .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_cdef ,_cdef );_fcba ,_ddae =_cdef .DecodeBytes (_fcba );if _ddae !=nil {return nil ,_ddae ;};};return _fcba ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_cagag *PdfObjectString )WriteString ()string {var _fadf _bf .Buffer ;if _cagag ._fccb {_baeb :=_c .EncodeToString (_cagag .Bytes ());_fadf .WriteString ("\u003c");_fadf .WriteString (_baeb );_fadf .WriteString ("\u003e");return _fadf .String ();};_cfea :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_fadf .WriteString ("\u0028");for _acfge :=0;_acfge < len (_cagag ._fgce );_acfge ++{_aaaa :=_cagag ._fgce [_acfge ];if _aeac ,_ffab :=_cfea [_aaaa ];_ffab {_fadf .WriteString (_aeac );}else {_fadf .WriteByte (_aaaa );};};_fadf .WriteString ("\u0029");return _fadf .String ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bba *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_efed :=MakeDict ();_efed .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bba .GetFilterName ()));_gffd :=_bba .MakeDecodeParams ();if _gffd !=nil {_efed .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gffd );};return _efed ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_fegb :=TraceToDirectObject (obj ).(*PdfObjectNull );return _fegb ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_bccg *PdfParser )GetFileOffset ()int64 {_gad ,_ :=_bccg ._bgfc .Seek (0,_b .SeekCurrent );_gad -=int64 (_bccg ._aae .Buffered ());return _gad ;};type xrefType int ;

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_fgcf *PdfParser )GetObjectNums ()[]int {var _edabe []int ;for _ ,_ggbb :=range _fgcf ._dceb .ObjectMap {_edabe =append (_edabe ,_ggbb .ObjectNumber );};_g .Ints (_edabe );return _edabe ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfaf *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_dabf int ,_ecgbd bool ){_bgef ,_ecgbd :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _ecgbd &&_bgef !=nil {return int (*_bgef ),true ;};return 0,false ;};

// Clear resets the dictionary to an empty state.
func (_fccc *PdfObjectDictionary )Clear (){_fccc ._effgc =[]PdfObjectName {};_fccc ._adfbf =map[PdfObjectName ]PdfObject {};};func _gee (_ddb *_dc .StdEncryptDict ,_cba *PdfObjectDictionary )error {R ,_geg :=_cba .Get ("\u0052").(*PdfObjectInteger );if !_geg {return _fd .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_ddb .R =int (*R );O ,_geg :=_cba .GetString ("\u004f");if !_geg {return _fd .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _ddb .R ==5||_ddb .R ==6{if len (O )< 48{return _cb .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _cb .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_ddb .O =[]byte (O );U ,_geg :=_cba .GetString ("\u0055");if !_geg {return _fd .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _ddb .R ==5||_ddb .R ==6{if len (U )< 48{return _cb .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_eg .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_ddb .U =[]byte (U );if _ddb .R >=5{OE ,_fff :=_cba .GetString ("\u004f\u0045");if !_fff {return _fd .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _cb .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_ddb .OE =[]byte (OE );UE ,_fff :=_cba .GetString ("\u0055\u0045");if !_fff {return _fd .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _cb .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_ddb .UE =[]byte (UE );};P ,_geg :=_cba .Get ("\u0050").(*PdfObjectInteger );if !_geg {return _fd .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_ddb .P =_dc .Permissions (*P );if _ddb .R ==6{Perms ,_fbad :=_cba .GetString ("\u0050\u0065\u0072m\u0073");if !_fbad {return _fd .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _cb .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_ddb .Perms =[]byte (Perms );};if _dee ,_baf :=_cba .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_baf {_ddb .EncryptMetadata =bool (*_dee );}else {_ddb .EncryptMetadata =true ;};return nil ;};const (_cagf =0;_fag =1;_eadb =2;_fbef =3;_aec =4;);func _egdb (_acbf *PdfObjectDictionary )(_fbdda *_efb .ImageBase ){var (_eeaec *PdfObjectInteger ;_efbg bool ;);if _eeaec ,_efbg =_acbf .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_efbg {_fbdda =&_efb .ImageBase {Width :int (*_eeaec )};}else {return nil ;};if _eeaec ,_efbg =_acbf .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_efbg {_fbdda .Height =int (*_eeaec );};if _eeaec ,_efbg =_acbf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_efbg {_fbdda .BitsPerComponent =int (*_eeaec );};if _eeaec ,_efbg =_acbf .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_efbg {_fbdda .ColorComponents =int (*_eeaec );};return _fbdda ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_adfbf map[PdfObjectName ]PdfObject ;_effgc []PdfObjectName ;_ceece *PdfParser ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_fedf *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_baeg :=_bf .NewReader (data );var _abefe []byte ;var _geea []byte ;_deeb ,_dadfe :=_baeg .ReadByte ();if _dadfe ==_b .EOF {return []byte {},nil ;}else if _dadfe !=nil {return nil ,_dadfe ;};_bagg :=1;for {_fde ,_eaaf :=_baeg .ReadByte ();if _eaaf ==_b .EOF {break ;}else if _eaaf !=nil {return nil ,_eaaf ;};if _fde ==_deeb {if len (_geea )> 0{_geea =_geea [:len (_geea )-1];if len (_geea )> 0{_abefe =append (_abefe ,byte (len (_geea )-1));_abefe =append (_abefe ,_geea ...);};_bagg =1;_geea =[]byte {};};_bagg ++;if _bagg >=127{_abefe =append (_abefe ,byte (257-_bagg ),_deeb );_bagg =0;};}else {if _bagg > 0{if _bagg ==1{_geea =[]byte {_deeb };}else {_abefe =append (_abefe ,byte (257-_bagg ),_deeb );};_bagg =0;};_geea =append (_geea ,_fde );if len (_geea )>=127{_abefe =append (_abefe ,byte (len (_geea )-1));_abefe =append (_abefe ,_geea ...);_geea =[]byte {};};};_deeb =_fde ;};if len (_geea )> 0{_abefe =append (_abefe ,byte (len (_geea )-1));_abefe =append (_abefe ,_geea ...);}else if _bagg > 0{_abefe =append (_abefe ,byte (257-_bagg ),_deeb );};_abefe =append (_abefe ,128);return _abefe ,nil ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_efda *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_dbfd :=data ;var _cfge error ;for _fceb :=len (_efda ._cgae )-1;_fceb >=0;_fceb --{_afcg :=_efda ._cgae [_fceb ];_dbfd ,_cfge =_afcg .EncodeBytes (_dbfd );if _cfge !=nil {return nil ,_cfge ;};};return _dbfd ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fgeff *PdfObjectArray )WriteString ()string {var _gggab _bd .Builder ;_gggab .WriteString ("\u005b");for _ccca ,_fgdbd :=range _fgeff .Elements (){_gggab .WriteString (_fgdbd .WriteString ());if _ccca < (_fgeff .Len ()-1){_gggab .WriteString ("\u0020");};};_gggab .WriteString ("\u005d");return _gggab .String ();};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_accfb *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _accfb .DecodeBytes (streamObj .Stream );};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_fgggc *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_gdfd :=range another .Keys (){_bdead :=another .Get (_gdfd );_fgggc .Set (_gdfd ,_bdead );};};return _fgggc ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cbgd *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_beec :=MakeDict ();_beec .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cbgd .GetFilterName ()));_gfcdc :=_cbgd .MakeDecodeParams ();if _gfcdc !=nil {_beec .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gfcdc );};return _beec ;};

// UpdateParams updates the parameter values of the encoder.
func (_cdag *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_acd *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };var _gcec =_dd .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_efge *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_bedc ,_fcec :=_efb .NewImage (_efge .Width ,_efge .Height ,_efge .BitsPerComponent ,_efge .ColorComponents ,data ,nil ,nil );if _fcec !=nil {return nil ,_fcec ;};_cefe :=_a .Options {};_cefe .Quality =_efge .Quality ;var _ecb _bf .Buffer ;if _fcec =_a .Encode (&_ecb ,_bedc ,&_cefe );_fcec !=nil {return nil ,_fcec ;};return _ecb .Bytes (),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dfgf *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetXrefType returns the type of the first xref object (table or stream).
func (_ggef *PdfParser )GetXrefType ()*xrefType {return _ggef ._febf };

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_agdg *PdfParser )Decrypt (password []byte )(bool ,error ){if _agdg ._ggec ==nil {return false ,_fd .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_gbfg ,_efefg :=_agdg ._ggec .authenticate (password );if _efefg !=nil {return false ,_efefg ;};if !_gbfg {_gbfg ,_efefg =_agdg ._ggec .authenticate ([]byte (""));};return _gbfg ,_efefg ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _dedc ,_ceag :=obj .(*PdfObjectReference );_ceag {obj =_dedc .Resolve ();};_dfcef ,_ddagc :=obj .(*PdfIndirectObject );_bggg :=0;for _ddagc {obj =_dfcef .PdfObject ;_dfcef ,_ddagc =GetIndirect (obj );_bggg ++;if _bggg > _faegd {_eg .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_faegd );return nil ;};};return obj ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _b .ReadSeeker )(*PdfParser ,error ){_ceae :=&PdfParser {_bgfc :rs ,ObjCache :make (objectCache ),_ebac :map[int64 ]bool {}};_cbaac ,_gcga ,_cgcf :=_ceae .parsePdfVersion ();if _cgcf !=nil {_eg .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_cgcf );return nil ,_cgcf ;};_ceae ._bbdb .Major =_cbaac ;_ceae ._bbdb .Minor =_gcga ;if _ceae ._eeff ,_cgcf =_ceae .loadXrefs ();_cgcf !=nil {_eg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_cgcf );return nil ,_cgcf ;};_eg .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_ceae ._eeff );if len (_ceae ._dceb .ObjectMap )==0{return nil ,_cb .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _ceae ,nil ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_aeca *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_ecge ,_ccfge :=_aeca ._adfbf [key ].(*PdfObjectString );if !_ccfge {return "",false ;};return _ecge .Str (),true ;};

// WriteString outputs the object as it is to be written to file.
func (_fcaa *PdfObjectInteger )WriteString ()string {return _e .FormatInt (int64 (*_fcaa ),10)};var _cdfb =_dd .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};func _ccc (_dfc XrefTable ){_eg .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_eg .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_fcb :=0;for _ ,_ege :=range _dfc .ObjectMap {_eg .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_fcb +1,_ege .ObjectNumber ,_ege .Generation ,_ege .Offset );_fcb ++;};};func (_ggece *PdfParser )parsePdfVersion ()(int ,int ,error ){var _ceffc int64 =20;_aed :=make ([]byte ,_ceffc );_ggece ._bgfc .Seek (0,_fb .SEEK_SET );_ggece ._bgfc .Read (_aed );var _aeda error ;var _egfd ,_adgd int ;if _feee :=_bbdd .FindStringSubmatch (string (_aed ));len (_feee )< 3{if _egfd ,_adgd ,_aeda =_ggece .seekPdfVersionTopDown ();_aeda !=nil {_eg .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_aeda ;};_ggece ._bgfc ,_aeda =_cded (_ggece ._bgfc ,_ggece .GetFileOffset ()-8);if _aeda !=nil {return 0,0,_aeda ;};}else {if _egfd ,_aeda =_e .Atoi (_feee [1]);_aeda !=nil {return 0,0,_aeda ;};if _adgd ,_aeda =_e .Atoi (_feee [2]);_aeda !=nil {return 0,0,_aeda ;};_ggece .SetFileOffset (0);};_ggece ._aae =_ga .NewReader (_ggece ._bgfc );_eg .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_egfd ,_adgd );return _egfd ,_adgd ,nil ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_fcfbg *MultiEncoder )GetFilterArray ()*PdfObjectArray {_fdfa :=make ([]PdfObject ,len (_fcfbg ._cgae ));for _ebbg ,_bcee :=range _fcfbg ._cgae {_fdfa [_ebbg ]=MakeName (_bcee .GetFilterName ());};return MakeArray (_fdfa ...);};

// String returns a string representation of the *PdfObjectString.
func (_adbe *PdfObjectString )String ()string {return _adbe ._fgce };

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_acgd *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _acgd .isDecrypted (obj ){return nil ;};switch _eec :=obj .(type ){case *PdfIndirectObject :_acgd ._daa [_eec ]=true ;_eg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_eec .ObjectNumber ,_eec .GenerationNumber );_cfgc :=_eec .ObjectNumber ;_ffb :=_eec .GenerationNumber ;_abeb :=_acgd .Decrypt (_eec .PdfObject ,_cfgc ,_ffb );if _abeb !=nil {return _abeb ;};return nil ;case *PdfObjectStream :_acgd ._daa [_eec ]=true ;_cccg :=_eec .PdfObjectDictionary ;if _acgd ._dga .R !=5{if _ccea ,_gcdfc :=_cccg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gcdfc &&*_ccea =="\u0058\u0052\u0065\u0066"{return nil ;};};_fabc :=_eec .ObjectNumber ;_efg :=_eec .GenerationNumber ;_eg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_fabc ,_efg );_gbe :=_beg ;if _acgd ._bdc .V >=4{_gbe =_acgd ._bed ;_eg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_acgd ._bed );if _aead ,_ead :=_cccg .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_ead {if _gge ,_eda :=GetName (_aead .Get (0));_eda {if *_gge =="\u0043\u0072\u0079p\u0074"{_gbe ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _feg ,_gcb :=_cccg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_gcb {if _acfbd ,_bee :=_feg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bee {if _ ,_ccf :=_acgd ._eabb [string (*_acfbd )];_ccf {_eg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_acfbd );_gbe =string (*_acfbd );};};};};};};_eg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gbe );if _gbe =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_edf :=_acgd .Decrypt (_cccg ,_fabc ,_efg );if _edf !=nil {return _edf ;};_cbgf ,_edf :=_acgd .makeKey (_gbe ,uint32 (_fabc ),uint32 (_efg ),_acgd ._dbb );if _edf !=nil {return _edf ;};_eec .Stream ,_edf =_acgd .decryptBytes (_eec .Stream ,_gbe ,_cbgf );if _edf !=nil {return _edf ;};_cccg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_eec .Stream ))));return nil ;case *PdfObjectString :_eg .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_fbg :=_beg ;if _acgd ._bdc .V >=4{_eg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_acgd ._cdf );if _acgd ._cdf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_fbg =_acgd ._cdf ;};_bag ,_dfeaf :=_acgd .makeKey (_fbg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_acgd ._dbb );if _dfeaf !=nil {return _dfeaf ;};_efcb :=_eec .Str ();_bbg :=make ([]byte ,len (_efcb ));for _fgbb :=0;_fgbb < len (_efcb );_fgbb ++{_bbg [_fgbb ]=_efcb [_fgbb ];};_eg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bbg ,_bbg );_bbg ,_dfeaf =_acgd .decryptBytes (_bbg ,_fbg ,_bag );if _dfeaf !=nil {return _dfeaf ;};_eec ._fgce =string (_bbg );return nil ;case *PdfObjectArray :for _ ,_egea :=range _eec .Elements (){_dae :=_acgd .Decrypt (_egea ,parentObjNum ,parentGenNum );if _dae !=nil {return _dae ;};};return nil ;case *PdfObjectDictionary :_fdcc :=false ;if _gfg :=_eec .Get ("\u0054\u0079\u0070\u0065");_gfg !=nil {_acgc ,_eabd :=_gfg .(*PdfObjectName );if _eabd &&*_acgc =="\u0053\u0069\u0067"{_fdcc =true ;};};for _ ,_efea :=range _eec .Keys (){_bcdc :=_eec .Get (_efea );if _fdcc &&string (_efea )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_efea )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_efea )!="\u0050\u0072\u0065\u0076"&&string (_efea )!="\u004c\u0061\u0073\u0074"{_ggff :=_acgd .Decrypt (_bcdc ,parentObjNum ,parentGenNum );if _ggff !=nil {return _ggff ;};};};return nil ;};return nil ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_cefc *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _eff []byte ;_eg .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_edcf :=0;_fcfe :=false ;for _edcf < len (encoded )&&!_fcfe {_gbg :=[5]byte {0,0,0,0,0};_gef :=0;_dcbgd :=0;_cgb :=4;for _dcbgd < 5+_gef {if _edcf +_dcbgd ==len (encoded ){break ;};_fdba :=encoded [_edcf +_dcbgd ];if IsWhiteSpace (_fdba ){_gef ++;_dcbgd ++;continue ;}else if _fdba =='~'&&_edcf +_dcbgd +1< len (encoded )&&encoded [_edcf +_dcbgd +1]=='>'{_cgb =(_dcbgd -_gef )-1;if _cgb < 0{_cgb =0;};_fcfe =true ;break ;}else if _fdba >='!'&&_fdba <='u'{_fdba -='!';}else if _fdba =='z'&&_dcbgd -_gef ==0{_cgb =4;_dcbgd ++;break ;}else {_eg .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_fd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_gbg [_dcbgd -_gef ]=_fdba ;_dcbgd ++;};_edcf +=_dcbgd ;for _cbce :=_cgb +1;_cbce < 5;_cbce ++{_gbg [_cbce ]=84;};_fcfb :=uint32 (_gbg [0])*85*85*85*85+uint32 (_gbg [1])*85*85*85+uint32 (_gbg [2])*85*85+uint32 (_gbg [3])*85+uint32 (_gbg [4]);_edg :=[]byte {byte ((_fcfb >>24)&0xff),byte ((_fcfb >>16)&0xff),byte ((_fcfb >>8)&0xff),byte (_fcfb &0xff)};_eff =append (_eff ,_edg [:_cgb ]...);};_eg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_eg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_eff );return _eff ,nil ;};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_agbf *PdfObjectString ,_gcab bool ){_agbf ,_gcab =TraceToDirectObject (obj ).(*PdfObjectString );return _agbf ,_gcab ;};const (DefaultJPEGQuality =75;);func _aaba (_edgb _efb .Image )*JBIG2Image {_cfdd :=_edgb .Base ();return &JBIG2Image {Data :_cfdd .Data ,Width :_cfdd .Width ,Height :_cfdd .Height ,HasPadding :true };};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_gcff *PdfObjectString )Str ()string {return _gcff ._fgce };

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_dffd :=&LZWEncoder {};_dffd .Predictor =1;_dffd .BitsPerComponent =8;_dffd .Colors =1;_dffd .Columns =1;_dffd .EarlyChange =1;return _dffd ;};

// DecodeStream implements ASCII85 stream decoding.
func (_dfa *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dfa .DecodeBytes (streamObj .Stream );};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_ffdec *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _eadd :=val .(type ){case *PdfObjectName :if _eadd !=nil {_ffdec .Set (key ,val );};case *PdfObjectDictionary :if _eadd !=nil {_ffdec .Set (key ,val );};case *PdfObjectStream :if _eadd !=nil {_ffdec .Set (key ,val );};case *PdfObjectString :if _eadd !=nil {_ffdec .Set (key ,val );};case *PdfObjectNull :if _eadd !=nil {_ffdec .Set (key ,val );};case *PdfObjectInteger :if _eadd !=nil {_ffdec .Set (key ,val );};case *PdfObjectArray :if _eadd !=nil {_ffdec .Set (key ,val );};case *PdfObjectBool :if _eadd !=nil {_ffdec .Set (key ,val );};case *PdfObjectFloat :if _eadd !=nil {_ffdec .Set (key ,val );};case *PdfObjectReference :if _eadd !=nil {_ffdec .Set (key ,val );};case *PdfIndirectObject :if _eadd !=nil {_ffdec .Set (key ,val );};default:_eg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// GetFilterName returns the name of the encoding filter.
func (_bgfe *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_agde *PdfParser )IsEncrypted ()(bool ,error ){if _agde ._ggec !=nil {return true ,nil ;}else if _agde ._eeff ==nil {return false ,nil ;};_eg .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_ebcfe :=_agde ._eeff .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _ebcfe ==nil {return false ,nil ;};_eg .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_cgdf *PdfObjectDictionary ;);switch _adaba :=_ebcfe .(type ){case *PdfObjectDictionary :_cgdf =_adaba ;case *PdfObjectReference :_eg .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_adaba );_bbec ,_fgbg :=_agde .LookupByReference (*_adaba );_eg .Log .Trace ("\u0031\u003a\u0020%\u0071",_bbec );if _fgbg !=nil {return false ,_fgbg ;};_daaf ,_dgea :=_bbec .(*PdfIndirectObject );if !_dgea {_eg .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_fd .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_adcg ,_dgea :=_daaf .PdfObject .(*PdfObjectDictionary );_eg .Log .Trace ("\u0032\u003a\u0020%\u0071",_adcg );if !_dgea {return false ,_fd .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_cgdf =_adcg ;case *PdfObjectNull :_eg .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_cb .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_adaba );};_beddf ,_abda :=PdfCryptNewDecrypt (_agde ,_cgdf ,_agde ._eeff );if _abda !=nil {return false ,_abda ;};for _ ,_fade :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_cefaee :=_agde ._eeff .Get (PdfObjectName (_fade ));if _cefaee ==nil {continue ;};switch _geda :=_cefaee .(type ){case *PdfObjectReference :_beddf ._ded [int (_geda .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_beddf ._daa [_geda ]=true ;_beddf ._ded [int (_geda .ObjectNumber )]=struct{}{};};};_agde ._ggec =_beddf ;_eg .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_beddf );return true ,nil ;};func _bab (_cce int )cryptFilters {return cryptFilters {_beg :_ad .NewFilterV2 (_cce )}};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};func _adbd (_agcb *PdfObjectStream ,_faceb *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_cbaf :=NewCCITTFaxEncoder ();_fgcg :=_agcb .PdfObjectDictionary ;if _fgcg ==nil {return _cbaf ,nil ;};if _faceb ==nil {_cefa :=TraceToDirectObject (_fgcg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _cefa !=nil {switch _ccbg :=_cefa .(type ){case *PdfObjectDictionary :_faceb =_ccbg ;break ;case *PdfObjectArray :if _ccbg .Len ()==1{if _cfdc ,_gaae :=GetDict (_ccbg .Get (0));_gaae {_faceb =_cfdc ;};};default:_eg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_cefa );return nil ,_fd .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _faceb ==nil {_eg .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_cefa );return nil ,_fd .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _ggffa ,_daef :=GetNumberAsInt64 (_faceb .Get ("\u004b"));_daef ==nil {_cbaf .K =int (_ggffa );};if _efedc ,_beac :=GetNumberAsInt64 (_faceb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_beac ==nil {_cbaf .Columns =int (_efedc );}else {_cbaf .Columns =1728;};if _eed ,_gged :=GetNumberAsInt64 (_faceb .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gged ==nil {_cbaf .BlackIs1 =_eed > 0;}else {if _cgbe ,_geaa :=GetBoolVal (_faceb .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_geaa {_cbaf .BlackIs1 =_cgbe ;}else {if _cegc ,_aeeg :=GetArray (_faceb .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_aeeg {_edeag ,_dfbg :=_cegc .ToIntegerArray ();if _dfbg ==nil {_cbaf .BlackIs1 =_edeag [0]==1&&_edeag [1]==0;};};};};if _faag ,_cde :=GetNumberAsInt64 (_faceb .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cde ==nil {_cbaf .EncodedByteAlign =_faag > 0;}else {if _aebc ,_cbcc :=GetBoolVal (_faceb .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cbcc {_cbaf .EncodedByteAlign =_aebc ;};};if _eee ,_gcfb :=GetNumberAsInt64 (_faceb .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gcfb ==nil {_cbaf .EndOfLine =_eee > 0;}else {if _fbbe ,_bbd :=GetBoolVal (_faceb .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bbd {_cbaf .EndOfLine =_fbbe ;};};if _adbf ,_cgbc :=GetNumberAsInt64 (_faceb .Get ("\u0052\u006f\u0077\u0073"));_cgbc ==nil {_cbaf .Rows =int (_adbf );};_cbaf .EndOfBlock =true ;if _dbgg ,_gbea :=GetNumberAsInt64 (_faceb .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gbea ==nil {_cbaf .EndOfBlock =_dbgg > 0;}else {if _ebgc ,_fcfed :=GetBoolVal (_faceb .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fcfed {_cbaf .EndOfBlock =_ebgc ;};};if _bcag ,_gacb :=GetNumberAsInt64 (_faceb .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_gacb !=nil {_cbaf .DamagedRowsBeforeError =int (_bcag );};_eg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_faceb .String ());return _cbaf ,nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_eaff *PdfObjectBool ,_agacba bool ){_eaff ,_agacba =TraceToDirectObject (obj ).(*PdfObjectBool );return _eaff ,_agacba ;};func (_gaead *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_b .SeekStart {offset +=_gaead ._gcdg ;};_edfba ,_cgbce :=_gaead ._dcea .Seek (offset ,whence );if _cgbce !=nil {return _edfba ,_cgbce ;};if whence ==_b .SeekCurrent {_edfba -=_gaead ._gcdg ;};if _edfba < 0{return 0,_fd .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _edfba ,nil ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_ggce :=MakeArray ();for _ ,_cggef :=range vals {_ggce .Append (MakeFloat (_cggef ));};return _ggce ;};func (_cga *PdfParser )lookupByNumberWrapper (_ge int ,_dad bool )(PdfObject ,bool ,error ){_gc ,_ega ,_fgb :=_cga .lookupByNumber (_ge ,_dad );if _fgb !=nil {return nil ,_ega ,_fgb ;};if !_ega &&_cga ._ggec !=nil &&!_cga ._ggec .isDecrypted (_gc ){_gg :=_cga ._ggec .Decrypt (_gc ,0,0);if _gg !=nil {return nil ,_ega ,_gg ;};};return _gc ,_ega ,nil ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_egeba :=&DCTEncoder {};_egeba .ColorComponents =3;_egeba .BitsPerComponent =8;_egeba .Quality =DefaultJPEGQuality ;return _egeba ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _dfca (obj1 ,obj2 ,0)};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_gebab *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_gebab ._gbbe ){return _fd .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_gebab ._gbbe [i ]=obj ;return nil ;};type offsetReader struct{_dcea _b .ReadSeeker ;_gcdg int64 ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_edda *PdfParser )IsAuthenticated ()bool {return _edda ._ggec ._dag };

// GetFilterName returns the name of the encoding filter.
func (_abae *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_edbd *PdfObjectDictionary );EncodeBytes (_dbf []byte )([]byte ,error );DecodeBytes (_bfd []byte )([]byte ,error );DecodeStream (_bge *PdfObjectStream )([]byte ,error );};

// SetImage sets the image base for given flate encoder.
func (_daga *FlateEncoder )SetImage (img *_efb .ImageBase ){_daga ._face =img };

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_fdbbd *JBIG2Encoder )EncodeImage (img _fa .Image )([]byte ,error ){return _fdbbd .encodeImage (img );};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_dcg *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dcg .DecodeBytes (streamObj .Stream );};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_gbbcf *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gbbcf .DecodeBytes (streamObj .Stream );};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fceg *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _fceg .isEncrypted (obj ){return nil ;};switch _fgge :=obj .(type ){case *PdfIndirectObject :_fceg ._abc [_fgge ]=true ;_eg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fgge .ObjectNumber ,_fgge .GenerationNumber );_abcf :=_fgge .ObjectNumber ;_dfd :=_fgge .GenerationNumber ;_ebd :=_fceg .Encrypt (_fgge .PdfObject ,_abcf ,_dfd );if _ebd !=nil {return _ebd ;};return nil ;case *PdfObjectStream :_fceg ._abc [_fgge ]=true ;_cbcf :=_fgge .PdfObjectDictionary ;if _gaf ,_fbb :=_cbcf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fbb &&*_gaf =="\u0058\u0052\u0065\u0066"{return nil ;};_gac :=_fgge .ObjectNumber ;_aab :=_fgge .GenerationNumber ;_eg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gac ,_aab );_geba :=_beg ;if _fceg ._bdc .V >=4{_geba =_fceg ._bed ;_eg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_fceg ._bed );if _cge ,_egeb :=_cbcf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_egeb {if _agfa ,_caa :=GetName (_cge .Get (0));_caa {if *_agfa =="\u0043\u0072\u0079p\u0074"{_geba ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dfce ,_afffe :=_cbcf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_afffe {if _efba ,_afag :=_dfce .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_afag {if _ ,_bdde :=_fceg ._eabb [string (*_efba )];_bdde {_eg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_efba );_geba =string (*_efba );};};};};};};_eg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_geba );if _geba =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ggcd :=_fceg .Encrypt (_fgge .PdfObjectDictionary ,_gac ,_aab );if _ggcd !=nil {return _ggcd ;};_dfb ,_ggcd :=_fceg .makeKey (_geba ,uint32 (_gac ),uint32 (_aab ),_fceg ._dbb );if _ggcd !=nil {return _ggcd ;};_fgge .Stream ,_ggcd =_fceg .encryptBytes (_fgge .Stream ,_geba ,_dfb );if _ggcd !=nil {return _ggcd ;};_cbcf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fgge .Stream ))));return nil ;case *PdfObjectString :_eg .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_ddage :=_beg ;if _fceg ._bdc .V >=4{_eg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fceg ._cdf );if _fceg ._cdf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_ddage =_fceg ._cdf ;};_fgf ,_ccb :=_fceg .makeKey (_ddage ,uint32 (parentObjNum ),uint32 (parentGenNum ),_fceg ._dbb );if _ccb !=nil {return _ccb ;};_edaa :=_fgge .Str ();_aeae :=make ([]byte ,len (_edaa ));for _efbb :=0;_efbb < len (_edaa );_efbb ++{_aeae [_efbb ]=_edaa [_efbb ];};_eg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_aeae ,_aeae );_aeae ,_ccb =_fceg .encryptBytes (_aeae ,_ddage ,_fgf );if _ccb !=nil {return _ccb ;};_fgge ._fgce =string (_aeae );return nil ;case *PdfObjectArray :for _ ,_bda :=range _fgge .Elements (){_ebde :=_fceg .Encrypt (_bda ,parentObjNum ,parentGenNum );if _ebde !=nil {return _ebde ;};};return nil ;case *PdfObjectDictionary :_adb :=false ;if _fgc :=_fgge .Get ("\u0054\u0079\u0070\u0065");_fgc !=nil {_gff ,_fdbg :=_fgc .(*PdfObjectName );if _fdbg &&*_gff =="\u0053\u0069\u0067"{_adb =true ;};};for _ ,_fgeea :=range _fgge .Keys (){_gfb :=_fgge .Get (_fgeea );if _adb &&string (_fgeea )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_fgeea )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_fgeea )!="\u0050\u0072\u0065\u0076"&&string (_fgeea )!="\u004c\u0061\u0073\u0074"{_ddaf :=_fceg .Encrypt (_gfb ,parentObjNum ,parentGenNum );if _ddaf !=nil {return _ddaf ;};};};return nil ;};return nil ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_fdfdd *PdfObjectStreams ,_cdfc bool ){_fdfdd ,_cdfc =obj .(*PdfObjectStreams );return _fdfdd ,_cdfc ;};func (_gbaff *PdfParser )rebuildXrefTable ()error {_cdfea :=XrefTable {};_cdfea .ObjectMap =map[int ]XrefObject {};for _bfee ,_afebe :=range _gbaff ._dceb .ObjectMap {_addd ,_ ,_babe :=_gbaff .lookupByNumberWrapper (_bfee ,false );if _babe !=nil {_eg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_babe );_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_aggg ,_ffcb :=_gbaff .repairRebuildXrefsTopDown ();if _ffcb !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_ffcb );return _ffcb ;};_gbaff ._dceb =*_aggg ;_eg .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_cagd ,_fcfef ,_babe :=_gfa (_addd );if _babe !=nil {return _babe ;};_afebe .ObjectNumber =int (_cagd );_afebe .Generation =int (_fcfef );_cdfea .ObjectMap [int (_cagd )]=_afebe ;};_gbaff ._dceb =_cdfea ;_eg .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_ccc (_gbaff ._dceb );return nil ;};

// DecodeStream implements ASCII hex decoding.
func (_eccb *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eccb .DecodeBytes (streamObj .Stream );};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_edfc *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _edfc .Predictor !=1&&_edfc .Predictor !=11{_eg .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _edfc .Predictor ==11{_efeg :=int (_edfc .Columns );_bea :=len (data )/_efeg ;if len (data )%_efeg !=0{_eg .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_fd .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_fffb :=_bf .NewBuffer (nil );_bcab :=make ([]byte ,_efeg );for _dbeb :=0;_dbeb < _bea ;_dbeb ++{_aaaf :=data [_efeg *_dbeb :_efeg *(_dbeb +1)];_bcab [0]=_aaaf [0];for _ceg :=1;_ceg < _efeg ;_ceg ++{_bcab [_ceg ]=byte (int (_aaaf [_ceg ]-_aaaf [_ceg -1])%256);};_fffb .WriteByte (1);_fffb .Write (_bcab );};data =_fffb .Bytes ();};var _cec _bf .Buffer ;_dcee :=_eb .NewWriter (&_cec );_dcee .Write (data );_dcee .Close ();return _cec .Bytes (),nil ;};func _cedg (_dafe string )(int ,int ,error ){_befg :=_baca .FindStringSubmatch (_dafe );if len (_befg )< 3{return 0,0,_fd .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_abge ,_ :=_e .Atoi (_befg [1]);_caba ,_ :=_e .Atoi (_befg [2]);return _abge ,_caba ,nil ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _fa .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _cdbc ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_ebc .Error (_cdbc ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_cfbcb uint8 ;_gecf _efb .Image ;_aebb error ;);if bwThreshold ==JB2ImageAutoThreshold {_gecf ,_aebb =_efb .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_ebc .Error (_cdbc ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_cfbcb =uint8 (255*bwThreshold );_gecf ,_aebb =_efb .MonochromeThresholdConverter (_cfbcb ).Convert (i );};if _aebb !=nil {return nil ,_aebb ;};return _aaba (_gecf ),nil ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_afbc *PdfParser )GetCrypter ()*PdfCrypt {return _afbc ._ggec };

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_ecag :=&ASCIIHexEncoder {};return _ecag };

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_fded *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gecg :=&_af .Encoder {K :_fded .K ,Columns :_fded .Columns ,EndOfLine :_fded .EndOfLine ,EndOfBlock :_fded .EndOfBlock ,BlackIs1 :_fded .BlackIs1 ,DamagedRowsBeforeError :_fded .DamagedRowsBeforeError ,Rows :_fded .Rows ,EncodedByteAlign :_fded .EncodedByteAlign };_deaa ,_aad :=_gecg .Decode (encoded );if _aad !=nil {return nil ,_aad ;};var _gcde []byte ;_acfdf :=0;var _cbaa byte ;var _bfag byte ;for _abac :=range _deaa {if _cbaa !=0{_gcde =append (_gcde ,_bfag );_bfag =0;_acfdf ++;_cbaa =0;};for _egge :=range _deaa [_abac ]{_bfag |=_deaa [_abac ][_egge ]<<(7-_cbaa );_cbaa ++;if _cbaa ==8{_gcde =append (_gcde ,_bfag );_bfag =0;_acfdf ++;_cbaa =0;};};};if _cbaa > 0{_gcde =append (_gcde ,_bfag );};return _gcde ,nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_dffe *PdfObjectDictionary )Keys ()[]PdfObjectName {if _dffe ==nil {return nil ;};return _dffe ._effgc ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_ddag *PdfCrypt )GetAccessPermissions ()_dc .Permissions {return _ddag ._dga .P };func _cdfa (_agf _ad .Filter ,_ecc _dc .AuthEvent )*PdfObjectDictionary {if _ecc ==""{_ecc =_dc .EventDocOpen ;};_eefa :=MakeDict ();_eefa .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_eefa .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_ecc )));_eefa .Set ("\u0043\u0046\u004d",MakeName (_agf .Name ()));_eefa .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_agf .KeyLength ())));return _eefa ;};func (_effb *PdfParser )readComment ()(string ,error ){var _gbge _bf .Buffer ;_ ,_fdacb :=_effb .skipSpaces ();if _fdacb !=nil {return _gbge .String (),_fdacb ;};_gcdb :=true ;for {_fbcd ,_abfb :=_effb ._aae .Peek (1);if _abfb !=nil {_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_abfb .Error ());return _gbge .String (),_abfb ;};if _gcdb &&_fbcd [0]!='%'{return _gbge .String (),_fd .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_gcdb =false ;if (_fbcd [0]!='\r')&&(_fbcd [0]!='\n'){_gefe ,_ :=_effb ._aae .ReadByte ();_gbge .WriteByte (_gefe );}else {break ;};};return _gbge .String (),nil ;};func _bcae (_gbgd ,_cdfae ,_dbd uint8 )uint8 {_fabd :=int (_dbd );_eagaf :=int (_cdfae )-_fabd ;_ecgg :=int (_gbgd )-_fabd ;_fabd =_efae (_eagaf +_ecgg );_eagaf =_efae (_eagaf );_ecgg =_efae (_ecgg );if _eagaf <=_ecgg &&_eagaf <=_fabd {return _gbgd ;}else if _ecgg <=_fabd {return _cdfae ;};return _dbd ;};

// GetFilterName returns the name of the encoding filter.
func (_cbac *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func (_ecbde *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_ecbde ._dceb .ObjectMap =make (map[int ]XrefObject );_ecbde ._adbb =make (objectStreams );_cbgdf ,_caga :=_ecbde ._bgfc .Seek (0,_b .SeekEnd );if _caga !=nil {return nil ,_caga ;};_eg .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_cbgdf );_ecbde ._agb =_cbgdf ;_caga =_ecbde .seekToEOFMarker (_cbgdf );if _caga !=nil {_eg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_caga );return nil ,_caga ;};_adc ,_caga :=_ecbde ._bgfc .Seek (0,_b .SeekCurrent );if _caga !=nil {return nil ,_caga ;};var _bggb int64 =64;_eaeg :=_adc -_bggb ;if _eaeg < 0{_eaeg =0;};_ ,_caga =_ecbde ._bgfc .Seek (_eaeg ,_b .SeekStart );if _caga !=nil {return nil ,_caga ;};_ebbf :=make ([]byte ,_bggb );_ ,_caga =_ecbde ._bgfc .Read (_ebbf );if _caga !=nil {_eg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_caga );return nil ,_caga ;};_bdbfc :=_bbfdb .FindStringSubmatch (string (_ebbf ));if len (_bdbfc )< 2{_eg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_fd .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_bdbfc )> 2{_eg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_ebbf );return nil ,_fd .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_ecae ,_ :=_e .ParseInt (_bdbfc [1],10,64);_eg .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_ecae );if _ecae > _cbgdf {_eg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_eg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_ecae ,_caga =_ecbde .repairLocateXref ();if _caga !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_caga ;};};_ecbde ._bgfc .Seek (int64 (_ecae ),_b .SeekStart );_ecbde ._aae =_ga .NewReader (_ecbde ._bgfc );_egdc ,_caga :=_ecbde .parseXref ();if _caga !=nil {return nil ,_caga ;};_fcgf :=_egdc .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _fcgf !=nil {_cedec ,_ecgc :=_fcgf .(*PdfObjectInteger );if !_ecgc {return nil ,_fd .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_caga =_ecbde .parseXrefStream (_cedec );if _caga !=nil {return nil ,_caga ;};};var _fgfb []int64 ;_cbfa :=func (_fgdg int64 ,_abbf []int64 )bool {for _ ,_deddg :=range _abbf {if _deddg ==_fgdg {return true ;};};return false ;};_fcgf =_egdc .Get ("\u0050\u0072\u0065\u0076");for _fcgf !=nil {_fccd ,_fgeg :=_fcgf .(*PdfObjectInteger );if !_fgeg {_eg .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_fcgf );return _egdc ,nil ;};_fagf :=*_fccd ;_eg .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_fagf );_ecbde ._bgfc .Seek (int64 (_fagf ),_fb .SEEK_SET );_ecbde ._aae =_ga .NewReader (_ecbde ._bgfc );_ebbd ,_cdfef :=_ecbde .parseXref ();if _cdfef !=nil {_eg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_eg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_fcgf =_ebbd .Get ("\u0050\u0072\u0065\u0076");if _fcgf !=nil {_efgd :=*(_fcgf .(*PdfObjectInteger ));if _cbfa (int64 (_efgd ),_fgfb ){_eg .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_fgfb =append (_fgfb ,int64 (_efgd ));};};return _egdc ,nil ;};

// Len returns the number of elements in the streams.
func (_feffd *PdfObjectStreams )Len ()int {if _feffd ==nil {return 0;};return len (_feffd ._dcad );};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// String returns a string describing `d`.
func (_fbbef *PdfObjectDictionary )String ()string {var _ggbe _bd .Builder ;_ggbe .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_cdfgf :=range _fbbef ._effgc {_dcdga :=_fbbef ._adfbf [_cdfgf ];_ggbe .WriteString ("\u0022"+_cdfgf .String ()+"\u0022\u003a\u0020");_ggbe .WriteString (_dcdga .String ());_ggbe .WriteString ("\u002c\u0020");};_ggbe .WriteString ("\u0029");return _ggbe .String ();};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_agca *JBIG2Encoder )Encode ()(_cfeg []byte ,_faeg error ){const _gebf ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _agca ._cbdg ==nil {return nil ,_ebc .Errorf (_gebf ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_agca ._cbdg .FullHeaders =_agca .DefaultPageSettings .FileMode ;_cfeg ,_faeg =_agca ._cbdg .Encode ();if _faeg !=nil {return nil ,_ebc .Wrap (_faeg ,_gebf ,"");};return _cfeg ,nil ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_adab *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};type objectStream struct{N int ;_adg []byte ;_cg map[int ]int64 ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_edd *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_eg .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_eg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_edd .Predictor );if _edd .BitsPerComponent !=8{return nil ,_cb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_edd .BitsPerComponent );};_cdfg ,_gaea :=_edd .DecodeBytes (streamObj .Stream );if _gaea !=nil {return nil ,_gaea ;};_cdfg ,_gaea =_edd .postDecodePredict (_cdfg );if _gaea !=nil {return nil ,_gaea ;};return _edd .cleanImageData (_cdfg );};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_gcfc float64 ,_bgbb bool ){_efgag ,_bgbb :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _bgbb {return float64 (*_efgag ),true ;};return 0,false ;};func (_cede *JBIG2Encoder )encodeImage (_agcc _fa .Image )([]byte ,error ){const _gbae ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_gdea ,_eaga :=GoImageToJBIG2 (_agcc ,JB2ImageAutoThreshold );if _eaga !=nil {return nil ,_ebc .Wrap (_eaga ,_gbae ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _eaga =_cede .AddPageImage (_gdea ,&_cede .DefaultPageSettings );_eaga !=nil {return nil ,_ebc .Wrap (_eaga ,_gbae ,"");};return _cede .Encode ();};func _gdcf (_cfg *_dc .StdEncryptDict ,_cfe *PdfObjectDictionary ){_cfe .Set ("\u0052",MakeInteger (int64 (_cfg .R )));_cfe .Set ("\u0050",MakeInteger (int64 (_cfg .P )));_cfe .Set ("\u004f",MakeStringFromBytes (_cfg .O ));_cfe .Set ("\u0055",MakeStringFromBytes (_cfg .U ));if _cfg .R >=5{_cfe .Set ("\u004f\u0045",MakeStringFromBytes (_cfg .OE ));_cfe .Set ("\u0055\u0045",MakeStringFromBytes (_cfg .UE ));_cfe .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_cfg .EncryptMetadata ));if _cfg .R > 5{_cfe .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_cfg .Perms ));};};};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_gag []XrefObject ;};func (_fege *FlateEncoder )postDecodePredict (_cdgb []byte )([]byte ,error ){if _fege .Predictor > 1{if _fege .Predictor ==2{_eg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_eg .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_fege .Colors );_efa :=int (_fege .Columns )*_fege .Colors ;if _efa < 1{return []byte {},nil ;};_acga :=len (_cdgb )/_efa ;if len (_cdgb )%_efa !=0{_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cdgb ),_efa );};if _efa %_fege .Colors !=0{return nil ,_cb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_efa ,_fege .Colors );};if _efa > len (_cdgb ){_eg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_efa ,len (_cdgb ));return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_cdgb ),_cdgb );_efbf :=_bf .NewBuffer (nil );for _gdf :=0;_gdf < _acga ;_gdf ++{_cbdb :=_cdgb [_efa *_gdf :_efa *(_gdf +1)];for _bcc :=_fege .Colors ;_bcc < _efa ;_bcc ++{_cbdb [_bcc ]+=_cbdb [_bcc -_fege .Colors ];};_efbf .Write (_cbdb );};_bdb :=_efbf .Bytes ();_eg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bdb ),_bdb );return _bdb ,nil ;}else if _fege .Predictor >=10&&_fege .Predictor <=15{_eg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cfbc :=int (_fege .Columns *_fege .Colors +1);_dedd :=len (_cdgb )/_cfbc ;if len (_cdgb )%_cfbc !=0{return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cdgb ),_cfbc );};if _cfbc > len (_cdgb ){_eg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cfbc ,len (_cdgb ));return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_debc :=_bf .NewBuffer (nil );_eg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_fege .Columns );_eg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_cdgb ),_cfbc ,_dedd );_bca :=make ([]byte ,_cfbc );for _dbcdf :=0;_dbcdf < _cfbc ;_dbcdf ++{_bca [_dbcdf ]=0;};_dgffe :=_fege .Colors ;for _fea :=0;_fea < _dedd ;_fea ++{_gbca :=_cdgb [_cfbc *_fea :_cfbc *(_fea +1)];_abef :=_gbca [0];switch _abef {case _cagf :case _fag :for _ggcdb :=1+_dgffe ;_ggcdb < _cfbc ;_ggcdb ++{_gbca [_ggcdb ]+=_gbca [_ggcdb -_dgffe ];};case _eadb :for _ggee :=1;_ggee < _cfbc ;_ggee ++{_gbca [_ggee ]+=_bca [_ggee ];};case _fbef :for _dedb :=1;_dedb < _dgffe +1;_dedb ++{_gbca [_dedb ]+=_bca [_dedb ]/2;};for _baac :=_dgffe +1;_baac < _cfbc ;_baac ++{_gbca [_baac ]+=byte ((int (_gbca [_baac -_dgffe ])+int (_bca [_baac ]))/2);};case _aec :for _cgea :=1;_cgea < _cfbc ;_cgea ++{var _ebdc ,_eeba ,_gca byte ;_eeba =_bca [_cgea ];if _cgea >=_dgffe +1{_ebdc =_gbca [_cgea -_dgffe ];_gca =_bca [_cgea -_dgffe ];};_gbca [_cgea ]+=_bcae (_ebdc ,_eeba ,_gca );};default:_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_abef ,_fea );return nil ,_cb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_abef );};copy (_bca ,_gbca );_debc .Write (_gbca [1:]);};_dce :=_debc .Bytes ();return _dce ,nil ;}else {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_fege .Predictor );return nil ,_cb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_fege .Predictor );};};return _cdgb ,nil ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_bbdb Version ;_bgfc _b .ReadSeeker ;_aae *_ga .Reader ;_agb int64 ;_dceb XrefTable ;_fdbef int64 ;_febf *xrefType ;_adbb objectStreams ;_eeff *PdfObjectDictionary ;_ggec *PdfCrypt ;_bcdfg bool ;ObjCache objectCache ;_ebac map[int64 ]bool ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_gbeg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ab .DecodeBytes (encoded ,_bbe .Parameters {},_gbeg .Globals );};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};func (_bbdg *PdfParser )repairSeekXrefMarker ()error {_aade ,_gdecg :=_bbdg ._bgfc .Seek (0,_fb .SEEK_END );if _gdecg !=nil {return _gdecg ;};_eecf :=_dd .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _abca int64 ;var _beddd int64 =1000;for _abca < _aade {if _aade <=(_beddd +_abca ){_beddd =_aade -_abca ;};_ ,_bage :=_bbdg ._bgfc .Seek (-_abca -_beddd ,_fb .SEEK_END );if _bage !=nil {return _bage ;};_ffbcd :=make ([]byte ,_beddd );_bbdg ._bgfc .Read (_ffbcd );_eg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_ffbcd ));_ecaga :=_eecf .FindAllStringIndex (string (_ffbcd ),-1);if _ecaga !=nil {_cgbcf :=_ecaga [len (_ecaga )-1];_eg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ecaga );_bbdg ._bgfc .Seek (-_abca -_beddd +int64 (_cgbcf [0]),_fb .SEEK_END );_bbdg ._aae =_ga .NewReader (_bbdg ._bgfc );for {_gfcb ,_efeabc :=_bbdg ._aae .Peek (1);if _efeabc !=nil {return _efeabc ;};_eg .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_gfcb [0],_gfcb [0]);if !IsWhiteSpace (_gfcb [0]){break ;};_bbdg ._aae .Discard (1);};return nil ;};_eg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_abca +=_beddd ;};_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _fd .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_def *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gcf :=_bf .NewReader (encoded );var _gffc []byte ;for {_eafc ,_dbg :=_gcf .ReadByte ();if _dbg !=nil {return nil ,_dbg ;};if _eafc =='>'{break ;};if IsWhiteSpace (_eafc ){continue ;};if (_eafc >='a'&&_eafc <='f')||(_eafc >='A'&&_eafc <='F')||(_eafc >='0'&&_eafc <='9'){_gffc =append (_gffc ,_eafc );}else {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_eafc );return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_eafc );};};if len (_gffc )%2==1{_gffc =append (_gffc ,'0');};_eg .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_gffc );_gfc :=make ([]byte ,_c .DecodedLen (len (_gffc )));_ ,_cbfc :=_c .Decode (_gfc ,_gffc );if _cbfc !=nil {return nil ,_cbfc ;};return _gfc ,nil ;};func (_ggc *PdfParser )lookupByNumber (_ddd int ,_bbf bool )(PdfObject ,bool ,error ){_fge ,_ebf :=_ggc .ObjCache [_ddd ];if _ebf {_eg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_ddd );return _fge ,false ,nil ;};_ebg ,_ebf :=_ggc ._dceb .ObjectMap [_ddd ];if !_ebf {_eg .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _gbb PdfObjectNull ;return &_gbb ,false ,nil ;};_eg .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_ddd );if _ebg .XType ==XrefTypeTableEntry {_eg .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_ebg .ObjectNumber );_eg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_ebg .Generation );_eg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_ebg .Offset );_ggc ._bgfc .Seek (_ebg .Offset ,_fb .SEEK_SET );_ggc ._aae =_ga .NewReader (_ggc ._bgfc );_cbe ,_gba :=_ggc .ParseIndirectObject ();if _gba !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_gba );if _bbf {_eg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_gdc ,_fcf :=_ggc .repairRebuildXrefsTopDown ();if _fcf !=nil {_eg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_fcf );return nil ,false ,_fcf ;};_ggc ._dceb =*_gdc ;return _ggc .lookupByNumber (_ddd ,false );};return nil ,false ,_gba ;};if _bbf {_dgb ,_ ,_ :=_gfa (_cbe );if int (_dgb )!=_ddd {_eg .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_fce :=_ggc .rebuildXrefTable ();if _fce !=nil {return nil ,false ,_fce ;};_ggc .ObjCache =objectCache {};return _ggc .lookupByNumberWrapper (_ddd ,false );};};_eg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_ggc .ObjCache [_ddd ]=_cbe ;return _cbe ,false ,nil ;}else if _ebg .XType ==XrefTypeObjectStream {_eg .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_eg .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_eg .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_ebg .OsObjNumber ,_ebg .OsObjIndex );if _ebg .OsObjNumber ==_ddd {_eg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_fd .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_ac :=_ggc ._dceb .ObjectMap [_ebg .OsObjNumber ];_ac {_egb ,_bef :=_ggc .lookupObjectViaOS (_ebg .OsObjNumber ,_ddd );if _bef !=nil {_eg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_bef );return nil ,true ,_bef ;};_eg .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_ggc .ObjCache [_ddd ]=_egb ;if _ggc ._ggec !=nil {_ggc ._ggec ._daa [_egb ]=true ;};return _egb ,true ,nil ;};_eg .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_fd .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_fd .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};func (_cdga *PdfParser )parseArray ()(*PdfObjectArray ,error ){_fgag :=MakeArray ();_cdga ._aae .ReadByte ();for {_cdga .skipSpaces ();_cgaee ,_eeea :=_cdga ._aae .Peek (1);if _eeea !=nil {return _fgag ,_eeea ;};if _cgaee [0]==']'{_cdga ._aae .ReadByte ();break ;};_ecd ,_eeea :=_cdga .parseObject ();if _eeea !=nil {return _fgag ,_eeea ;};_fgag .Append (_ecd );};return _fgag ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fdgd *PdfObjectStreams )WriteString ()string {var _adbg _bd .Builder ;_adbg .WriteString (_e .FormatInt (_fdgd .ObjectNumber ,10));_adbg .WriteString ("\u0020\u0030\u0020\u0052");return _adbg .String ();};func _cded (_ade _b .ReadSeeker ,_baee int64 )(*offsetReader ,error ){_aefc :=&offsetReader {_dcea :_ade ,_gcdg :_baee };_ ,_fadc :=_aefc .Seek (0,_b .SeekStart );return _aefc ,_fadc ;};

// UpdateParams updates the parameter values of the encoder.
func (_gaaf *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_aba ,_abf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _abf ==nil {_gaaf .ColorComponents =int (_aba );};_gcg ,_abf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _abf ==nil {_gaaf .BitsPerComponent =int (_gcg );};_cbed ,_abf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _abf ==nil {_gaaf .Width =int (_cbed );};_gfag ,_abf :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _abf ==nil {_gaaf .Height =int (_gfag );};_fcc ,_abf :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _abf ==nil {_gaaf .Quality =int (_fcc );};};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_caae *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_eg .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_eg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_caae .Predictor );_dfeg ,_daaa :=_caae .DecodeBytes (streamObj .Stream );if _daaa !=nil {return nil ,_daaa ;};_eg .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_eg .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_dfeg ),_dfeg );if _caae .Predictor > 1{if _caae .Predictor ==2{_eg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ecf :=int (_caae .Columns )*_caae .Colors ;if _ecf < 1{return []byte {},nil ;};_cgg :=len (_dfeg )/_ecf ;if len (_dfeg )%_ecf !=0{_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dfeg ),_ecf );};if _ecf %_caae .Colors !=0{return nil ,_cb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ecf ,_caae .Colors );};if _ecf > len (_dfeg ){_eg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ecf ,len (_dfeg ));return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dfeg ),_dfeg );_bdaf :=_bf .NewBuffer (nil );for _fbd :=0;_fbd < _cgg ;_fbd ++{_fegef :=_dfeg [_ecf *_fbd :_ecf *(_fbd +1)];for _facf :=_caae .Colors ;_facf < _ecf ;_facf ++{_fegef [_facf ]=byte (int (_fegef [_facf ]+_fegef [_facf -_caae .Colors ])%256);};_bdaf .Write (_fegef );};_cef :=_bdaf .Bytes ();_eg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_cef ),_cef );return _cef ,nil ;}else if _caae .Predictor >=10&&_caae .Predictor <=15{_eg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_accf :=int (_caae .Columns *_caae .Colors +1);if _accf < 1{return []byte {},nil ;};_ggb :=len (_dfeg )/_accf ;if len (_dfeg )%_accf !=0{return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dfeg ),_accf );};if _accf > len (_dfeg ){_eg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_accf ,len (_dfeg ));return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_agc :=_bf .NewBuffer (nil );_eg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_caae .Columns );_eg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dfeg ),_accf ,_ggb );_ebcb :=make ([]byte ,_accf );for _bcge :=0;_bcge < _accf ;_bcge ++{_ebcb [_bcge ]=0;};for _cfca :=0;_cfca < _ggb ;_cfca ++{_adfe :=_dfeg [_accf *_cfca :_accf *(_cfca +1)];_bece :=_adfe [0];switch _bece {case 0:case 1:for _bddc :=2;_bddc < _accf ;_bddc ++{_adfe [_bddc ]=byte (int (_adfe [_bddc ]+_adfe [_bddc -1])%256);};case 2:for _bbcg :=1;_bbcg < _accf ;_bbcg ++{_adfe [_bbcg ]=byte (int (_adfe [_bbcg ]+_ebcb [_bbcg ])%256);};default:_eg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bece );return nil ,_cb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bece );};for _bada :=0;_bada < _accf ;_bada ++{_ebcb [_bada ]=_adfe [_bada ];};_agc .Write (_adfe [1:]);};_fdbb :=_agc .Bytes ();return _fdbb ,nil ;}else {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_caae .Predictor );return nil ,_cb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_caae .Predictor );};};return _dfeg ,nil ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_dcfbe :=&PdfObjectStreams {};_dcfbe ._dcad =[]PdfObject {};for _ ,_cega :=range objects {_dcfbe ._dcad =append (_dcfbe ._dcad ,_cega );};return _dcfbe ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_cee *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_dgca *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_daea :=_bf .NewReader (encoded );var _afbg []byte ;for {_cada ,_dege :=_daea .ReadByte ();if _dege !=nil {return nil ,_dege ;};if _cada > 128{_bedg ,_dcd :=_daea .ReadByte ();if _dcd !=nil {return nil ,_dcd ;};for _ceff :=0;_ceff < 257-int (_cada );_ceff ++{_afbg =append (_afbg ,_bedg );};}else if _cada < 128{for _cbee :=0;_cbee < int (_cada )+1;_cbee ++{_bfff ,_fcdc :=_daea .ReadByte ();if _fcdc !=nil {return nil ,_fcdc ;};_afbg =append (_afbg ,_bfff );};}else {break ;};};return _afbg ,nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_fced :=PdfObjectString {_fgce :s };return &_fced };

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_efddb *PdfIndirectObject ,_gbcagf bool ){obj =ResolveReference (obj );_efddb ,_gbcagf =obj .(*PdfIndirectObject );return _efddb ,_gbcagf ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bdea *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_dfced :=MakeDict ();_dfced .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bdea .GetFilterName ()));_ddbce :=_bdea .MakeDecodeParams ();if _ddbce !=nil {_dfced .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ddbce );};_dfced .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_bdea .EarlyChange )));return _dfced ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_dbab *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _gccgg _bf .Buffer ;for _cebf :=0;_cebf < len (data );_cebf +=4{_gfcd :=data [_cebf ];_dgcg :=1;_abad :=byte (0);if _cebf +1< len (data ){_abad =data [_cebf +1];_dgcg ++;};_eeaf :=byte (0);if _cebf +2< len (data ){_eeaf =data [_cebf +2];_dgcg ++;};_gcdd :=byte (0);if _cebf +3< len (data ){_gcdd =data [_cebf +3];_dgcg ++;};_ccd :=(uint32 (_gfcd )<<24)|(uint32 (_abad )<<16)|(uint32 (_eeaf )<<8)|uint32 (_gcdd );if _ccd ==0{_gccgg .WriteByte ('z');}else {_bfgc :=_dbab .base256Tobase85 (_ccd );for _ ,_gbd :=range _bfgc [:_dgcg +1]{_gccgg .WriteByte (_gbd +'!');};};};_gccgg .WriteString ("\u007e\u003e");return _gccgg .Bytes (),nil ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_daad *PdfObjectReference )Resolve ()PdfObject {if _daad ._bbed ==nil {return MakeNull ();};_aebbb ,_ ,_gefc :=_daad ._bbed .resolveReference (_daad );if _gefc !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_gefc );return MakeNull ();};if _aebbb ==nil {_eg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _aebbb ;};

// String returns a string describing `ref`.
func (_eabag *PdfObjectReference )String ()string {return _cb .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_eabag .ObjectNumber ,_eabag .GenerationNumber );};func (_gffac *PdfParser )parseString ()(*PdfObjectString ,error ){_gffac ._aae .ReadByte ();var _dagg _bf .Buffer ;_dgdg :=1;for {_faaa ,_cbfb :=_gffac ._aae .Peek (1);if _cbfb !=nil {return MakeString (_dagg .String ()),_cbfb ;};if _faaa [0]=='\\'{_gffac ._aae .ReadByte ();_fggg ,_ddca :=_gffac ._aae .ReadByte ();if _ddca !=nil {return MakeString (_dagg .String ()),_ddca ;};if IsOctalDigit (_fggg ){_fdea ,_adabf :=_gffac ._aae .Peek (2);if _adabf !=nil {return MakeString (_dagg .String ()),_adabf ;};var _dgg []byte ;_dgg =append (_dgg ,_fggg );for _ ,_gbed :=range _fdea {if IsOctalDigit (_gbed ){_dgg =append (_dgg ,_gbed );}else {break ;};};_gffac ._aae .Discard (len (_dgg )-1);_eg .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_dgg );_bbddf ,_adabf :=_e .ParseUint (string (_dgg ),8,32);if _adabf !=nil {return MakeString (_dagg .String ()),_adabf ;};_dagg .WriteByte (byte (_bbddf ));continue ;};switch _fggg {case 'n':_dagg .WriteRune ('\n');case 'r':_dagg .WriteRune ('\r');case 't':_dagg .WriteRune ('\t');case 'b':_dagg .WriteRune ('\b');case 'f':_dagg .WriteRune ('\f');case '(':_dagg .WriteRune ('(');case ')':_dagg .WriteRune (')');case '\\':_dagg .WriteRune ('\\');};continue ;}else if _faaa [0]=='('{_dgdg ++;}else if _faaa [0]==')'{_dgdg --;if _dgdg ==0{_gffac ._aae .ReadByte ();break ;};};_egfe ,_ :=_gffac ._aae .ReadByte ();_dagg .WriteByte (_egfe );};return MakeString (_dagg .String ()),nil ;};func (_gec *PdfCrypt )makeKey (_cdg string ,_deec ,_abce uint32 ,_affe []byte )([]byte ,error ){_dcc ,_dcf :=_gec ._eabb [_cdg ];if !_dcf {return nil ,_cb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cdg );};return _dcc .MakeKey (_deec ,_abce ,_affe );};

// Bytes returns the PdfObjectString content as a []byte array.
func (_agee *PdfObjectString )Bytes ()[]byte {return []byte (_agee ._fgce )};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_afeb *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_gbdc :=n ;_afbe :=0;_fgfd :=0;for _gbdc > 0{_dgeg ,_debf :=_afeb ._aae .Read (p [_afbe :]);if _debf !=nil {_eg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_dgeg ,_fgfd ,_debf .Error ());return _afbe ,_fd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_fgfd ++;_afbe +=_dgeg ;_gbdc -=_dgeg ;};return _afbe ,nil ;};func _ffa (_fec *_ad .FilterDict ,_ccg *PdfObjectDictionary )error {if _gbf ,_aea :=_ccg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_aea {if _ffe :=string (*_gbf );_ffe !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_eg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_ffe );};};_abb ,_eea :=_ccg .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_eea {return _cb .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_fec .CFM =string (*_abb );if _dfg ,_gcdf :=_ccg .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_gcdf {_fec .AuthEvent =_dc .AuthEvent (*_dfg );}else {_fec .AuthEvent =_dc .EventDocOpen ;};if _bgb ,_cag :=_ccg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_cag {_fec .Length =int (*_bgb );};return nil ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_agfaa *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bacb _bf .Buffer ;_cad :=_bf .NewReader (encoded );var _bcg _b .ReadCloser ;if _agfaa .EarlyChange ==1{_bcg =_aa .NewReader (_cad ,_aa .MSB ,8);}else {_bcg =_gf .NewReader (_cad ,_gf .MSB ,8);};defer _bcg .Close ();_ ,_afce :=_bacb .ReadFrom (_bcg );if _afce !=nil {return nil ,_afce ;};return _bacb .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fbea *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_bbed *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};func (_gdcc *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_gdcc ._aae )};func (_fdab *PdfCrypt )loadCryptFilters (_deac *PdfObjectDictionary )error {_fdab ._eabb =cryptFilters {};_edc :=_deac .Get ("\u0043\u0046");_edc =TraceToDirectObject (_edc );if _aaa ,_dbe :=_edc .(*PdfObjectReference );_dbe {_ag ,_cbc :=_fdab ._ggg .LookupByReference (*_aaa );if _cbc !=nil {_eg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _cbc ;};_edc =TraceToDirectObject (_ag );};_edb ,_afc :=_edc .(*PdfObjectDictionary );if !_afc {_eg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_edc );return _fd .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_ccec :=range _edb .Keys (){_gccg :=_edb .Get (_ccec );if _ddc ,_ddbc :=_gccg .(*PdfObjectReference );_ddbc {_fed ,_fcg :=_fdab ._ggg .LookupByReference (*_ddc );if _fcg !=nil {_eg .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _fcg ;};_gccg =TraceToDirectObject (_fed );};_eca ,_bff :=_gccg .(*PdfObjectDictionary );if !_bff {return _cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_ccec ,_gccg );};if _ccec =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _fgee _ad .FilterDict ;if _dff :=_ffa (&_fgee ,_eca );_dff !=nil {return _dff ;};_gfd ,_deg :=_ad .NewFilter (_fgee );if _deg !=nil {return _deg ;};_fdab ._eabb [string (_ccec )]=_gfd ;};_fdab ._eabb ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ad .NewIdentity ();_fdab ._cdf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ebeb ,_ggf :=_deac .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ggf {if _ ,_ddcd :=_fdab ._eabb [string (*_ebeb )];!_ddcd {return _cb .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_ebeb );};_fdab ._cdf =string (*_ebeb );};_fdab ._bed ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gdec ,_eba :=_deac .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_eba {if _ ,_aag :=_fdab ._eabb [string (*_gdec )];!_aag {return _cb .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_gdec );};_fdab ._bed =string (*_gdec );};return nil ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_cfcba *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_afdc :=_cfcba .GetFileOffset ();_ ,_dgbf :=_cfcba ._bgfc .Seek (offset ,_b .SeekStart );if _dgbf !=nil {return nil ,_dgbf ;};_dbaa :=make ([]byte ,len );_ ,_dgbf =_b .ReadAtLeast (_cfcba ._bgfc ,_dbaa ,int (len ));if _dgbf !=nil {return nil ,_dgbf ;};_cfcba .SetFileOffset (_afdc );return _dbaa ,nil ;};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_fgga *JBIG2Encoder )DecodeImages (encoded []byte )([]_fa .Image ,error ){const _ddgc ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_dbeg ,_ged :=_bbe .Decode (encoded ,_bbe .Parameters {},_fgga .Globals .ToDocumentGlobals ());if _ged !=nil {return nil ,_ebc .Wrap (_ged ,_ddgc ,"");};_ace ,_ged :=_dbeg .PageNumber ();if _ged !=nil {return nil ,_ebc .Wrap (_ged ,_ddgc ,"");};_eeef :=[]_fa .Image {};var _cfdb _fa .Image ;for _abgf :=1;_abgf <=_ace ;_abgf ++{_cfdb ,_ged =_dbeg .DecodePageImage (_abgf );if _ged !=nil {return nil ,_ebc .Wrapf (_ged ,_ddgc ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_abgf );};_eeef =append (_eeef ,_cfdb );};return _eeef ,nil ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_eddf *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eddf .DecodeBytes (streamObj .Stream );};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_agdb *PdfObjectDictionary ,_cbedd bool ){_agdb ,_cbedd =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _agdb ,_cbedd ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_cdba []float64 ,_ffgb error ){for _ ,_faaf :=range objects {_ddgcb ,_dgge :=GetNumberAsFloat (_faaf );if _dgge !=nil {return nil ,_dgge ;};_cdba =append (_cdba ,_ddgcb );};return _cdba ,nil ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_ecab :=PdfObjectName (s );return &_ecab };

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_dafba *PdfObjectArray ,_bafdc bool ){_dafba ,_bafdc =TraceToDirectObject (obj ).(*PdfObjectArray );return _dafba ,_bafdc ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_dccf *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_aaf :=MakeDict ();_aaf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dccf .GetFilterName ()));return _aaf ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ad .Filter ,userPass ,ownerPass []byte ,perm _dc .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_fba :=&PdfCrypt {_abc :make (map[PdfObject ]bool ),_eabb :make (cryptFilters ),_dga :_dc .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _bgc Version ;if cf !=nil {_gbc :=cf .PDFVersion ();_bgc .Major ,_bgc .Minor =_gbc [0],_gbc [1];V ,R :=cf .HandlerVersion ();_fba ._bdc .V =V ;_fba ._dga .R =R ;_fba ._bdc .Length =cf .KeyLength ()*8;};const (_efe =_beg ;);_fba ._eabb [_efe ]=cf ;if _fba ._bdc .V >=4{_fba ._bed =_efe ;_fba ._cdf =_efe ;};_acg :=_fba .newEncryptDict ();_gcca :=_ef .Sum ([]byte (_ea .Now ().Format (_ea .RFC850 )));_ca :=string (_gcca [:]);_fcd :=make ([]byte ,100);_gd .Read (_fcd );_gcca =_ef .Sum (_fcd );_eaba :=string (_gcca [:]);_eg .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_fcd );_eg .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_ca );_fba ._eeg =string (_ca );_abe :=_fba .generateParams (userPass ,ownerPass );if _abe !=nil {return nil ,nil ,_abe ;};_gdcf (&_fba ._dga ,_acg );if _fba ._bdc .V >=4{if _cd :=_fba .saveCryptFilters (_acg );_cd !=nil {return nil ,nil ,_cd ;};};return _fba ,&EncryptInfo {Version :_bgc ,Encrypt :_acg ,ID0 :_ca ,ID1 :_eaba },nil ;};func (_gaa *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_dgf :=MakeDict ();_dgf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_dgf .Set ("\u0056",MakeInteger (int64 (_gaa ._bdc .V )));_dgf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_gaa ._bdc .Length )));return _dgf ;};func _efae (_fefc int )int {_ecbb :=_fefc >>(_faec -1);return (_fefc ^_ecbb )-_ecbb };func _affc (_cea *PdfObjectStream ,_gdeef *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};func _fdfbd (_cedac int )int {if _cedac < 0{return -_cedac ;};return _cedac ;};func (_cfdg *PdfParser )traceStreamLength (_gabd PdfObject )(PdfObject ,error ){_baba ,_ccga :=_gabd .(*PdfObjectReference );if _ccga {_ddegb ,_bdgb :=_cfdg ._ebac [_baba .ObjectNumber ];if _bdgb &&_ddegb {_eg .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_fd .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_cfdg ._ebac [_baba .ObjectNumber ]=true ;};_eeeg ,_cccd :=_cfdg .Resolve (_gabd );if _cccd !=nil {return nil ,_cccd ;};_eg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_eeeg );if _ccga {_cfdg ._ebac [_baba .ObjectNumber ]=false ;};return _eeeg ,nil ;};var _bedd =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _gada ,_ecdg :=obj .(*PdfObjectReference );_ecdg {return _gada .Resolve ();};return obj ;};func _dfca (_faafb ,_ceccf PdfObject ,_fgcef int )bool {if _fgcef > _faegd {_eg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_faegd );return false ;};if _faafb ==nil &&_ceccf ==nil {return true ;}else if _faafb ==nil ||_ceccf ==nil {return false ;};if _d .TypeOf (_faafb )!=_d .TypeOf (_ceccf ){return false ;};switch _ebdg :=_faafb .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_ebdg ==*(_ceccf .(*PdfObjectName ));case *PdfObjectString :return *_ebdg ==*(_ceccf .(*PdfObjectString ));case *PdfObjectInteger :return *_ebdg ==*(_ceccf .(*PdfObjectInteger ));case *PdfObjectBool :return *_ebdg ==*(_ceccf .(*PdfObjectBool ));case *PdfObjectFloat :return *_ebdg ==*(_ceccf .(*PdfObjectFloat ));case *PdfIndirectObject :return _dfca (TraceToDirectObject (_faafb ),TraceToDirectObject (_ceccf ),_fgcef +1);case *PdfObjectArray :_deef :=_ceccf .(*PdfObjectArray );if len ((*_ebdg )._gbbe )!=len ((*_deef )._gbbe ){return false ;};for _ecece ,_efbeg :=range (*_ebdg )._gbbe {if !_dfca (_efbeg ,(*_deef )._gbbe [_ecece ],_fgcef +1){return false ;};};return true ;case *PdfObjectDictionary :_gddg :=_ceccf .(*PdfObjectDictionary );_cceeb ,_cdee :=(*_ebdg )._adfbf ,(*_gddg )._adfbf ;if len (_cceeb )!=len (_cdee ){return false ;};for _bbae ,_eeaeg :=range _cceeb {_cgabg ,_fegefb :=_cdee [_bbae ];if !_fegefb ||!_dfca (_eeaeg ,_cgabg ,_fgcef +1){return false ;};};return true ;case *PdfObjectStream :_bcfe :=_ceccf .(*PdfObjectStream );return _dfca ((*_ebdg ).PdfObjectDictionary ,(*_bcfe ).PdfObjectDictionary ,_fgcef +1);default:_eg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_faafb );};return false ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_aeaf *PdfObjectArray )Elements ()[]PdfObject {if _aeaf ==nil {return nil ;};return _aeaf ._gbbe ;};

// WriteString outputs the object as it is to be written to file.
func (_dcag *PdfIndirectObject )WriteString ()string {var _edfg _bd .Builder ;_edfg .WriteString (_e .FormatInt (_dcag .ObjectNumber ,10));_edfg .WriteString ("\u0020\u0030\u0020\u0052");return _edfg .String ();};const _beg ="\u0053\u0074\u0064C\u0046";var _gdbd =_dd .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");func _dab (_aga *PdfObjectStream ,_aee *PdfObjectDictionary )(*LZWEncoder ,error ){_egaa :=NewLZWEncoder ();_cbb :=_aga .PdfObjectDictionary ;if _cbb ==nil {return _egaa ,nil ;};if _aee ==nil {_cae :=TraceToDirectObject (_cbb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _cae !=nil {if _dccb ,_bedb :=_cae .(*PdfObjectDictionary );_bedb {_aee =_dccb ;}else if _ggcbf ,_dcce :=_cae .(*PdfObjectArray );_dcce {if _ggcbf .Len ()==1{if _gbbc ,_ddec :=GetDict (_ggcbf .Get (0));_ddec {_aee =_gbbc ;};};};if _aee ==nil {_eg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_cae );return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_bdf :=_cbb .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _bdf !=nil {_becb ,_dcb :=_bdf .(*PdfObjectInteger );if !_dcb {_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_bdf );return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_becb !=0&&*_becb !=1{return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_egaa .EarlyChange =int (*_becb );}else {_egaa .EarlyChange =1;};if _aee ==nil {return _egaa ,nil ;};_bdf =_aee .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _bdf !=nil {_fbbd ,_eecd :=_bdf .(*PdfObjectInteger );if !_eecd {_eg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_bdf );return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_egaa .Predictor =int (*_fbbd );};_bdf =_aee .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _bdf !=nil {_baea ,_ebga :=_bdf .(*PdfObjectInteger );if !_ebga {_eg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_cb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_egaa .BitsPerComponent =int (*_baea );};if _egaa .Predictor > 1{_egaa .Columns =1;_bdf =_aee .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _bdf !=nil {_ebfc ,_ced :=_bdf .(*PdfObjectInteger );if !_ced {return nil ,_cb .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_egaa .Columns =int (*_ebfc );};_egaa .Colors =1;_bdf =_aee .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _bdf !=nil {_gcbg ,_ddagd :=_bdf .(*PdfObjectInteger );if !_ddagd {return nil ,_cb .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_egaa .Colors =int (*_gcbg );};};_eg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_aee .String ());return _egaa ,nil ;};func (_dfga *offsetReader )Read (p []byte )(_fgae int ,_eaae error ){return _dfga ._dcea .Read (p )};var _gced =_dd .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");type objectCache map[int ]PdfObject ;

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ggeg *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _ccde []int ;for _ ,_gagd :=range _ggeg .Elements (){if _daedd ,_cdffa :=_gagd .(*PdfObjectInteger );_cdffa {_ccde =append (_ccde ,int (*_daedd ));}else {return nil ,ErrTypeError ;};};return _ccde ,nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_aagf bool ,_ffea bool ){_afedb ,_ffea :=TraceToDirectObject (obj ).(*PdfObjectBool );if _ffea {return bool (*_afedb ),true ;};return false ,false ;};

// UpdateParams updates the parameter values of the encoder.
func (_gafc *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_agge *PdfParser )repairLocateXref ()(int64 ,error ){_bcfa :=int64 (1000);_agge ._bgfc .Seek (-_bcfa ,_fb .SEEK_CUR );_aedag ,_eeacf :=_agge ._bgfc .Seek (0,_fb .SEEK_CUR );if _eeacf !=nil {return 0,_eeacf ;};_aabd :=make ([]byte ,_bcfa );_agge ._bgfc .Read (_aabd );_cgdcd :=_gdbd .FindAllStringIndex (string (_aabd ),-1);if len (_cgdcd )< 1{_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_fd .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_babbe :=int64 (_cgdcd [len (_cgdcd )-1][0]);_cdaf :=_aedag +_babbe ;return _cdaf ,nil ;};var _bbdd =_dd .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");var _bccc =_dd .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");func (_bgf *PdfCrypt )saveCryptFilters (_bffa *PdfObjectDictionary )error {if _bgf ._bdc .V < 4{return _fd .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_eae :=MakeDict ();_bffa .Set ("\u0043\u0046",_eae );for _cbda ,_gagb :=range _bgf ._eabb {if _cbda =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_bec :=_cdfa (_gagb ,"");_eae .Set (PdfObjectName (_cbda ),_bec );};_bffa .Set ("\u0053\u0074\u0072\u0046",MakeName (_bgf ._cdf ));_bffa .Set ("\u0053\u0074\u006d\u0046",MakeName (_bgf ._bed ));return nil ;};

// String returns a string describing `ind`.
func (_ggfe *PdfIndirectObject )String ()string {return _cb .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_ggfe ).ObjectNumber );};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_cbcaa *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _dfgag []int64 ;for _ ,_fbgd :=range _cbcaa .Elements (){if _afaa ,_afad :=_fbgd .(*PdfObjectInteger );_afad {_dfgag =append (_dfgag ,int64 (*_afaa ));}else {return nil ,ErrTypeError ;};};return _dfgag ,nil ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_agacb *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _bbcb ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _agacb .ColorComponents !=1||_agacb .BitsPerComponent !=1{return nil ,_ebc .Errorf (_bbcb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_bfc *_eab .Bitmap ;_ccbga error ;);_ddbdd :=(_agacb .Width *_agacb .Height )==len (data );if _ddbdd {_bfc ,_ccbga =_eab .NewWithUnpaddedData (_agacb .Width ,_agacb .Height ,data );}else {_bfc ,_ccbga =_eab .NewWithData (_agacb .Width ,_agacb .Height ,data );};if _ccbga !=nil {return nil ,_ccbga ;};_cdab :=_agacb .DefaultPageSettings ;if _ccbga =_cdab .Validate ();_ccbga !=nil {return nil ,_ebc .Wrap (_ccbga ,_bbcb ,"");};switch _cdab .Compression {case JB2Generic :if _ccbga =_agacb ._cbdg .AddGenericPage (_bfc ,_cdab .DuplicatedLinesRemoval );_ccbga !=nil {return nil ,_ebc .Wrap (_ccbga ,_bbcb ,"");};case JB2SymbolCorrelation :return nil ,_ebc .Error (_bbcb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_ebc .Error (_bbcb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_ebc .Error (_bbcb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _agacb .Encode ();};

// String returns a string describing `array`.
func (_afee *PdfObjectArray )String ()string {_afcef :="\u005b";for _ceaa ,_gbac :=range _afee .Elements (){_afcef +=_gbac .String ();if _ceaa < (_afee .Len ()-1){_afcef +="\u002c\u0020";};};_afcef +="\u005d";return _afcef ;};var _bdab =_dd .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_ga .Reader )(PdfObject ,error ){_dded :=false ;_dfbd :=true ;var _ccgf _bf .Buffer ;for {if _eg .Log .IsLogLevel (_eg .LogLevelTrace ){_eg .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_ccgf .String ());};_aged ,_abed :=buf .Peek (1);if _abed ==_b .EOF {break ;};if _abed !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_abed );return nil ,_abed ;};if _dfbd &&(_aged [0]=='-'||_aged [0]=='+'){_dcdf ,_ :=buf .ReadByte ();_ccgf .WriteByte (_dcdf );_dfbd =false ;}else if IsDecimalDigit (_aged [0]){_gbbda ,_ :=buf .ReadByte ();_ccgf .WriteByte (_gbbda );}else if _aged [0]=='.'{_effdg ,_ :=buf .ReadByte ();_ccgf .WriteByte (_effdg );_dded =true ;}else if _aged [0]=='e'||_aged [0]=='E'{_efag ,_ :=buf .ReadByte ();_ccgf .WriteByte (_efag );_dded =true ;_dfbd =true ;}else {break ;};};var _ebfa PdfObject ;if _dded {_facd ,_afge :=_e .ParseFloat (_ccgf .String (),64);if _afge !=nil {_eg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_ccgf .String (),_afge );_facd =0.0;_afge =nil ;};_gfgd :=PdfObjectFloat (_facd );_ebfa =&_gfgd ;}else {_cbgfb ,_caac :=_e .ParseInt (_ccgf .String (),10,64);if _caac !=nil {_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_ccgf .String (),_caac );_cbgfb =0;_caac =nil ;};_fdad :=PdfObjectInteger (_cbgfb );_ebfa =&_fdad ;};return _ebfa ,nil ;};func _dcbg (_beb *PdfObjectStream ,_fggf *MultiEncoder )(*DCTEncoder ,error ){_gbcagg :=NewDCTEncoder ();_gea :=_beb .PdfObjectDictionary ;if _gea ==nil {return _gbcagg ,nil ;};_eega :=_beb .Stream ;if _fggf !=nil {_dgc ,_bce :=_fggf .DecodeBytes (_eega );if _bce !=nil {return nil ,_bce ;};_eega =_dgc ;};_abfd :=_bf .NewReader (_eega );_cbf ,_cggc :=_a .DecodeConfig (_abfd );if _cggc !=nil {_eg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_cggc );return nil ,_cggc ;};switch _cbf .ColorModel {case _gb .RGBAModel :_gbcagg .BitsPerComponent =8;_gbcagg .ColorComponents =3;case _gb .RGBA64Model :_gbcagg .BitsPerComponent =16;_gbcagg .ColorComponents =3;case _gb .GrayModel :_gbcagg .BitsPerComponent =8;_gbcagg .ColorComponents =1;case _gb .Gray16Model :_gbcagg .BitsPerComponent =16;_gbcagg .ColorComponents =1;case _gb .CMYKModel :_gbcagg .BitsPerComponent =8;_gbcagg .ColorComponents =4;case _gb .YCbCrModel :_gbcagg .BitsPerComponent =8;_gbcagg .ColorComponents =3;default:return nil ,_fd .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_gbcagg .Width =_cbf .Width ;_gbcagg .Height =_cbf .Height ;_eg .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_gbcagg );_gbcagg .Quality =DefaultJPEGQuality ;return _gbcagg ,nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_fbdc *PdfObjectString )Decoded ()string {if _fbdc ==nil {return "";};_cbdd :=[]byte (_fbdc ._fgce );if len (_cbdd )>=2&&_cbdd [0]==0xFE&&_cbdd [1]==0xFF{return _bb .UTF16ToString (_cbdd [2:]);};return _bb .PDFDocEncodingToString (_cbdd );};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_fgged :=PdfObjectFloat (val );return &_fgged };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bgeg *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_dccee :=MakeDict ();_dccee .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bgeg .GetFilterName ()));return _dccee ;};func (_bddea *JBIG2Image )toBitmap ()(_bgbe *_eab .Bitmap ,_bccd error ){const _dcge ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _bddea .Data ==nil {return nil ,_ebc .Error (_dcge ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _bddea .Width ==0||_bddea .Height ==0{return nil ,_ebc .Error (_dcge ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _bddea .HasPadding {_bgbe ,_bccd =_eab .NewWithData (_bddea .Width ,_bddea .Height ,_bddea .Data );}else {_bgbe ,_bccd =_eab .NewWithUnpaddedData (_bddea .Width ,_bddea .Height ,_bddea .Data );};if _bccd !=nil {return nil ,_ebc .Wrap (_bccd ,_dcge ,"");};return _bgbe ,nil ;};func (_ffba *PdfParser )xrefNextObjectOffset (_edac int64 )int64 {_abgd :=int64 (0);if len (_ffba ._dceb .ObjectMap )==0{return 0;};if len (_ffba ._dceb ._gag )==0{_acee :=0;for _ ,_ceeba :=range _ffba ._dceb .ObjectMap {if _ceeba .Offset > 0{_acee ++;};};if _acee ==0{return 0;};_ffba ._dceb ._gag =make ([]XrefObject ,_acee );_bagc :=0;for _ ,_aeebb :=range _ffba ._dceb .ObjectMap {if _aeebb .Offset > 0{_ffba ._dceb ._gag [_bagc ]=_aeebb ;_bagc ++;};};_g .Slice (_ffba ._dceb ._gag ,func (_addc ,_cgba int )bool {return _ffba ._dceb ._gag [_addc ].Offset < _ffba ._dceb ._gag [_cgba ].Offset });};_egc :=_g .Search (len (_ffba ._dceb ._gag ),func (_geaaf int )bool {return _ffba ._dceb ._gag [_geaaf ].Offset >=_edac });if _egc < len (_ffba ._dceb ._gag ){_abgd =_ffba ._dceb ._gag [_egc ].Offset ;};return _abgd ;};func (_daee *PdfParser )skipComments ()error {if _ ,_badf :=_daee .skipSpaces ();_badf !=nil {return _badf ;};_bfe :=true ;for {_dddc ,_dfede :=_daee ._aae .Peek (1);if _dfede !=nil {_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_dfede .Error ());return _dfede ;};if _bfe &&_dddc [0]!='%'{return nil ;};_bfe =false ;if (_dddc [0]!='\r')&&(_dddc [0]!='\n'){_daee ._aae .ReadByte ();}else {break ;};};return _daee .skipComments ();};var _bbfdb =_dd .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");func (_cgfe *PdfParser )seekToEOFMarker (_aeadg int64 )error {var _bgdf int64 ;var _cfddd int64 =2048;for _bgdf < _aeadg -4{if _aeadg <=(_cfddd +_bgdf ){_cfddd =_aeadg -_bgdf ;};_ ,_bdg :=_cgfe ._bgfc .Seek (-_bgdf -_cfddd ,_b .SeekEnd );if _bdg !=nil {return _bdg ;};_aeab :=make ([]byte ,_cfddd );_cgfe ._bgfc .Read (_aeab );_eg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_aeab ));_acfg :=_cgfb .FindAllStringIndex (string (_aeab ),-1);if _acfg !=nil {_bcce :=_acfg [len (_acfg )-1];_eg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_acfg );_cgfe ._bgfc .Seek (-_bgdf -_cfddd +int64 (_bcce [0]),_b .SeekEnd );return nil ;};_eg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_bgdf +=_cfddd -4;};_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _fd .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};type cryptFilters map[string ]_ad .Filter ;

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_caab *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _caab .DecodeBytes (streamObj .Stream );};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_fcgg :=MultiEncoder {};_fcgg ._cgae =[]StreamEncoder {};return &_fcgg ;};

// WriteString outputs the object as it is to be written to file.
func (_bfbcc *PdfObjectBool )WriteString ()string {if *_bfbcc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func (_dabe *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_dabe ._bgfc .Seek (0,_fb .SEEK_SET );_dabe ._aae =_ga .NewReader (_dabe ._bgfc );_bfbbf :=20;_ebda :=make ([]byte ,_bfbbf );for {_bddg ,_dfddc :=_dabe ._aae .ReadByte ();if _dfddc !=nil {if _dfddc ==_b .EOF {break ;}else {return 0,0,_dfddc ;};};if IsDecimalDigit (_bddg )&&_ebda [_bfbbf -1]=='.'&&IsDecimalDigit (_ebda [_bfbbf -2])&&_ebda [_bfbbf -3]=='-'&&_ebda [_bfbbf -4]=='F'&&_ebda [_bfbbf -5]=='D'&&_ebda [_bfbbf -6]=='P'{_gfdc :=int (_ebda [_bfbbf -2]-'0');_egead :=int (_bddg -'0');return _gfdc ,_egead ,nil ;};_ebda =append (_ebda [1:_bfbbf ],_bddg );};return 0,0,_fd .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_bbged *PdfObjectName ,_ccfd bool ){_bbged ,_ccfd =TraceToDirectObject (obj ).(*PdfObjectName );return _bbged ,_ccfd ;};func (_cbca *PdfCrypt )isEncrypted (_dbcd PdfObject )bool {_ ,_fcga :=_cbca ._abc [_dbcd ];if _fcga {_eg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_eg .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// GetFilterName returns the name of the encoding filter.
func (_gbcag *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ddbb *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_gbcd :=MakeArray ();for _ ,_bcgea :=range vals {_gbcd .Append (MakeInteger (_bcgea ));};return _gbcd ;};

// WriteString outputs the object as it is to be written to file.
func (_fcfdc *PdfObjectName )WriteString ()string {var _fggb _bf .Buffer ;if len (*_fcfdc )> 127{_eg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_fcfdc );};_fggb .WriteString ("\u002f");for _dcaa :=0;_dcaa < len (*_fcfdc );_dcaa ++{_fdfd :=(*_fcfdc )[_dcaa ];if !IsPrintable (_fdfd )||_fdfd =='#'||IsDelimiter (_fdfd ){_fggb .WriteString (_cb .Sprintf ("\u0023\u0025\u002e2\u0078",_fdfd ));}else {_fggb .WriteByte (_fdfd );};};return _fggb .String ();};func (_afbee *PdfParser )parseHexString ()(*PdfObjectString ,error ){_afbee ._aae .ReadByte ();var _ccff _bf .Buffer ;for {_afbeb ,_cgeb :=_afbee ._aae .Peek (1);if _cgeb !=nil {return MakeString (""),_cgeb ;};if _afbeb [0]=='>'{_afbee ._aae .ReadByte ();break ;};_eead ,_ :=_afbee ._aae .ReadByte ();if !IsWhiteSpace (_eead ){_ccff .WriteByte (_eead );};};if _ccff .Len ()%2==1{_ccff .WriteRune ('0');};_cfce ,_ :=_c .DecodeString (_ccff .String ());return MakeHexString (string (_cfce )),nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_gefg *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_gcac ,_cbgb :=_gefg ._adfbf [key ];if !_cbgb {return nil ;};return _gcac ;};

// Clear resets the array to an empty state.
func (_cdffb *PdfObjectArray )Clear (){_cdffb ._gbbe =[]PdfObject {}};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_dgfaf *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _bfdc []float64 ;for _ ,_afcf :=range _dgfaf .Elements (){_bdfg ,_cegab :=GetNumberAsFloat (TraceToDirectObject (_afcf ));if _cegab !=nil {return nil ,_cb .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_bfdc =append (_bfdc ,_bdfg );};return _bfdc ,nil ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;func (_acfaa *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _faba *PdfObjectDictionary ;_fdef ,_caaef :=_acfaa .readTextLine ();if _caaef !=nil {return nil ,_caaef ;};_eg .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fdef );_fbfc :=-1;_fgd :=0;_edfe :=false ;_fbcdd :="";for {_acfaa .skipSpaces ();_ ,_fafb :=_acfaa ._aae .Peek (1);if _fafb !=nil {return nil ,_fafb ;};_fdef ,_fafb =_acfaa .readTextLine ();if _fafb !=nil {return nil ,_fafb ;};_fdefa :=_bdab .FindStringSubmatch (_fdef );if len (_fdefa )==0{_cccc :=len (_fbcdd )> 0;_fbcdd +=_fdef +"\u000a";if _cccc {_fdefa =_bdab .FindStringSubmatch (_fbcdd );};};if len (_fdefa )==3{_gceb ,_ :=_e .Atoi (_fdefa [1]);_gcdfg ,_ :=_e .Atoi (_fdefa [2]);_fbfc =_gceb ;_fgd =_gcdfg ;_edfe =true ;_fbcdd ="";_eg .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_fbfc ,_fgd );continue ;};_gebcf :=_gced .FindStringSubmatch (_fdef );if len (_gebcf )==4{if _edfe ==false {_eg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_fd .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_cbcd ,_ :=_e .ParseInt (_gebcf [1],10,64);_bdbba ,_ :=_e .Atoi (_gebcf [2]);_fdge :=_gebcf [3];_fbcdd ="";if _bd .ToLower (_fdge )=="\u006e"&&_cbcd > 1{_efab ,_babb :=_acfaa ._dceb .ObjectMap [_fbfc ];if !_babb ||_bdbba > _efab .Generation {_ebce :=XrefObject {ObjectNumber :_fbfc ,XType :XrefTypeTableEntry ,Offset :_cbcd ,Generation :_bdbba };_acfaa ._dceb .ObjectMap [_fbfc ]=_ebce ;};};_fbfc ++;continue ;};if (len (_fdef )> 6)&&(_fdef [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_eg .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_fdef );if len (_fdef )> 9{_fcde :=_acfaa .GetFileOffset ();_acfaa .SetFileOffset (_fcde -int64 (len (_fdef ))+7);};_acfaa .skipSpaces ();_acfaa .skipComments ();_eg .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_eg .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_fdef );_faba ,_fafb =_acfaa .ParseDict ();_eg .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _fafb !=nil {_eg .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_fafb );return nil ,_fafb ;};break ;};if _fdef =="\u0025\u0025\u0045O\u0046"{_eg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_fd .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_eg .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_fdef );};_eg .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _acfaa ._febf ==nil {_decbf :=XrefTypeTableEntry ;_acfaa ._febf =&_decbf ;};return _faba ,nil ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_feed :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _feed ==nil {return NewRawEncoder (),nil ;};if _ ,_cegb :=_feed .(*PdfObjectNull );_cegb {return NewRawEncoder (),nil ;};_cbba ,_ggbc :=_feed .(*PdfObjectName );if !_ggbc {_bgfdg ,_cbedf :=_feed .(*PdfObjectArray );if !_cbedf {return nil ,_cb .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _bgfdg .Len ()==0{return NewRawEncoder (),nil ;};if _bgfdg .Len ()!=1{_ebaa ,_bced :=_affcb (streamObj );if _bced !=nil {_eg .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_bced );return nil ,_bced ;};_eg .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_ebaa );return _ebaa ,nil ;};_feed =_bgfdg .Get (0);_cbba ,_cbedf =_feed .(*PdfObjectName );if !_cbedf {return nil ,_cb .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_cbba {case StreamEncodingFilterNameFlate :return _eadg (streamObj ,nil );case StreamEncodingFilterNameLZW :return _dab (streamObj ,nil );case StreamEncodingFilterNameDCT :return _dcbg (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _affc (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _adbd (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _ceeb (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_eg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_cb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_cbba );};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};func (_ccad *PdfParser )resolveReference (_ddcdf *PdfObjectReference )(PdfObject ,bool ,error ){_gddc ,_egfec :=_ccad .ObjCache [int (_ddcdf .ObjectNumber )];if _egfec {return _gddc ,true ,nil ;};_gcfg ,_cafd :=_ccad .LookupByReference (*_ddcdf );if _cafd !=nil {return nil ,false ,_cafd ;};_ccad .ObjCache [int (_ddcdf .ObjectNumber )]=_gcfg ;return _gcfg ,false ,nil ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_bcgc *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bfbd _bf .Buffer ;for _ ,_dge :=range data {_bfbd .WriteString (_cb .Sprintf ("\u0025\u002e\u0032X\u0020",_dge ));};_bfbd .WriteByte ('>');return _bfbd .Bytes (),nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_cfcb JBIG2EncoderSettings )Validate ()error {const _edbg ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _cfcb .Threshold < 0||_cfcb .Threshold > 1.0{return _ebc .Errorf (_edbg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_cfcb .Threshold );};if _cfcb .ResolutionX < 0{return _ebc .Errorf (_edbg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_cfcb .ResolutionX );};if _cfcb .ResolutionY < 0{return _ebc .Errorf (_edbg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_cfcb .ResolutionY );};if _cfcb .DefaultPixelValue !=0&&_cfcb .DefaultPixelValue !=1{return _ebc .Errorf (_edbg ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_cfcb .DefaultPixelValue );};if _cfcb .Compression !=JB2Generic {return _ebc .Errorf (_edbg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};func _affcb (_ecfa *PdfObjectStream )(*MultiEncoder ,error ){_ebb :=NewMultiEncoder ();_babd :=_ecfa .PdfObjectDictionary ;if _babd ==nil {return _ebb ,nil ;};var _bbbd *PdfObjectDictionary ;var _agaea []PdfObject ;_bgd :=_babd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _bgd !=nil {_fga ,_efbc :=_bgd .(*PdfObjectDictionary );if _efbc {_bbbd =_fga ;};_dbce ,_cggd :=_bgd .(*PdfObjectArray );if _cggd {for _ ,_fgbc :=range _dbce .Elements (){_fgbc =TraceToDirectObject (_fgbc );if _ccbc ,_cbea :=_fgbc .(*PdfObjectDictionary );_cbea {_agaea =append (_agaea ,_ccbc );}else {_agaea =append (_agaea ,MakeDict ());};};};};_bgd =_babd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _bgd ==nil {return nil ,_cb .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_cgec ,_efaf :=_bgd .(*PdfObjectArray );if !_efaf {return nil ,_cb .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _dcfg ,_bgde :=range _cgec .Elements (){_fcecd ,_aeg :=_bgde .(*PdfObjectName );if !_aeg {return nil ,_cb .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _bdbb PdfObject ;if _bbbd !=nil {_bdbb =_bbbd ;}else {if len (_agaea )> 0{if _dcfg >=len (_agaea ){return nil ,_cb .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_bdbb =_agaea [_dcfg ];};};var _gbcg *PdfObjectDictionary ;if _bebg ,_ffbg :=_bdbb .(*PdfObjectDictionary );_ffbg {_gbcg =_bebg ;};_eg .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_fcecd ,_bdbb ,_gbcg );if *_fcecd ==StreamEncodingFilterNameFlate {_bacd ,_facc :=_eadg (_ecfa ,_gbcg );if _facc !=nil {return nil ,_facc ;};_ebb .AddEncoder (_bacd );}else if *_fcecd ==StreamEncodingFilterNameLZW {_bedf ,_ebbb :=_dab (_ecfa ,_gbcg );if _ebbb !=nil {return nil ,_ebbb ;};_ebb .AddEncoder (_bedf );}else if *_fcecd ==StreamEncodingFilterNameASCIIHex {_edbc :=NewASCIIHexEncoder ();_ebb .AddEncoder (_edbc );}else if *_fcecd ==StreamEncodingFilterNameASCII85 {_fee :=NewASCII85Encoder ();_ebb .AddEncoder (_fee );}else if *_fcecd ==StreamEncodingFilterNameDCT {_adfd ,_cgc :=_dcbg (_ecfa ,_ebb );if _cgc !=nil {return nil ,_cgc ;};_ebb .AddEncoder (_adfd );_eg .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_eg .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_ebb );}else {_eg .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_fcecd );return nil ,_cb .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _ebb ,nil ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _gegb (o ,0,traversed );};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_dgefd :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_dgefd .PdfObjectDictionary =encoder .MakeStreamDict ();_gfaf ,_geff :=encoder .EncodeBytes (contents );if _geff !=nil {return nil ,_geff ;};_dgefd .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gfaf ))));_dgefd .Stream =_gfaf ;return _dgefd ,nil ;};func _eadg (_abbe *PdfObjectStream ,_cgf *PdfObjectDictionary )(*FlateEncoder ,error ){_cfcf :=NewFlateEncoder ();_baa :=_abbe .PdfObjectDictionary ;if _baa ==nil {return _cfcf ,nil ;};_cfcf ._face =_egdb (_baa );if _cgf ==nil {_ece :=TraceToDirectObject (_baa .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _ccbf :=_ece .(type ){case *PdfObjectArray :_gega :=_ccbf ;if _gega .Len ()!=1{_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_gega .Len ());return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ece =TraceToDirectObject (_gega .Get (0));case *PdfObjectDictionary :_cgf =_ccbf ;case *PdfObjectNull ,nil :default:_eg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_ece );return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cgf ==nil {return _cfcf ,nil ;};_eg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cgf .String ());_dca :=_cgf .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _dca ==nil {_eg .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_begg ,_cbeb :=_dca .(*PdfObjectInteger );if !_cbeb {_eg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dca );return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_cfcf .Predictor =int (*_begg );};_dca =_cgf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _dca !=nil {_eaed ,_fcag :=_dca .(*PdfObjectInteger );if !_fcag {_eg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_cb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_cfcf .BitsPerComponent =int (*_eaed );};if _cfcf .Predictor > 1{_cfcf .Columns =1;_dca =_cgf .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _dca !=nil {_dedf ,_bbgg :=_dca .(*PdfObjectInteger );if !_bbgg {return nil ,_cb .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_cfcf .Columns =int (*_dedf );};_cfcf .Colors =1;_dca =_cgf .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dca !=nil {_edaag ,_eaf :=_dca .(*PdfObjectInteger );if !_eaf {return nil ,_cb .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_cfcf .Colors =int (*_edaag );};};return _cfcf ,nil ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_bdc encryptDict ;_dga _dc .StdEncryptDict ;_eeg string ;_dbb []byte ;_daa map[PdfObject ]bool ;_abc map[PdfObject ]bool ;_dag bool ;_eabb cryptFilters ;_bed string ;_cdf string ;_ggg *PdfParser ;_ded map[int ]struct{};};

// GetFilterName returns the name of the encoding filter.
func (_fdd *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_aagg *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_aagg .GetFilterName ());return data ,ErrNoJPXDecode ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _dedba :=obj .(type ){case *PdfObjectFloat :_eg .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_dedba ),nil ;case *PdfObjectInteger :return int64 (*_dedba ),nil ;};return 0,ErrNotANumber ;};const _faegd =10;

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_gagg *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_gagg .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_feged :=&ASCII85Encoder {};return _feged };

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_gcdfe *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_ffde error ){const _cdcc ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _gcdfe ==nil {return _ebc .Error (_cdcc ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_gcdfe .DefaultPageSettings ;};if _gcdfe ._cbdg ==nil {_gcdfe ._cbdg =_db .InitEncodeDocument (settings .FileMode );};if _ffde =settings .Validate ();_ffde !=nil {return _ebc .Wrap (_ffde ,_cdcc ,"");};_afed ,_ffde :=img .toBitmap ();if _ffde !=nil {return _ebc .Wrap (_ffde ,_cdcc ,"");};switch settings .Compression {case JB2Generic :if _ffde =_gcdfe ._cbdg .AddGenericPage (_afed ,settings .DuplicatedLinesRemoval );_ffde !=nil {return _ebc .Wrap (_ffde ,_cdcc ,"");};case JB2SymbolCorrelation :return _ebc .Error (_cdcc ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _ebc .Error (_cdcc ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _ebc .Error (_cdcc ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};func _bfcb (_daeff PdfObject )(*float64 ,error ){switch _dace :=_daeff .(type ){case *PdfObjectFloat :_ddab :=float64 (*_dace );return &_ddab ,nil ;case *PdfObjectInteger :_fbdd :=float64 (*_dace );return &_fbdd ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};func (_ebfdc *PdfParser )parseObject ()(PdfObject ,error ){_eg .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_ebfdc .skipSpaces ();for {_abdd ,_ecbd :=_ebfdc ._aae .Peek (2);if _ecbd !=nil {if _ecbd !=_b .EOF ||len (_abdd )==0{return nil ,_ecbd ;};if len (_abdd )==1{_abdd =append (_abdd ,' ');};};_eg .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_abdd ));if _abdd [0]=='/'{_acgad ,_eeda :=_ebfdc .parseName ();_eg .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_acgad );return &_acgad ,_eeda ;}else if _abdd [0]=='('{_eg .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_aegb ,_bcgee :=_ebfdc .parseString ();return _aegb ,_bcgee ;}else if _abdd [0]=='['{_eg .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_bcfb ,_cab :=_ebfdc .parseArray ();return _bcfb ,_cab ;}else if (_abdd [0]=='<')&&(_abdd [1]=='<'){_eg .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_edag ,_fabe :=_ebfdc .ParseDict ();return _edag ,_fabe ;}else if _abdd [0]=='<'{_eg .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_cbfba ,_egaf :=_ebfdc .parseHexString ();return _cbfba ,_egaf ;}else if _abdd [0]=='%'{_ebfdc .readComment ();_ebfdc .skipSpaces ();}else {_eg .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_abdd ,_ =_ebfdc ._aae .Peek (15);_gaggd :=string (_abdd );_eg .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_gaggd );if (len (_gaggd )> 3)&&(_gaggd [:4]=="\u006e\u0075\u006c\u006c"){_gafee ,_bdfbe :=_ebfdc .parseNull ();return &_gafee ,_bdfbe ;}else if (len (_gaggd )> 4)&&(_gaggd [:5]=="\u0066\u0061\u006cs\u0065"){_dcfb ,_gdeaf :=_ebfdc .parseBool ();return &_dcfb ,_gdeaf ;}else if (len (_gaggd )> 3)&&(_gaggd [:4]=="\u0074\u0072\u0075\u0065"){_afebc ,_gdcgd :=_ebfdc .parseBool ();return &_afebc ,_gdcgd ;};_fedg :=_gcec .FindStringSubmatch (string (_gaggd ));if len (_fedg )> 1{_abdd ,_ =_ebfdc ._aae .ReadBytes ('R');_eg .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_abdd [:]));_gdd ,_bfbc :=_dcdg (string (_abdd ));_gdd ._bbed =_ebfdc ;return &_gdd ,_bfbc ;};_gbfb :=_cdfb .FindStringSubmatch (string (_gaggd ));if len (_gbfb )> 1{_eg .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_gaff ,_ddbbg :=_ebfdc .parseNumber ();return _gaff ,_ddbbg ;};_gbfb =_cfga .FindStringSubmatch (string (_gaggd ));if len (_gbfb )> 1{_eg .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_eg .Log .Trace ("\u0025\u0020\u0073",_gbfb );_eedb ,_cgcb :=_ebfdc .parseNumber ();return _eedb ,_cgcb ;};_eg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_gaggd );return nil ,_fd .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_bgdea *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_febe :=_bgdea ._adfbf [key ];if !_febe {_bgdea ._effgc =append (_bgdea ._effgc ,key );};_bgdea ._adfbf [key ]=val ;};var _cfga =_dd .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_cefd :=PdfObjectBool (val );return &_cefd };

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_cgdca *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aacd :=_bf .NewReader (encoded );_agfc ,_afb :=_a .Decode (_aacd );if _afb !=nil {_eg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_afb );return nil ,_afb ;};_eeacc :=_agfc .Bounds ();var _aecf =make ([]byte ,_eeacc .Dx ()*_eeacc .Dy ()*_cgdca .ColorComponents *_cgdca .BitsPerComponent /8);_dcbf :=0;for _bbbe :=_eeacc .Min .Y ;_bbbe < _eeacc .Max .Y ;_bbbe ++{for _fbfd :=_eeacc .Min .X ;_fbfd < _eeacc .Max .X ;_fbfd ++{_abgg :=_agfc .At (_fbfd ,_bbbe );if _cgdca .ColorComponents ==1{if _cgdca .BitsPerComponent ==16{_baec ,_gabg :=_abgg .(_gb .Gray16 );if !_gabg {return nil ,_fd .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_aecf [_dcbf ]=byte ((_baec .Y >>8)&0xff);_dcbf ++;_aecf [_dcbf ]=byte (_baec .Y &0xff);_dcbf ++;}else {_cda ,_cfa :=_abgg .(_gb .Gray );if !_cfa {return nil ,_fd .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_aecf [_dcbf ]=byte (_cda .Y &0xff);_dcbf ++;};}else if _cgdca .ColorComponents ==3{if _cgdca .BitsPerComponent ==16{_dfda ,_ede :=_abgg .(_gb .RGBA64 );if !_ede {return nil ,_fd .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_aecf [_dcbf ]=byte ((_dfda .R >>8)&0xff);_dcbf ++;_aecf [_dcbf ]=byte (_dfda .R &0xff);_dcbf ++;_aecf [_dcbf ]=byte ((_dfda .G >>8)&0xff);_dcbf ++;_aecf [_dcbf ]=byte (_dfda .G &0xff);_dcbf ++;_aecf [_dcbf ]=byte ((_dfda .B >>8)&0xff);_dcbf ++;_aecf [_dcbf ]=byte (_dfda .B &0xff);_dcbf ++;}else {_gebc ,_bgea :=_abgg .(_gb .RGBA );if _bgea {_aecf [_dcbf ]=_gebc .R &0xff;_dcbf ++;_aecf [_dcbf ]=_gebc .G &0xff;_dcbf ++;_aecf [_dcbf ]=_gebc .B &0xff;_dcbf ++;}else {_bfdf ,_ecgb :=_abgg .(_gb .YCbCr );if !_ecgb {return nil ,_fd .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_efef ,_daac ,_dfcd ,_ :=_bfdf .RGBA ();_aecf [_dcbf ]=byte (_efef >>8);_dcbf ++;_aecf [_dcbf ]=byte (_daac >>8);_dcbf ++;_aecf [_dcbf ]=byte (_dfcd >>8);_dcbf ++;};};}else if _cgdca .ColorComponents ==4{_cedb ,_dadf :=_abgg .(_gb .CMYK );if !_dadf {return nil ,_fd .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_aecf [_dcbf ]=255-_cedb .C &0xff;_dcbf ++;_aecf [_dcbf ]=255-_cedb .M &0xff;_dcbf ++;_aecf [_dcbf ]=255-_cedb .Y &0xff;_dcbf ++;_aecf [_dcbf ]=255-_cedb .K &0xff;_dcbf ++;};};};return _aecf ,nil ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_ddac []byte ,_gfcf bool ){_geca ,_gfcf :=TraceToDirectObject (obj ).(*PdfObjectString );if _gfcf {return _geca .Bytes (),true ;};return ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);func (_acgg *PdfCrypt )securityHandler ()_dc .StdHandler {if _acgg ._dga .R >=5{return _dc .NewHandlerR6 ();};return _dc .NewHandlerR4 (_acgg ._eeg ,_acgg ._bdc .Length );};

// GetFilterName returns the name of the encoding filter.
func (_bbge *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_gbfbb *PdfParser )CheckAccessRights (password []byte )(bool ,_dc .Permissions ,error ){if _gbfbb ._ggec ==nil {return true ,_dc .PermOwner ,nil ;};return _gbfbb ._ggec .checkAccessRights (password );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_afd *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_eag :=MakeDict ();_eag .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_afd .GetFilterName ()));return _eag ;};

// GetXrefOffset returns the offset of the xref table.
func (_gaca *PdfParser )GetXrefOffset ()int64 {return _gaca ._fdbef };

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_bgg *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cedbb *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_eddg *PdfParser )GetTrailer ()*PdfObjectDictionary {return _eddg ._eeff };func _eaca (_cdabb ,_dagc ,_bgccb int )error {if _dagc < 0||_dagc > _cdabb {return _fd .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _bgccb < _dagc {return _fd .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _bgccb > _cdabb {return _fd .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gebe *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_bgbff *PdfObjectInteger ,_adge bool ){_bgbff ,_adge =TraceToDirectObject (obj ).(*PdfObjectInteger );return _bgbff ,_adge ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_daed *PdfObjectReference )GetParser ()*PdfParser {return _daed ._bbed };

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_fabcg *MultiEncoder )GetFilterName ()string {_dgfg :="";for _bdbf ,_ecea :=range _fabcg ._cgae {_dgfg +=_ecea .GetFilterName ();if _bdbf < len (_fabcg ._cgae )-1{_dgfg +="\u0020";};};return _dgfg ;};func _gegb (_gcbc PdfObject ,_edeaa int ,_fdca map[PdfObject ]struct{})error {_eg .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_edeaa );if _ ,_bbef :=_fdca [_gcbc ];_bbef {_eg .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_fdca [_gcbc ]=struct{}{};switch _cbae :=_gcbc .(type ){case *PdfIndirectObject :_ffbd :=_cbae ;_eg .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_ffbd );_eg .Log .Trace ("\u002d\u0020\u0025\u0073",_ffbd .PdfObject );return _gegb (_ffbd .PdfObject ,_edeaa +1,_fdca );case *PdfObjectStream :_ebfb :=_cbae ;return _gegb (_ebfb .PdfObjectDictionary ,_edeaa +1,_fdca );case *PdfObjectDictionary :_ffbae :=_cbae ;_eg .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_ffbae );for _ ,_edfa :=range _ffbae .Keys (){_eecc :=_ffbae .Get (_edfa );if _gggc ,_ggcbg :=_eecc .(*PdfObjectReference );_ggcbg {_dgdc :=_gggc .Resolve ();_ffbae .Set (_edfa ,_dgdc );_cagfe :=_gegb (_dgdc ,_edeaa +1,_fdca );if _cagfe !=nil {return _cagfe ;};}else {_fbaa :=_gegb (_eecc ,_edeaa +1,_fdca );if _fbaa !=nil {return _fbaa ;};};};return nil ;case *PdfObjectArray :_dfgb :=_cbae ;_eg .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_dfgb );for _bgfb ,_fffbf :=range _dfgb .Elements (){if _efedb ,_efabf :=_fffbf .(*PdfObjectReference );_efabf {_geaf :=_efedb .Resolve ();_dfgb .Set (_bgfb ,_geaf );_agccf :=_gegb (_geaf ,_edeaa +1,_fdca );if _agccf !=nil {return _agccf ;};}else {_egdcd :=_gegb (_fffbf ,_edeaa +1,_fdca );if _egdcd !=nil {return _egdcd ;};};};return nil ;case *PdfObjectReference :_eg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _fd .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eedf *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_fdda :=MakeDict ();_fdda .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_eedf .GetFilterArray ());for _ ,_fdac :=range _eedf ._cgae {_bdfb :=_fdac .MakeStreamDict ();for _ ,_bfdd :=range _bdfb .Keys (){_gabf :=_bdfb .Get (_bfdd );if _bfdd !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_bfdd !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_fdda .Set (_bfdd ,_gabf );};};};_cbbb :=_eedf .MakeDecodeParams ();if _cbbb !=nil {_fdda .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cbbb );};return _fdda ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_cbccf *JBIG2Image )ToGoImage ()(_fa .Image ,error ){const _eafaa ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _cbccf .Data ==nil {return nil ,_ebc .Error (_eafaa ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _cbccf .Width ==0||_cbccf .Height ==0{return nil ,_ebc .Error (_eafaa ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_cgge ,_cdcd :=_efb .NewImage (_cbccf .Width ,_cbccf .Height ,1,1,_cbccf .Data ,nil ,nil );if _cdcd !=nil {return nil ,_cdcd ;};return _cgge ,nil ;};func (_bfgb *FlateEncoder )cleanImageData (_eeac []byte )([]byte ,error ){if _bfgb ._face ==nil {return _eeac ,nil ;};if _bfgb ._face .BitsPerComponent >=8{return _eeac ,nil ;};_faa :=_bfgb ._face .BitsPerComponent *_bfgb ._face .Width *_bfgb ._face .ColorComponents *_bfgb ._face .Height /8;_eeac =_eeac [:_faa ];var _bfge error ;_eeac ,_bfge =_efb .AddDataPadding (_bfgb ._face .Width ,_bfgb ._face .Height ,_bfgb ._face .BitsPerComponent ,_bfgb ._face .ColorComponents ,_eeac );if _bfge !=nil {return nil ,_bfge ;};return _eeac ,nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _bfagg _bf .Buffer ;_bfagg .Write ([]byte {0xFE,0xFF});_bfagg .WriteString (_bb .StringToUTF16 (s ));return &PdfObjectString {_fgce :_bfagg .String (),_fccb :true };};return &PdfObjectString {_fgce :string (_bb .StringToPDFDocEncoding (s )),_fccb :false };};func (_gbdf *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_accfd :=_gbdf ._aae .Discard (4);return PdfObjectNull {},_accfd ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_gcd *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_cc ,_bbc :=obj .(*PdfObjectReference );if !_bbc {return obj ,nil ;};_bae :=_gcd .GetFileOffset ();defer func (){_gcd .SetFileOffset (_bae )}();_ae ,_fdb :=_gcd .LookupByReference (*_cc );if _fdb !=nil {return nil ,_fdb ;};_dea ,_acf :=_ae .(*PdfIndirectObject );if !_acf {return _ae ,nil ;};_ae =_dea .PdfObject ;_ ,_bbc =_ae .(*PdfObjectReference );if _bbc {return _dea ,_fd .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _ae ,nil ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_ffc :=&PdfIndirectObject {};_ffc .PdfObject =obj ;return _ffc ;};

// UpdateParams updates the parameter values of the encoder.
func (_gace *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_face *_efb .ImageBase ;};func (_bfg *PdfCrypt )authenticate (_bcf []byte )(bool ,error ){_bfg ._dag =false ;_gab :=_bfg .securityHandler ();_cff ,_fad ,_eggc :=_gab .Authenticate (&_bfg ._dga ,_bcf );if _eggc !=nil {return false ,_eggc ;}else if _fad ==0||len (_cff )==0{return false ,nil ;};_bfg ._dag =true ;_bfg ._dbb =_cff ;return true ,nil ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_efd *FlateEncoder )SetPredictor (columns int ){_efd .Predictor =11;_efd .Columns =columns };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dfdb *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_eg .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_fgcag ,_fgbd :=NewEncoderFromStream (streamObj );if _fgbd !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_fgbd );return nil ,_fgbd ;};_eg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_fgcag );_gbce ,_fgbd :=_fgcag .DecodeStream (streamObj );if _fgbd !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_fgbd );return nil ,_fgbd ;};return _gbce ,nil ;};

// Remove removes an element specified by key.
func (_eeae *PdfObjectDictionary )Remove (key PdfObjectName ){_abbga :=-1;for _fabcd ,_cabd :=range _eeae ._effgc {if _cabd ==key {_abbga =_fabcd ;break ;};};if _abbga >=0{_eeae ._effgc =append (_eeae ._effgc [:_abbga ],_eeae ._effgc [_abbga +1:]...);delete (_eeae ._adfbf ,key );};};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_edcc :=MakeArray ();for _ ,_gaag :=range vals {_edcc .Append (MakeInteger (int64 (_gaag )));};return _edcc ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};func (_fdcce *PdfObjectFloat )String ()string {return _cb .Sprintf ("\u0025\u0066",*_fdcce )};

// String returns a string describing `stream`.
func (_eefd *PdfObjectStream )String ()string {return _cb .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_eefd .ObjectNumber ,_eefd .PdfObjectDictionary );};func (_gdee *PdfCrypt )generateParams (_dede ,_dcfa []byte )error {_cffg :=_gdee .securityHandler ();_eaa ,_adf :=_cffg .GenerateParams (&_gdee ._dga ,_dcfa ,_dede );if _adf !=nil {return _adf ;};_gdee ._dbb =_eaa ;return nil ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_gfcg *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_ddgcd ,_deeg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _deeg ==nil {_gfcg .BitsPerComponent =int (_ddgcd );};_ebeg ,_deeg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _deeg ==nil {_gfcg .Width =int (_ebeg );};_eafa ,_deeg :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _deeg ==nil {_gfcg .Height =int (_eafa );};_dddg ,_deeg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _deeg ==nil {_gfcg .ColorComponents =int (_dddg );};};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_gbbe []PdfObject };

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_cfed :=PdfObjectString {_fgce :s ,_fccb :true };return &_cfed ;};

// GetFilterName returns the name of the encoding filter.
func (_fegf *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };func (_bbga *PdfParser )skipSpaces ()(int ,error ){_cdae :=0;for {_eagc ,_eafd :=_bbga ._aae .ReadByte ();if _eafd !=nil {return 0,_eafd ;};if IsWhiteSpace (_eagc ){_cdae ++;}else {_bbga ._aae .UnreadByte ();break ;};};return _cdae ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cecc *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// GetFilterName returns the name of the encoding filter.
func (_eagd *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_efga *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ab .Globals ,error ){return _ab .DecodeGlobals (encoded );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbcc *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_adgc :=MakeDict ();_adgc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bbcc .GetFilterName ()));return _adgc ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_egbb *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_eg .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_ecga :=MakeDict ();_ecga ._ceece =_egbb ;_cefae ,_ :=_egbb ._aae .ReadByte ();if _cefae !='<'{return nil ,_fd .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_cefae ,_ =_egbb ._aae .ReadByte ();if _cefae !='<'{return nil ,_fd .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_egbb .skipSpaces ();_egbb .skipComments ();_dcbc ,_ebae :=_egbb ._aae .Peek (2);if _ebae !=nil {return nil ,_ebae ;};_eg .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_dcbc ),string (_dcbc ));if (_dcbc [0]=='>')&&(_dcbc [1]=='>'){_eg .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_egbb ._aae .ReadByte ();_egbb ._aae .ReadByte ();break ;};_eg .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_gfgg ,_ebae :=_egbb .parseName ();_eg .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_gfgg );if _ebae !=nil {_eg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_ebae );return nil ,_ebae ;};if len (_gfgg )> 4&&_gfgg [len (_gfgg )-4:]=="\u006e\u0075\u006c\u006c"{_eafg :=_gfgg [0:len (_gfgg )-4];_eg .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_gfgg );_eg .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_eafg );_egbb .skipSpaces ();_gcecd ,_ :=_egbb ._aae .Peek (1);if _gcecd [0]=='/'{_ecga .Set (_eafg ,MakeNull ());continue ;};};_egbb .skipSpaces ();_ebad ,_ebae :=_egbb .parseObject ();if _ebae !=nil {return nil ,_ebae ;};_ecga .Set (_gfgg ,_ebad );if _eg .Log .IsLogLevel (_eg .LogLevelTrace ){_eg .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_gfgg ,_ebad .String ());};};_eg .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _ecga ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gga *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_eaeb *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_eaeb .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// WriteString outputs the object as it is to be written to file.
func (_cceb *PdfObjectReference )WriteString ()string {var _aabaa _bd .Builder ;_aabaa .WriteString (_e .FormatInt (_cceb .ObjectNumber ,10));_aabaa .WriteString ("\u0020");_aabaa .WriteString (_e .FormatInt (_cceb .GenerationNumber ,10));_aabaa .WriteString ("\u0020\u0052");return _aabaa .String ();};

// GetFilterName returns the name of the encoding filter.
func (_dfdd *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_cbdg *_db .Document ;

// Globals are the JBIG2 global segments.
Globals _ab .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_decb *MultiEncoder )AddEncoder (encoder StreamEncoder ){_decb ._cgae =append (_decb ._cgae ,encoder );};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_dcad []PdfObject ;};func (_bgbf *PdfCrypt )decryptBytes (_cbg []byte ,_fab string ,_ada []byte )([]byte ,error ){_eg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_befb ,_feff :=_bgbf ._eabb [_fab ];if !_feff {return nil ,_cb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_fab );};return _befb .DecryptBytes (_cbg ,_ada );};func (_gdbc *ASCII85Encoder )base256Tobase85 (_add uint32 )[5]byte {_bgaa :=[5]byte {0,0,0,0,0};_cfd :=_add ;for _aeed :=0;_aeed < 5;_aeed ++{_dec :=uint32 (1);for _caeg :=0;_caeg < 4-_aeed ;_caeg ++{_dec *=85;};_effd :=_cfd /_dec ;_cfd =_cfd %_dec ;_bgaa [_aeed ]=byte (_effd );};return _bgaa ;};

// String returns a string describing `streams`.
func (_bfafa *PdfObjectStreams )String ()string {return _cb .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_bfafa .ObjectNumber );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dbcdff *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_gbcc :=MakeDict ();_gbcc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dbcdff .GetFilterName ()));return _gbcc ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_fdag *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_fdag ._dcad ){return _fd .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_fdag ._dcad [i ]=obj ;return nil ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_ccae *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _cfbe ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _bgfd :=_ccae .AddPageImage (img ,&_ccae .DefaultPageSettings );_bgfd !=nil {return nil ,_ebc .Wrap (_bgfd ,_cfbe ,"");};return _ccae .Encode ();};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_eef *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_cfc ,_ ,_fdf :=_eef .lookupByNumberWrapper (objNumber ,true );return _cfc ,_fdf ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_dgcge *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_dfef :=PdfIndirectObject {};_dfef ._bbed =_dgcge ;_eg .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_fgdb ,_bgfdf :=_dgcge ._aae .Peek (20);if _bgfdf !=nil {if _bgfdf !=_b .EOF {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_dfef ,_bgfdf ;};};_eg .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_fgdb ));_aabg :=_baca .FindStringSubmatchIndex (string (_fgdb ));if len (_aabg )< 6{if _bgfdf ==_b .EOF {return nil ,_bgfdf ;};_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_fgdb ));return &_dfef ,_fd .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dgcge ._aae .Discard (_aabg [0]);_eg .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_aabg );_ggca :=_aabg [1]-_aabg [0];_adbde :=make ([]byte ,_ggca );_ ,_bgfdf =_dgcge .ReadAtLeast (_adbde ,_ggca );if _bgfdf !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_bgfdf );return nil ,_bgfdf ;};_eg .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_adbde );_feae :=_baca .FindStringSubmatch (string (_adbde ));if len (_feae )< 3{_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_adbde ));return &_dfef ,_fd .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_gedc ,_ :=_e .Atoi (_feae [1]);_efee ,_ :=_e .Atoi (_feae [2]);_dfef .ObjectNumber =int64 (_gedc );_dfef .GenerationNumber =int64 (_efee );for {_gbbfe ,_cgfa :=_dgcge ._aae .Peek (2);if _cgfa !=nil {return &_dfef ,_cgfa ;};_eg .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_gbbfe ),string (_gbbfe ));if IsWhiteSpace (_gbbfe [0]){_dgcge .skipSpaces ();}else if _gbbfe [0]=='%'{_dgcge .skipComments ();}else if (_gbbfe [0]=='<')&&(_gbbfe [1]=='<'){_eg .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_dfef .PdfObject ,_cgfa =_dgcge .ParseDict ();_eg .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_cgfa );if _cgfa !=nil {return &_dfef ,_cgfa ;};_eg .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_gbbfe [0]=='/')||(_gbbfe [0]=='(')||(_gbbfe [0]=='[')||(_gbbfe [0]=='<'){_dfef .PdfObject ,_cgfa =_dgcge .parseObject ();if _cgfa !=nil {return &_dfef ,_cgfa ;};_eg .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _gbbfe [0]==']'{_eg .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_dgcge ._aae .Discard (1);}else {if _gbbfe [0]=='e'{_facebg ,_cgaef :=_dgcge .readTextLine ();if _cgaef !=nil {return nil ,_cgaef ;};if len (_facebg )>=6&&_facebg [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _gbbfe [0]=='s'{_gbbfe ,_ =_dgcge ._aae .Peek (10);if string (_gbbfe [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_abcc :=6;if len (_gbbfe )> 6{if IsWhiteSpace (_gbbfe [_abcc ])&&_gbbfe [_abcc ]!='\r'&&_gbbfe [_abcc ]!='\n'{_eg .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_abcc ++;};if _gbbfe [_abcc ]=='\r'{_abcc ++;if _gbbfe [_abcc ]=='\n'{_abcc ++;};}else if _gbbfe [_abcc ]=='\n'{_abcc ++;};};_dgcge ._aae .Discard (_abcc );_fffd ,_gbdff :=_dfef .PdfObject .(*PdfObjectDictionary );if !_gbdff {return nil ,_fd .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_eg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_fffd );_cfec ,_bdbfg :=_dgcge .traceStreamLength (_fffd .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _bdbfg !=nil {_eg .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_bdbfg );return nil ,_bdbfg ;};_eg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_cfec );_dfefd ,_gbef :=_cfec .(*PdfObjectInteger );if !_gbef {return nil ,_fd .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_baaa :=*_dfefd ;if _baaa < 0{return nil ,_fd .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_ebfda :=_dgcge .GetFileOffset ();_ffg :=_dgcge .xrefNextObjectOffset (_ebfda );if _ebfda +int64 (_baaa )> _ffg &&_ffg > _ebfda {_eg .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_ebfda +int64 (_baaa ));_eg .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_ffg );_cbbg :=_ffg -_ebfda -17;if _cbbg < 0{return nil ,_fd .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_eg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_cbbg );_baaa =PdfObjectInteger (_cbbg );_fffd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_cbbg ));};if int64 (_baaa )> _dgcge ._agb {_eg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_fd .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_adacc :=make ([]byte ,_baaa );_ ,_bdbfg =_dgcge .ReadAtLeast (_adacc ,int (_baaa ));if _bdbfg !=nil {_eg .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_adacc ),_adacc );_eg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bdbfg );return nil ,_bdbfg ;};_fgdgd :=PdfObjectStream {};_fgdgd .Stream =_adacc ;_fgdgd .PdfObjectDictionary =_dfef .PdfObject .(*PdfObjectDictionary );_fgdgd .ObjectNumber =_dfef .ObjectNumber ;_fgdgd .GenerationNumber =_dfef .GenerationNumber ;_fgdgd .PdfObjectReference ._bbed =_dgcge ;_dgcge .skipSpaces ();_dgcge ._aae .Discard (9);_dgcge .skipSpaces ();return &_fgdgd ,nil ;};};_dfef .PdfObject ,_cgfa =_dgcge .parseObject ();if _dfef .PdfObject ==nil {_eg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_dfef .PdfObject =MakeNull ();};return &_dfef ,_cgfa ;};};if _dfef .PdfObject ==nil {_eg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_dfef .PdfObject =MakeNull ();};_eg .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_dfef ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gcda *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_gdba *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _cgebb []float64 ;for _ ,_cbbbea :=range _gdba .Elements (){switch _cggda :=_cbbbea .(type ){case *PdfObjectInteger :_cgebb =append (_cgebb ,float64 (*_cggda ));case *PdfObjectFloat :_cgebb =append (_cgebb ,float64 (*_cggda ));default:return nil ,ErrTypeError ;};};return _cgebb ,nil ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_eg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_bgbd ,_ddge :=NewEncoderFromStream (streamObj );if _ddge !=nil {_eg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ddge );return _ddge ;};if _abgga ,_egda :=_bgbd .(*LZWEncoder );_egda {_abgga .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_eg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_bgbd );_cdca ,_ddge :=_bgbd .EncodeBytes (streamObj .Stream );if _ddge !=nil {_eg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ddge );return _ddge ;};streamObj .Stream =_cdca ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cdca ))));return nil ;};func _bfad ()string {return _eg .Version };const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// WriteString outputs the object as it is to be written to file.
func (_gdge *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_adgb *PdfObjectStream ,_fcee bool ){obj =ResolveReference (obj );_adgb ,_fcee =obj .(*PdfObjectStream );return _adgb ,_fcee ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_fbba :=_bf .NewReader ([]byte (txt ));_cbef :=&PdfParser {ObjCache :objectCache {},_bgfc :_fbba ,_aae :_ga .NewReader (_fbba ),_agb :int64 (len (txt )),_ebac :map[int64 ]bool {}};_cbef ._dceb .ObjectMap =make (map[int ]XrefObject );return _cbef ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;const JB2ImageAutoThreshold =-1.0;

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_cbdg :_db .InitEncodeDocument (false )}};

// String returns a descriptive information string about the encryption method used.
func (_geb *PdfCrypt )String ()string {if _geb ==nil {return "";};_gde :=_geb ._bdc .Filter +"\u0020\u002d\u0020";if _geb ._bdc .V ==0{_gde +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _geb ._bdc .V ==1{_gde +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _geb ._bdc .V ==2{_gde +=_cb .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_geb ._bdc .Length );}else if _geb ._bdc .V ==3{_gde +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _geb ._bdc .V >=4{_gde +=_cb .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_geb ._bed ,_geb ._cdf );_gde +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _dfe ,_bbbg :=range _geb ._eabb {_gde +=_cb .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_dfe ,_bbbg .Name (),_bbbg .KeyLength ());};};_bcd :=_geb .GetAccessPermissions ();_gde +=_cb .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_bcd );return _gde ;};func (_dgbe *PdfParser )readTextLine ()(string ,error ){var _ddeb _bf .Buffer ;for {_gaee ,_acce :=_dgbe ._aae .Peek (1);if _acce !=nil {_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_acce .Error ());return _ddeb .String (),_acce ;};if (_gaee [0]!='\r')&&(_gaee [0]!='\n'){_aabf ,_ :=_dgbe ._aae .ReadByte ();_ddeb .WriteByte (_aabf );}else {break ;};};return _ddeb .String (),nil ;};func (_abbg *PdfParser )parseBool ()(PdfObjectBool ,error ){_ebef ,_acfab :=_abbg ._aae .Peek (4);if _acfab !=nil {return PdfObjectBool (false ),_acfab ;};if (len (_ebef )>=4)&&(string (_ebef [:4])=="\u0074\u0072\u0075\u0065"){_abbg ._aae .Discard (4);return PdfObjectBool (true ),nil ;};_ebef ,_acfab =_abbg ._aae .Peek (5);if _acfab !=nil {return PdfObjectBool (false ),_acfab ;};if (len (_ebef )>=5)&&(string (_ebef [:5])=="\u0066\u0061\u006cs\u0065"){_abbg ._aae .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_fd .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_afbac *PdfObjectArray )Get (i int )PdfObject {if _afbac ==nil ||i >=len (_afbac ._gbbe )||i < 0{return nil ;};return _afbac ._gbbe [i ];};func _gfa (_egg PdfObject )(int64 ,int64 ,error ){if _gcc ,_feb :=_egg .(*PdfIndirectObject );_feb {return _gcc .ObjectNumber ,_gcc .GenerationNumber ,nil ;};if _bdd ,_gda :=_egg .(*PdfObjectStream );_gda {return _bdd .ObjectNumber ,_bdd .GenerationNumber ,nil ;};return 0,0,_fd .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};func (_fecd *PdfParser )inspect ()(map[string ]int ,error ){_eg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_eg .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_cegaba :=map[string ]int {};_gabfa :=0;_fbac :=0;var _gafb []int ;for _bbgd :=range _fecd ._dceb .ObjectMap {_gafb =append (_gafb ,_bbgd );};_g .Ints (_gafb );_edbca :=0;for _ ,_bagb :=range _gafb {_bdfe :=_fecd ._dceb .ObjectMap [_bagb ];if _bdfe .ObjectNumber ==0{continue ;};_gabfa ++;_eg .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_eg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_bdfe .ObjectNumber );_ebgf ,_bcabb :=_fecd .LookupByNumber (_bdfe .ObjectNumber );if _bcabb !=nil {_eg .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_bdfe .ObjectNumber ,_bcabb );_fbac ++;continue ;};_eg .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_ebgf );_cgbag ,_fbcc :=_ebgf .(*PdfIndirectObject );if _fbcc {_eg .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_bdfe .ObjectNumber ,_cgbag );_ccada ,_ffca :=_cgbag .PdfObject .(*PdfObjectDictionary );if _ffca {if _debe ,_bgegb :=_ccada .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bgegb {_egef :=string (*_debe );_eg .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_egef );_ ,_fgeb :=_cegaba [_egef ];if _fgeb {_cegaba [_egef ]++;}else {_cegaba [_egef ]=1;};}else if _bgbc ,_ddcc :=_ccada .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_ddcc {_ebadd :=string (*_bgbc );_eg .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_ebadd );_ ,_dcca :=_cegaba [_ebadd ];if _dcca {_cegaba [_ebadd ]++;}else {_cegaba [_ebadd ]=1;};};if _beccb ,_beda :=_ccada .Get ("\u0053").(*PdfObjectName );_beda &&*_beccb =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_cgfd :=_cegaba ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _cgfd {_cegaba ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_cegaba ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _bcac ,_dfgc :=_ebgf .(*PdfObjectStream );_dfgc {if _gdgb ,_ffbf :=_bcac .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ffbf {_eg .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_gdgb );_gdde :=string (*_gdgb );if _ ,_ddcaa :=_cegaba [_gdde ];_ddcaa {_cegaba [_gdde ]++;}else {_cegaba [_gdde ]=1;};};}else {_fbde ,_gfagd :=_ebgf .(*PdfObjectDictionary );if _gfagd {_ecfe ,_bbeec :=_fbde .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _bbeec {_degc :=string (*_ecfe );_eg .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_degc );_cegaba [_degc ]++;};};_eg .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_bdfe .ObjectNumber ,_ebgf );};_edbca ++;};_eg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_eg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_eg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_gabfa );_eg .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_fbac );for _daff ,_ggd :=range _cegaba {_eg .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_daff ,_ggd );};_eg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_fecd ._dceb .ObjectMap )< 1{_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_cb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_cbdga ,_fegedb :=_cegaba ["\u0046\u006f\u006e\u0074"];if !_fegedb ||_cbdga < 2{_eg .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_eg .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _cegaba ,nil ;};func (_dda *PdfParser )lookupObjectViaOS (_ba int ,_cgd int )(PdfObject ,error ){var _bbb *_bf .Reader ;var _da objectStream ;var _afe bool ;_da ,_afe =_dda ._adbb [_ba ];if !_afe {_fg ,_fbe :=_dda .LookupByNumber (_ba );if _fbe !=nil {_eg .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ba );return nil ,_fbe ;};_be ,_fdc :=_fg .(*PdfObjectStream );if !_fdc {return nil ,_fd .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _dda ._ggec !=nil &&!_dda ._ggec .isDecrypted (_be ){return nil ,_fd .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_df :=_be .PdfObjectDictionary ;_eg .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_df .String ());_ee ,_fdc :=_df .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_fdc {_eg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_fd .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _bd .ToLower (string (*_ee ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_fd .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_fdc :=_df .Get ("\u004e").(*PdfObjectInteger );if !_fdc {return nil ,_fd .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fc ,_fdc :=_df .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_fdc {return nil ,_fd .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_eg .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ee ,*N );_bac ,_fbe :=DecodeStream (_be );if _fbe !=nil {return nil ,_fbe ;};_eg .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_bac );_fda :=_dda .GetFileOffset ();defer func (){_dda .SetFileOffset (_fda )}();_bbb =_bf .NewReader (_bac );_dda ._aae =_ga .NewReader (_bbb );_eg .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_fe :=map[int ]int64 {};for _aff :=0;_aff < int (*N );_aff ++{_dda .skipSpaces ();_ff ,_egf :=_dda .parseNumber ();if _egf !=nil {return nil ,_egf ;};_de ,_eeb :=_ff .(*PdfObjectInteger );if !_eeb {return nil ,_fd .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_dda .skipSpaces ();_ff ,_egf =_dda .parseNumber ();if _egf !=nil {return nil ,_egf ;};_fdg ,_eeb :=_ff .(*PdfObjectInteger );if !_eeb {return nil ,_fd .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_eg .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_de ,*_fdg );_fe [int (*_de )]=int64 (*_fc +*_fdg );};_da =objectStream {N :int (*N ),_adg :_bac ,_cg :_fe };_dda ._adbb [_ba ]=_da ;}else {_ebe :=_dda .GetFileOffset ();defer func (){_dda .SetFileOffset (_ebe )}();_bbb =_bf .NewReader (_da ._adg );_dda ._aae =_ga .NewReader (_bbb );};_dg :=_da ._cg [_cgd ];_eg .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_cgd ,_dg );_bbb .Seek (_dg ,_fb .SEEK_SET );_dda ._aae =_ga .NewReader (_bbb );_ec ,_ :=_dda ._aae .Peek (100);_eg .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ec ));_ed ,_cf :=_dda .parseObject ();if _cf !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cf );return nil ,_cf ;};if _ed ==nil {return nil ,_fd .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_bg :=PdfIndirectObject {};_bg .ObjectNumber =int64 (_cgd );_bg .PdfObject =_ed ;return &_bg ,nil ;};func (_bcec *PdfParser )parseXrefStream (_baed *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _baed !=nil {_eg .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_baed );_bcec ._bgfc .Seek (int64 (*_baed ),_b .SeekStart );_bcec ._aae =_ga .NewReader (_bcec ._bgfc );};_fdce :=_bcec .GetFileOffset ();_dfae ,_bfcc :=_bcec .ParseIndirectObject ();if _bfcc !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_fd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_eg .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_dfae );_cfegc ,_ggga :=_dfae .(*PdfObjectStream );if !_ggga {_eg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_fd .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_cdbcg :=_cfegc .PdfObjectDictionary ;_ggfg ,_ggga :=_cfegc .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_ggga {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_fd .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_ggfg )> 8388607{_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_ggfg );return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_agg :=_cfegc .PdfObjectDictionary .Get ("\u0057");_afba ,_ggga :=_agg .(*PdfObjectArray );if !_ggga {return nil ,_fd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_abbc :=_afba .Len ();if _abbc !=3{_eg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_abbc );return nil ,_fd .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _ggbg []int64 ;for _gdgc :=0;_gdgc < 3;_gdgc ++{_gbbg ,_gbdg :=GetInt (_afba .Get (_gdgc ));if !_gbdg {return nil ,_fd .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_ggbg =append (_ggbg ,int64 (*_gbbg ));};_effg ,_bfcc :=DecodeStream (_cfegc );if _bfcc !=nil {_eg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_bfcc );return nil ,_bfcc ;};_gbbd :=int (_ggbg [0]);_cgeca :=int (_ggbg [0]+_ggbg [1]);_abgge :=int (_ggbg [0]+_ggbg [1]+_ggbg [2]);_eedbe :=int (_ggbg [0]+_ggbg [1]+_ggbg [2]);if _gbbd < 0||_cgeca < 0||_abgge < 0{_eg .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_gbbd ,_cgeca ,_abgge );return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _eedbe ==0{_eg .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _cdbcg ,nil ;};_edga :=len (_effg )/_eedbe ;_fgca :=0;_gaeag :=_cfegc .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _edab []int ;if _gaeag !=nil {_eg .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_gaeag );_dcab ,_ceda :=_gaeag .(*PdfObjectArray );if !_ceda {_eg .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_fd .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _dcab .Len ()%2!=0{_eg .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fgca =0;_adac ,_cdbg :=_dcab .ToIntegerArray ();if _cdbg !=nil {_eg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_cdbg );return nil ,_cdbg ;};for _geeg :=0;_geeg < len (_adac );_geeg +=2{_fead :=_adac [_geeg ];_aaee :=_adac [_geeg +1];for _gbaf :=0;_gbaf < _aaee ;_gbaf ++{_edab =append (_edab ,_fead +_gbaf );};_fgca +=_aaee ;};}else {for _bbcd :=0;_bbcd < int (*_ggfg );_bbcd ++{_edab =append (_edab ,_bbcd );};_fgca =int (*_ggfg );};if _edga ==_fgca +1{_eg .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_dbaf :=_fgca -1;for _ ,_cdff :=range _edab {if _cdff > _dbaf {_dbaf =_cdff ;};};_edab =append (_edab ,_dbaf +1);_fgca ++;};if _edga !=len (_edab ){_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_edga ,len (_edab ));return nil ,_fd .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_eg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_fgca );_eg .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_edab );_dabgg :=func (_cfcbc []byte )int64 {var _aeebg int64 ;for _cgab :=0;_cgab < len (_cfcbc );_cgab ++{_aeebg +=int64 (_cfcbc [_cgab ])*(1<<uint (8*(len (_cfcbc )-_cgab -1)));};return _aeebg ;};_eg .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_effg ));_cdfe :=0;for _geaab :=0;_geaab < len (_effg );_geaab +=_eedbe {_acdg :=_eaca (len (_effg ),_geaab ,_geaab +_gbbd );if _acdg !=nil {_eg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_acdg );return nil ,_acdg ;};_eecb :=_effg [_geaab :_geaab +_gbbd ];_acdg =_eaca (len (_effg ),_geaab +_gbbd ,_geaab +_cgeca );if _acdg !=nil {_eg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_acdg );return nil ,_acdg ;};_aca :=_effg [_geaab +_gbbd :_geaab +_cgeca ];_acdg =_eaca (len (_effg ),_geaab +_cgeca ,_geaab +_abgge );if _acdg !=nil {_eg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_acdg );return nil ,_acdg ;};_aede :=_effg [_geaab +_cgeca :_geaab +_abgge ];_dgbg :=_dabgg (_eecb );_edfec :=_dabgg (_aca );_agd :=_dabgg (_aede );if _ggbg [0]==0{_dgbg =1;};if _cdfe >=len (_edab ){_eg .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_eabdg :=_edab [_cdfe ];_cdfe ++;_eg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_eabdg ,_eecb );_eg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_eabdg ,_aca );_eg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_eabdg ,_aede );_eg .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_eabdg ,_dgbg ,_edfec ,_agd );if _dgbg ==0{_eg .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _dgbg ==1{_eg .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_aca );if _edfec ==_fdce {_eg .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_eabdg ,_cfegc .ObjectNumber );_eabdg =int (_cfegc .ObjectNumber );};if _feec ,_degf :=_bcec ._dceb .ObjectMap [_eabdg ];!_degf ||int (_agd )> _feec .Generation {_dbcde :=XrefObject {ObjectNumber :_eabdg ,XType :XrefTypeTableEntry ,Offset :_edfec ,Generation :int (_agd )};_bcec ._dceb .ObjectMap [_eabdg ]=_dbcde ;};}else if _dgbg ==2{_eg .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_abddc :=_bcec ._dceb .ObjectMap [_eabdg ];!_abddc {_cbga :=XrefObject {ObjectNumber :_eabdg ,XType :XrefTypeObjectStream ,OsObjNumber :int (_edfec ),OsObjIndex :int (_agd )};_bcec ._dceb .ObjectMap [_eabdg ]=_cbga ;_eg .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_cbga );};}else {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _bcec ._febf ==nil {_bdbfb :=XrefTypeObjectStream ;_bcec ._febf =&_bdbfb ;};return _cdbcg ,nil ;};var (ErrUnsupportedEncodingParameters =_fd .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_fd .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_fd .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_fd .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_fd .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_fd .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_fd .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_fd .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_ffgd string ,_fgfe bool ){_afg ,_fgfe :=TraceToDirectObject (obj ).(*PdfObjectName );if _fgfe {return string (*_afg ),true ;};return ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aefe *LZWEncoder )MakeDecodeParams ()PdfObject {if _aefe .Predictor > 1{_bfb :=MakeDict ();_bfb .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_aefe .Predictor )));if _aefe .BitsPerComponent !=8{_bfb .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_aefe .BitsPerComponent )));};if _aefe .Columns !=1{_bfb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_aefe .Columns )));};if _aefe .Colors !=1{_bfb .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_aefe .Colors )));};return _bfb ;};return nil ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_gb .Model ;Bounds ()_fa .Rectangle ;At (_bfa ,_fggeg int )_gb .Color ;Set (_dcfd ,_ebdd int ,_afbd _gb .Color );};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_faac *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _faac .Predictor !=1{return nil ,_cb .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _faac .EarlyChange ==1{return nil ,_cb .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _fbed _bf .Buffer ;_edfb :=_gf .NewWriter (&_fbed ,_gf .MSB ,8);_edfb .Write (data );_edfb .Close ();return _fbed .Bytes (),nil ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_dcbbac Version )String ()string {return _cb .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_dcbbac .Major ,_dcbbac .Minor );};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_efdf string ,_agcfg bool ){_cffd ,_agcfg :=TraceToDirectObject (obj ).(*PdfObjectString );if _agcfg {return _cffd .Str (),true ;};return ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _cced :=obj .(type ){case *PdfObjectFloat :return float64 (*_cced ),nil ;case *PdfObjectInteger :return float64 (*_cced ),nil ;};return 0,ErrNotANumber ;};

// UpdateParams updates the parameter values of the encoder.
func (_ddddc *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _dcbb ,_bbgb :=GetNumberAsInt64 (params .Get ("\u004b"));_bbgb ==nil {_ddddc .K =int (_dcbb );};if _adag ,_gefa :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_gefa ==nil {_ddddc .Columns =int (_adag );}else if _adag ,_gefa =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_gefa ==nil {_ddddc .Columns =int (_adag );};if _agae ,_befea :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_befea ==nil {_ddddc .BlackIs1 =_agae > 0;}else {if _dbge ,_aagd :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_aagd {_ddddc .BlackIs1 =_dbge ;}else {if _ddeg ,_aafg :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_aafg {_ccgc ,_dfed :=_ddeg .ToIntegerArray ();if _dfed ==nil {_ddddc .BlackIs1 =_ccgc [0]==1&&_ccgc [1]==0;};};};};if _fgef ,_fcab :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_fcab ==nil {_ddddc .EncodedByteAlign =_fgef > 0;}else {if _bbde ,_dcbba :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_dcbba {_ddddc .EncodedByteAlign =_bbde ;};};if _baacc ,_cdc :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cdc ==nil {_ddddc .EndOfLine =_baacc > 0;}else {if _ffaf ,_acfa :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_acfa {_ddddc .EndOfLine =_ffaf ;};};if _fdabe ,_ffd :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_ffd ==nil {_ddddc .Rows =int (_fdabe );}else if _fdabe ,_ffd =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_ffd ==nil {_ddddc .Rows =int (_fdabe );};if _eada ,_dgbd :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dgbd ==nil {_ddddc .EndOfBlock =_eada > 0;}else {if _agcd ,_faga :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_faga {_ddddc .EndOfBlock =_agcd ;};};if _fdbe ,_ecac :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_ecac !=nil {_ddddc .DamagedRowsBeforeError =int (_fdbe );};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_efbe *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_efbe ._cgae )==0{return nil ;};if len (_efbe ._cgae )==1{return _efbe ._cgae [0].MakeDecodeParams ();};_gecd :=MakeArray ();for _ ,_fggd :=range _efbe ._cgae {_dabg :=_fggd .MakeDecodeParams ();if _dabg ==nil {_gecd .Append (MakeNull ());}else {_gecd .Append (_dabg );};};return _gecd ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_ad .FilterDict ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_agcf *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_agcf ._bgfc .Seek (offset ,_b .SeekStart );_agcf ._aae =_ga .NewReader (_agcf ._bgfc );};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};func (_eeca *PdfCrypt )encryptBytes (_bcdf []byte ,_dddd string ,_dgff []byte )([]byte ,error ){_eg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_eac ,_afff :=_eeca ._eabb [_dddd ];if !_afff {return nil ,_cb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dddd );};return _eac .EncryptBytes (_bcdf ,_dgff );};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};func (_dceg *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _dceg ._bcdfg {return nil ,_cb .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_dceg ._bcdfg =true ;_dceg ._bgfc .Seek (0,_fb .SEEK_SET );_dceg ._aae =_ga .NewReader (_dceg ._bgfc );_fdcd :=20;_bdeb :=make ([]byte ,_fdcd );_gdgeg :=XrefTable {};_gdgeg .ObjectMap =make (map[int ]XrefObject );for {_bbee ,_gggag :=_dceg ._aae .ReadByte ();if _gggag !=nil {if _gggag ==_b .EOF {break ;}else {return nil ,_gggag ;};};if _bbee =='j'&&_bdeb [_fdcd -1]=='b'&&_bdeb [_fdcd -2]=='o'&&IsWhiteSpace (_bdeb [_fdcd -3]){_eefae :=_fdcd -4;for IsWhiteSpace (_bdeb [_eefae ])&&_eefae > 0{_eefae --;};if _eefae ==0||!IsDecimalDigit (_bdeb [_eefae ]){continue ;};for IsDecimalDigit (_bdeb [_eefae ])&&_eefae > 0{_eefae --;};if _eefae ==0||!IsWhiteSpace (_bdeb [_eefae ]){continue ;};for IsWhiteSpace (_bdeb [_eefae ])&&_eefae > 0{_eefae --;};if _eefae ==0||!IsDecimalDigit (_bdeb [_eefae ]){continue ;};for IsDecimalDigit (_bdeb [_eefae ])&&_eefae > 0{_eefae --;};if _eefae ==0{continue ;};_dged :=_dceg .GetFileOffset ()-int64 (_fdcd -_eefae );_faege :=append (_bdeb [_eefae +1:],_bbee );_gbfgb ,_gfaa ,_efaeg :=_cedg (string (_faege ));if _efaeg !=nil {_eg .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_efaeg );return nil ,_efaeg ;};if _eegb ,_efeab :=_gdgeg .ObjectMap [_gbfgb ];!_efeab ||_eegb .Generation < _gfaa {_fbee :=XrefObject {};_fbee .XType =XrefTypeTableEntry ;_fbee .ObjectNumber =int (_gbfgb );_fbee .Generation =int (_gfaa );_fbee .Offset =_dged ;_gdgeg .ObjectMap [_gbfgb ]=_fbee ;};};_bdeb =append (_bdeb [1:_fdcd ],_bbee );};return &_gdgeg ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_fcegb *PdfObjectStreams )Elements ()[]PdfObject {if _fcegb ==nil {return nil ;};return _fcegb ._dcad ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _aced (obj ,0)};

// WriteString outputs the object as it is to be written to file.
func (_accfa *PdfObjectStream )WriteString ()string {var _gdcb _bd .Builder ;_gdcb .WriteString (_e .FormatInt (_accfa .ObjectNumber ,10));_gdcb .WriteString ("\u0020\u0030\u0020\u0052");return _gdcb .String ();};const _faec =32<<(^uint (0)>>63);func (_cecee *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _aacg =20;_ebcf ,_ :=_cecee ._aae .Peek (_aacg );for _dgfa :=0;_dgfa < 2;_dgfa ++{if _cecee ._fdbef ==0{_cecee ._fdbef =_cecee .GetFileOffset ();};if _baca .Match (_ebcf ){_eg .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_eg .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_ebcf ));return _cecee .parseXrefStream (nil );};if _bccc .Match (_ebcf ){_eg .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _cecee .parseXrefTable ();};_cceg :=_cecee .GetFileOffset ();if _cecee ._fdbef ==0{_cecee ._fdbef =_cceg ;};_cecee .SetFileOffset (_cceg -_aacg );defer _cecee .SetFileOffset (_cceg );_fbgg ,_ :=_cecee ._aae .Peek (_aacg );_ebcf =append (_fbgg ,_ebcf ...);};_eg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _dbfa :=_cecee .repairSeekXrefMarker ();_dbfa !=nil {_eg .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_dbfa );return nil ,_dbfa ;};return _cecee .parseXrefTable ();};

// GetXrefTable returns the PDFs xref table.
func (_agcac *PdfParser )GetXrefTable ()XrefTable {return _agcac ._dceb };func (_bfdfg *PdfObjectInteger )String ()string {return _cb .Sprintf ("\u0025\u0064",*_bfdfg )};

// UpdateParams updates the parameter values of the encoder.
func (_ccgcg *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};var _baca =_dd .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_dfgg :=PdfObjectNull {};return &_dfgg };

// Append appends PdfObject(s) to the streams.
func (_fdccc *PdfObjectStreams )Append (objects ...PdfObject ){if _fdccc ==nil {_eg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _fdccc ._dcad ==nil {_fdccc ._dcad =[]PdfObject {};};for _ ,_baga :=range objects {_fdccc ._dcad =append (_fdccc ._dcad ,_baga );};};func _ceeb (_eaac *PdfObjectStream ,_acfba *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _gcae ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_bfbb :=&JBIG2Encoder {};_acge :=_eaac .PdfObjectDictionary ;if _acge ==nil {return _bfbb ,nil ;};if _acfba ==nil {_aegc :=_acge .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _aegc !=nil {switch _ddfg :=_aegc .(type ){case *PdfObjectDictionary :_acfba =_ddfg ;case *PdfObjectArray :if _ddfg .Len ()==1{if _dafb ,_fcaf :=GetDict (_ddfg .Get (0));_fcaf {_acfba =_dafb ;};};default:_eg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_aegc );return nil ,_ebc .Errorf (_gcae ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_ddfg );};};};if _acfba ==nil {return _bfbb ,nil ;};_bfbb .UpdateParams (_acfba );_ccfe :=_acfba .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _ccfe ==nil {return _bfbb ,nil ;};var _ebfd error ;_bdaa ,_faacf :=_ccfe .(*PdfObjectStream );if !_faacf {_ebfd =_ebc .Error (_gcae ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_eg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ebfd );return nil ,_ebfd ;};_bfbb .Globals ,_ebfd =_ab .DecodeGlobals (_bdaa .Stream );if _ebfd !=nil {_ebfd =_ebc .Wrap (_ebfd ,_gcae ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_eg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ebfd );return nil ,_ebfd ;};return _bfbb ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fdfb *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_ecec :=MakeDict ();_ecec .Set ("\u004b",MakeInteger (int64 (_fdfb .K )));_ecec .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fdfb .Columns )));if _fdfb .BlackIs1 {_ecec .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_fdfb .BlackIs1 ));};if _fdfb .EncodedByteAlign {_ecec .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_fdfb .EncodedByteAlign ));};if _fdfb .EndOfLine &&_fdfb .K >=0{_ecec .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_fdfb .EndOfLine ));};if _fdfb .Rows !=0&&!_fdfb .EndOfBlock {_ecec .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_fdfb .Rows )));};if !_fdfb .EndOfBlock {_ecec .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_fdfb .EndOfBlock ));};if _fdfb .DamagedRowsBeforeError !=0{_ecec .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_fdfb .DamagedRowsBeforeError )));};return _ecec ;};func _aced (_ceca PdfObject ,_fbbc int )PdfObject {if _fbbc > _faegd {_eg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_faegd );return MakeNull ();};switch _eagf :=_ceca .(type ){case *PdfIndirectObject :_ceca =_aced ((*_eagf ).PdfObject ,_fbbc +1);case *PdfObjectArray :for _geag ,_afdcg :=range (*_eagf )._gbbe {(*_eagf )._gbbe [_geag ]=_aced (_afdcg ,_fbbc +1);};case *PdfObjectDictionary :for _gadf ,_ggeeg :=range (*_eagf )._adfbf {(*_eagf )._adfbf [_gadf ]=_aced (_ggeeg ,_fbbc +1);};_g .Slice ((*_eagf )._effgc ,func (_gdbcg ,_bgdff int )bool {return (*_eagf )._effgc [_gdbcg ]< (*_eagf )._effgc [_bgdff ]});};return _ceca ;};

// UpdateParams updates the parameter values of the encoder.
func (_eaab *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_deff :=range _eaab ._cgae {_deff .UpdateParams (params );};};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_cfaf *PdfObjectFloat ,_effe bool ){_cfaf ,_effe =TraceToDirectObject (obj ).(*PdfObjectFloat );return _cfaf ,_effe ;};

// Append appends PdfObject(s) to the array.
func (_babaa *PdfObjectArray )Append (objects ...PdfObject ){if _babaa ==nil {_eg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _babaa ._gbbe ==nil {_babaa ._gbbe =[]PdfObject {};};for _ ,_fcfg :=range objects {_babaa ._gbbe =append (_babaa ._gbbe ,_fcfg );};};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_cffb :=&FlateEncoder {};_cffb .Predictor =1;_cffb .BitsPerComponent =8;_cffb .Colors =1;_cffb .Columns =1;return _cffb ;};

// UpdateParams updates the parameter values of the encoder.
func (_fca *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_aeb ,_acfd :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _acfd ==nil {_fca .Predictor =int (_aeb );};_befe ,_acfd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _acfd ==nil {_fca .BitsPerComponent =int (_befe );};_gfda ,_acfd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _acfd ==nil {_fca .Columns =int (_gfda );};_eacg ,_acfd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _acfd ==nil {_fca .Colors =int (_eacg );};};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_aef *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_eg .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_bafd :=_bf .NewReader (encoded );_ceb ,_acb :=_eb .NewReader (_bafd );if _acb !=nil {_eg .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_acb );_eg .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_acb ;};defer _ceb .Close ();var _dba _bf .Buffer ;_dba .ReadFrom (_ceb );return _dba .Bytes (),nil ;};func (_efc *PdfCrypt )isDecrypted (_cdb PdfObject )bool {_ ,_deb :=_efc ._daa [_cdb ];if _deb {_eg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _ggcb :=_cdb .(type ){case *PdfObjectStream :if _efc ._dga .R !=5{if _abg ,_dde :=_ggcb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dde &&*_abg =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_deb =_efc ._ded [int (_ggcb .ObjectNumber )];_deb {return true ;};switch _ccee :=_ggcb .PdfObject .(type ){case *PdfObjectDictionary :_gae :=true ;for _ ,_fbf :=range _bedd {if _ccee .Get (_fbf )==nil {_gae =false ;break ;};};if _gae {return true ;};};};_eg .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// Len returns the number of elements in the array.
func (_ecgd *PdfObjectArray )Len ()int {if _ecgd ==nil {return 0;};return len (_ecgd ._gbbe );};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_edce :=&PdfObjectDictionary {};_edce ._adfbf =map[PdfObjectName ]PdfObject {};_edce ._effgc =[]PdfObjectName {};return _edce ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgba *FlateEncoder )MakeDecodeParams ()PdfObject {if _fgba .Predictor > 1{_gdbf :=MakeDict ();_gdbf .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_fgba .Predictor )));if _fgba .BitsPerComponent !=8{_gdbf .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_fgba .BitsPerComponent )));};if _fgba .Columns !=1{_gdbf .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fgba .Columns )));};if _fgba .Colors !=1{_gdbf .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_fgba .Colors )));};return _gdbf ;};return nil ;};

// String returns the state of the bool as "true" or "false".
func (_ffbc *PdfObjectBool )String ()string {if *_ffbc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// LookupByReference looks up a PdfObject by a reference.
func (_eebg *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_eg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _eebg .LookupByNumber (int (ref .ObjectNumber ));};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_fgce string ;_fccb bool ;};

// String returns a string describing `null`.
func (_fedfa *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};type objectStreams map[int ]objectStream ;

// UpdateParams updates the parameter values of the encoder.
func (_gdg *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_beed ,_ecg :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ecg ==nil {_gdg .Predictor =int (_beed );};_gagbd ,_ecg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ecg ==nil {_gdg .BitsPerComponent =int (_gagbd );};_cca ,_ecg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ecg ==nil {_gdg .Columns =int (_cca );};_baag ,_ecg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ecg ==nil {_gdg .Colors =int (_baag );};_acc ,_ecg :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _ecg ==nil {_gdg .EarlyChange =int (_acc );};};var _cgfb =_dd .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// WriteString outputs the object as it is to be written to file.
func (_ccfg *PdfObjectDictionary )WriteString ()string {var _gedaf _bd .Builder ;_gedaf .WriteString ("\u003c\u003c");for _ ,_bbca :=range _ccfg ._effgc {_edbe :=_ccfg ._adfbf [_bbca ];_gedaf .WriteString (_bbca .WriteString ());_gedaf .WriteString ("\u0020");_gedaf .WriteString (_edbe .WriteString ());};_gedaf .WriteString ("\u003e\u003e");return _gedaf .String ();};

// WriteString outputs the object as it is to be written to file.
func (_ggge *PdfObjectFloat )WriteString ()string {return _e .FormatFloat (float64 (*_ggge ),'f',-1,64);};func (_faf *PdfCrypt )checkAccessRights (_bde []byte )(bool ,_dc .Permissions ,error ){_fgec :=_faf .securityHandler ();_bga ,_cgdc ,_fbc :=_fgec .Authenticate (&_faf ._dga ,_bde );if _fbc !=nil {return false ,0,_fbc ;}else if _cgdc ==0||len (_bga )==0{return false ,0,nil ;};return true ,_cgdc ,nil ;};

// String returns a string representation of `name`.
func (_aaag *PdfObjectName )String ()string {return string (*_aaag )};func (_aaff *PdfParser )parseName ()(PdfObjectName ,error ){var _ecff _bf .Buffer ;_cdefb :=false ;for {_cbbbe ,_aaab :=_aaff ._aae .Peek (1);if _aaab ==_b .EOF {break ;};if _aaab !=nil {return PdfObjectName (_ecff .String ()),_aaab ;};if !_cdefb {if _cbbbe [0]=='/'{_cdefb =true ;_aaff ._aae .ReadByte ();}else if _cbbbe [0]=='%'{_aaff .readComment ();_aaff .skipSpaces ();}else {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_cbbbe ,_cbbbe );return PdfObjectName (_ecff .String ()),_cb .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_cbbbe [0]);};}else {if IsWhiteSpace (_cbbbe [0]){break ;}else if (_cbbbe [0]=='/')||(_cbbbe [0]=='[')||(_cbbbe [0]=='(')||(_cbbbe [0]==']')||(_cbbbe [0]=='<')||(_cbbbe [0]=='>'){break ;}else if _cbbbe [0]=='#'{_dgd ,_bgff :=_aaff ._aae .Peek (3);if _bgff !=nil {return PdfObjectName (_ecff .String ()),_bgff ;};_abd ,_bgff :=_c .DecodeString (string (_dgd [1:3]));if _bgff !=nil {_eg .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_ecff .WriteByte ('#');_aaff ._aae .Discard (1);continue ;};_aaff ._aae .Discard (3);_ecff .Write (_abd );}else {_efcc ,_ :=_aaff ._aae .ReadByte ();_ecff .WriteByte (_efcc );};};};return PdfObjectName (_ecff .String ()),nil ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_gcbb :=PdfObjectInteger (val );return &_gcbb };func _dcdg (_adae string )(PdfObjectReference ,error ){_bgfeb :=PdfObjectReference {};_adfb :=_gcec .FindStringSubmatch (string (_adae ));if len (_adfb )< 3{_eg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _bgfeb ,_fd .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_ccfa ,_ :=_e .Atoi (_adfb [1]);_dcec ,_ :=_e .Atoi (_adfb [2]);_bgfeb .ObjectNumber =int64 (_ccfa );_bgfeb .GenerationNumber =int64 (_dcec );return _bgfeb ,nil ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_fgg :=&PdfCrypt {_dag :false ,_daa :make (map[PdfObject ]bool ),_abc :make (map[PdfObject ]bool ),_ded :make (map[int ]struct{}),_ggg :parser };_ddbf ,_fcfd :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_fcfd {_eg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _fgg ,_fd .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_ddbf !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_eg .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_ddbf );return _fgg ,_fd .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_fgg ._bdc .Filter =string (*_ddbf );if _bad ,_cage :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_cage {_fgg ._bdc .SubFilter =_bad .Str ();_eg .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_bad );};if L ,_acfb :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_acfb {if (*L %8)!=0{_eg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _fgg ,_fd .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_fgg ._bdc .Length =int (*L );}else {_fgg ._bdc .Length =40;};_fgg ._bdc .V =0;if _ddg ,_dbc :=ed .Get ("\u0056").(*PdfObjectInteger );_dbc {V :=int (*_ddg );_fgg ._bdc .V =V ;if V >=1&&V <=2{_fgg ._eabb =_bab (_fgg ._bdc .Length );}else if V >=4&&V <=5{if _fac :=_fgg .loadCryptFilters (ed );_fac !=nil {return _fgg ,_fac ;};}else {_eg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _fgg ,_fd .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _eggg :=_gee (&_fgg ._dga ,ed );_eggg !=nil {return _fgg ,_eggg ;};_gce :="";if _ddbd ,_caf :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_caf &&_ddbd .Len ()>=1{_dfea ,_dffc :=GetString (_ddbd .Get (0));if !_dffc {return _fgg ,_fd .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_gce =_dfea .Str ();}else {_eg .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_fgg ._eeg =_gce ;return _fgg ,nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_cgae []StreamEncoder };

// PdfVersion returns version of the PDF file.
func (_fdfe *PdfParser )PdfVersion ()Version {return _fdfe ._bbdb };

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_gaffa *PdfParser )Inspect ()(map[string ]int ,error ){return _gaffa .inspect ()};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_fece *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _gcgd [][]byte ;for _ebdcd :=0;_ebdcd < len (data );_ebdcd +=_fece .Columns {_agac :=make ([]byte ,_fece .Columns );_gefd :=0;for _gffa :=0;_gffa < _fece .Columns ;_gffa ++{if data [_ebdcd +_gffa ]==255{_agac [_gefd ]=1;}else {_agac [_gefd ]=0;};_gefd ++;};_gcgd =append (_gcgd ,_agac );};_eeaa :=&_af .Encoder {K :_fece .K ,Columns :_fece .Columns ,EndOfLine :_fece .EndOfLine ,EndOfBlock :_fece .EndOfBlock ,BlackIs1 :_fece .BlackIs1 ,DamagedRowsBeforeError :_fece .DamagedRowsBeforeError ,Rows :_fece .Rows ,EncodedByteAlign :_fece .EncodedByteAlign };return _eeaa .Encode (_gcgd ),nil ;};