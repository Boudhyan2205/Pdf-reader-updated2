//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_db "bufio";_cc "bytes";_edg "compress/lzw";_ga "compress/zlib";_fgd "crypto/md5";_a "crypto/rand";_fe "encoding/hex";_f "errors";_ca "fmt";_gc "github.com/unidoc/unipdf/v3/common";_ae "github.com/unidoc/unipdf/v3/core/security";_cbg "github.com/unidoc/unipdf/v3/core/security/crypt";
_af "github.com/unidoc/unipdf/v3/internal/ccittfax";_fb "github.com/unidoc/unipdf/v3/internal/imageutil";_cb "github.com/unidoc/unipdf/v3/internal/jbig2";_fa "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ee "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";
_dda "github.com/unidoc/unipdf/v3/internal/jbig2/document";_bfb "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ac "github.com/unidoc/unipdf/v3/internal/strutils";_bb "golang.org/x/image/tiff/lzw";_ce "golang.org/x/xerrors";_d "image";_b "image/color";
_ed "image/jpeg";_dd "io";_e "reflect";_ea "regexp";_ef "sort";_g "strconv";_fd "strings";_fg "sync";_bf "time";);func _abdc (_fdf *_ae .StdEncryptDict ,_dgc *PdfObjectDictionary ){_dgc .Set ("\u0052",MakeInteger (int64 (_fdf .R )));_dgc .Set ("\u0050",MakeInteger (int64 (_fdf .P )));
_dgc .Set ("\u004f",MakeStringFromBytes (_fdf .O ));_dgc .Set ("\u0055",MakeStringFromBytes (_fdf .U ));if _fdf .R >=5{_dgc .Set ("\u004f\u0045",MakeStringFromBytes (_fdf .OE ));_dgc .Set ("\u0055\u0045",MakeStringFromBytes (_fdf .UE ));_dgc .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_fdf .EncryptMetadata ));
if _fdf .R > 5{_dgc .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_fdf .Perms ));};};};

// String returns a descriptive information string about the encryption method used.
func (_aae *PdfCrypt )String ()string {if _aae ==nil {return "";};_acec :=_aae ._be .Filter +"\u0020\u002d\u0020";if _aae ._be .V ==0{_acec +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _aae ._be .V ==1{_acec +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _aae ._be .V ==2{_acec +=_ca .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_aae ._be .Length );}else if _aae ._be .V ==3{_acec +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _aae ._be .V >=4{_acec +=_ca .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_aae ._aba ,_aae ._gfeb );
_acec +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _eece ,_afa :=range _aae ._aaa {_acec +=_ca .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_eece ,_afa .Name (),_afa .KeyLength ());
};};_bdf :=_aae .GetAccessPermissions ();_acec +=_ca .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_bdf );return _acec ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_aaca *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bcaae _d .Image ;if _aaca .ColorComponents ==1&&_aaca .BitsPerComponent ==8{_bcaae =&_d .Gray {Rect :_d .Rect (0,0,_aaca .Width ,_aaca .Height ),Pix :data ,Stride :_fb .BytesPerLine (_aaca .Width ,_aaca .BitsPerComponent ,_aaca .ColorComponents )};
}else {var _abg error ;_bcaae ,_abg =_fb .NewImage (_aaca .Width ,_aaca .Height ,_aaca .BitsPerComponent ,_aaca .ColorComponents ,data ,nil ,nil );if _abg !=nil {return nil ,_abg ;};};_cdca :=_ed .Options {};_cdca .Quality =_aaca .Quality ;var _eebg _cc .Buffer ;
if _adfd :=_ed .Encode (&_eebg ,_bcaae ,&_cdca );_adfd !=nil {return nil ,_adfd ;};return _eebg .Bytes (),nil ;};func _cdcbe (_eaff ,_gdfc ,_fgfd uint8 )uint8 {_bgaf :=int (_fgfd );_bgba :=int (_gdfc )-_bgaf ;_dcea :=int (_eaff )-_bgaf ;_bgaf =_gdfba (_bgba +_dcea );
_bgba =_gdfba (_bgba );_dcea =_gdfba (_dcea );if _bgba <=_dcea &&_bgba <=_bgaf {return _eaff ;}else if _dcea <=_bgaf {return _gdfc ;};return _fgfd ;};var _eegg =_ea .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");


// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bca *PdfCrypt )GetAccessPermissions ()_ae .Permissions {return _bca ._bbc .P };var _ece =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};func (_ebddc *PdfParser )parseArray ()(*PdfObjectArray ,error ){_fddgb :=MakeArray ();_ebddc ._ceecd .ReadByte ();
for {_ebddc .skipSpaces ();_bcgf ,_ffee :=_ebddc ._ceecd .Peek (1);if _ffee !=nil {return _fddgb ,_ffee ;};if _bcgf [0]==']'{_ebddc ._ceecd .ReadByte ();break ;};_fcb ,_ffee :=_ebddc .parseObject ();if _ffee !=nil {return _fddgb ,_ffee ;};_fddgb .Append (_fcb );
};return _fddgb ,nil ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_gbgg :objects };};func _bdc (_febgd *PdfObjectStream ,_beae *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _gbbdf ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";
_gcgde :=NewJBIG2Encoder ();_gfee :=_febgd .PdfObjectDictionary ;if _gfee ==nil {return _gcgde ,nil ;};if _beae ==nil {_ccbg :=_gfee .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _ccbg !=nil {switch _dgac :=_ccbg .(type ){case *PdfObjectDictionary :_beae =_dgac ;
case *PdfObjectArray :if _dgac .Len ()==1{if _cdfa ,_eebf :=GetDict (_dgac .Get (0));_eebf {_beae =_cdfa ;};};default:_gc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_ccbg );
return nil ,_bfb .Errorf (_gbbdf ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_dgac );};};};if _beae ==nil {return _gcgde ,nil ;};_gcgde .UpdateParams (_beae );
_eafe ,_eceb :=GetStream (_beae .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_eceb {return _gcgde ,nil ;};var _dbed error ;_gcgde .Globals ,_dbed =_cb .DecodeGlobals (_eafe .Stream );if _dbed !=nil {_dbed =_bfb .Wrap (_dbed ,_gbbdf ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_gc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dbed );return nil ,_dbed ;};return _gcgde ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_adfa *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};func _ebbee (_gcgga _fb .Image )*JBIG2Image {_fbea :=_gcgga .Base ();return &JBIG2Image {Data :_fbea .Data ,Width :_fbea .Width ,Height :_fbea .Height ,HasPadding :true };};

// HeaderPosition gets the file header position.
func (_ebba *parserMetadata )HeaderPosition ()int {return _ebba ._deggf };

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_ecc *PdfObjectDictionary );EncodeBytes (_gffda []byte )([]byte ,error );DecodeBytes (_fbdc []byte )([]byte ,error );
DecodeStream (_dde *PdfObjectStream )([]byte ,error );};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_dcfd *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_dcfd ._gbgg ){return _f .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_dcfd ._gbgg [i ]=obj ;return nil ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ggcf *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _gcggd []int ;for _ ,_bfcb :=range _ggcf .Elements (){if _edab ,_cefc :=_bfcb .(*PdfObjectInteger );_cefc {_gcggd =append (_gcggd ,int (*_edab ));}else {return nil ,ErrTypeError ;};};return _gcggd ,nil ;
};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_cafe :=&FlateEncoder {};_cafe .Predictor =1;_cafe .BitsPerComponent =8;_cafe .Colors =1;_cafe .Columns =1;return _cafe ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_deded *PdfParser )GetTrailer ()*PdfObjectDictionary {return _deded ._aecc };

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// GetFilterName returns the name of the encoding filter.
func (_gcgd *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };func (_fcc *PdfCrypt )loadCryptFilters (_dca *PdfObjectDictionary )error {_fcc ._aaa =cryptFilters {};_fgbdd :=_dca .Get ("\u0043\u0046");_fgbdd =TraceToDirectObject (_fgbdd );
if _gfa ,_bgc :=_fgbdd .(*PdfObjectReference );_bgc {_edbg ,_acc :=_fcc ._dge .LookupByReference (*_gfa );if _acc !=nil {_gc .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _acc ;};_fgbdd =TraceToDirectObject (_edbg );};_gdf ,_gdg :=_fgbdd .(*PdfObjectDictionary );if !_gdg {_gc .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_fgbdd );return _f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_daf :=range _gdf .Keys (){_adc :=_gdf .Get (_daf );if _dac ,_bcd :=_adc .(*PdfObjectReference );_bcd {_gbfe ,_fbc :=_fcc ._dge .LookupByReference (*_dac );if _fbc !=nil {_gc .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _fbc ;};_adc =TraceToDirectObject (_gbfe );};_dadc ,_dcba :=_adc .(*PdfObjectDictionary );if !_dcba {return _ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_daf ,_adc );
};if _daf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _dae _cbg .FilterDict ;if _eaea :=_fgbd (&_dae ,_dadc );_eaea !=nil {return _eaea ;};_fdd ,_ccd :=_cbg .NewFilter (_dae );if _ccd !=nil {return _ccd ;};_fcc ._aaa [string (_daf )]=_fdd ;};_fcc ._aaa ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_cbg .NewIdentity ();
_fcc ._gfeb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cbgd ,_dbbe :=_dca .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_dbbe {if _ ,_fda :=_fcc ._aaa [string (*_cbgd )];!_fda {return _ca .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_cbgd );
};_fcc ._gfeb =string (*_cbgd );};_fcc ._aba ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dcgb ,_gebc :=_dca .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_gebc {if _ ,_aec :=_fcc ._aaa [string (*_dcgb )];!_aec {return _ca .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dcgb );
};_fcc ._aba =string (*_dcgb );};return nil ;};

// Append appends PdfObject(s) to the array.
func (_cceg *PdfObjectArray )Append (objects ...PdfObject ){if _cceg ==nil {_gc .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_cceg ._gcgag =append (_cceg ._gcgag ,objects ...);};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_dgae :=&PdfCrypt {_efba :false ,_acf :make (map[PdfObject ]bool ),_cgf :make (map[PdfObject ]bool ),_dga :make (map[int ]struct{}),_dge :parser };_gcb ,_gbb :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_gbb {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _dgae ,_f .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_gcb !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_gc .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_gcb );
return _dgae ,_f .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_dgae ._be .Filter =string (*_gcb );if _cbe ,_dbdg :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_dbdg {_dgae ._be .SubFilter =_cbe .Str ();
_gc .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_cbe );};if L ,_faea :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_faea {if (*L %8)!=0{_gc .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _dgae ,_f .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_dgae ._be .Length =int (*L );}else {_dgae ._be .Length =40;};_dgae ._be .V =0;if _gce ,_gbe :=ed .Get ("\u0056").(*PdfObjectInteger );
_gbe {V :=int (*_gce );_dgae ._be .V =V ;if V >=1&&V <=2{_dgae ._aaa =_fdb (_dgae ._be .Length );}else if V >=4&&V <=5{if _ccb :=_dgae .loadCryptFilters (ed );_ccb !=nil {return _dgae ,_ccb ;};}else {_gc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _dgae ,_f .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _bce :=_eg (&_dgae ._bbc ,ed );_bce !=nil {return _dgae ,_bce ;};_fgg :="";if _edbf ,_ecfg :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_ecfg &&_edbf .Len ()>=1{_cbac ,_baefc :=GetString (_edbf .Get (0));if !_baefc {return _dgae ,_f .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_fgg =_cbac .Str ();}else {_gc .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_dgae ._dggc =_fgg ;return _dgae ,nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_ceae JBIG2EncoderSettings )Validate ()error {const _afca ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _ceae .Threshold < 0||_ceae .Threshold > 1.0{return _bfb .Errorf (_afca ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_ceae .Threshold );
};if _ceae .ResolutionX < 0{return _bfb .Errorf (_afca ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_ceae .ResolutionX );
};if _ceae .ResolutionY < 0{return _bfb .Errorf (_afca ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_ceae .ResolutionY );
};if _ceae .DefaultPixelValue !=0&&_ceae .DefaultPixelValue !=1{return _bfb .Errorf (_afca ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_ceae .DefaultPixelValue );
};if _ceae .Compression !=JB2Generic {return _bfb .Errorf (_afca ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_acea *JBIG2Encoder )EncodeImage (img _d .Image )([]byte ,error ){return _acea .encodeImage (img )};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_abbg *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_affa :=MakeDict ();_affa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_abbg .GetFilterName ()));return _affa ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_ceeg Version )String ()string {return _ca .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_ceeg .Major ,_ceeg .Minor );};func (_gcdd *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _eddc =20;_dbecf ,_ :=_gcdd ._ceecd .Peek (_eddc );
for _gecc :=0;_gecc < 2;_gecc ++{if _gcdd ._cefdc ==0{_gcdd ._cefdc =_gcdd .GetFileOffset ();};if _efdd .Match (_dbecf ){_gc .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_gc .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_dbecf ));return _gcdd .parseXrefStream (nil );};if _adga .Match (_dbecf ){_gc .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _gcdd .parseXrefTable ();};_ega :=_gcdd .GetFileOffset ();if _gcdd ._cefdc ==0{_gcdd ._cefdc =_ega ;};_gcdd .SetFileOffset (_ega -_eddc );defer _gcdd .SetFileOffset (_ega );_bbacc ,_ :=_gcdd ._ceecd .Peek (_eddc );_dbecf =append (_bbacc ,_dbecf ...);
};_gc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _fbdd :=_gcdd .repairSeekXrefMarker ();_fbdd !=nil {_gc .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_fbdd );return nil ,_fbdd ;};return _gcdd .parseXrefTable ();};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bafa *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_cbad :=&PdfIndirectObject {};_cbad .PdfObject =obj ;return _cbad ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_cfd :=PdfObjectString {_effa :s ,_adfge :true };return &_cfd ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_fgbg *MultiEncoder )GetFilterName ()string {_aeag :="";for _cdgg ,_dadb :=range _fgbg ._egc {_aeag +=_dadb .GetFilterName ();if _cdgg < len (_fgbg ._egc )-1{_aeag +="\u0020";};};return _aeag ;};

// WriteString outputs the object as it is to be written to file.
func (_gaed *PdfObjectFloat )WriteString ()string {return _g .FormatFloat (float64 (*_gaed ),'f',-1,64);};

// WriteString outputs the object as it is to be written to file.
func (_fcbb *PdfObjectInteger )WriteString ()string {return _g .FormatInt (int64 (*_fcbb ),10)};

// UpdateParams updates the parameter values of the encoder.
func (_aefe *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_gaeb :=&ASCIIHexEncoder {};return _gaeb };type objectCache map[int ]PdfObject ;

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_edca *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _edca .Predictor !=1&&_edca .Predictor !=11{_gc .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _edca .Predictor ==11{_aaf :=_edca .Columns ;_decd :=len (data )/_aaf ;if len (data )%_aaf !=0{_gc .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_f .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_cbdb :=_cc .NewBuffer (nil );_fcab :=make ([]byte ,_aaf );for _bebe :=0;_bebe < _decd ;_bebe ++{_dfdf :=data [_aaf *_bebe :_aaf *(_bebe +1)];
_fcab [0]=_dfdf [0];for _bcdg :=1;_bcdg < _aaf ;_bcdg ++{_fcab [_bcdg ]=byte (int (_dfdf [_bcdg ]-_dfdf [_bcdg -1])%256);};_cbdb .WriteByte (1);_cbdb .Write (_fcab );};data =_cbdb .Bytes ();};var _aegb _cc .Buffer ;_ffd :=_ga .NewWriter (&_aegb );_ffd .Write (data );
_ffd .Close ();return _aegb .Bytes (),nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_ffe *PdfParser )GetXrefType ()*xrefType {return _ffe ._ecfge };

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_gafaf *PdfObjectString )Decoded ()string {if _gafaf ==nil {return "";};_aece :=[]byte (_gafaf ._effa );if len (_aece )>=2&&_aece [0]==0xFE&&_aece [1]==0xFF{return _ac .UTF16ToString (_aece [2:]);};return _ac .PDFDocEncodingToString (_aece );};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_cbgge *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_egdeg :=_cbgge ._gaddd [key ];if !_egdeg {_cbgge ._fdbbd =append (_cbgge ._fdbbd ,key );};_cbgge ._gaddd [key ]=val ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_eaca *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_faba :=_cc .NewReader (encoded );var _eff []byte ;for {_dbf ,_cbdg :=_faba .ReadByte ();if _cbdg !=nil {return nil ,_cbdg ;};if _dbf > 128{_gge ,_gbca :=_faba .ReadByte ();if _gbca !=nil {return nil ,_gbca ;
};for _eegae :=0;_eegae < 257-int (_dbf );_eegae ++{_eff =append (_eff ,_gge );};}else if _dbf < 128{for _adb :=0;_adb < int (_dbf )+1;_adb ++{_agbe ,_cade :=_faba .ReadByte ();if _cade !=nil {return nil ,_cade ;};_eff =append (_eff ,_agbe );};}else {break ;
};};return _eff ,nil ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_gbggd :=PdfObjectNull {};return &_gbggd };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_feg *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_aggb *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_baac :=MakeDict ();_baac .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aggb .GetFilterName ()));_cfa :=_aggb .MakeDecodeParams ();if _cfa !=nil {_baac .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cfa );
};return _baac ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bgbc *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _bdaf (o ,0,traversed );};

// GetFilterName returns the name of the encoding filter.
func (_aedf *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func (_fdbf *PdfCrypt )checkAccessRights (_fbd []byte )(bool ,_ae .Permissions ,error ){_deg :=_fdbf .securityHandler ();
_bfa ,_acce ,_dgbd :=_deg .Authenticate (&_fdbf ._bbc ,_fbd );if _dgbd !=nil {return false ,0,_dgbd ;}else if _acce ==0||len (_bfa )==0{return false ,0,nil ;};return true ,_acce ,nil ;};func (_adac *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_dd .SeekStart {offset +=_adac ._dbff ;
};_degf ,_bcce :=_adac ._eebd .Seek (offset ,whence );if _bcce !=nil {return _degf ,_bcce ;};if whence ==_dd .SeekCurrent {_degf -=_adac ._dbff ;};if _degf < 0{return 0,_f .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _degf ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dcf *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };func (_bggd *ASCII85Encoder )base256Tobase85 (_gfec uint32 )[5]byte {_dcab :=[5]byte {0,0,0,0,0};_aacg :=_gfec ;for _ebc :=0;_ebc < 5;_ebc ++{_eda :=uint32 (1);for _dbgg :=0;_dbgg < 4-_ebc ;
_dbgg ++{_eda *=85;};_dbcb :=_aacg /_eda ;_aacg =_aacg %_eda ;_dcab [_ebc ]=byte (_dbcb );};return _dcab ;};func (_gadbe *PdfParser )parseHexString ()(*PdfObjectString ,error ){_gadbe ._ceecd .ReadByte ();var _adfb _cc .Buffer ;for {_ccec ,_daae :=_gadbe ._ceecd .Peek (1);
if _daae !=nil {return MakeString (""),_daae ;};if _ccec [0]=='>'{_gadbe ._ceecd .ReadByte ();break ;};_afgfc ,_ :=_gadbe ._ceecd .ReadByte ();if !IsWhiteSpace (_afgfc ){_adfb .WriteByte (_afgfc );};};if _adfb .Len ()%2==1{_adfb .WriteRune ('0');};_dcec ,_ :=_fe .DecodeString (_adfb .String ());
return MakeHexString (string (_dcec )),nil ;};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_fag *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {for _gdfe ,_abce :=range objmap {_fag .Set (PdfObjectName (_gdfe ),_abce );};return _fag ;};func (_deafd *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_deafd ._ceecd )};


// GetXrefOffset returns the offset of the xref table.
func (_fbagd *PdfParser )GetXrefOffset ()int64 {return _fbagd ._cefdc };

// UpdateParams updates the parameter values of the encoder.
func (_bgbd *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_ddfg ,_dccd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _dccd ==nil {_bgbd .ColorComponents =int (_ddfg );
};_cgbd ,_dccd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _dccd ==nil {_bgbd .BitsPerComponent =int (_cgbd );};_ebbb ,_dccd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _dccd ==nil {_bgbd .Width =int (_ebbb );};_fbcf ,_dccd :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _dccd ==nil {_bgbd .Height =int (_fbcf );};_cdge ,_dccd :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _dccd ==nil {_bgbd .Quality =int (_cdge );};};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_deggc *PdfParser )IsEncrypted ()(bool ,error ){if _deggc ._cddb !=nil {return true ,nil ;}else if _deggc ._aecc ==nil {return false ,nil ;};_gc .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_bfdde :=_deggc ._aecc .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _bfdde ==nil {return false ,nil ;};_gc .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_ggbga *PdfObjectDictionary ;);switch _dfb :=_bfdde .(type ){case *PdfObjectDictionary :_ggbga =_dfb ;
case *PdfObjectReference :_gc .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_dfb );_caab ,_edbb :=_deggc .LookupByReference (*_dfb );_gc .Log .Trace ("\u0031\u003a\u0020%\u0071",_caab );
if _edbb !=nil {return false ,_edbb ;};_ddgg ,_bcegf :=_caab .(*PdfIndirectObject );if !_bcegf {_gc .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_f .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_dgda ,_bcegf :=_ddgg .PdfObject .(*PdfObjectDictionary );_gc .Log .Trace ("\u0032\u003a\u0020%\u0071",_dgda );if !_bcegf {return false ,_f .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_ggbga =_dgda ;case *PdfObjectNull :_gc .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_ca .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_dfb );};_daee ,_afacg :=PdfCryptNewDecrypt (_deggc ,_ggbga ,_deggc ._aecc );if _afacg !=nil {return false ,_afacg ;
};for _ ,_eegf :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_bdded :=_deggc ._aecc .Get (PdfObjectName (_eegf ));if _bdded ==nil {continue ;};switch _abcf :=_bdded .(type ){case *PdfObjectReference :_daee ._dga [int (_abcf .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_daee ._acf [_abcf ]=true ;_daee ._dga [int (_abcf .ObjectNumber )]=struct{}{};};};_deggc ._cddb =_daee ;_gc .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_daee );
return true ,nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_gcgag []PdfObject };func _fgbd (_caa *_cbg .FilterDict ,_dgb *PdfObjectDictionary )error {if _aef ,_gffd :=_dgb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gffd {if _fca :=string (*_aef );_fca !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_gc .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_fca );
};};_edb ,_fae :=_dgb .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_fae {return _ca .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_caa .CFM =string (*_edb );if _gbff ,_dcb :=_dgb .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_dcb {_caa .AuthEvent =_ae .AuthEvent (*_gbff );}else {_caa .AuthEvent =_ae .EventDocOpen ;};if _faf ,_gacb :=_dgb .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_gacb {_caa .Length =int (*_faf );};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_bcba *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_aab *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ffc _cc .Buffer ;for _ ,_gaad :=range data {_ffc .WriteString (_ca .Sprintf ("\u0025\u002e\u0032X\u0020",_gaad ));};_ffc .WriteByte ('>');return _ffc .Bytes (),nil ;};

// String returns the state of the bool as "true" or "false".
func (_ccbgc *PdfObjectBool )String ()string {if *_ccbgc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func (_ecdb *PdfParser )seekToEOFMarker (_gea int64 )error {var _fbfg int64 ;var _bgdde int64 =2048;for _fbfg < _gea -4{if _gea <=(_bgdde +_fbfg ){_bgdde =_gea -_fbfg ;
};_ ,_cacg :=_ecdb ._efbf .Seek (-_fbfg -_bgdde ,_dd .SeekEnd );if _cacg !=nil {return _cacg ;};_bfcf :=make ([]byte ,_bgdde );_ecdb ._efbf .Read (_bfcf );_gc .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_bfcf ));
_bdcb :=_bdae .FindAllStringIndex (string (_bfcf ),-1);if _bdcb !=nil {_gdb :=_bdcb [len (_bdcb )-1];_gc .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_bdcb );_bgfaa :=-_fbfg -_bgdde +int64 (_gdb [0]);_ecdb ._efbf .Seek (_bgfaa ,_dd .SeekEnd );
return nil ;};_gc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_fbfg +=_bgdde -4;};_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _f .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_bbaa *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _cb .DecodeBytes (encoded ,_ee .Parameters {},_bbaa .Globals );};

// Clear resets the dictionary to an empty state.
func (_ebcg *PdfObjectDictionary )Clear (){_ebcg ._fdbbd =[]PdfObjectName {};_ebcg ._gaddd =map[PdfObjectName ]PdfObject {};};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_adbf *JBIG2Encoder )DecodeImages (encoded []byte )([]_d .Image ,error ){const _eeeg ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_cgfd ,_cbgb :=_ee .Decode (encoded ,_ee .Parameters {},_adbf .Globals .ToDocumentGlobals ());
if _cbgb !=nil {return nil ,_bfb .Wrap (_cbgb ,_eeeg ,"");};_fgga ,_cbgb :=_cgfd .PageNumber ();if _cbgb !=nil {return nil ,_bfb .Wrap (_cbgb ,_eeeg ,"");};_afac :=[]_d .Image {};var _cdfd _d .Image ;for _dbec :=1;_dbec <=_fgga ;_dbec ++{_cdfd ,_cbgb =_cgfd .DecodePageImage (_dbec );
if _cbgb !=nil {return nil ,_bfb .Wrapf (_cbgb ,_eeeg ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_dbec );};_afac =append (_afac ,_cdfd );};return _afac ,nil ;};func _agf (_abafa PdfObject )(*float64 ,error ){switch _cegg :=_abafa .(type ){case *PdfObjectFloat :_ebbaa :=float64 (*_cegg );
return &_ebbaa ,nil ;case *PdfObjectInteger :_befbc :=float64 (*_cegg );return &_befbc ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};func _ace (_cbd PdfObject )(int64 ,int64 ,error ){if _fce ,_eeg :=_cbd .(*PdfIndirectObject );
_eeg {return _fce .ObjectNumber ,_fce .GenerationNumber ,nil ;};if _dbdd ,_agcb :=_cbd .(*PdfObjectStream );_agcb {return _dbdd .ObjectNumber ,_dbdd .GenerationNumber ,nil ;};return 0,0,_f .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");
};

// GetFilterName returns the name of the encoding filter.
func (_fgec *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// WriteString outputs the object as it is to be written to file.
func (_ceege *PdfObjectArray )WriteString ()string {var _gga _fd .Builder ;_gga .WriteString ("\u005b");for _egggg ,_gcgb :=range _ceege .Elements (){_gga .WriteString (_gcgb .WriteString ());if _egggg < (_ceege .Len ()-1){_gga .WriteString ("\u0020");
};};_gga .WriteString ("\u005d");return _gga .String ();};

// WriteString outputs the object as it is to be written to file.
func (_aefg *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_cdbc float64 ,_fcbc bool ){_aaec ,_fcbc :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _fcbc {return float64 (*_aaec ),true ;};return 0,false ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_gaddd map[PdfObjectName ]PdfObject ;_fdbbd []PdfObjectName ;_gfgd *PdfParser ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_gace *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_gace .GetFilterName ());
return data ,ErrNoJPXDecode ;};

// LookupByReference looks up a PdfObject by a reference.
func (_efb *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_gc .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _efb .LookupByNumber (int (ref .ObjectNumber ));
};

// GetParser returns the parser for lazy-loading or compare references.
func (_adgfg *PdfObjectReference )GetParser ()*PdfParser {return _adgfg ._fecc };

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _dgec :=obj .(type ){case *PdfObjectFloat :return float64 (*_dgec ),nil ;case *PdfObjectInteger :return float64 (*_dgec ),nil ;};return 0,ErrNotANumber ;};var _bdae =_ea .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");


// String returns a string describing `stream`.
func (_gadc *PdfObjectStream )String ()string {return _ca .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_gadc .ObjectNumber ,_gadc .PdfObjectDictionary );};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_babg *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gc .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_ged :=_cc .NewReader (encoded );_aaef ,_ffac :=_ga .NewReader (_ged );if _ffac !=nil {_gc .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_ffac );_gc .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_ffac ;};defer _aaef .Close ();var _dcag _cc .Buffer ;_dcag .ReadFrom (_aaef );return _dcag .Bytes (),nil ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);func (_gebd *PdfCrypt )authenticate (_efg []byte )(bool ,error ){_gebd ._efba =false ;
_eag :=_gebd .securityHandler ();_ffab ,_ebg ,_gfgc :=_eag .Authenticate (&_gebd ._bbc ,_efg );if _gfgc !=nil {return false ,_gfgc ;}else if _ebg ==0||len (_ffab )==0{return false ,nil ;};_gebd ._efba =true ;_gebd ._edf =_ffab ;return true ,nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_bac *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ggf :=_cc .NewReader (encoded );_ggdd ,_eeda :=_ed .Decode (_ggf );if _eeda !=nil {_gc .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_eeda );
return nil ,_eeda ;};_bebec :=_ggdd .Bounds ();var _gadb =make ([]byte ,_bebec .Dx ()*_bebec .Dy ()*_bac .ColorComponents *_bac .BitsPerComponent /8);_ddef :=0;for _eecg :=_bebec .Min .Y ;_eecg < _bebec .Max .Y ;_eecg ++{for _abef :=_bebec .Min .X ;_abef < _bebec .Max .X ;
_abef ++{_gcaf :=_ggdd .At (_abef ,_eecg );if _bac .ColorComponents ==1{if _bac .BitsPerComponent ==16{_bcaf ,_afc :=_gcaf .(_b .Gray16 );if !_afc {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gadb [_ddef ]=byte ((_bcaf .Y >>8)&0xff);_ddef ++;_gadb [_ddef ]=byte (_bcaf .Y &0xff);_ddef ++;}else {_gdga ,_egg :=_gcaf .(_b .Gray );if !_egg {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gadb [_ddef ]=_gdga .Y &0xff;_ddef ++;};}else if _bac .ColorComponents ==3{if _bac .BitsPerComponent ==16{_ecbd ,_accbe :=_gcaf .(_b .RGBA64 );if !_accbe {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gadb [_ddef ]=byte ((_ecbd .R >>8)&0xff);_ddef ++;_gadb [_ddef ]=byte (_ecbd .R &0xff);_ddef ++;_gadb [_ddef ]=byte ((_ecbd .G >>8)&0xff);_ddef ++;_gadb [_ddef ]=byte (_ecbd .G &0xff);_ddef ++;_gadb [_ddef ]=byte ((_ecbd .B >>8)&0xff);_ddef ++;_gadb [_ddef ]=byte (_ecbd .B &0xff);
_ddef ++;}else {_afgd ,_bfab :=_gcaf .(_b .RGBA );if _bfab {_gadb [_ddef ]=_afgd .R &0xff;_ddef ++;_gadb [_ddef ]=_afgd .G &0xff;_ddef ++;_gadb [_ddef ]=_afgd .B &0xff;_ddef ++;}else {_cac ,_bfg :=_gcaf .(_b .YCbCr );if !_bfg {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_fad ,_ggc ,_efe ,_ :=_cac .RGBA ();_gadb [_ddef ]=byte (_fad >>8);_ddef ++;_gadb [_ddef ]=byte (_ggc >>8);_ddef ++;_gadb [_ddef ]=byte (_efe >>8);_ddef ++;};};}else if _bac .ColorComponents ==4{_aaegc ,_geg :=_gcaf .(_b .CMYK );if !_geg {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gadb [_ddef ]=255-_aaegc .C &0xff;_ddef ++;_gadb [_ddef ]=255-_aaegc .M &0xff;_ddef ++;_gadb [_ddef ]=255-_aaegc .Y &0xff;_ddef ++;_gadb [_ddef ]=255-_aaegc .K &0xff;_ddef ++;};};};return _gadb ,nil ;};func (_eefa *PdfObjectFloat )String ()string {return _ca .Sprintf ("\u0025\u0066",*_eefa )};


// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_egeg *PdfParser )Decrypt (password []byte )(bool ,error ){if _egeg ._cddb ==nil {return false ,_f .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_edgg ,_gffaf :=_egeg ._cddb .authenticate (password );
if _gffaf !=nil {return false ,_gffaf ;};if !_edgg {_edgg ,_gffaf =_egeg ._cddb .authenticate ([]byte (""));};return _edgg ,_gffaf ;};

// UpdateParams updates the parameter values of the encoder.
func (_babd *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_accee :=range _babd ._egc {_accee .UpdateParams (params );};};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_ddgeb *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_egef ,_ddabc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ddabc ==nil {_ddgeb .BitsPerComponent =int (_egef );
};_gbae ,_ddabc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ddabc ==nil {_ddgeb .Width =int (_gbae );};_dbgd ,_ddabc :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ddabc ==nil {_ddgeb .Height =int (_dbgd );
};_ffcf ,_ddabc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ddabc ==nil {_ddgeb .ColorComponents =int (_ffcf );};};

// GetFilterName returns the name of the encoding filter.
func (_bebc *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func (_ccaf *PdfParser )xrefNextObjectOffset (_bfgb int64 )int64 {_gegeg :=int64 (0);if len (_ccaf ._cfbe .ObjectMap )==0{return 0;};if len (_ccaf ._cfbe ._dc )==0{_bcdf :=0;
for _ ,_acaf :=range _ccaf ._cfbe .ObjectMap {if _acaf .Offset > 0{_bcdf ++;};};if _bcdf ==0{return 0;};_ccaf ._cfbe ._dc =make ([]XrefObject ,_bcdf );_cbcf :=0;for _ ,_gbcb :=range _ccaf ._cfbe .ObjectMap {if _gbcb .Offset > 0{_ccaf ._cfbe ._dc [_cbcf ]=_gbcb ;
_cbcf ++;};};_ef .Slice (_ccaf ._cfbe ._dc ,func (_geeb ,_gccc int )bool {return _ccaf ._cfbe ._dc [_geeb ].Offset < _ccaf ._cfbe ._dc [_gccc ].Offset });};_bdab :=_ef .Search (len (_ccaf ._cfbe ._dc ),func (_cage int )bool {return _ccaf ._cfbe ._dc [_cage ].Offset >=_bfgb });
if _bdab < len (_ccaf ._cfbe ._dc ){_gegeg =_ccaf ._cfbe ._dc [_bdab ].Offset ;};return _gegeg ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bbda *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_cgda *PdfParser )GetCrypter ()*PdfCrypt {return _cgda ._cddb };

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_acca :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _acca ==nil {return NewRawEncoder (),nil ;};if _ ,_gcbge :=_acca .(*PdfObjectNull );
_gcbge {return NewRawEncoder (),nil ;};_dcefd ,_degb :=_acca .(*PdfObjectName );if !_degb {_adec ,_cfbeb :=_acca .(*PdfObjectArray );if !_cfbeb {return nil ,_ca .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _adec .Len ()==0{return NewRawEncoder (),nil ;};if _adec .Len ()!=1{_ebce ,_geed :=_gcee (streamObj );if _geed !=nil {_gc .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_geed );
return nil ,_geed ;};_gc .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_ebce );return _ebce ,nil ;};_acca =_adec .Get (0);_dcefd ,_cfbeb =_acca .(*PdfObjectName );if !_cfbeb {return nil ,_ca .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _ffgff ,_ffge :=_gffdb .Load (_dcefd .String ());_ffge {return _ffgff .(StreamEncoder ),nil ;};switch *_dcefd {case StreamEncodingFilterNameFlate :return _eea (streamObj ,nil );case StreamEncodingFilterNameLZW :return _deaf (streamObj ,nil );case StreamEncodingFilterNameDCT :return _eadf (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _edgf (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _cdd (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _bdc (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_gc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_ca .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_dcefd );};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_ecce *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ecce .DecodeBytes (streamObj .Stream );};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_be encryptDict ;_bbc _ae .StdEncryptDict ;_dggc string ;_edf []byte ;_acf map[PdfObject ]bool ;_cgf map[PdfObject ]bool ;_efba bool ;_aaa cryptFilters ;_aba string ;_gfeb string ;_dge *PdfParser ;_dga map[int ]struct{};};func (_efbae *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_bcge :=_efbae ._ceecd .Discard (4);
return PdfObjectNull {},_bcge ;};

// String returns a string describing `ind`.
func (_fbeg *PdfIndirectObject )String ()string {return _ca .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_fbeg ).ObjectNumber );};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_fcfg :=MakeArray ();for _ ,_cddgg :=range vals {_fcfg .Append (MakeInteger (_cddgg ));};return _fcfg ;};const _ebdf =32<<(^uint (0)>>63);

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_deac *PdfObjectStream ,_afaaa bool ){obj =ResolveReference (obj );_deac ,_afaaa =obj .(*PdfObjectStream );return _deac ,_afaaa ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_bcfb *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_gca :=MakeDict ();_gca .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bcfb .GetFilterName ()));return _gca ;};func (_cfgg *PdfParser )traceStreamLength (_agbc PdfObject )(PdfObject ,error ){_gded ,_cfgf :=_agbc .(*PdfObjectReference );
if _cfgf {_ccfd ,_ffdb :=_cfgg ._aead [_gded .ObjectNumber ];if _ffdb &&_ccfd {_gc .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_f .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_cfgg ._aead [_gded .ObjectNumber ]=true ;};_bdaa ,_aded :=_cfgg .Resolve (_agbc );if _aded !=nil {return nil ,_aded ;
};_gc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_bdaa );if _cfgf {_cfgg ._aead [_gded .ObjectNumber ]=false ;};return _bdaa ,nil ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gaec *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };func _eg (_cee *_ae .StdEncryptDict ,_ede *PdfObjectDictionary )error {R ,_cbc :=_ede .Get ("\u0052").(*PdfObjectInteger );if !_cbc {return _f .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_cee .R =int (*R );O ,_cbc :=_ede .GetString ("\u004f");if !_cbc {return _f .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _cee .R ==5||_cee .R ==6{if len (O )< 48{return _ca .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _ca .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_cee .O =[]byte (O );U ,_cbc :=_ede .GetString ("\u0055");if !_cbc {return _f .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _cee .R ==5||_cee .R ==6{if len (U )< 48{return _ca .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_gc .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_cee .U =[]byte (U );if _cee .R >=5{OE ,_eega :=_ede .GetString ("\u004f\u0045");
if !_eega {return _f .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _ca .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_cee .OE =[]byte (OE );UE ,_eega :=_ede .GetString ("\u0055\u0045");if !_eega {return _f .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _ca .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_cee .UE =[]byte (UE );};P ,_cbc :=_ede .Get ("\u0050").(*PdfObjectInteger );if !_cbc {return _f .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_cee .P =_ae .Permissions (*P );if _cee .R ==6{Perms ,_aaae :=_ede .GetString ("\u0050\u0065\u0072m\u0073");if !_aaae {return _f .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _ca .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_cee .Perms =[]byte (Perms );};if _dgd ,_gef :=_ede .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_gef {_cee .EncryptMetadata =bool (*_dgd );}else {_cee .EncryptMetadata =true ;};return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_afb *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_ddab :=MakeDict ();_ddab .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_afb .GetFilterName ()));_ggga :=_afb .MakeDecodeParams ();if _ggga !=nil {_ddab .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ggga );
};return _ddab ;};func (_bae *PdfParser )lookupByNumber (_agge int ,_dg bool )(PdfObject ,bool ,error ){_gaf ,_dee :=_bae .ObjCache [_agge ];if _dee {_gc .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_agge );
return _gaf ,false ,nil ;};if _bae ._aaeb ==nil {_bae ._aaeb =map[int ]bool {};};if _bae ._aaeb [_agge ]{_gc .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_agge );
return nil ,false ,_f .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_bae ._aaeb [_agge ]=true ;defer delete (_bae ._aaeb ,_agge );
_ecd ,_dee :=_bae ._cfbe .ObjectMap [_agge ];if !_dee {_gc .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _aa PdfObjectNull ;return &_aa ,false ,nil ;};_gc .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_agge );if _ecd .XType ==XrefTypeTableEntry {_gc .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_ecd .ObjectNumber );
_gc .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_ecd .Generation );_gc .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_ecd .Offset );_bae ._efbf .Seek (_ecd .Offset ,_dd .SeekStart );
_bae ._ceecd =_db .NewReader (_bae ._efbf );_bc ,_cef :=_bae .ParseIndirectObject ();if _cef !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_cef );
if _dg {_gc .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_feff ,_baef :=_bae .repairRebuildXrefsTopDown ();
if _baef !=nil {_gc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_baef );return nil ,false ,_baef ;};_bae ._cfbe =*_feff ;return _bae .lookupByNumber (_agge ,false );
};return nil ,false ,_cef ;};if _dg {_afd ,_ ,_ :=_ace (_bc );if int (_afd )!=_agge {_gc .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_aea :=_bae .rebuildXrefTable ();
if _aea !=nil {return nil ,false ,_aea ;};_bae .ObjCache =objectCache {};return _bae .lookupByNumberWrapper (_agge ,false );};};_gc .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_bae .ObjCache [_agge ]=_bc ;
return _bc ,false ,nil ;}else if _ecd .XType ==XrefTypeObjectStream {_gc .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_gc .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_gc .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_ecd .OsObjNumber ,_ecd .OsObjIndex );
if _ecd .OsObjNumber ==_agge {_gc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_f .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_df :=_bae ._cfbe .ObjectMap [_ecd .OsObjNumber ];_df {_eec ,_fea :=_bae .lookupObjectViaOS (_ecd .OsObjNumber ,_agge );if _fea !=nil {_gc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_fea );
return nil ,true ,_fea ;};_gc .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_bae .ObjCache [_agge ]=_eec ;if _bae ._cddb !=nil {_bae ._cddb ._acf [_eec ]=true ;};return _eec ,true ,nil ;};_gc .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_f .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_f .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// Append appends PdfObject(s) to the streams.
func (_ebgc *PdfObjectStreams )Append (objects ...PdfObject ){if _ebgc ==nil {_gc .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_ebgc ._gbgg =append (_ebgc ._gbgg ,objects ...);};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_b .Model ;Bounds ()_d .Rectangle ;At (_dbc ,_gceg int )_b .Color ;Set (_eceed ,_eagb int ,_dgged _b .Color );};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_bbf *MultiEncoder )GetFilterArray ()*PdfObjectArray {_bec :=make ([]PdfObject ,len (_bbf ._egc ));for _afbb ,_fdeg :=range _bbf ._egc {_bec [_afbb ]=MakeName (_fdeg .GetFilterName ());};return MakeArray (_bec ...);};func _beef (_egcad string )(int ,int ,error ){_gcbfd :=_efdd .FindStringSubmatch (_egcad );
if len (_gcbfd )< 3{return 0,0,_f .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_agafb ,_ :=_g .Atoi (_gcbfd [1]);_dacg ,_ :=_g .Atoi (_gcbfd [2]);return _agafb ,_dacg ,nil ;};func (_cfga *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_cfga ._cfbe .ObjectMap =make (map[int ]XrefObject );_cfga ._gfed =make (objectStreams );
_ggge ,_bgfg :=_cfga ._efbf .Seek (0,_dd .SeekEnd );if _bgfg !=nil {return nil ,_bgfg ;};_gc .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_ggge );_cfga ._dcbg =_ggge ;_bgfg =_cfga .seekToEOFMarker (_ggge );if _bgfg !=nil {_gc .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_bgfg );
return nil ,_bgfg ;};_eage ,_bgfg :=_cfga ._efbf .Seek (0,_dd .SeekCurrent );if _bgfg !=nil {return nil ,_bgfg ;};var _accef int64 =64;_eefb :=_eage -_accef ;if _eefb < 0{_eefb =0;};_ ,_bgfg =_cfga ._efbf .Seek (_eefb ,_dd .SeekStart );if _bgfg !=nil {return nil ,_bgfg ;
};_fdcc :=make ([]byte ,_accef );_ ,_bgfg =_cfga ._efbf .Read (_fdcc );if _bgfg !=nil {_gc .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_bgfg );
return nil ,_bgfg ;};_gbge :=_dbge .FindStringSubmatch (string (_fdcc ));if len (_gbge )< 2{_gc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_f .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
};if len (_gbge )> 2{_gc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_fdcc );return nil ,_f .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");
};_bega ,_ :=_g .ParseInt (_gbge [1],10,64);_gc .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_bega );if _bega > _ggge {_gc .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");
_gc .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_bega ,_bgfg =_cfga .repairLocateXref ();if _bgfg !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_bgfg ;};};_cfga ._efbf .Seek (_bega ,_dd .SeekStart );_cfga ._ceecd =_db .NewReader (_cfga ._efbf );_bgde ,_bgfg :=_cfga .parseXref ();if _bgfg !=nil {return nil ,_bgfg ;};_fddcf :=_bgde .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _fddcf !=nil {_adgf ,_fadc :=_fddcf .(*PdfObjectInteger );
if !_fadc {return nil ,_f .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_bgfg =_cfga .parseXrefStream (_adgf );if _bgfg !=nil {return nil ,_bgfg ;};};var _edcf []int64 ;_cccdd :=func (_dbbf int64 ,_bdce []int64 )bool {for _ ,_abggf :=range _bdce {if _abggf ==_dbbf {return true ;
};};return false ;};_fddcf =_bgde .Get ("\u0050\u0072\u0065\u0076");for _fddcf !=nil {_fgfb ,_fafe :=_fddcf .(*PdfObjectInteger );if !_fafe {_gc .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_fddcf );
return _bgde ,nil ;};_bdfb :=*_fgfb ;_gc .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_bdfb );_cfga ._efbf .Seek (int64 (_bdfb ),_dd .SeekStart );
_cfga ._ceecd =_db .NewReader (_cfga ._efbf );_bbdef ,_bdbb :=_cfga .parseXref ();if _bdbb !=nil {_gc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_gc .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_fddcf =_bbdef .Get ("\u0050\u0072\u0065\u0076");
if _fddcf !=nil {_abde :=*(_fddcf .(*PdfObjectInteger ));if _cccdd (int64 (_abde ),_edcf ){_gc .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_edcf =append (_edcf ,int64 (_abde ));};};return _bgde ,nil ;};

// GetXrefTable returns the PDFs xref table.
func (_ebge *PdfParser )GetXrefTable ()XrefTable {return _ebge ._cfbe };

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_aca *parserMetadata )HasDataAfterEOF ()bool {return _aca ._agba };

// SetImage sets the image base for given flate encoder.
func (_agbg *FlateEncoder )SetImage (img *_fb .ImageBase ){_agbg ._bgee =img };var _cace =_ea .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_bbb *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_ffgd error ){const _dgeb ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _bbb ==nil {return _bfb .Error (_dgeb ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_bbb .DefaultPageSettings ;};if _bbb ._gbcd ==nil {_bbb ._gbcd =_dda .InitEncodeDocument (settings .FileMode );
};if _ffgd =settings .Validate ();_ffgd !=nil {return _bfb .Wrap (_ffgd ,_dgeb ,"");};_eadff ,_ffgd :=img .toBitmap ();if _ffgd !=nil {return _bfb .Wrap (_ffgd ,_dgeb ,"");};switch settings .Compression {case JB2Generic :if _ffgd =_bbb ._gbcd .AddGenericPage (_eadff ,settings .DuplicatedLinesRemoval );
_ffgd !=nil {return _bfb .Wrap (_ffgd ,_dgeb ,"");};case JB2SymbolCorrelation :return _bfb .Error (_dgeb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _bfb .Error (_dgeb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _bfb .Error (_dgeb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};func _bgaa (_ggcb int )int {if _ggcb < 0{return -_ggcb ;
};return _ggcb ;};func _edgf (_gfb *PdfObjectStream ,_cge *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_dabb *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aaacc :=encoded ;var _aacdf error ;for _ ,_bbac :=range _dabb ._egc {_gc .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_bbac ,_bbac );
_aaacc ,_aacdf =_bbac .DecodeBytes (_aaacc );if _aacdf !=nil {return nil ,_aacdf ;};};return _aaacc ,nil ;};func _fdb (_deeb int )cryptFilters {return cryptFilters {_gacf :_cbg .NewFilterV2 (_deeb )}};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbcg *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_cfcgf :=MakeDict ();_cfcgf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bbcg .GetFilterName ()));return _cfcgf ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_fbbee *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _ecfc []byte ;_gc .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_cdcc :=0;_bgdb :=false ;for _cdcc < len (encoded )&&!_bgdb {_acbb :=[5]byte {0,0,0,0,0};
_edfb :=0;_caee :=0;_gbcf :=4;for _caee < 5+_edfb {if _cdcc +_caee ==len (encoded ){break ;};_adcaf :=encoded [_cdcc +_caee ];if IsWhiteSpace (_adcaf ){_edfb ++;_caee ++;continue ;}else if _adcaf =='~'&&_cdcc +_caee +1< len (encoded )&&encoded [_cdcc +_caee +1]=='>'{_gbcf =(_caee -_edfb )-1;
if _gbcf < 0{_gbcf =0;};_bgdb =true ;break ;}else if _adcaf >='!'&&_adcaf <='u'{_adcaf -='!';}else if _adcaf =='z'&&_caee -_edfb ==0{_gbcf =4;_caee ++;break ;}else {_gc .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_acbb [_caee -_edfb ]=_adcaf ;_caee ++;};_cdcc +=_caee ;for _afgf :=_gbcf +1;_afgf < 5;_afgf ++{_acbb [_afgf ]=84;
};_bdd :=uint32 (_acbb [0])*85*85*85*85+uint32 (_acbb [1])*85*85*85+uint32 (_acbb [2])*85*85+uint32 (_acbb [3])*85+uint32 (_acbb [4]);_fdfgc :=[]byte {byte ((_bdd >>24)&0xff),byte ((_bdd >>16)&0xff),byte ((_bdd >>8)&0xff),byte (_bdd &0xff)};_ecfc =append (_ecfc ,_fdfgc [:_gbcf ]...);
};_gc .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_gc .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_ecfc );
return _ecfc ,nil ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_dggff *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_bda :=data ;var _bggfc error ;for _dcedc :=len (_dggff ._egc )-1;_dcedc >=0;_dcedc --{_fbdcc :=_dggff ._egc [_dcedc ];_bda ,_bggfc =_fbdcc .EncodeBytes (_bda );if _bggfc !=nil {return nil ,_bggfc ;
};};return _bda ,nil ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_ffde :=&PdfObjectDictionary {};_ffde ._gaddd =map[PdfObjectName ]PdfObject {};_ffde ._fdbbd =[]PdfObjectName {};return _ffde ;};func (_aceb *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _aceb ._geff {return nil ,_ca .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_aceb ._geff =true ;_aceb ._efbf .Seek (0,_dd .SeekStart );_aceb ._ceecd =_db .NewReader (_aceb ._efbf );_bfdc :=20;_fefaa :=make ([]byte ,_bfdc );_eadd :=XrefTable {};_eadd .ObjectMap =make (map[int ]XrefObject );for {_afag ,_cdbgf :=_aceb ._ceecd .ReadByte ();
if _cdbgf !=nil {if _cdbgf ==_dd .EOF {break ;}else {return nil ,_cdbgf ;};};if _afag =='j'&&_fefaa [_bfdc -1]=='b'&&_fefaa [_bfdc -2]=='o'&&IsWhiteSpace (_fefaa [_bfdc -3]){_cdaea :=_bfdc -4;for IsWhiteSpace (_fefaa [_cdaea ])&&_cdaea > 0{_cdaea --;};
if _cdaea ==0||!IsDecimalDigit (_fefaa [_cdaea ]){continue ;};for IsDecimalDigit (_fefaa [_cdaea ])&&_cdaea > 0{_cdaea --;};if _cdaea ==0||!IsWhiteSpace (_fefaa [_cdaea ]){continue ;};for IsWhiteSpace (_fefaa [_cdaea ])&&_cdaea > 0{_cdaea --;};if _cdaea ==0||!IsDecimalDigit (_fefaa [_cdaea ]){continue ;
};for IsDecimalDigit (_fefaa [_cdaea ])&&_cdaea > 0{_cdaea --;};if _cdaea ==0{continue ;};_cbbaa :=_aceb .GetFileOffset ()-int64 (_bfdc -_cdaea );_daeef :=append (_fefaa [_cdaea +1:],_afag );_feaa ,_ebcb ,_cddcd :=_beef (string (_daeef ));if _cddcd !=nil {_gc .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_cddcd );
return nil ,_cddcd ;};if _adee ,_aeab :=_eadd .ObjectMap [_feaa ];!_aeab ||_adee .Generation < _ebcb {_bbaag :=XrefObject {};_bbaag .XType =XrefTypeTableEntry ;_bbaag .ObjectNumber =_feaa ;_bbaag .Generation =_ebcb ;_bbaag .Offset =_cbbaa ;_eadd .ObjectMap [_feaa ]=_bbaag ;
};};_fefaa =append (_fefaa [1:_bfdc ],_afag );};_aceb ._aaeb =nil ;return &_eadd ,nil ;};func _gcee (_egda *PdfObjectStream )(*MultiEncoder ,error ){_eccdg :=NewMultiEncoder ();_bfccd :=_egda .PdfObjectDictionary ;if _bfccd ==nil {return _eccdg ,nil ;};
var _facfg *PdfObjectDictionary ;var _gbed []PdfObject ;_ddad :=_bfccd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _ddad !=nil {_cafd ,_faab :=_ddad .(*PdfObjectDictionary );if _faab {_facfg =_cafd ;};_dggb ,_edef :=_ddad .(*PdfObjectArray );
if _edef {for _ ,_addca :=range _dggb .Elements (){_addca =TraceToDirectObject (_addca );if _gcga ,_ddba :=_addca .(*PdfObjectDictionary );_ddba {_gbed =append (_gbed ,_gcga );}else {_gbed =append (_gbed ,MakeDict ());};};};};_ddad =_bfccd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");
if _ddad ==nil {return nil ,_ca .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_edgba ,_bgfe :=_ddad .(*PdfObjectArray );if !_bgfe {return nil ,_ca .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _aga ,_gccf :=range _edgba .Elements (){_aecb ,_faac :=_gccf .(*PdfObjectName );if !_faac {return nil ,_ca .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _cffb PdfObject ;if _facfg !=nil {_cffb =_facfg ;}else {if len (_gbed )> 0{if _aga >=len (_gbed ){return nil ,_ca .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_cffb =_gbed [_aga ];};};var _eebe *PdfObjectDictionary ;if _ebbde ,_fedf :=_cffb .(*PdfObjectDictionary );_fedf {_eebe =_ebbde ;};_gc .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_aecb ,_cffb ,_eebe );
if *_aecb ==StreamEncodingFilterNameFlate {_fdfgg ,_edeaa :=_eea (_egda ,_eebe );if _edeaa !=nil {return nil ,_edeaa ;};_eccdg .AddEncoder (_fdfgg );}else if *_aecb ==StreamEncodingFilterNameLZW {_eada ,_baeb :=_deaf (_egda ,_eebe );if _baeb !=nil {return nil ,_baeb ;
};_eccdg .AddEncoder (_eada );}else if *_aecb ==StreamEncodingFilterNameASCIIHex {_fbef :=NewASCIIHexEncoder ();_eccdg .AddEncoder (_fbef );}else if *_aecb ==StreamEncodingFilterNameASCII85 {_dddac :=NewASCII85Encoder ();_eccdg .AddEncoder (_dddac );}else if *_aecb ==StreamEncodingFilterNameDCT {_gffg ,_beff :=_eadf (_egda ,_eccdg );
if _beff !=nil {return nil ,_beff ;};_eccdg .AddEncoder (_gffg );_gc .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_gc .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_eccdg );
}else {_gc .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_aecb );return nil ,_ca .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");
};};return _eccdg ,nil ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_agfg *PdfObjectDictionary ,_cbea bool ){_agfg ,_cbea =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _agfg ,_cbea ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _dgfgf ,_bgab :=obj .(*PdfObjectReference );_bgab {obj =_dgfgf .Resolve ();};_cbggc ,_edfca :=obj .(*PdfIndirectObject );_edee :=0;for _edfca {obj =_cbggc .PdfObject ;_cbggc ,_edfca =GetIndirect (obj );
_edee ++;if _edee > _acccg {_gc .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_acccg );
return nil ;};};return obj ;};

// PdfVersion returns version of the PDF file.
func (_dceff *PdfParser )PdfVersion ()Version {return _dceff ._deebf };func (_fgde *PdfCrypt )generateParams (_dade ,_gffe []byte )error {_cbdc :=_fgde .securityHandler ();_cdab ,_ada :=_cbdc .GenerateParams (&_fgde ._bbc ,_gffe ,_dade );if _ada !=nil {return _ada ;
};_fgde ._edf =_cdab ;return nil ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _ccdf ,_bgcba :=obj .(*PdfObjectReference );_bgcba {return _ccdf .Resolve ();};return obj ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};type cryptFilters map[string ]_cbg .Filter ;

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_egca :=TraceToDirectObject (obj ).(*PdfObjectNull );return _egca ;};

// UpdateParams updates the parameter values of the encoder.
func (_ggb *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_adcf *PdfParser )readTextLine ()(string ,error ){var _dgfg _cc .Buffer ;for {_cacf ,_bbec :=_adcf ._ceecd .Peek (1);if _bbec !=nil {_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_bbec .Error ());
return _dgfg .String (),_bbec ;};if (_cacf [0]!='\r')&&(_cacf [0]!='\n'){_ababa ,_ :=_adcf ._ceecd .ReadByte ();_dgfg .WriteByte (_ababa );}else {break ;};};return _dgfg .String (),nil ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_dgdb *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ceca :=&_af .Encoder {K :_dgdb .K ,Columns :_dgdb .Columns ,EndOfLine :_dgdb .EndOfLine ,EndOfBlock :_dgdb .EndOfBlock ,BlackIs1 :_dgdb .BlackIs1 ,DamagedRowsBeforeError :_dgdb .DamagedRowsBeforeError ,Rows :_dgdb .Rows ,EncodedByteAlign :_dgdb .EncodedByteAlign };
_egbc ,_gdfd :=_ceca .Decode (encoded );if _gdfd !=nil {return nil ,_gdfd ;};var _fceb []byte ;_dce :=0;var _cgcb byte ;var _dccc byte ;for _dbgc :=range _egbc {if _cgcb !=0{_fceb =append (_fceb ,_dccc );_dccc =0;_dce ++;_cgcb =0;};for _gcag :=range _egbc [_dbgc ]{_dccc |=_egbc [_dbgc ][_gcag ]<<(7-_cgcb );
_cgcb ++;if _cgcb ==8{_fceb =append (_fceb ,_dccc );_dccc =0;_dce ++;_cgcb =0;};};};if _cgcb > 0{_fceb =append (_fceb ,_dccc );};return _fceb ,nil ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_afed *PdfObjectStreams ,_becc bool ){_afed ,_becc =obj .(*PdfObjectStreams );return _afed ,_becc ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _d .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _fbcg ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_bfb .Error (_fbcg ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_fegc uint8 ;_bbdg _fb .Image ;_fcgf error ;);if bwThreshold ==JB2ImageAutoThreshold {_bbdg ,_fcgf =_fb .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_bfb .Error (_fbcg ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_fegc =uint8 (255*bwThreshold );_bbdg ,_fcgf =_fb .MonochromeThresholdConverter (_fegc ).Convert (i );};if _fcgf !=nil {return nil ,_fcgf ;};return _ebbee (_bbdg ),nil ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_bgee *_fb .ImageBase ;};func (_decf *PdfParser )checkPostEOFData ()error {const _abaf ="\u0025\u0025\u0045O\u0046";_ ,_dbdc :=_decf ._efbf .Seek (-int64 (len ([]byte (_abaf )))-1,_dd .SeekEnd );if _dbdc !=nil {return _dbdc ;
};_fba :=make ([]byte ,len ([]byte (_abaf ))+1);_ ,_dbdc =_decf ._efbf .Read (_fba );if _dbdc !=nil {if _dbdc !=_dd .EOF {return _dbdc ;};};if string (_fba )==_abaf ||string (_fba )==_abaf +"\u000a"{_decf ._fafa ._agba =true ;};return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_adab *PdfObjectDictionary )WriteString ()string {var _fadd _fd .Builder ;_fadd .WriteString ("\u003c\u003c");for _ ,_afff :=range _adab ._fdbbd {_gbeb :=_adab ._gaddd [_afff ];_fadd .WriteString (_afff .WriteString ());_fadd .WriteString ("\u0020");
_fadd .WriteString (_gbeb .WriteString ());};_fadd .WriteString ("\u003e\u003e");return _fadd .String ();};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_cefd *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_bcfa :=n ;_eeeeb :=0;_cbed :=0;for _bcfa > 0{_cgdg ,_aaaa :=_cefd ._ceecd .Read (p [_eeeeb :]);if _aaaa !=nil {_gc .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_cgdg ,_cbed ,_aaaa .Error ());
return _eeeeb ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_cbed ++;_eeeeb +=_cgdg ;_bcfa -=_cgdg ;};return _eeeeb ,nil ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_gddfa *PdfIndirectObject ,_ffbfb bool ){obj =ResolveReference (obj );_gddfa ,_ffbfb =obj .(*PdfIndirectObject );return _gddfa ,_ffbfb ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_ccde :=_cc .NewReader ([]byte (txt ));_bbge :=&PdfParser {ObjCache :objectCache {},_efbf :_ccde ,_ceecd :_db .NewReader (_ccde ),_dcbg :int64 (len (txt )),_aead :map[int64 ]bool {}};_bbge ._cfbe .ObjectMap =make (map[int ]XrefObject );
return _bbge ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_agae *PdfObjectString )Str ()string {return _agae ._effa };

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_edec *MultiEncoder )AddEncoder (encoder StreamEncoder ){_edec ._egc =append (_edec ._egc ,encoder );};

// GetFilterName returns the name of the encoding filter.
func (_bbgc *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_effa string ;_adfge bool ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_gafg *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _gafg .isEncrypted (obj ){return nil ;};switch _cgb :=obj .(type ){case *PdfIndirectObject :_gafg ._cgf [_cgb ]=true ;_gc .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_cgb .ObjectNumber ,_cgb .GenerationNumber );
_edd :=_cgb .ObjectNumber ;_bea :=_cgb .GenerationNumber ;_aed :=_gafg .Encrypt (_cgb .PdfObject ,_edd ,_bea );if _aed !=nil {return _aed ;};return nil ;case *PdfObjectStream :_gafg ._cgf [_cgb ]=true ;_bee :=_cgb .PdfObjectDictionary ;if _fac ,_faa :=_bee .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_faa &&*_fac =="\u0058\u0052\u0065\u0066"{return nil ;};_cggf :=_cgb .ObjectNumber ;_baa :=_cgb .GenerationNumber ;_gc .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_cggf ,_baa );
_deca :=_gacf ;if _gafg ._be .V >=4{_deca =_gafg ._aba ;_gc .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_gafg ._aba );if _ecee ,_gdc :=_bee .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_gdc {if _ddfb ,_ddb :=GetName (_ecee .Get (0));_ddb {if *_ddfb =="\u0043\u0072\u0079p\u0074"{_deca ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gdee ,_bde :=_bee .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_bde {if _adf ,_cbb :=_gdee .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cbb {if _ ,_bga :=_gafg ._aaa [string (*_adf )];_bga {_gc .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_adf );
_deca =string (*_adf );};};};};};};_gc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_deca );if _deca =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_dege :=_gafg .Encrypt (_cgb .PdfObjectDictionary ,_cggf ,_baa );
if _dege !=nil {return _dege ;};_fcg ,_dege :=_gafg .makeKey (_deca ,uint32 (_cggf ),uint32 (_baa ),_gafg ._edf );if _dege !=nil {return _dege ;};_cgb .Stream ,_dege =_gafg .encryptBytes (_cgb .Stream ,_deca ,_fcg );if _dege !=nil {return _dege ;};_bee .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cgb .Stream ))));
return nil ;case *PdfObjectString :_gc .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_acd :=_gacf ;if _gafg ._be .V >=4{_gc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gafg ._gfeb );
if _gafg ._gfeb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_acd =_gafg ._gfeb ;};_cdae ,_facf :=_gafg .makeKey (_acd ,uint32 (parentObjNum ),uint32 (parentGenNum ),_gafg ._edf );if _facf !=nil {return _facf ;};_befb :=_cgb .Str ();
_abb :=make ([]byte ,len (_befb ));for _gbbd :=0;_gbbd < len (_befb );_gbbd ++{_abb [_gbbd ]=_befb [_gbbd ];};_gc .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_abb ,_abb );
_abb ,_facf =_gafg .encryptBytes (_abb ,_acd ,_cdae );if _facf !=nil {return _facf ;};_cgb ._effa =string (_abb );return nil ;case *PdfObjectArray :for _ ,_eacd :=range _cgb .Elements (){_bgd :=_gafg .Encrypt (_eacd ,parentObjNum ,parentGenNum );if _bgd !=nil {return _bgd ;
};};return nil ;case *PdfObjectDictionary :_cbgdc :=false ;if _faag :=_cgb .Get ("\u0054\u0079\u0070\u0065");_faag !=nil {_cbec ,_bgeb :=_faag .(*PdfObjectName );if _bgeb &&*_cbec =="\u0053\u0069\u0067"{_cbgdc =true ;};};for _ ,_gbab :=range _cgb .Keys (){_efa :=_cgb .Get (_gbab );
if _cbgdc &&string (_gbab )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gbab )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gbab )!="\u0050\u0072\u0065\u0076"&&string (_gbab )!="\u004c\u0061\u0073\u0074"{_dggf :=_gafg .Encrypt (_efa ,parentObjNum ,parentGenNum );
if _dggf !=nil {return _dggf ;};};};return nil ;};return nil ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_dcagg *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_agbbb ,_gcaa :=_dcagg ._gaddd [key ].(*PdfObjectString );if !_gcaa {return "",false ;};return _agbbb .Str (),true ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_fcef *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gc .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_gc .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_fcef .Predictor );
if _fcef .BitsPerComponent !=8{return nil ,_ca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_fcef .BitsPerComponent );
};_baaca ,_ecg :=_fcef .DecodeBytes (streamObj .Stream );if _ecg !=nil {return nil ,_ecg ;};_baaca ,_ecg =_fcef .postDecodePredict (_baaca );if _ecg !=nil {return nil ,_ecg ;};return _baaca ,nil ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_db .Reader )(PdfObject ,error ){_ababab :=false ;_daed :=true ;var _fabcg _cc .Buffer ;for {if _gc .Log .IsLogLevel (_gc .LogLevelTrace ){_gc .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_fabcg .String ());
};_ddcc ,_edac :=buf .Peek (1);if _edac ==_dd .EOF {break ;};if _edac !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_edac );return nil ,_edac ;};if _daed &&(_ddcc [0]=='-'||_ddcc [0]=='+'){_gdgb ,_ :=buf .ReadByte ();_fabcg .WriteByte (_gdgb );
_daed =false ;}else if IsDecimalDigit (_ddcc [0]){_dafdb ,_ :=buf .ReadByte ();_fabcg .WriteByte (_dafdb );}else if _ddcc [0]=='.'{_aaaaf ,_ :=buf .ReadByte ();_fabcg .WriteByte (_aaaaf );_ababab =true ;}else if _ddcc [0]=='e'||_ddcc [0]=='E'{_cefdf ,_ :=buf .ReadByte ();
_fabcg .WriteByte (_cefdf );_ababab =true ;_daed =true ;}else {break ;};};var _caedf PdfObject ;if _ababab {_gdag ,_edcag :=_g .ParseFloat (_fabcg .String (),64);if _edcag !=nil {_gc .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_fabcg .String (),_edcag );
_gdag =0.0;};_dgfcg :=PdfObjectFloat (_gdag );_caedf =&_dgfcg ;}else {_dggbc ,_adbc :=_g .ParseInt (_fabcg .String (),10,64);if _adbc !=nil {_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_fabcg .String (),_adbc );
_dggbc =0;};_bcfbg :=PdfObjectInteger (_dggbc );_caedf =&_bcfbg ;};return _caedf ,nil ;};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_fgfc *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _cfdd []float64 ;for _ ,_afec :=range _fgfc .Elements (){switch _cagb :=_afec .(type ){case *PdfObjectInteger :_cfdd =append (_cfdd ,float64 (*_cagb ));case *PdfObjectFloat :_cfdd =append (_cfdd ,float64 (*_cagb ));
default:return nil ,ErrTypeError ;};};return _cfdd ,nil ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_aeca *PdfObjectArray )Get (i int )PdfObject {if _aeca ==nil ||i >=len (_aeca ._gcgag )||i < 0{return nil ;};return _aeca ._gcgag [i ];};

// WriteString outputs the object as it is to be written to file.
func (_bgcb *PdfObjectName )WriteString ()string {var _beaa _cc .Buffer ;if len (*_bgcb )> 127{_gc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_bgcb );};_beaa .WriteString ("\u002f");
for _cbaa :=0;_cbaa < len (*_bgcb );_cbaa ++{_bgcfc :=(*_bgcb )[_cbaa ];if !IsPrintable (_bgcfc )||_bgcfc =='#'||IsDelimiter (_bgcfc ){_beaa .WriteString (_ca .Sprintf ("\u0023\u0025\u002e2\u0078",_bgcfc ));}else {_beaa .WriteByte (_bgcfc );};};return _beaa .String ();
};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _fecd (obj1 ,obj2 ,0)};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_cgcg *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cgcg .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_edded *JBIG2Image )ToGoImage ()(_d .Image ,error ){const _efab ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _edded .Data ==nil {return nil ,_bfb .Error (_efab ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _edded .Width ==0||_edded .Height ==0{return nil ,_bfb .Error (_efab ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_faeg ,_eccf :=_fb .NewImage (_edded .Width ,_edded .Height ,1,1,_edded .Data ,nil ,nil );if _eccf !=nil {return nil ,_eccf ;};return _faeg ,nil ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_egc []StreamEncoder };

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_eadcb *PdfObjectString ,_dcge bool ){_eadcb ,_dcge =TraceToDirectObject (obj ).(*PdfObjectString );return _eadcb ,_dcge ;};

// Len returns the number of elements in the streams.
func (_fcebc *PdfObjectStreams )Len ()int {if _fcebc ==nil {return 0;};return len (_fcebc ._gbgg );};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_gbcd :_dda .InitEncodeDocument (false )}};func (_dba *PdfParser )parseDetailedHeader ()(_ebe error ){_dba ._efbf .Seek (0,_dd .SeekStart );_dba ._ceecd =_db .NewReader (_dba ._efbf );_cbf :=20;
_aggd :=make ([]byte ,_cbf );var (_bcc bool ;_eegb int ;);for {_adg ,_gddf :=_dba ._ceecd .ReadByte ();if _gddf !=nil {if _gddf ==_dd .EOF {break ;}else {return _gddf ;};};if IsDecimalDigit (_adg )&&_aggd [_cbf -1]=='.'&&IsDecimalDigit (_aggd [_cbf -2])&&_aggd [_cbf -3]=='-'&&_aggd [_cbf -4]=='F'&&_aggd [_cbf -5]=='D'&&_aggd [_cbf -6]=='P'&&_aggd [_cbf -7]=='%'{_dba ._deebf =Version {Major :int (_aggd [_cbf -2]-'0'),Minor :int (_adg -'0')};
_dba ._fafa ._deggf =_eegb -7;_bcc =true ;break ;};_eegb ++;_aggd =append (_aggd [1:_cbf ],_adg );};if !_bcc {return _ca .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_gcbg ,_ebe :=_dba ._ceecd .ReadByte ();
if _ebe ==_dd .EOF {return _ca .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _ebe !=nil {return _ebe ;};_dba ._fafa ._ebdd =_gcbg =='\n';_gcbg ,_ebe =_dba ._ceecd .ReadByte ();
if _ebe !=nil {return _ca .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_ebe );};if _gcbg !='%'{return nil ;};_ecbb :=make ([]byte ,4);_ ,_ebe =_dba ._ceecd .Read (_ecbb );
if _ebe !=nil {return _ca .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_ebe );};_dba ._fafa ._dged =[4]byte {_ecbb [0],_ecbb [1],_ecbb [2],_ecbb [3]};
return nil ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_egce *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_gc .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_bgfa :=MakeDict ();_bgfa ._gfgd =_egce ;_ggda ,_ :=_egce ._ceecd .ReadByte ();
if _ggda !='<'{return nil ,_f .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_ggda ,_ =_egce ._ceecd .ReadByte ();if _ggda !='<'{return nil ,_f .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
};for {_egce .skipSpaces ();_egce .skipComments ();_eeba ,_cfe :=_egce ._ceecd .Peek (2);if _cfe !=nil {return nil ,_cfe ;};_gc .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_eeba ),string (_eeba ));
if (_eeba [0]=='>')&&(_eeba [1]=='>'){_gc .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_egce ._ceecd .ReadByte ();_egce ._ceecd .ReadByte ();break ;};_gc .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_abbc ,_cfe :=_egce .parseName ();_gc .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_abbc );if _cfe !=nil {_gc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_cfe );
return nil ,_cfe ;};if len (_abbc )> 4&&_abbc [len (_abbc )-4:]=="\u006e\u0075\u006c\u006c"{_gaadf :=_abbc [0:len (_abbc )-4];_gc .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_abbc );
_gc .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_gaadf );_egce .skipSpaces ();_fggb ,_ :=_egce ._ceecd .Peek (1);if _fggb [0]=='/'{_bgfa .Set (_gaadf ,MakeNull ());continue ;};
};_egce .skipSpaces ();_bgbea ,_cfe :=_egce .parseObject ();if _cfe !=nil {return nil ,_cfe ;};_bgfa .Set (_abbc ,_bgbea );if _gc .Log .IsLogLevel (_gc .LogLevelTrace ){_gc .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_abbc ,_bgbea .String ());
};};_gc .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _bgfa ,nil ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_eeed *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fdac :=_cc .NewReader (encoded );var _bag []byte ;for {_bbg ,_bfgd :=_fdac .ReadByte ();if _bfgd !=nil {return nil ,_bfgd ;};if _bbg =='>'{break ;};if IsWhiteSpace (_bbg ){continue ;
};if (_bbg >='a'&&_bbg <='f')||(_bbg >='A'&&_bbg <='F')||(_bbg >='0'&&_bbg <='9'){_bag =append (_bag ,_bbg );}else {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_bbg );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_bbg );};};if len (_bag )%2==1{_bag =append (_bag ,'0');
};_gc .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_bag );_dbe :=make ([]byte ,_fe .DecodedLen (len (_bag )));_ ,_gbfg :=_fe .Decode (_dbe ,_bag );if _gbfg !=nil {return nil ,_gbfg ;};return _dbe ,nil ;};func (_dfd *FlateEncoder )postDecodePredict (_beea []byte )([]byte ,error ){if _dfd .Predictor > 1{if _dfd .Predictor ==2{_gc .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_gc .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_dfd .Colors );_aaeg :=_dfd .Columns *_dfd .Colors ;if _aaeg < 1{return []byte {},nil ;};_fed :=len (_beea )/_aaeg ;if len (_beea )%_aaeg !=0{_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_beea ),_aaeg );};if _aaeg %_dfd .Colors !=0{return nil ,_ca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_aaeg ,_dfd .Colors );
};if _aaeg > len (_beea ){_gc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_aaeg ,len (_beea ));
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gc .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_beea ),_beea );
_bgeg :=_cc .NewBuffer (nil );for _eaec :=0;_eaec < _fed ;_eaec ++{_fbff :=_beea [_aaeg *_eaec :_aaeg *(_eaec +1)];for _accb :=_dfd .Colors ;_accb < _aaeg ;_accb ++{_fbff [_accb ]+=_fbff [_accb -_dfd .Colors ];};_bgeg .Write (_fbff );};_aced :=_bgeg .Bytes ();
_gc .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_aced ),_aced );return _aced ,nil ;}else if _dfd .Predictor >=10&&_dfd .Predictor <=15{_gc .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_beed :=_dfd .Columns *_dfd .Colors +1;_eeaf :=len (_beea )/_beed ;if len (_beea )%_beed !=0{return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_beea ),_beed );
};if _beed > len (_beea ){_gc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_beed ,len (_beea ));
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aecd :=_cc .NewBuffer (nil );_gc .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_dfd .Columns );
_gc .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_beea ),_beed ,_eeaf );_ggg :=make ([]byte ,_beed );for _ceec :=0;_ceec < _beed ;_ceec ++{_ggg [_ceec ]=0;};
_ddbe :=_dfd .Colors ;for _egddf :=0;_egddf < _eeaf ;_egddf ++{_cdf :=_beea [_beed *_egddf :_beed *(_egddf +1)];_deec :=_cdf [0];switch _deec {case _bggf :case _dbdb :for _ebbd :=1+_ddbe ;_ebbd < _beed ;_ebbd ++{_cdf [_ebbd ]+=_cdf [_ebbd -_ddbe ];};case _ffg :for _fbe :=1;
_fbe < _beed ;_fbe ++{_cdf [_fbe ]+=_ggg [_fbe ];};case _beb :for _cff :=1;_cff < _ddbe +1;_cff ++{_cdf [_cff ]+=_ggg [_cff ]/2;};for _ddbd :=_ddbe +1;_ddbd < _beed ;_ddbd ++{_cdf [_ddbd ]+=byte ((int (_cdf [_ddbd -_ddbe ])+int (_ggg [_ddbd ]))/2);};case _ebf :for _ffbb :=1;
_ffbb < _beed ;_ffbb ++{var _edea ,_cfg ,_gggc byte ;_cfg =_ggg [_ffbb ];if _ffbb >=_ddbe +1{_edea =_cdf [_ffbb -_ddbe ];_gggc =_ggg [_ffbb -_ddbe ];};_cdf [_ffbb ]+=_cdcbe (_edea ,_cfg ,_gggc );};default:_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_deec ,_egddf );
return nil ,_ca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_deec );};copy (_ggg ,_cdf );_aecd .Write (_cdf [1:]);};_acfb :=_aecd .Bytes ();return _acfb ,nil ;
}else {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_dfd .Predictor );return nil ,_ca .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_dfd .Predictor );
};};return _beea ,nil ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_fcbbg *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _gdge :=val .(type ){case *PdfObjectName :if _gdge !=nil {_fcbbg .Set (key ,val );};case *PdfObjectDictionary :if _gdge !=nil {_fcbbg .Set (key ,val );
};case *PdfObjectStream :if _gdge !=nil {_fcbbg .Set (key ,val );};case *PdfObjectString :if _gdge !=nil {_fcbbg .Set (key ,val );};case *PdfObjectNull :if _gdge !=nil {_fcbbg .Set (key ,val );};case *PdfObjectInteger :if _gdge !=nil {_fcbbg .Set (key ,val );
};case *PdfObjectArray :if _gdge !=nil {_fcbbg .Set (key ,val );};case *PdfObjectBool :if _gdge !=nil {_fcbbg .Set (key ,val );};case *PdfObjectFloat :if _gdge !=nil {_fcbbg .Set (key ,val );};case *PdfObjectReference :if _gdge !=nil {_fcbbg .Set (key ,val );
};case *PdfIndirectObject :if _gdge !=nil {_fcbbg .Set (key ,val );};default:_gc .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_deebf Version ;_efbf _dd .ReadSeeker ;_ceecd *_db .Reader ;_dcbg int64 ;_cfbe XrefTable ;_cefdc int64 ;_ecfge *xrefType ;_gfed objectStreams ;_aecc *PdfObjectDictionary ;_cddb *PdfCrypt ;_geff bool ;ObjCache objectCache ;_aaeb map[int ]bool ;
_aead map[int64 ]bool ;_fafa parserMetadata ;_eafeg bool ;};

// String returns a string describing `array`.
func (_eebgg *PdfObjectArray )String ()string {_egee :="\u005b";for _aaaag ,_egcf :=range _eebgg .Elements (){_egee +=_egcf .String ();if _aaaag < (_eebgg .Len ()-1){_egee +="\u002c\u0020";};};_egee +="\u005d";return _egee ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_fdbd *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _cfbbe []float64 ;for _ ,_bcff :=range _fdbd .Elements (){_fbefd ,_gbedf :=GetNumberAsFloat (TraceToDirectObject (_bcff ));if _gbedf !=nil {return nil ,_ca .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_cfbbe =append (_cfbbe ,_fbefd );};return _cfbbe ,nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_gbcd *_dda .Document ;

// Globals are the JBIG2 global segments.
Globals _cb .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_bcg *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _bcg .Predictor !=1{return nil ,_ca .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _bcg .EarlyChange ==1{return nil ,_ca .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _dbdf _cc .Buffer ;_dff :=_edg .NewWriter (&_dbdf ,_edg .MSB ,8);_dff .Write (data );_dff .Close ();return _dbdf .Bytes (),nil ;};

// String returns a string representation of `name`.
func (_bgad *PdfObjectName )String ()string {return string (*_bgad )};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};func (_fccb *PdfCrypt )encryptBytes (_dcd []byte ,_ead string ,_cgff []byte )([]byte ,error ){_gc .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_gde ,_bgf :=_fccb ._aaa [_ead ];if !_bgf {return nil ,_ca .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ead );};return _gde .EncryptBytes (_dcd ,_cgff );};func (_eecgf *PdfParser )inspect ()(map[string ]int ,error ){_gc .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_gc .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_cbfc :=map[string ]int {};_gcfd :=0;_aaecd :=0;var _gbgc []int ;for _gbbg :=range _eecgf ._cfbe .ObjectMap {_gbgc =append (_gbgc ,_gbbg );};_ef .Ints (_gbgc );_ddced :=0;
for _ ,_edcaf :=range _gbgc {_faaa :=_eecgf ._cfbe .ObjectMap [_edcaf ];if _faaa .ObjectNumber ==0{continue ;};_gcfd ++;_gc .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_gc .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_faaa .ObjectNumber );
_cfbba ,_bfeg :=_eecgf .LookupByNumber (_faaa .ObjectNumber );if _bfeg !=nil {_gc .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_faaa .ObjectNumber ,_bfeg );
_aaecd ++;continue ;};_gc .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_cfbba );_bdaaa ,_aafe :=_cfbba .(*PdfIndirectObject );if _aafe {_gc .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_faaa .ObjectNumber ,_bdaaa );
_bfddc ,_afdc :=_bdaaa .PdfObject .(*PdfObjectDictionary );if _afdc {if _gaggb ,_ffdef :=_bfddc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ffdef {_aedb :=string (*_gaggb );_gc .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_aedb );
_ ,_badgd :=_cbfc [_aedb ];if _badgd {_cbfc [_aedb ]++;}else {_cbfc [_aedb ]=1;};}else if _dfgce ,_dcefc :=_bfddc .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_dcefc {_agcc :=string (*_dfgce );_gc .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_agcc );
_ ,_ccdb :=_cbfc [_agcc ];if _ccdb {_cbfc [_agcc ]++;}else {_cbfc [_agcc ]=1;};};if _agaef ,_fgee :=_bfddc .Get ("\u0053").(*PdfObjectName );_fgee &&*_agaef =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_gceea :=_cbfc ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _gceea {_cbfc ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_cbfc ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _bagb ,_fabde :=_cfbba .(*PdfObjectStream );_fabde {if _bdgg ,_ecfe :=_bagb .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_ecfe {_gc .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_bdgg );_bfbb :=string (*_bdgg );_cbfc [_bfbb ]++;};}else {_bcgg ,_geeg :=_cfbba .(*PdfObjectDictionary );
if _geeg {_afcc ,_cfdb :=_bcgg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _cfdb {_dgff :=string (*_afcc );_gc .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_dgff );_cbfc [_dgff ]++;};};_gc .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_faaa .ObjectNumber ,_cfbba );
};_ddced ++;};_gc .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_gc .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");
_gc .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_gcfd );_gc .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_aaecd );for _adge ,_gecge :=range _cbfc {_gc .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_adge ,_gecge );
};_gc .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_eecgf ._cfbe .ObjectMap )< 1{_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_ca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_eafef ,_aaga :=_cbfc ["\u0046\u006f\u006e\u0074"];
if !_aaga ||_eafef < 2{_gc .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_gc .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _cbfc ,nil ;};const JB2ImageAutoThreshold =-1.0;

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_gcgag :objects }};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_cgge *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_bdgb :=MakeDict ();_bdgb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cgge .GetFilterName ()));return _bdgb ;};var _gggca =_ea .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");
func (_cdec *PdfObjectInteger )String ()string {return _ca .Sprintf ("\u0025\u0064",*_cdec )};func (_cfff *PdfParser )readComment ()(string ,error ){var _aebg _cc .Buffer ;_ ,_edcc :=_cfff .skipSpaces ();if _edcc !=nil {return _aebg .String (),_edcc ;};
_bbde :=true ;for {_eggg ,_agab :=_cfff ._ceecd .Peek (1);if _agab !=nil {_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_agab .Error ());return _aebg .String (),_agab ;};if _bbde &&_eggg [0]!='%'{return _aebg .String (),_f .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");
};_bbde =false ;if (_eggg [0]!='\r')&&(_eggg [0]!='\n'){_cag ,_ :=_cfff ._ceecd .ReadByte ();_aebg .WriteByte (_cag );}else {break ;};};return _aebg .String (),nil ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_deabe *PdfObjectReference )Resolve ()PdfObject {if _deabe ._fecc ==nil {return MakeNull ();};_bbbf ,_ ,_facfc :=_deabe ._fecc .resolveReference (_deabe );if _facfc !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_facfc );
return MakeNull ();};if _bbbf ==nil {_gc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _bbbf ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bagc *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_gcbf *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _abgc ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _gcbf .ColorComponents !=1||_gcbf .BitsPerComponent !=1{return nil ,_bfb .Errorf (_abgc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_fbg *_fa .Bitmap ;_baba error ;);_adbe :=(_gcbf .Width *_gcbf .Height )==len (data );if _adbe {_fbg ,_baba =_fa .NewWithUnpaddedData (_gcbf .Width ,_gcbf .Height ,data );}else {_fbg ,_baba =_fa .NewWithData (_gcbf .Width ,_gcbf .Height ,data );
};if _baba !=nil {return nil ,_baba ;};_cbefc :=_gcbf .DefaultPageSettings ;if _baba =_cbefc .Validate ();_baba !=nil {return nil ,_bfb .Wrap (_baba ,_abgc ,"");};if _gcbf ._gbcd ==nil {_gcbf ._gbcd =_dda .InitEncodeDocument (_cbefc .FileMode );};switch _cbefc .Compression {case JB2Generic :if _baba =_gcbf ._gbcd .AddGenericPage (_fbg ,_cbefc .DuplicatedLinesRemoval );
_baba !=nil {return nil ,_bfb .Wrap (_baba ,_abgc ,"");};case JB2SymbolCorrelation :return nil ,_bfb .Error (_abgc ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_bfb .Error (_abgc ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_bfb .Error (_abgc ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _gcbf .Encode ();};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// WriteString outputs the object as it is to be written to file.
func (_fcfd *PdfObjectStream )WriteString ()string {var _eace _fd .Builder ;_eace .WriteString (_g .FormatInt (_fcfd .ObjectNumber ,10));_eace .WriteString ("\u0020\u0030\u0020\u0052");return _eace .String ();};

// WriteString outputs the object as it is to be written to file.
func (_bdabc *PdfObjectString )WriteString ()string {var _dddba _cc .Buffer ;if _bdabc ._adfge {_eccce :=_fe .EncodeToString (_bdabc .Bytes ());_dddba .WriteString ("\u003c");_dddba .WriteString (_eccce );_dddba .WriteString ("\u003e");return _dddba .String ();
};_cfef :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_dddba .WriteString ("\u0028");for _bgegb :=0;_bgegb < len (_bdabc ._effa );
_bgegb ++{_bcafa :=_bdabc ._effa [_bgegb ];if _cgbb ,_aafc :=_cfef [_bcafa ];_aafc {_dddba .WriteString (_cgbb );}else {_dddba .WriteByte (_bcafa );};};_dddba .WriteString ("\u0029");return _dddba .String ();};

// Elements returns a slice of the PdfObject elements in the array.
func (_gdea *PdfObjectArray )Elements ()[]PdfObject {if _gdea ==nil {return nil ;};return _gdea ._gcgag ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_faege *PdfObjectName ,_edfgg bool ){_faege ,_edfgg =TraceToDirectObject (obj ).(*PdfObjectName );return _faege ,_edfgg ;};

// Remove removes an element specified by key.
func (_fbab *PdfObjectDictionary )Remove (key PdfObjectName ){_cbdf :=-1;for _fdbc ,_befc :=range _fbab ._fdbbd {if _befc ==key {_cbdf =_fdbc ;break ;};};if _cbdf >=0{_fbab ._fdbbd =append (_fbab ._fdbbd [:_cbdf ],_fbab ._fdbbd [_cbdf +1:]...);delete (_fbab ._gaddd ,key );
};};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_gccg *PdfObjectArray ,_efaf bool ){_gccg ,_efaf =TraceToDirectObject (obj ).(*PdfObjectArray );return _gccg ,_efaf ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_bcfdd *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_ebeed ,_ggdg :=_bcfdd ._gaddd [key ];if !_ggdg {return nil ;};return _ebeed ;};func (_faace *PdfParser )parseString ()(*PdfObjectString ,error ){_faace ._ceecd .ReadByte ();var _abgcf _cc .Buffer ;
_fade :=1;for {_gafb ,_aeefd :=_faace ._ceecd .Peek (1);if _aeefd !=nil {return MakeString (_abgcf .String ()),_aeefd ;};if _gafb [0]=='\\'{_faace ._ceecd .ReadByte ();_afaa ,_abad :=_faace ._ceecd .ReadByte ();if _abad !=nil {return MakeString (_abgcf .String ()),_abad ;
};if IsOctalDigit (_afaa ){_afbd ,_fefa :=_faace ._ceecd .Peek (2);if _fefa !=nil {return MakeString (_abgcf .String ()),_fefa ;};var _eedf []byte ;_eedf =append (_eedf ,_afaa );for _ ,_eabc :=range _afbd {if IsOctalDigit (_eabc ){_eedf =append (_eedf ,_eabc );
}else {break ;};};_faace ._ceecd .Discard (len (_eedf )-1);_gc .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_eedf );_fabd ,_fefa :=_g .ParseUint (string (_eedf ),8,32);if _fefa !=nil {return MakeString (_abgcf .String ()),_fefa ;
};_abgcf .WriteByte (byte (_fabd ));continue ;};switch _afaa {case 'n':_abgcf .WriteRune ('\n');case 'r':_abgcf .WriteRune ('\r');case 't':_abgcf .WriteRune ('\t');case 'b':_abgcf .WriteRune ('\b');case 'f':_abgcf .WriteRune ('\f');case '(':_abgcf .WriteRune ('(');
case ')':_abgcf .WriteRune (')');case '\\':_abgcf .WriteRune ('\\');};continue ;}else if _gafb [0]=='('{_fade ++;}else if _gafb [0]==')'{_fade --;if _fade ==0{_faace ._ceecd .ReadByte ();break ;};};_gbcfg ,_ :=_faace ._ceecd .ReadByte ();_abgcf .WriteByte (_gbcfg );
};return MakeString (_abgcf .String ()),nil ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_abbgb bool ,_eadcg bool ){_gaac ,_eadcg :=TraceToDirectObject (obj ).(*PdfObjectBool );if _eadcg {return bool (*_gaac ),true ;};return false ,false ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_abgf *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _eccd _cc .Buffer ;for _bfbd :=0;_bfbd < len (data );_bfbd +=4{_add :=data [_bfbd ];_dbdec :=1;_egbg :=byte (0);if _bfbd +1< len (data ){_egbg =data [_bfbd +1];_dbdec ++;};_aacga :=byte (0);
if _bfbd +2< len (data ){_aacga =data [_bfbd +2];_dbdec ++;};_bdef :=byte (0);if _bfbd +3< len (data ){_bdef =data [_bfbd +3];_dbdec ++;};_ddbg :=(uint32 (_add )<<24)|(uint32 (_egbg )<<16)|(uint32 (_aacga )<<8)|uint32 (_bdef );if _ddbg ==0{_eccd .WriteByte ('z');
}else {_gbfd :=_abgf .base256Tobase85 (_ddbg );for _ ,_bcbd :=range _gbfd [:_dbdec +1]{_eccd .WriteByte (_bcbd +'!');};};};_eccd .WriteString ("\u007e\u003e");return _eccd .Bytes (),nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_abab *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _abab .DecodeBytes (streamObj .Stream );};func (_gegb *PdfParser )parseBool ()(PdfObjectBool ,error ){_dbee ,_cab :=_gegb ._ceecd .Peek (4);if _cab !=nil {return PdfObjectBool (false ),_cab ;
};if (len (_dbee )>=4)&&(string (_dbee [:4])=="\u0074\u0072\u0075\u0065"){_gegb ._ceecd .Discard (4);return PdfObjectBool (true ),nil ;};_dbee ,_cab =_gegb ._ceecd .Peek (5);if _cab !=nil {return PdfObjectBool (false ),_cab ;};if (len (_dbee )>=5)&&(string (_dbee [:5])=="\u0066\u0061\u006cs\u0065"){_gegb ._ceecd .Discard (5);
return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_f .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};func (_gdgab *PdfParser )parseObject ()(PdfObject ,error ){_gc .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");
_gdgab .skipSpaces ();for {_gcf ,_edcb :=_gdgab ._ceecd .Peek (2);if _edcb !=nil {if _edcb !=_dd .EOF ||len (_gcf )==0{return nil ,_edcb ;};if len (_gcf )==1{_gcf =append (_gcf ,' ');};};_gc .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_gcf ));
if _gcf [0]=='/'{_aafd ,_gffa :=_gdgab .parseName ();_gc .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_aafd );return &_aafd ,_gffa ;}else if _gcf [0]=='('{_gc .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_bfgf ,_gfc :=_gdgab .parseString ();return _bfgf ,_gfc ;}else if _gcf [0]=='['{_gc .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_fbbda ,_deb :=_gdgab .parseArray ();return _fbbda ,_deb ;}else if (_gcf [0]=='<')&&(_gcf [1]=='<'){_gc .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_fbfe ,_dddb :=_gdgab .ParseDict ();return _fbfe ,_dddb ;}else if _gcf [0]=='<'{_gc .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_bbbg ,_abff :=_gdgab .parseHexString ();return _bbbg ,_abff ;}else if _gcf [0]=='%'{_gdgab .readComment ();
_gdgab .skipSpaces ();}else {_gc .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_gcf ,_ =_gdgab ._ceecd .Peek (15);_dgca :=string (_gcf );_gc .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_dgca );
if (len (_dgca )> 3)&&(_dgca [:4]=="\u006e\u0075\u006c\u006c"){_cbfea ,_dccb :=_gdgab .parseNull ();return &_cbfea ,_dccb ;}else if (len (_dgca )> 4)&&(_dgca [:5]=="\u0066\u0061\u006cs\u0065"){_bdcd ,_ccee :=_gdgab .parseBool ();return &_bdcd ,_ccee ;}else if (len (_dgca )> 3)&&(_dgca [:4]=="\u0074\u0072\u0075\u0065"){_ccfe ,_adcfe :=_gdgab .parseBool ();
return &_ccfe ,_adcfe ;};_cddf :=_cdfaf .FindStringSubmatch (_dgca );if len (_cddf )> 1{_gcf ,_ =_gdgab ._ceecd .ReadBytes ('R');_gc .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_gcf [:]));_eccc ,_beee :=_bdb (string (_gcf ));
_eccc ._fecc =_gdgab ;return &_eccc ,_beee ;};_fece :=_cdeg .FindStringSubmatch (_dgca );if len (_fece )> 1{_gc .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_cgag ,_gcge :=_gdgab .parseNumber ();return _cgag ,_gcge ;};_fece =_cace .FindStringSubmatch (_dgca );
if len (_fece )> 1{_gc .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_gc .Log .Trace ("\u0025\u0020\u0073",_fece );_dffg ,_gefc :=_gdgab .parseNumber ();return _dffg ,_gefc ;
};_gc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_dgca );return nil ,_f .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// WriteString outputs the object as it is to be written to file.
func (_edeaf *PdfObjectBool )WriteString ()string {if *_edeaf {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_dc []XrefObject ;};

// Len returns the number of elements in the array.
func (_eeef *PdfObjectArray )Len ()int {if _eeef ==nil {return 0;};return len (_eeef ._gcgag );};

// DecodeStream implements ASCII85 stream decoding.
func (_bbafc *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bbafc .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_bff *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };var _efdd =_ea .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// WriteString outputs the object as it is to be written to file.
func (_gbgea *PdfIndirectObject )WriteString ()string {var _bdbe _fd .Builder ;_bdbe .WriteString (_g .FormatInt (_gbgea .ObjectNumber ,10));_bdbe .WriteString ("\u0020\u0030\u0020\u0052");return _bdbe .String ();};

// String returns a string describing `d`.
func (_baadb *PdfObjectDictionary )String ()string {var _bbba _fd .Builder ;_bbba .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_bbece :=range _baadb ._fdbbd {_aege :=_baadb ._gaddd [_bbece ];_bbba .WriteString ("\u0022"+_bbece .String ()+"\u0022\u003a\u0020");
_bbba .WriteString (_aege .String ());_bbba .WriteString ("\u002c\u0020");};_bbba .WriteString ("\u0029");return _bbba .String ();};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bcf *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bcf .isDecrypted (obj ){return nil ;};switch _bab :=obj .(type ){case *PdfIndirectObject :_bcf ._acf [_bab ]=true ;_gc .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_bab .ObjectNumber ,_bab .GenerationNumber );
_edgb :=_bab .ObjectNumber ;_bafe :=_bab .GenerationNumber ;_bcb :=_bcf .Decrypt (_bab .PdfObject ,_edgb ,_bafe );if _bcb !=nil {return _bcb ;};return nil ;case *PdfObjectStream :_bcf ._acf [_bab ]=true ;_ebd :=_bab .PdfObjectDictionary ;if _bcf ._bbc .R !=5{if _cde ,_degg :=_ebd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_degg &&*_cde =="\u0058\u0052\u0065\u0066"{return nil ;};};_fgf :=_bab .ObjectNumber ;_agb :=_bab .GenerationNumber ;_gc .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_fgf ,_agb );
_fge :=_gacf ;if _bcf ._be .V >=4{_fge =_bcf ._aba ;_gc .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bcf ._aba );if _acb ,_aff :=_ebd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_aff {if _ddg ,_ceb :=GetName (_acb .Get (0));_ceb {if *_ddg =="\u0043\u0072\u0079p\u0074"{_fge ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cfc ,_ccc :=_ebd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_ccc {if _ebb ,_fde :=_cfc .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_fde {if _ ,_dag :=_bcf ._aaa [string (*_ebb )];_dag {_gc .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_ebb );
_fge =string (*_ebb );};};};};};};_gc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fge );if _fge =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ddfa :=_bcf .Decrypt (_ebd ,_fgf ,_agb );
if _ddfa !=nil {return _ddfa ;};_ddc ,_ddfa :=_bcf .makeKey (_fge ,uint32 (_fgf ),uint32 (_agb ),_bcf ._edf );if _ddfa !=nil {return _ddfa ;};_bab .Stream ,_ddfa =_bcf .decryptBytes (_bab .Stream ,_fge ,_ddc );if _ddfa !=nil {return _ddfa ;};_ebd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bab .Stream ))));
return nil ;case *PdfObjectString :_gc .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_cdg :=_gacf ;if _bcf ._be .V >=4{_gc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bcf ._gfeb );
if _bcf ._gfeb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_cdg =_bcf ._gfeb ;};_efd ,_bba :=_bcf .makeKey (_cdg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bcf ._edf );if _bba !=nil {return _bba ;};_dec :=_bab .Str ();_fdcf :=make ([]byte ,len (_dec ));
for _bgcf :=0;_bgcf < len (_dec );_bgcf ++{_fdcf [_bgcf ]=_dec [_bgcf ];};_gc .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_fdcf ,_fdcf );_fdcf ,_bba =_bcf .decryptBytes (_fdcf ,_cdg ,_efd );
if _bba !=nil {return _bba ;};_bab ._effa =string (_fdcf );return nil ;case *PdfObjectArray :for _ ,_gcc :=range _bab .Elements (){_bef :=_bcf .Decrypt (_gcc ,parentObjNum ,parentGenNum );if _bef !=nil {return _bef ;};};return nil ;case *PdfObjectDictionary :_bfc :=false ;
if _ggd :=_bab .Get ("\u0054\u0079\u0070\u0065");_ggd !=nil {_dbde ,_edfc :=_ggd .(*PdfObjectName );if _edfc &&*_dbde =="\u0053\u0069\u0067"{_bfc =true ;};};for _ ,_bfcc :=range _bab .Keys (){_fcaf :=_bab .Get (_bfcc );if _bfc &&string (_bfcc )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;
};if string (_bfcc )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_bfcc )!="\u0050\u0072\u0065\u0076"&&string (_bfcc )!="\u004c\u0061\u0073\u0074"{_fbbe :=_bcf .Decrypt (_fcaf ,parentObjNum ,parentGenNum );if _fbbe !=nil {return _fbbe ;};};};return nil ;
};return nil ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_gddc *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _cefa []int64 ;for _ ,_caga :=range _gddc .Elements (){if _ddga ,_ceece :=_caga .(*PdfObjectInteger );_ceece {_cefa =append (_cefa ,int64 (*_ddga ));}else {return nil ,ErrTypeError ;};};
return _cefa ,nil ;};func _abd (_dbb XrefTable ){_gc .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_gc .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_agcd :=0;for _ ,_gff :=range _dbb .ObjectMap {_gc .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_agcd +1,_gff .ObjectNumber ,_gff .Generation ,_gff .Offset );
_agcd ++;};};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_gaff :=MakeArray ();for _ ,_beab :=range vals {_gaff .Append (MakeFloat (_beab ));};return _gaff ;};func (_cebbb *PdfParser )parseName ()(PdfObjectName ,error ){var _fedfd _cc .Buffer ;_fgac :=false ;
for {_faacc ,_fdad :=_cebbb ._ceecd .Peek (1);if _fdad ==_dd .EOF {break ;};if _fdad !=nil {return PdfObjectName (_fedfd .String ()),_fdad ;};if !_fgac {if _faacc [0]=='/'{_fgac =true ;_cebbb ._ceecd .ReadByte ();}else if _faacc [0]=='%'{_cebbb .readComment ();
_cebbb .skipSpaces ();}else {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_faacc ,_faacc );return PdfObjectName (_fedfd .String ()),_ca .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_faacc [0]);
};}else {if IsWhiteSpace (_faacc [0]){break ;}else if (_faacc [0]=='/')||(_faacc [0]=='[')||(_faacc [0]=='(')||(_faacc [0]==']')||(_faacc [0]=='<')||(_faacc [0]=='>'){break ;}else if _faacc [0]=='#'{_ffgf ,_effb :=_cebbb ._ceecd .Peek (3);if _effb !=nil {return PdfObjectName (_fedfd .String ()),_effb ;
};_fcccb ,_effb :=_fe .DecodeString (string (_ffgf [1:3]));if _effb !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_fedfd .WriteByte ('#');_cebbb ._ceecd .Discard (1);continue ;};_cebbb ._ceecd .Discard (3);_fedfd .Write (_fcccb );}else {_cdaec ,_ :=_cebbb ._ceecd .ReadByte ();_fedfd .WriteByte (_cdaec );};};};return PdfObjectName (_fedfd .String ()),nil ;};func (_afgg *PdfParser )rebuildXrefTable ()error {_cdef :=XrefTable {};
_cdef .ObjectMap =map[int ]XrefObject {};_bfca :=make ([]int ,0,len (_afgg ._cfbe .ObjectMap ));for _fcec :=range _afgg ._cfbe .ObjectMap {_bfca =append (_bfca ,_fcec );};_ef .Ints (_bfca );for _ ,_feacb :=range _bfca {_baafd :=_afgg ._cfbe .ObjectMap [_feacb ];
_acfc ,_ ,_gfgb :=_afgg .lookupByNumberWrapper (_feacb ,false );if _gfgb !=nil {_gc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_gfgb );
_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_dcfce ,_gcafc :=_afgg .repairRebuildXrefsTopDown ();if _gcafc !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_gcafc );
return _gcafc ;};_afgg ._cfbe =*_dcfce ;_gc .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_adeb ,_ddea ,_gfgb :=_ace (_acfc );if _gfgb !=nil {return _gfgb ;
};_baafd .ObjectNumber =int (_adeb );_baafd .Generation =int (_ddea );_cdef .ObjectMap [int (_adeb )]=_baafd ;};_afgg ._cfbe =_cdef ;_gc .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_abd (_afgg ._cfbe );
return nil ;};

// HeaderCommentBytes gets the header comment bytes.
func (_ecbf *parserMetadata )HeaderCommentBytes ()[4]byte {return _ecbf ._dged };

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_fefb :=PdfObjectBool (val );return &_fefb };func _eadf (_ecgf *PdfObjectStream ,_fefg *MultiEncoder )(*DCTEncoder ,error ){_gfgg :=NewDCTEncoder ();_afdg :=_ecgf .PdfObjectDictionary ;if _afdg ==nil {return _gfgg ,nil ;
};_dcce :=_ecgf .Stream ;if _fefg !=nil {_fdfg ,_bdfa :=_fefg .DecodeBytes (_dcce );if _bdfa !=nil {return nil ,_bdfa ;};_dcce =_fdfg ;};_bbaf :=_cc .NewReader (_dcce );_fddb ,_gaee :=_ed .DecodeConfig (_bbaf );if _gaee !=nil {_gc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_gaee );
return nil ,_gaee ;};switch _fddb .ColorModel {case _b .RGBAModel :_gfgg .BitsPerComponent =8;_gfgg .ColorComponents =3;case _b .RGBA64Model :_gfgg .BitsPerComponent =16;_gfgg .ColorComponents =3;case _b .GrayModel :_gfgg .BitsPerComponent =8;_gfgg .ColorComponents =1;
case _b .Gray16Model :_gfgg .BitsPerComponent =16;_gfgg .ColorComponents =1;case _b .CMYKModel :_gfgg .BitsPerComponent =8;_gfgg .ColorComponents =4;case _b .YCbCrModel :_gfgg .BitsPerComponent =8;_gfgg .ColorComponents =3;default:return nil ,_f .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_gfgg .Width =_fddb .Width ;_gfgg .Height =_fddb .Height ;_gc .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_gfgg );_gfgg .Quality =DefaultJPEGQuality ;return _gfgg ,nil ;};const (DefaultJPEGQuality =75;
);

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_eagg *PdfParser )GetFileOffset ()int64 {_ddff ,_ :=_eagg ._efbf .Seek (0,_dd .SeekCurrent );_ddff -=int64 (_eagg ._ceecd .Buffered ());return _ddff ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_fdfe :=&DCTEncoder {};_fdfe .ColorComponents =3;_fdfe .BitsPerComponent =8;_fdfe .Quality =DefaultJPEGQuality ;return _fdfe ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};func (_bad *PdfCrypt )securityHandler ()_ae .StdHandler {if _bad ._bbc .R >=5{return _ae .NewHandlerR6 ();};return _ae .NewHandlerR4 (_bad ._dggc ,_bad ._be .Length );};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_adff *JBIG2Encoder )Encode ()(_affb []byte ,_edfg error ){const _bcaca ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _adff ._gbcd ==nil {return nil ,_bfb .Errorf (_bcaca ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_adff ._gbcd .FullHeaders =_adff .DefaultPageSettings .FileMode ;_affb ,_edfg =_adff ._gbcd .Encode ();if _edfg !=nil {return nil ,_bfb .Wrap (_edfg ,_bcaca ,"");};return _affb ,nil ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_ecdc :=&ASCII85Encoder {};return _ecdc };

// SetFileOffset sets the file to an offset position and resets buffer.
func (_gedc *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_gedc ._efbf .Seek (offset ,_dd .SeekStart );_gedc ._ceecd =_db .NewReader (_gedc ._efbf );};func _gdfba (_dede int )int {_fbcfd :=_dede >>(_ebdf -1);return (_dede ^_fbcfd )-_fbcfd };


// WriteString outputs the object as it is to be written to file.
func (_bacde *PdfObjectStreams )WriteString ()string {var _bbdf _fd .Builder ;_bbdf .WriteString (_g .FormatInt (_bacde .ObjectNumber ,10));_bbdf .WriteString ("\u0020\u0030\u0020\u0052");return _bbdf .String ();};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_fgdb *JBIG2Encoder )DecodeGlobals (encoded []byte )(_cb .Globals ,error ){return _cb .DecodeGlobals (encoded );};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dgdc *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fbbf *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_bcfaa *PdfObjectDictionary )Keys ()[]PdfObjectName {if _bcfaa ==nil {return nil ;};return _bcfaa ._fdbbd ;};

// GetFilterName returns the name of the encoding filter.
func (_bgebe *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_caff int ,_eceg bool ){_abec ,_eceg :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _eceg &&_abec !=nil {return int (*_abec ),true ;};return 0,false ;};const (_bggf =0;_dbdb =1;_ffg =2;_beb =3;_ebf =4;);func _fecd (_dfcf ,_aacgag PdfObject ,_cbfb int )bool {if _cbfb > _acccg {_gc .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_acccg );
return false ;};if _dfcf ==nil &&_aacgag ==nil {return true ;}else if _dfcf ==nil ||_aacgag ==nil {return false ;};if _e .TypeOf (_dfcf )!=_e .TypeOf (_aacgag ){return false ;};switch _agdc :=_dfcf .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_agdc ==*(_aacgag .(*PdfObjectName ));case *PdfObjectString :return *_agdc ==*(_aacgag .(*PdfObjectString ));case *PdfObjectInteger :return *_agdc ==*(_aacgag .(*PdfObjectInteger ));case *PdfObjectBool :return *_agdc ==*(_aacgag .(*PdfObjectBool ));
case *PdfObjectFloat :return *_agdc ==*(_aacgag .(*PdfObjectFloat ));case *PdfIndirectObject :return _fecd (TraceToDirectObject (_dfcf ),TraceToDirectObject (_aacgag ),_cbfb +1);case *PdfObjectArray :_ffdeb :=_aacgag .(*PdfObjectArray );if len ((*_agdc )._gcgag )!=len ((*_ffdeb )._gcgag ){return false ;
};for _bcgfe ,_dfaa :=range (*_agdc )._gcgag {if !_fecd (_dfaa ,(*_ffdeb )._gcgag [_bcgfe ],_cbfb +1){return false ;};};return true ;case *PdfObjectDictionary :_baeff :=_aacgag .(*PdfObjectDictionary );_eedba ,_faaag :=(*_agdc )._gaddd ,(*_baeff )._gaddd ;
if len (_eedba )!=len (_faaag ){return false ;};for _ebddf ,_bdaad :=range _eedba {_gcgee ,_bgaaa :=_faaag [_ebddf ];if !_bgaaa ||!_fecd (_bdaad ,_gcgee ,_cbfb +1){return false ;};};return true ;case *PdfObjectStream :_fcgb :=_aacgag .(*PdfObjectStream );
return _fecd ((*_agdc ).PdfObjectDictionary ,(*_fcgb ).PdfObjectDictionary ,_cbfb +1);default:_gc .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_dfcf );
};return false ;};const _acccg =10;

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_affd []float64 ,_cddca error ){for _ ,_ffcd :=range objects {_gafbg ,_abbgg :=GetNumberAsFloat (_ffcd );if _abbgg !=nil {return nil ,_abbgg ;};_affd =append (_affd ,_gafbg );};return _affd ,nil ;};func (_cdaa *PdfCrypt )decryptBytes (_aeg []byte ,_caf string ,_egd []byte )([]byte ,error ){_gc .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_fddg ,_eaa :=_cdaa ._aaa [_caf ];if !_eaa {return nil ,_ca .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_caf );};return _fddg .DecryptBytes (_aeg ,_egd );};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_agbf *PdfObjectBool ,_bfced bool ){_agbf ,_bfced =TraceToDirectObject (obj ).(*PdfObjectBool );return _agbf ,_bfced ;};

// DecodeStream implements ASCII hex decoding.
func (_ddce *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ddce .DecodeBytes (streamObj .Stream );};type offsetReader struct{_eebd _dd .ReadSeeker ;_dbff int64 ;};var _adga =_ea .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");


// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_adfg *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_fabc :=MakeDict ();_fabc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_adfg .GetFilterName ()));_ddda :=_adfg .MakeDecodeParams ();if _ddda !=nil {_fabc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ddda );
};_fabc .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_adfg .EarlyChange )));return _fabc ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_aaac *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _gecgf _cc .Buffer ;_gecgf .Write ([]byte {0xFE,0xFF});_gecgf .WriteString (_ac .StringToUTF16 (s ));return &PdfObjectString {_effa :_gecgf .String (),_adfge :true };};return &PdfObjectString {_effa :string (_ac .StringToPDFDocEncoding (s )),_adfge :false };
};func _bdb (_gefd string )(PdfObjectReference ,error ){_fdbb :=PdfObjectReference {};_ggba :=_cdfaf .FindStringSubmatch (_gefd );if len (_ggba )< 3{_gc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _fdbb ,_f .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_dfde ,_ :=_g .Atoi (_ggba [1]);_begd ,_ :=_g .Atoi (_ggba [2]);_fdbb .ObjectNumber =int64 (_dfde );_fdbb .GenerationNumber =int64 (_begd );
return _fdbb ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_dabe *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// WriteString outputs the object as it is to be written to file.
func (_ggfdg *PdfObjectReference )WriteString ()string {var _fegd _fd .Builder ;_fegd .WriteString (_g .FormatInt (_ggfdg .ObjectNumber ,10));_fegd .WriteString ("\u0020");_fegd .WriteString (_g .FormatInt (_ggfdg .GenerationNumber ,10));_fegd .WriteString ("\u0020\u0052");
return _fegd .String ();};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// String returns a string representation of the *PdfObjectString.
func (_fcgg *PdfObjectString )String ()string {return _fcgg ._effa };

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_dgf *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_dbad :=_cc .NewReader (data );var _adeg []byte ;var _eca []byte ;_fbffb ,_fedd :=_dbad .ReadByte ();if _fedd ==_dd .EOF {return []byte {},nil ;}else if _fedd !=nil {return nil ,_fedd ;
};_bcegg :=1;for {_agbb ,_aada :=_dbad .ReadByte ();if _aada ==_dd .EOF {break ;}else if _aada !=nil {return nil ,_aada ;};if _agbb ==_fbffb {if len (_eca )> 0{_eca =_eca [:len (_eca )-1];if len (_eca )> 0{_adeg =append (_adeg ,byte (len (_eca )-1));_adeg =append (_adeg ,_eca ...);
};_bcegg =1;_eca =[]byte {};};_bcegg ++;if _bcegg >=127{_adeg =append (_adeg ,byte (257-_bcegg ),_fbffb );_bcegg =0;};}else {if _bcegg > 0{if _bcegg ==1{_eca =[]byte {_fbffb };}else {_adeg =append (_adeg ,byte (257-_bcegg ),_fbffb );};_bcegg =0;};_eca =append (_eca ,_agbb );
if len (_eca )>=127{_adeg =append (_adeg ,byte (len (_eca )-1));_adeg =append (_adeg ,_eca ...);_eca =[]byte {};};};_fbffb =_agbb ;};if len (_eca )> 0{_adeg =append (_adeg ,byte (len (_eca )-1));_adeg =append (_adeg ,_eca ...);}else if _bcegg > 0{_adeg =append (_adeg ,byte (257-_bcegg ),_fbffb );
};_adeg =append (_adeg ,128);return _adeg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgae *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_edde :=MakeDict ();_edde .Set ("\u004b",MakeInteger (int64 (_fgae .K )));_edde .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fgae .Columns )));if _fgae .BlackIs1 {_edde .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_fgae .BlackIs1 ));
};if _fgae .EncodedByteAlign {_edde .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_fgae .EncodedByteAlign ));};if _fgae .EndOfLine &&_fgae .K >=0{_edde .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_fgae .EndOfLine ));
};if _fgae .Rows !=0&&!_fgae .EndOfBlock {_edde .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_fgae .Rows )));};if !_fgae .EndOfBlock {_edde .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_fgae .EndOfBlock ));};if _fgae .DamagedRowsBeforeError !=0{_edde .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_fgae .DamagedRowsBeforeError )));
};return _edde ;};func _dgaa ()string {return _gc .Version };func _eea (_gcgg *PdfObjectStream ,_eaf *PdfObjectDictionary )(*FlateEncoder ,error ){_dea :=NewFlateEncoder ();_ebad :=_gcgg .PdfObjectDictionary ;if _ebad ==nil {return _dea ,nil ;};_dea ._bgee =_dfc (_ebad );
if _eaf ==nil {_fbdf :=TraceToDirectObject (_ebad .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _cae :=_fbdf .(type ){case *PdfObjectArray :if _cae .Len ()!=1{_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_cae .Len ());
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _febg ,_cfcg :=GetDict (_cae .Get (0));_cfcg {_eaf =_febg ;};case *PdfObjectDictionary :_eaf =_cae ;case *PdfObjectNull ,nil :default:_gc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_fbdf );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _eaf ==nil {return _dea ,nil ;};_gc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_eaf .String ());
_dacc :=_eaf .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _dacc ==nil {_gc .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_fccd ,_egdd :=_dacc .(*PdfObjectInteger );if !_egdd {_gc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dacc );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_dea .Predictor =int (*_fccd );};_dacc =_eaf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _dacc !=nil {_dafg ,_dbga :=_dacc .(*PdfObjectInteger );if !_dbga {_gc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_ca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_dea .BitsPerComponent =int (*_dafg );};if _dea .Predictor > 1{_dea .Columns =1;_dacc =_eaf .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _dacc !=nil {_bgbe ,_bedd :=_dacc .(*PdfObjectInteger );if !_bedd {return nil ,_ca .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_dea .Columns =int (*_bgbe );
};_dea .Colors =1;_dacc =_eaf .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dacc !=nil {_baaf ,_abae :=_dacc .(*PdfObjectInteger );if !_abae {return nil ,_ca .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_dea .Colors =int (*_baaf );};};return _dea ,nil ;};func (_accba *JBIG2Encoder )encodeImage (_fec _d .Image )([]byte ,error ){const _ffgb ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_afcf ,_degee :=GoImageToJBIG2 (_fec ,JB2ImageAutoThreshold );
if _degee !=nil {return nil ,_bfb .Wrap (_degee ,_ffgb ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _degee =_accba .AddPageImage (_afcf ,&_accba .DefaultPageSettings );
_degee !=nil {return nil ,_bfb .Wrap (_degee ,_ffgb ,"");};return _accba .Encode ();};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_gefee :=PdfObjectFloat (val );return &_gefee };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cec *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_febd *FlateEncoder )SetPredictor (columns int ){_febd .Predictor =11;_febd .Columns =columns };

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_gaa *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gc .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_gc .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gaa .Predictor );
_cfcf ,_caec :=_gaa .DecodeBytes (streamObj .Stream );if _caec !=nil {return nil ,_caec ;};_gc .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_gc .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_cfcf ),_cfcf );
if _gaa .Predictor > 1{if _gaa .Predictor ==2{_gc .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_aad :=_gaa .Columns *_gaa .Colors ;if _aad < 1{return []byte {},nil ;};_bffa :=len (_cfcf )/_aad ;if len (_cfcf )%_aad !=0{_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cfcf ),_aad );};if _aad %_gaa .Colors !=0{return nil ,_ca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_aad ,_gaa .Colors );
};if _aad > len (_cfcf ){_gc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_aad ,len (_cfcf ));
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gc .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_cfcf ),_cfcf );
_eagf :=_cc .NewBuffer (nil );for _fbag :=0;_fbag < _bffa ;_fbag ++{_ffbf :=_cfcf [_aad *_fbag :_aad *(_fbag +1)];for _gcdg :=_gaa .Colors ;_gcdg < _aad ;_gcdg ++{_ffbf [_gcdg ]=byte (int (_ffbf [_gcdg ]+_ffbf [_gcdg -_gaa .Colors ])%256);};_eagf .Write (_ffbf );
};_dcdb :=_eagf .Bytes ();_gc .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_dcdb ),_dcdb );return _dcdb ,nil ;}else if _gaa .Predictor >=10&&_gaa .Predictor <=15{_gc .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_fgda :=_gaa .Columns *_gaa .Colors +1;if _fgda < 1{return []byte {},nil ;};_ffda :=len (_cfcf )/_fgda ;if len (_cfcf )%_fgda !=0{return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cfcf ),_fgda );
};if _fgda > len (_cfcf ){_gc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fgda ,len (_cfcf ));
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_adcb :=_cc .NewBuffer (nil );_gc .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_gaa .Columns );
_gc .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_cfcf ),_fgda ,_ffda );_adca :=make ([]byte ,_fgda );for _ebbe :=0;_ebbe < _fgda ;_ebbe ++{_adca [_ebbe ]=0;
};for _eegad :=0;_eegad < _ffda ;_eegad ++{_bdg :=_cfcf [_fgda *_eegad :_fgda *(_eegad +1)];_dfa :=_bdg [0];switch _dfa {case 0:case 1:for _bceg :=2;_bceg < _fgda ;_bceg ++{_bdg [_bceg ]=byte (int (_bdg [_bceg ]+_bdg [_bceg -1])%256);};case 2:for _fcd :=1;
_fcd < _fgda ;_fcd ++{_bdg [_fcd ]=byte (int (_bdg [_fcd ]+_adca [_fcd ])%256);};default:_gc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dfa );
return nil ,_ca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dfa );};for _ecbc :=0;_ecbc < _fgda ;_ecbc ++{_adca [_ecbc ]=_bdg [_ecbc ];};_adcb .Write (_bdg [1:]);
};_eee :=_adcb .Bytes ();return _eee ,nil ;}else {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_gaa .Predictor );
return nil ,_ca .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_gaa .Predictor );};};return _cfcf ,nil ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_eacf *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eacf .DecodeBytes (streamObj .Stream );};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_eabd :=MultiEncoder {};_eabd ._egc =[]StreamEncoder {};return &_eabd ;};func (_bed *PdfCrypt )isDecrypted (_ecde PdfObject )bool {_ ,_eef :=_bed ._acf [_ecde ];if _eef {_gc .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};switch _dgee :=_ecde .(type ){case *PdfObjectStream :if _bed ._bbc .R !=5{if _gebg ,_cdbg :=_dgee .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cdbg &&*_gebg =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_eef =_bed ._dga [int (_dgee .ObjectNumber )];
_eef {return true ;};switch _edc :=_dgee .PdfObject .(type ){case *PdfObjectDictionary :_cbcb :=true ;for _ ,_baf :=range _ece {if _edc .Get (_baf )==nil {_cbcb =false ;break ;};};if _cbcb {return true ;};};};_gc .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_aefa *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_bfbc :=PdfIndirectObject {};_bfbc ._fecc =_aefa ;_gc .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_dfff ,_ebbf :=_aefa ._ceecd .Peek (20);
if _ebbf !=nil {if _ebbf !=_dd .EOF {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_bfbc ,_ebbf ;
};};_gc .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_dfff ));_ccgc :=_efdd .FindStringSubmatchIndex (string (_dfff ));if len (_ccgc )< 6{if _ebbf ==_dd .EOF {return nil ,_ebbf ;
};_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_dfff ));
return &_bfbc ,_f .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_aefa ._ceecd .Discard (_ccgc [0]);_gc .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_ccgc );_aaff :=_ccgc [1]-_ccgc [0];_beec :=make ([]byte ,_aaff );_ ,_ebbf =_aefa .ReadAtLeast (_beec ,_aaff );if _ebbf !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_ebbf );
return nil ,_ebbf ;};_gc .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_beec );_efff :=_efdd .FindStringSubmatch (string (_beec ));if len (_efff )< 3{_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_beec ));
return &_bfbc ,_f .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_bfba ,_ :=_g .Atoi (_efff [1]);_ecfb ,_ :=_g .Atoi (_efff [2]);_bfbc .ObjectNumber =int64 (_bfba );_bfbc .GenerationNumber =int64 (_ecfb );for {_accc ,_gbfb :=_aefa ._ceecd .Peek (2);if _gbfb !=nil {return &_bfbc ,_gbfb ;};_gc .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_accc ),string (_accc ));
if IsWhiteSpace (_accc [0]){_aefa .skipSpaces ();}else if _accc [0]=='%'{_aefa .skipComments ();}else if (_accc [0]=='<')&&(_accc [1]=='<'){_gc .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_bfbc .PdfObject ,_gbfb =_aefa .ParseDict ();
_gc .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_gbfb );if _gbfb !=nil {return &_bfbc ,_gbfb ;};_gc .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_accc [0]=='/')||(_accc [0]=='(')||(_accc [0]=='[')||(_accc [0]=='<'){_bfbc .PdfObject ,_gbfb =_aefa .parseObject ();if _gbfb !=nil {return &_bfbc ,_gbfb ;};_gc .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _accc [0]==']'{_gc .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_aefa ._ceecd .Discard (1);}else {if _accc [0]=='e'{_effbe ,_ggbg :=_aefa .readTextLine ();if _ggbg !=nil {return nil ,_ggbg ;};if len (_effbe )>=6&&_effbe [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _accc [0]=='s'{_accc ,_ =_aefa ._ceecd .Peek (10);
if string (_accc [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_cegc :=6;if len (_accc )> 6{if IsWhiteSpace (_accc [_cegc ])&&_accc [_cegc ]!='\r'&&_accc [_cegc ]!='\n'{_gc .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_cegc ++;};if _accc [_cegc ]=='\r'{_cegc ++;if _accc [_cegc ]=='\n'{_cegc ++;};}else if _accc [_cegc ]=='\n'{_cegc ++;};};_aefa ._ceecd .Discard (_cegc );_agdg ,_ceef :=_bfbc .PdfObject .(*PdfObjectDictionary );if !_ceef {return nil ,_f .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_gc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_agdg );_beac ,_dadcf :=_aefa .traceStreamLength (_agdg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _dadcf !=nil {_gc .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_dadcf );
return nil ,_dadcf ;};_gc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_beac );_dgdd ,_efea :=_beac .(*PdfObjectInteger );if !_efea {return nil ,_f .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_aadd :=*_dgdd ;if _aadd < 0{return nil ,_f .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_bbag :=_aefa .GetFileOffset ();
_becf :=_aefa .xrefNextObjectOffset (_bbag );if _bbag +int64 (_aadd )> _becf &&_becf > _bbag {_gc .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_bbag +int64 (_aadd ));_gc .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_becf );
_fdfd :=_becf -_bbag -17;if _fdfd < 0{return nil ,_f .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_gc .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_fdfd );_aadd =PdfObjectInteger (_fdfd );
_agdg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_fdfd ));};if int64 (_aadd )> _aefa ._dcbg {_gc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_f .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_dbbb :=make ([]byte ,_aadd );
_ ,_dadcf =_aefa .ReadAtLeast (_dbbb ,int (_aadd ));if _dadcf !=nil {_gc .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_dbbb ),_dbbb );_gc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dadcf );
return nil ,_dadcf ;};_fgfbf :=PdfObjectStream {};_fgfbf .Stream =_dbbb ;_fgfbf .PdfObjectDictionary =_bfbc .PdfObject .(*PdfObjectDictionary );_fgfbf .ObjectNumber =_bfbc .ObjectNumber ;_fgfbf .GenerationNumber =_bfbc .GenerationNumber ;_fgfbf .PdfObjectReference ._fecc =_aefa ;
_aefa .skipSpaces ();_aefa ._ceecd .Discard (9);_aefa .skipSpaces ();return &_fgfbf ,nil ;};};_bfbc .PdfObject ,_gbfb =_aefa .parseObject ();if _bfbc .PdfObject ==nil {_gc .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_bfbc .PdfObject =MakeNull ();};return &_bfbc ,_gbfb ;};};if _bfbc .PdfObject ==nil {_gc .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_bfbc .PdfObject =MakeNull ();};_gc .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_bfbc ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bfga *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};var _cdfaf =_ea .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_cdcg *PdfParser )CheckAccessRights (password []byte )(bool ,_ae .Permissions ,error ){if _cdcg ._cddb ==nil {return true ,_ae .PermOwner ,nil ;};return _cdcg ._cddb .checkAccessRights (password );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eadc *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_eadc ._egc )==0{return nil ;};if len (_eadc ._egc )==1{return _eadc ._egc [0].MakeDecodeParams ();};_dfgc :=MakeArray ();for _ ,_dcef :=range _eadc ._egc {_gceeg :=_dcef .MakeDecodeParams ();
if _gceeg ==nil {_dfgc .Append (MakeNull ());}else {_dfgc .Append (_gceeg );};};return _dfgc ;};func (_cgg *PdfCrypt )saveCryptFilters (_cdc *PdfObjectDictionary )error {if _cgg ._be .V < 4{return _f .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_daeb :=MakeDict ();_cdc .Set ("\u0043\u0046",_daeb );for _bgg ,_ffa :=range _cgg ._aaa {if _bgg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_bcdd :=_faef (_ffa ,"");_daeb .Set (PdfObjectName (_bgg ),_bcdd );};_cdc .Set ("\u0053\u0074\u0072\u0046",MakeName (_cgg ._gfeb ));
_cdc .Set ("\u0053\u0074\u006d\u0046",MakeName (_cgg ._aba ));return nil ;};

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_ecgd :=MakeDict ();return _ecgd .Update (objmap );};

// String returns a string describing `streams`.
func (_gbec *PdfObjectStreams )String ()string {return _ca .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_gbec .ObjectNumber );};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};var _dbge =_ea .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");type objectStream struct{N int ;_ba []byte ;_ceg map[int ]int64 ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// ParserMetadata is an interface that allows to get meta information about document parser.
type ParserMetadata interface{

// HeaderPosition gets the file header position.
HeaderPosition ()int ;

// HeaderCommentBytes gets the header comment bytes.
HeaderCommentBytes ()[4]byte ;

// HasEOLAfterHeader gets information if there is a EOL after the version header.
HasEOLAfterHeader ()bool ;

// HasDataAfterEOF checks if there is some data after EOF marker.
HasDataAfterEOF ()bool ;};func _faef (_ff _cbg .Filter ,_cdba _ae .AuthEvent )*PdfObjectDictionary {if _cdba ==""{_cdba =_ae .EventDocOpen ;};_eedb :=MakeDict ();_eedb .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));
_eedb .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_cdba )));_eedb .Set ("\u0043\u0046\u004d",MakeName (_ff .Name ()));_eedb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_ff .KeyLength ())));return _eedb ;};


// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_fecc *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gcca *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_cdac :=MakeDict ();_cdac .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gcca .GetFilterName ()));return _cdac ;};

// UpdateParams updates the parameter values of the encoder.
func (_cdbe *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_def ,_bfe :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bfe ==nil {_cdbe .Predictor =int (_def );};_gagg ,_bfe :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _bfe ==nil {_cdbe .BitsPerComponent =int (_gagg );};_dgge ,_bfe :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bfe ==nil {_cdbe .Columns =int (_dgge );};_faeb ,_bfe :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _bfe ==nil {_cdbe .Colors =int (_faeb );};};func (_becg *offsetReader )Read (p []byte )(_gacfb int ,_dbgdb error ){return _becg ._eebd .Read (p )};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_gecb *PdfObjectFloat ,_adaa bool ){_gecb ,_adaa =TraceToDirectObject (obj ).(*PdfObjectFloat );return _gecb ,_adaa ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_dcgc []byte ,_edfa bool ){_fefgb ,_edfa :=TraceToDirectObject (obj ).(*PdfObjectString );if _edfa {return _fefgb .Bytes (),true ;};return ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _cbg .Filter ,userPass ,ownerPass []byte ,perm _ae .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_dab :=&PdfCrypt {_cgf :make (map[PdfObject ]bool ),_aaa :make (cryptFilters ),_bbc :_ae .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _gbc Version ;if cf !=nil {_gebf :=cf .PDFVersion ();_gbc .Major ,_gbc .Minor =_gebf [0],_gebf [1];V ,R :=cf .HandlerVersion ();_dab ._be .V =V ;_dab ._bbc .R =R ;_dab ._be .Length =cf .KeyLength ()*8;};const (_ccf =_gacf ;);_dab ._aaa [_ccf ]=cf ;
if _dab ._be .V >=4{_dab ._aba =_ccf ;_dab ._gfeb =_ccf ;};_ddf :=_dab .newEncryptDict ();_feb :=_fgd .Sum ([]byte (_bf .Now ().Format (_bf .RFC850 )));_gcg :=string (_feb [:]);_gac :=make ([]byte ,100);_a .Read (_gac );_feb =_fgd .Sum (_gac );_dgg :=string (_feb [:]);
_gc .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_gac );_gc .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_gcg );_dab ._dggc =_gcg ;_fab :=_dab .generateParams (userPass ,ownerPass );
if _fab !=nil {return nil ,nil ,_fab ;};_abdc (&_dab ._bbc ,_ddf );if _dab ._be .V >=4{if _ecf :=_dab .saveCryptFilters (_ddf );_ecf !=nil {return nil ,nil ,_ecf ;};};return _dab ,&EncryptInfo {Version :_gbc ,Encrypt :_ddf ,ID0 :_gcg ,ID1 :_dgg },nil ;
};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_ddcg :=PdfObjectString {_effa :s };return &_ddcg };

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_dbg *parserMetadata )HasEOLAfterHeader ()bool {return _dbg ._ebdd };

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_badg *FlateEncoder )MakeDecodeParams ()PdfObject {if _badg .Predictor > 1{_aee :=MakeDict ();_aee .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_badg .Predictor )));if _badg .BitsPerComponent !=8{_aee .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_badg .BitsPerComponent )));
};if _badg .Columns !=1{_aee .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_badg .Columns )));};if _badg .Colors !=1{_aee .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_badg .Colors )));};return _aee ;};return nil ;
};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_daeg string ,_egf bool ){_cfegg ,_egf :=TraceToDirectObject (obj ).(*PdfObjectName );if _egf {return string (*_cfegg ),true ;};return ;};func _ceba (_abbf PdfObject ,_bbcbb int )PdfObject {if _bbcbb > _acccg {_gc .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_acccg );
return MakeNull ();};switch _gbfec :=_abbf .(type ){case *PdfIndirectObject :_abbf =_ceba ((*_gbfec ).PdfObject ,_bbcbb +1);case *PdfObjectArray :for _cffeg ,_ccbae :=range (*_gbfec )._gcgag {(*_gbfec )._gcgag [_cffeg ]=_ceba (_ccbae ,_bbcbb +1);};case *PdfObjectDictionary :for _aaddd ,_aebgd :=range (*_gbfec )._gaddd {(*_gbfec )._gaddd [_aaddd ]=_ceba (_aebgd ,_bbcbb +1);
};_ef .Slice ((*_gbfec )._fdbbd ,func (_ddgge ,_afba int )bool {return (*_gbfec )._fdbbd [_ddgge ]< (*_gbfec )._fdbbd [_afba ]});};return _abbf ;};

// UpdateParams updates the parameter values of the encoder.
func (_bedga *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _ddfe ,_edgfb :=GetNumberAsInt64 (params .Get ("\u004b"));_edgfb ==nil {_bedga .K =int (_ddfe );};if _aacd ,_abgfd :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_abgfd ==nil {_bedga .Columns =int (_aacd );}else if _aacd ,_abgfd =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_abgfd ==nil {_bedga .Columns =int (_aacd );};if _ecgfc ,_effg :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_effg ==nil {_bedga .BlackIs1 =_ecgfc > 0;}else {if _gfff ,_cfb :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cfb {_bedga .BlackIs1 =_gfff ;}else {if _aaegb ,_bcfe :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_bcfe {_fcf ,_cddg :=_aaegb .ToIntegerArray ();if _cddg ==nil {_bedga .BlackIs1 =_fcf [0]==1&&_fcf [1]==0;};};};};if _cbfe ,_gafa :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_gafa ==nil {_bedga .EncodedByteAlign =_cbfe > 0;}else {if _ebcf ,_eccb :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_eccb {_bedga .EncodedByteAlign =_ebcf ;};};if _addc ,_daa :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_daa ==nil {_bedga .EndOfLine =_addc > 0;}else {if _cdbf ,_cecg :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cecg {_bedga .EndOfLine =_cdbf ;};};if _befd ,_face :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_face ==nil {_bedga .Rows =int (_befd );}else if _befd ,_face =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_face ==nil {_bedga .Rows =int (_befd );};if _bcfd ,_dagg :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_dagg ==nil {_bedga .EndOfBlock =_bcfd > 0;}else {if _gbfa ,_cgd :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cgd {_bedga .EndOfBlock =_gbfa ;};};if _ecaa ,_dedfe :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_dedfe !=nil {_bedga .DamagedRowsBeforeError =int (_ecaa );};};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_gc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_gfbc ,_fbca :=NewEncoderFromStream (streamObj );if _fbca !=nil {_gc .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fbca );
return _fbca ;};if _feca ,_aefc :=_gfbc .(*LZWEncoder );_aefc {_feca .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_gc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_gfbc );
_fcfa ,_fbca :=_gfbc .EncodeBytes (streamObj .Stream );if _fbca !=nil {_gc .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fbca );return _fbca ;
};streamObj .Stream =_fcfa ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fcfa ))));return nil ;};var _abgg =_ea .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");


// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// UpdateParams updates the parameter values of the encoder.
func (_aeda *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_gbd ,_eaga :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _eaga ==nil {_aeda .Predictor =int (_gbd );};_cgba ,_eaga :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _eaga ==nil {_aeda .BitsPerComponent =int (_cgba );};_eaef ,_eaga :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _eaga ==nil {_aeda .Columns =int (_eaef );};_beda ,_eaga :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _eaga ==nil {_aeda .Colors =int (_beda );};_afdd ,_eaga :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _eaga ==nil {_aeda .EarlyChange =int (_afdd );};};func (_ded *PdfParser )lookupByNumberWrapper (_fef int ,_ec bool )(PdfObject ,bool ,error ){_dedf ,_cd ,_bfd :=_ded .lookupByNumber (_fef ,_ec );
if _bfd !=nil {return nil ,_cd ,_bfd ;};if !_cd &&_ded ._cddb !=nil &&!_ded ._cddb .isDecrypted (_dedf ){_abc :=_ded ._cddb .Decrypt (_dedf ,0,0);if _abc !=nil {return nil ,_cd ,_abc ;};};return _dedf ,_cd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cedgd *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// String returns a string describing `ref`.
func (_aaad *PdfObjectReference )String ()string {return _ca .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_aaad .ObjectNumber ,_aaad .GenerationNumber );};type parserMetadata struct{_deggf int ;_ebdd bool ;_dged [4]byte ;_agba bool ;
};func (_gabc *PdfParser )parsePdfVersion ()(int ,int ,error ){var _bgbed int64 =20;_beag :=make ([]byte ,_bgbed );_gabc ._efbf .Seek (0,_dd .SeekStart );_gabc ._efbf .Read (_beag );var _cfffa error ;var _gbag ,_gda int ;if _cdged :=_eegg .FindStringSubmatch (string (_beag ));
len (_cdged )< 3{if _gbag ,_gda ,_cfffa =_gabc .seekPdfVersionTopDown ();_cfffa !=nil {_gc .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_cfffa ;};_gabc ._efbf ,_cfffa =_cfbb (_gabc ._efbf ,_gabc .GetFileOffset ()-8);if _cfffa !=nil {return 0,0,_cfffa ;};}else {if _gbag ,_cfffa =_g .Atoi (_cdged [1]);_cfffa !=nil {return 0,0,_cfffa ;};if _gda ,_cfffa =_g .Atoi (_cdged [2]);_cfffa !=nil {return 0,0,_cfffa ;
};_gabc .SetFileOffset (0);};_gabc ._ceecd =_db .NewReader (_gabc ._efbf );_gc .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_gbag ,_gda );return _gbag ,_gda ,nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_cddc *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_cddc ._gcgag ){return _f .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_cddc ._gcgag [i ]=obj ;return nil ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_ebcfe *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ebcfe .DecodeBytes (streamObj .Stream );};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_gbgg []PdfObject ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_bgbcb *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bgbcb .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _dd .ReadSeeker )(*PdfParser ,error ){_ffag :=&PdfParser {_efbf :rs ,ObjCache :make (objectCache ),_aead :map[int64 ]bool {}};_ggfd ,_afbf ,_dafd :=_ffag .parsePdfVersion ();if _dafd !=nil {_gc .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_dafd );
return nil ,_dafd ;};_ffag ._deebf .Major =_ggfd ;_ffag ._deebf .Minor =_afbf ;if _ffag ._aecc ,_dafd =_ffag .loadXrefs ();_dafd !=nil {_gc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_dafd );
return nil ,_dafd ;};_gc .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_ffag ._aecc );if len (_ffag ._cfbe .ObjectMap )==0{return nil ,_ca .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _ffag ,nil ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_ebdc :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_ebdc .PdfObjectDictionary =encoder .MakeStreamDict ();_adffd ,_aaed :=encoder .EncodeBytes (contents );
if _aaed !=nil {return nil ,_aaed ;};_ebdc .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_adffd ))));_ebdc .Stream =_adffd ;return _ebdc ,nil ;};func (_dad *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_bgb :=MakeDict ();
_bgb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_bgb .Set ("\u0056",MakeInteger (int64 (_dad ._be .V )));_bgb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_dad ._be .Length )));
return _bgb ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};func (_bacd *PdfParser )parseXrefStream (_eaefc *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _eaefc !=nil {_gc .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_eaefc );
_bacd ._efbf .Seek (int64 (*_eaefc ),_dd .SeekStart );_bacd ._ceecd =_db .NewReader (_bacd ._efbf );};_cbbf :=_bacd .GetFileOffset ();_gaba ,_cdag :=_bacd .ParseIndirectObject ();if _cdag !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_gc .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_gaba );
_bcbbf ,_eddg :=_gaba .(*PdfObjectStream );if !_eddg {_gc .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_f .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_gaab :=_bcbbf .PdfObjectDictionary ;
_bbcb ,_eddg :=_bcbbf .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_eddg {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_f .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_bbcb )> 8388607{_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_bbcb );
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dgdce :=_bcbbf .PdfObjectDictionary .Get ("\u0057");_fgfgf ,_eddg :=_dgdce .(*PdfObjectArray );if !_eddg {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_gcec :=_fgfgf .Len ();if _gcec !=3{_gc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_gcec );
return nil ,_f .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _facef []int64 ;for _ddaf :=0;_ddaf < 3;
_ddaf ++{_defc ,_cggg :=GetInt (_fgfgf .Get (_ddaf ));if !_cggg {return nil ,_f .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_facef =append (_facef ,int64 (*_defc ));};_gacbf ,_cdag :=DecodeStream (_bcbbf );
if _cdag !=nil {_gc .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_cdag );return nil ,_cdag ;};_deee :=int (_facef [0]);
_adgac :=int (_facef [0]+_facef [1]);_fddc :=int (_facef [0]+_facef [1]+_facef [2]);_abaec :=int (_facef [0]+_facef [1]+_facef [2]);if _deee < 0||_adgac < 0||_fddc < 0{_gc .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_deee ,_adgac ,_fddc );
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _abaec ==0{_gc .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _gaab ,nil ;};_beaf :=len (_gacbf )/_abaec ;_dbef :=0;_acaa :=_bcbbf .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _cbbff []int ;if _acaa !=nil {_gc .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_acaa );_gfcg ,_ddag :=_acaa .(*PdfObjectArray );
if !_ddag {_gc .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_f .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _gfcg .Len ()%2!=0{_gc .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dbef =0;_befde ,_bgdd :=_gfcg .ToIntegerArray ();if _bgdd !=nil {_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_bgdd );
return nil ,_bgdd ;};for _gbg :=0;_gbg < len (_befde );_gbg +=2{_gddff :=_befde [_gbg ];_ebee :=_befde [_gbg +1];for _fefag :=0;_fefag < _ebee ;_fefag ++{_cbbff =append (_cbbff ,_gddff +_fefag );};_dbef +=_ebee ;};}else {for _bdde :=0;_bdde < int (*_bbcb );
_bdde ++{_cbbff =append (_cbbff ,_bdde );};_dbef =int (*_bbcb );};if _beaf ==_dbef +1{_gc .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_dffgb :=_dbef -1;for _ ,_bbff :=range _cbbff {if _bbff > _dffgb {_dffgb =_bbff ;};};_cbbff =append (_cbbff ,_dffgb +1);_dbef ++;};if _beaf !=len (_cbbff ){_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_beaf ,len (_cbbff ));
return nil ,_f .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_gc .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_dbef );
_gc .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_cbbff );_adegf :=func (_fcbf []byte )int64 {var _fffg int64 ;for _bbcc :=0;_bbcc < len (_fcbf );_bbcc ++{_fffg +=int64 (_fcbf [_bbcc ])*(1<<uint (8*(len (_fcbf )-_bbcc -1)));
};return _fffg ;};_gc .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_gacbf ));_aeac :=0;for _cbacf :=0;_cbacf < len (_gacbf );_cbacf +=_abaec {_dabee :=_acfbb (len (_gacbf ),_cbacf ,_cbacf +_deee );
if _dabee !=nil {_gc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dabee );return nil ,_dabee ;};_gadd :=_gacbf [_cbacf :_cbacf +_deee ];_dabee =_acfbb (len (_gacbf ),_cbacf +_deee ,_cbacf +_adgac );
if _dabee !=nil {_gc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dabee );return nil ,_dabee ;};_ddgd :=_gacbf [_cbacf +_deee :_cbacf +_adgac ];_dabee =_acfbb (len (_gacbf ),_cbacf +_adgac ,_cbacf +_fddc );
if _dabee !=nil {_gc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dabee );return nil ,_dabee ;};_gefe :=_gacbf [_cbacf +_adgac :_cbacf +_fddc ];_cceee :=_adegf (_gadd );
_fabca :=_adegf (_ddgd );_bcfdf :=_adegf (_gefe );if _facef [0]==0{_cceee =1;};if _aeac >=len (_cbbff ){_gc .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_cggfb :=_cbbff [_aeac ];_aeac ++;_gc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_cggfb ,_gadd );_gc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_cggfb ,_ddgd );_gc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_cggfb ,_gefe );
_gc .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_cggfb ,_cceee ,_fabca ,_bcfdf );if _cceee ==0{_gc .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _cceee ==1{_gc .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_ddgd );if _fabca ==_cbbf {_gc .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_cggfb ,_bcbbf .ObjectNumber );
_cggfb =int (_bcbbf .ObjectNumber );};if _gbcc ,_cca :=_bacd ._cfbe .ObjectMap [_cggfb ];!_cca ||int (_bcfdf )> _gbcc .Generation {_bddb :=XrefObject {ObjectNumber :_cggfb ,XType :XrefTypeTableEntry ,Offset :_fabca ,Generation :int (_bcfdf )};_bacd ._cfbe .ObjectMap [_cggfb ]=_bddb ;
};}else if _cceee ==2{_gc .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_fgge :=_bacd ._cfbe .ObjectMap [_cggfb ];!_fgge {_abgd :=XrefObject {ObjectNumber :_cggfb ,XType :XrefTypeObjectStream ,OsObjNumber :int (_fabca ),OsObjIndex :int (_bcfdf )};
_bacd ._cfbe .ObjectMap [_cggfb ]=_abgd ;_gc .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_abgd );};}else {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _bacd ._ecfge ==nil {_caed :=XrefTypeObjectStream ;_bacd ._ecfge =&_caed ;};return _gaab ,nil ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_dbae string ,_ccba bool ){_dgcd ,_ccba :=TraceToDirectObject (obj ).(*PdfObjectString );if _ccba {return _dgcd .Str (),true ;};return ;};func (_eeegd *JBIG2Image )toBitmap ()(_aeb *_fa .Bitmap ,_cefb error ){const _gbfdd ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";
if _eeegd .Data ==nil {return nil ,_bfb .Error (_gbfdd ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _eeegd .Width ==0||_eeegd .Height ==0{return nil ,_bfb .Error (_gbfdd ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _eeegd .HasPadding {_aeb ,_cefb =_fa .NewWithData (_eeegd .Width ,_eeegd .Height ,_eeegd .Data );}else {_aeb ,_cefb =_fa .NewWithUnpaddedData (_eeegd .Width ,_eeegd .Height ,_eeegd .Data );};if _cefb !=nil {return nil ,_bfb .Wrap (_cefb ,_gbfdd ,"");
};return _aeb ,nil ;};func _acfbb (_fegf ,_bedb ,_eagbc int )error {if _bedb < 0||_bedb > _fegf {return _f .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _eagbc < _bedb {return _f .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _eagbc > _fegf {return _f .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};type objectStreams map[int ]objectStream ;

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_bgff *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _fdcg _fb .Gray ;switch len (data ){case _bgff .Rows *_bgff .Columns :_gfad ,_edae :=_fb .NewImage (_bgff .Columns ,_bgff .Rows ,8,1,data ,nil ,nil );if _edae !=nil {return nil ,_edae ;
};_fdcg =_gfad .(_fb .Gray );case (_bgff .Columns *_bgff .Rows )+7>>3:_fcfc ,_fdce :=_fb .NewImage (_bgff .Columns ,_bgff .Rows ,1,1,data ,nil ,nil );if _fdce !=nil {return nil ,_fdce ;};_fbbg :=_fcfc .(*_fb .Monochrome );if _fdce =_fbbg .AddPadding ();
_fdce !=nil {return nil ,_fdce ;};_fdcg =_fbbg ;default:if len (data )< _fb .BytesPerLine (_bgff .Columns ,1,1)*_bgff .Rows {return nil ,_f .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_gecg ,_beg :=_fb .NewImage (_bgff .Columns ,_bgff .Rows ,1,1,data ,nil ,nil );if _beg !=nil {return nil ,_beg ;};_cccd :=_gecg .(*_fb .Monochrome );_fdcg =_cccd ;};_fdab :=make ([][]byte ,_bgff .Rows );for _fefga :=0;_fefga < _bgff .Rows ;_fefga ++{_dced :=make ([]byte ,_bgff .Columns );
for _fgba :=0;_fgba < _bgff .Columns ;_fgba ++{_cea :=_fdcg .GrayAt (_fgba ,_fefga );_dced [_fgba ]=_cea .Y >>7;};_fdab [_fefga ]=_dced ;};_cebf :=&_af .Encoder {K :_bgff .K ,Columns :_bgff .Columns ,EndOfLine :_bgff .EndOfLine ,EndOfBlock :_bgff .EndOfBlock ,BlackIs1 :_bgff .BlackIs1 ,DamagedRowsBeforeError :_bgff .DamagedRowsBeforeError ,Rows :_bgff .Rows ,EncodedByteAlign :_bgff .EncodedByteAlign };
return _cebf .Encode (_fdab ),nil ;};func (_fgc *PdfParser )lookupObjectViaOS (_eed int ,_ag int )(PdfObject ,error ){var _de *_cc .Reader ;var _dbd objectStream ;var _cba bool ;_dbd ,_cba =_fgc ._gfed [_eed ];if !_cba {_gd ,_gb :=_fgc .LookupByNumber (_eed );
if _gb !=nil {_gc .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_eed );return nil ,_gb ;};_fc ,_ab :=_gd .(*PdfObjectStream );
if !_ab {return nil ,_f .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _fgc ._cddb !=nil &&!_fgc ._cddb .isDecrypted (_fc ){return nil ,_f .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_gg :=_fc .PdfObjectDictionary ;_gc .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_gg .String ());_ddd ,_ab :=_gg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_ab {_gc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_f .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _fd .ToLower (string (*_ddd ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_f .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_ab :=_gg .Get ("\u004e").(*PdfObjectInteger );if !_ab {return nil ,_f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_eeb ,_ab :=_gg .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_ab {return nil ,_f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_gc .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ddd ,*N );_ad ,_gb :=DecodeStream (_fc );if _gb !=nil {return nil ,_gb ;
};_gc .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ad );_agc :=_fgc .GetFileOffset ();defer func (){_fgc .SetFileOffset (_agc )}();_de =_cc .NewReader (_ad );_fgc ._ceecd =_db .NewReader (_de );_gc .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_fgb :=map[int ]int64 {};for _cg :=0;_cg < int (*N );_cg ++{_fgc .skipSpaces ();_cf ,_dcg :=_fgc .parseNumber ();if _dcg !=nil {return nil ,_dcg ;};_gad ,_dcc :=_cf .(*PdfObjectInteger );if !_dcc {return nil ,_f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_fgc .skipSpaces ();_cf ,_dcg =_fgc .parseNumber ();if _dcg !=nil {return nil ,_dcg ;};_eb ,_dcc :=_cf .(*PdfObjectInteger );if !_dcc {return nil ,_f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_gc .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_gad ,*_eb );_fgb [int (*_gad )]=int64 (*_eeb +*_eb );};_dbd =objectStream {N :int (*N ),_ba :_ad ,_ceg :_fgb };_fgc ._gfed [_eed ]=_dbd ;}else {_cgc :=_fgc .GetFileOffset ();
defer func (){_fgc .SetFileOffset (_cgc )}();_de =_cc .NewReader (_dbd ._ba );_fgc ._ceecd =_db .NewReader (_de );};_agg :=_dbd ._ceg [_ag ];_gc .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_ag ,_agg );
_de .Seek (_agg ,_dd .SeekStart );_fgc ._ceecd =_db .NewReader (_de );_bd ,_ :=_fgc ._ceecd .Peek (100);_gc .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_bd ));_abe ,_gf :=_fgc .parseObject ();if _gf !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_gf );
return nil ,_gf ;};if _abe ==nil {return nil ,_f .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_cbge :=PdfIndirectObject {};_cbge .ObjectNumber =int64 (_ag );_cbge .PdfObject =_abe ;return &_cbge ,nil ;
};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_gfe *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_fbf ,_ ,_eae :=_gfe .lookupByNumberWrapper (objNumber ,true );return _fbf ,_eae ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _ceba (obj ,0)};func (_fbbca *PdfCrypt )makeKey (_bcaa string ,_gba ,_ccg uint32 ,_fee []byte )([]byte ,error ){_gag ,_fga :=_fbbca ._aaa [_bcaa ];if !_fga {return nil ,_ca .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bcaa );
};return _gag .MakeKey (_gba ,_ccg ,_fee );};

// ParserMetadata gets the pdf parser metadata.
func (_fdba *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_fdba ._eafeg {return nil ,_ca .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return &_fdba ._fafa ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_aag *PdfObjectStreams )Elements ()[]PdfObject {if _aag ==nil {return nil ;};return _aag ._gbgg ;};var _gedf =_ea .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");


// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_dfab *PdfParser )Inspect ()(map[string ]int ,error ){return _dfab .inspect ()};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fgcf *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_aedag *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aedag .DecodeBytes (streamObj .Stream );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_aadb *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_dceb :=MakeDict ();_dceb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_aadb .GetFilterArray ());for _ ,_cgeg :=range _aadb ._egc {_cafc :=_cgeg .MakeStreamDict ();for _ ,_bffg :=range _cafc .Keys (){_fcaa :=_cafc .Get (_bffg );
if _bffg !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_bffg !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_dceb .Set (_bffg ,_fcaa );};};};_gfggc :=_aadb .MakeDecodeParams ();if _gfggc !=nil {_dceb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gfggc );
};return _dceb ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_dcbc *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _aedac ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _cdfc :=_dcbc .AddPageImage (img ,&_dcbc .DefaultPageSettings );
_cdfc !=nil {return nil ,_bfb .Wrap (_cdfc ,_aedac ,"");};return _dcbc .Encode ();};func _cdd (_ecga *PdfObjectStream ,_bfdd *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_feda :=NewCCITTFaxEncoder ();_bedg :=_ecga .PdfObjectDictionary ;if _bedg ==nil {return _feda ,nil ;
};if _bfdd ==nil {_dedd :=TraceToDirectObject (_bedg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _dedd !=nil {switch _gdfb :=_dedd .(type ){case *PdfObjectDictionary :_bfdd =_gdfb ;case *PdfObjectArray :if _gdfb .Len ()==1{if _bedge ,_geef :=GetDict (_gdfb .Get (0));
_geef {_bfdd =_bedge ;};};default:_gc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_dedd );return nil ,_f .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _bfdd ==nil {_gc .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_dedd );return nil ,_f .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _cbff ,_cadb :=GetNumberAsInt64 (_bfdd .Get ("\u004b"));_cadb ==nil {_feda .K =int (_cbff );};if _cggb ,_eeee :=GetNumberAsInt64 (_bfdd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_eeee ==nil {_feda .Columns =int (_cggb );}else {_feda .Columns =1728;
};if _gfbg ,_eedd :=GetNumberAsInt64 (_bfdd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eedd ==nil {_feda .BlackIs1 =_gfbg > 0;}else {if _gfgf ,_fgaf :=GetBoolVal (_bfdd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_fgaf {_feda .BlackIs1 =_gfgf ;
}else {if _dcgd ,_bcbb :=GetArray (_bfdd .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_bcbb {_gab ,_dfg :=_dcgd .ToIntegerArray ();if _dfg ==nil {_feda .BlackIs1 =_gab [0]==1&&_gab [1]==0;};};};};if _cbef ,_ggbf :=GetNumberAsInt64 (_bfdd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_ggbf ==nil {_feda .EncodedByteAlign =_cbef > 0;}else {if _acbcf ,_gege :=GetBoolVal (_bfdd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gege {_feda .EncodedByteAlign =_acbcf ;};};if _bfaf ,_aeef :=GetNumberAsInt64 (_bfdd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_aeef ==nil {_feda .EndOfLine =_bfaf > 0;}else {if _fgcb ,_bffb :=GetBoolVal (_bfdd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bffb {_feda .EndOfLine =_fgcb ;};};if _abag ,_ddgee :=GetNumberAsInt64 (_bfdd .Get ("\u0052\u006f\u0077\u0073"));
_ddgee ==nil {_feda .Rows =int (_abag );};_feda .EndOfBlock =true ;if _dgef ,_cce :=GetNumberAsInt64 (_bfdd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cce ==nil {_feda .EndOfBlock =_dgef > 0;}else {if _geca ,_dgcb :=GetBoolVal (_bfdd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_dgcb {_feda .EndOfBlock =_geca ;};};if _bfgab ,_bcac :=GetNumberAsInt64 (_bfdd .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_bcac !=nil {_feda .DamagedRowsBeforeError =int (_bfgab );
};_gc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bfdd .String ());return _feda ,nil ;};const _gacf ="\u0053\u0074\u0064C\u0046";func (_bgga *PdfParser )resolveReference (_afcb *PdfObjectReference )(PdfObject ,bool ,error ){_acfd ,_abba :=_bgga .ObjCache [int (_afcb .ObjectNumber )];
if _abba {return _acfd ,true ,nil ;};_adag ,_decc :=_bgga .LookupByReference (*_afcb );if _decc !=nil {return nil ,false ,_decc ;};_bgga .ObjCache [int (_afcb .ObjectNumber )]=_adag ;return _adag ,false ,nil ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;func (_cegd *PdfParser )skipComments ()error {if _ ,_dccf :=_cegd .skipSpaces ();_dccf !=nil {return _dccf ;};_efbd :=true ;for {_ffgdf ,_bfad :=_cegd ._ceecd .Peek (1);if _bfad !=nil {_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_bfad .Error ());
return _bfad ;};if _efbd &&_ffgdf [0]!='%'{return nil ;};_efbd =false ;if (_ffgdf [0]!='\r')&&(_ffgdf [0]!='\n'){_cegd ._ceecd .ReadByte ();}else {break ;};};return _cegd .skipComments ();};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cgcd *LZWEncoder )MakeDecodeParams ()PdfObject {if _cgcd .Predictor > 1{_eacc :=MakeDict ();_eacc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_cgcd .Predictor )));if _cgcd .BitsPerComponent !=8{_eacc .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_cgcd .BitsPerComponent )));
};if _cgcd .Columns !=1{_eacc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_cgcd .Columns )));};if _cgcd .Colors !=1{_eacc .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_cgcd .Colors )));};return _eacc ;};return nil ;
};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_ffce *PdfObjectInteger ,_gfba bool ){_ffce ,_gfba =TraceToDirectObject (obj ).(*PdfObjectInteger );return _ffce ,_gfba ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_cgab :=PdfObjectInteger (val );return &_cgab };

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _gfd :=obj .(type ){case *PdfObjectFloat :_gc .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_gfd ),nil ;case *PdfObjectInteger :return int64 (*_gfd ),nil ;};return 0,ErrNotANumber ;};func (_gccd *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_gccd ._efbf .Seek (0,_dd .SeekStart );_gccd ._ceecd =_db .NewReader (_gccd ._efbf );
_bdda :=20;_accf :=make ([]byte ,_bdda );for {_fgbaf ,_dcaa :=_gccd ._ceecd .ReadByte ();if _dcaa !=nil {if _dcaa ==_dd .EOF {break ;}else {return 0,0,_dcaa ;};};if IsDecimalDigit (_fgbaf )&&_accf [_bdda -1]=='.'&&IsDecimalDigit (_accf [_bdda -2])&&_accf [_bdda -3]=='-'&&_accf [_bdda -4]=='F'&&_accf [_bdda -5]=='D'&&_accf [_bdda -6]=='P'{_ggea :=int (_accf [_bdda -2]-'0');
_dgfc :=int (_fgbaf -'0');return _ggea ,_dgfc ,nil ;};_accf =append (_accf [1:_bdda ],_fgbaf );};return 0,0,_f .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gc .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_gdeb ,_ddbfa :=NewEncoderFromStream (streamObj );if _ddbfa !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_ddbfa );
return nil ,_ddbfa ;};_gc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_gdeb );_gabe ,_ddbfa :=_gdeb .DecodeStream (streamObj );if _ddbfa !=nil {_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_ddbfa );
return nil ,_ddbfa ;};return _gabe ,nil ;};var (ErrUnsupportedEncodingParameters =_f .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_f .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_f .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_f .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_f .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_f .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_ce .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_f .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_dcgda *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_egde :=_dcgda .GetFileOffset ();_ ,_cbbc :=_dcgda ._efbf .Seek (offset ,_dd .SeekStart );if _cbbc !=nil {return nil ,_cbbc ;};_cdcb :=make ([]byte ,len );_ ,_cbbc =_dd .ReadAtLeast (_dcgda ._efbf ,_cdcb ,int (len ));
if _cbbc !=nil {return nil ,_cbbc ;};_dcgda .SetFileOffset (_egde );return _cdcb ,nil ;};func _bdaf (_afggd PdfObject ,_cfdc int ,_efaae map[PdfObject ]struct{})error {_gc .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_cfdc );
if _ ,_befg :=_efaae [_afggd ];_befg {_gc .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_efaae [_afggd ]=struct{}{};switch _bcab :=_afggd .(type ){case *PdfIndirectObject :_ecbff :=_bcab ;
_gc .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_ecbff );_gc .Log .Trace ("\u002d\u0020\u0025\u0073",_ecbff .PdfObject );return _bdaf (_ecbff .PdfObject ,_cfdc +1,_efaae );case *PdfObjectStream :_fbde :=_bcab ;return _bdaf (_fbde .PdfObjectDictionary ,_cfdc +1,_efaae );
case *PdfObjectDictionary :_afae :=_bcab ;_gc .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_afae );for _ ,_edbgd :=range _afae .Keys (){_afaac :=_afae .Get (_edbgd );if _edag ,_ecdcb :=_afaac .(*PdfObjectReference );_ecdcb {_cggga :=_edag .Resolve ();
_afae .Set (_edbgd ,_cggga );_geefdg :=_bdaf (_cggga ,_cfdc +1,_efaae );if _geefdg !=nil {return _geefdg ;};}else {_adgad :=_bdaf (_afaac ,_cfdc +1,_efaae );if _adgad !=nil {return _adgad ;};};};return nil ;case *PdfObjectArray :_cdee :=_bcab ;_gc .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_cdee );
for _ccea ,_acdef :=range _cdee .Elements (){if _ddae ,_ccge :=_acdef .(*PdfObjectReference );_ccge {_cffc :=_ddae .Resolve ();_cdee .Set (_ccea ,_cffc );_bagca :=_bdaf (_cffc ,_cfdc +1,_efaae );if _bagca !=nil {return _bagca ;};}else {_ffga :=_bdaf (_acdef ,_cfdc +1,_efaae );
if _ffga !=nil {return _ffga ;};};};return nil ;case *PdfObjectReference :_gc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _f .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};func _cfbb (_ecfd _dd .ReadSeeker ,_facd int64 )(*offsetReader ,error ){_bcgd :=&offsetReader {_eebd :_ecfd ,_dbff :_facd };_ ,_bdac :=_bcgd .Seek (0,_dd .SeekStart );return _bcgd ,_bdac ;};func (_gdeeg *PdfParser )repairSeekXrefMarker ()error {_aaaf ,_cbcfa :=_gdeeg ._efbf .Seek (0,_dd .SeekEnd );
if _cbcfa !=nil {return _cbcfa ;};_dfe :=_ea .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _cgdc int64 ;var _acef int64 =1000;for _cgdc < _aaaf {if _aaaf <=(_acef +_cgdc ){_acef =_aaaf -_cgdc ;};_ ,_daggc :=_gdeeg ._efbf .Seek (-_cgdc -_acef ,_dd .SeekEnd );
if _daggc !=nil {return _daggc ;};_fggad :=make ([]byte ,_acef );_gdeeg ._efbf .Read (_fggad );_gc .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_fggad ));
_gbea :=_dfe .FindAllStringIndex (string (_fggad ),-1);if _gbea !=nil {_adcg :=_gbea [len (_gbea )-1];_gc .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gbea );_gdeeg ._efbf .Seek (-_cgdc -_acef +int64 (_adcg [0]),_dd .SeekEnd );_gdeeg ._ceecd =_db .NewReader (_gdeeg ._efbf );
for {_dgcdd ,_dafa :=_gdeeg ._ceecd .Peek (1);if _dafa !=nil {return _dafa ;};_gc .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_dgcdd [0],_dgcdd [0]);if !IsWhiteSpace (_dgcdd [0]){break ;};_gdeeg ._ceecd .Discard (1);};return nil ;};
_gc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_cgdc +=_acef ;};_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _f .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_dbag :=&LZWEncoder {};_dbag .Predictor =1;_dbag .BitsPerComponent =8;_dbag .Colors =1;_dbag .Columns =1;_dbag .EarlyChange =1;return _dbag ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_gfebb *PdfParser )IsAuthenticated ()bool {return _gfebb ._cddb ._efba };func _deaf (_deab *PdfObjectStream ,_cccc *PdfObjectDictionary )(*LZWEncoder ,error ){_cebb :=NewLZWEncoder ();_feac :=_deab .PdfObjectDictionary ;if _feac ==nil {return _cebb ,nil ;
};if _cccc ==nil {_acbc :=TraceToDirectObject (_feac .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _acbc !=nil {if _eeff ,_fccc :=_acbc .(*PdfObjectDictionary );_fccc {_cccc =_eeff ;}else if _bccb ,_fgff :=_acbc .(*PdfObjectArray );
_fgff {if _bccb .Len ()==1{if _aega ,_dcdd :=GetDict (_bccb .Get (0));_dcdd {_cccc =_aega ;};};};if _cccc ==nil {_gc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_acbc );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_bgbf :=_feac .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _bgbf !=nil {_affe ,_ced :=_bgbf .(*PdfObjectInteger );
if !_ced {_gc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_bgbf );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_affe !=0&&*_affe !=1{return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_cebb .EarlyChange =int (*_affe );}else {_cebb .EarlyChange =1;};if _cccc ==nil {return _cebb ,nil ;};if _gcd ,_ecec :=GetIntVal (_cccc .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_ecec {if _gcd ==0||_gcd ==1{_cebb .EarlyChange =_gcd ;
}else {_gc .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_gcd );};};_bgbf =_cccc .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _bgbf !=nil {_eab ,_gbdd :=_bgbf .(*PdfObjectInteger );if !_gbdd {_gc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_bgbf );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_cebb .Predictor =int (*_eab );};_bgbf =_cccc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _bgbf !=nil {_cad ,_gbfc :=_bgbf .(*PdfObjectInteger );if !_gbfc {_gc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_ca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_cebb .BitsPerComponent =int (*_cad );};if _cebb .Predictor > 1{_cebb .Columns =1;_bgbf =_cccc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _bgbf !=nil {_ecbg ,_egb :=_bgbf .(*PdfObjectInteger );if !_egb {return nil ,_ca .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_cebb .Columns =int (*_ecbg );
};_cebb .Colors =1;_bgbf =_cccc .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _bgbf !=nil {_gae ,_gcef :=_bgbf .(*PdfObjectInteger );if !_gcef {return nil ,_ca .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_cebb .Colors =int (*_gae );};};_gc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cccc .String ());return _cebb ,nil ;};func (_geffa *PdfParser )repairLocateXref ()(int64 ,error ){_fafad :=int64 (1000);
_geffa ._efbf .Seek (-_fafad ,_dd .SeekCurrent );_feace ,_fdaa :=_geffa ._efbf .Seek (0,_dd .SeekCurrent );if _fdaa !=nil {return 0,_fdaa ;};_beaeg :=make ([]byte ,_fafad );_geffa ._efbf .Read (_beaeg );_dcebd :=_gggca .FindAllStringIndex (string (_beaeg ),-1);
if len (_dcebd )< 1{_gc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_f .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");
};_babf :=int64 (_dcebd [len (_dcebd )-1][0]);_deabg :=_feace +_babf ;return _deabg ,nil ;};func (_fdacf *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _aedad *PdfObjectDictionary ;_dddc ,_afgdc :=_fdacf .readTextLine ();if _afgdc !=nil {return nil ,_afgdc ;
};_gc .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_dddc );_eded :=-1;_ggcg :=0;_agd :=false ;_dbeca :="";for {_fdacf .skipSpaces ();_ ,_eaed :=_fdacf ._ceecd .Peek (1);if _eaed !=nil {return nil ,_eaed ;
};_dddc ,_eaed =_fdacf .readTextLine ();if _eaed !=nil {return nil ,_eaed ;};_egdg :=_abgg .FindStringSubmatch (_dddc );if len (_egdg )==0{_dffa :=len (_dbeca )> 0;_dbeca +=_dddc +"\u000a";if _dffa {_egdg =_abgg .FindStringSubmatch (_dbeca );};};if len (_egdg )==3{_aeae ,_ :=_g .Atoi (_egdg [1]);
_baee ,_ :=_g .Atoi (_egdg [2]);_eded =_aeae ;_ggcg =_baee ;_agd =true ;_dbeca ="";_gc .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_eded ,_ggcg );
continue ;};_cbbb :=_gedf .FindStringSubmatch (_dddc );if len (_cbbb )==4{if !_agd {_gc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_f .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_eeeec ,_ :=_g .ParseInt (_cbbb [1],10,64);_bbfb ,_ :=_g .Atoi (_cbbb [2]);_aedg :=_cbbb [3];_dbeca ="";if _fd .ToLower (_aedg )=="\u006e"&&_eeeec > 1{_abdb ,_gafac :=_fdacf ._cfbe .ObjectMap [_eded ];if !_gafac ||_bbfb > _abdb .Generation {_ccgg :=XrefObject {ObjectNumber :_eded ,XType :XrefTypeTableEntry ,Offset :_eeeec ,Generation :_bbfb };
_fdacf ._cfbe .ObjectMap [_eded ]=_ccgg ;};};_eded ++;continue ;};if (len (_dddc )> 6)&&(_dddc [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_gc .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_dddc );
if len (_dddc )> 9{_cfeg :=_fdacf .GetFileOffset ();_fdacf .SetFileOffset (_cfeg -int64 (len (_dddc ))+7);};_fdacf .skipSpaces ();_fdacf .skipComments ();_gc .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_gc .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_dddc );_aedad ,_eaed =_fdacf .ParseDict ();_gc .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _eaed !=nil {_gc .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_eaed );return nil ,_eaed ;};break ;};if _dddc =="\u0025\u0025\u0045O\u0046"{_gc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_f .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_gc .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_dddc );
};_gc .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _fdacf ._ecfge ==nil {_bagg :=XrefTypeTableEntry ;_fdacf ._ecfge =&_bagg ;};return _aedad ,nil ;};
type xrefType int ;

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_fdagg *PdfParser )GetObjectNums ()[]int {var _cgdf []int ;for _ ,_eceef :=range _fdagg ._cfbe .ObjectMap {_cgdf =append (_cgdf ,_eceef .ObjectNumber );};_ef .Ints (_cgdf );return _cgdf ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_bade *PdfObjectString )Bytes ()[]byte {return []byte (_bade ._effa )};

// Clear resets the array to an empty state.
func (_gbcbb *PdfObjectArray )Clear (){_gbcbb ._gcgag =[]PdfObject {}};

// String returns a string describing `null`.
func (_facee *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);func (_afde *PdfParser )skipSpaces ()(int ,error ){_efaa :=0;for {_bdgd ,_cbee :=_afde ._ceecd .ReadByte ();
if _cbee !=nil {return 0,_cbee ;};if IsWhiteSpace (_bdgd ){_efaa ++;}else {_afde ._ceecd .UnreadByte ();break ;};};return _efaa ,nil ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_baad *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _fbbd _cc .Buffer ;_cbba :=_cc .NewReader (encoded );var _ade _dd .ReadCloser ;if _baad .EarlyChange ==1{_ade =_bb .NewReader (_cbba ,_bb .MSB ,8);}else {_ade =_edg .NewReader (_cbba ,_edg .MSB ,8);
};defer _ade .Close ();if _ ,_aaegd :=_fbbd .ReadFrom (_ade );_aaegd !=nil {if _aaegd !=_dd .ErrUnexpectedEOF ||_fbbd .Len ()==0{return nil ,_aaegd ;};_gc .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_aaegd );
};return _fbbd .Bytes (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_afbbd *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// NewDetailedPdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewDetailedPdfParser (rs _dd .ReadSeeker )(_gec *PdfParser ,_eba error ){_gec =&PdfParser {_efbf :rs ,ObjCache :make (objectCache ),_aead :map[int64 ]bool {},_eafeg :true };if _eba =_gec .parseDetailedHeader ();_eba !=nil {return nil ,_eba ;};if _gec ._aecc ,_eba =_gec .loadXrefs ();
_eba !=nil {_gc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_eba );return nil ,_eba ;};_gc .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_gec ._aecc );
if len (_gec ._cfbe .ObjectMap )==0{return nil ,_ca .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _gec ,nil ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_bg *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_cdb ,_fbbc :=obj .(*PdfObjectReference );if !_fbbc {return obj ,nil ;};_bge :=_bg .GetFileOffset ();defer func (){_bg .SetFileOffset (_bge )}();_geb ,_cbgg :=_bg .LookupByReference (*_cdb );
if _cbgg !=nil {return nil ,_cbgg ;};_gbf ,_afe :=_geb .(*PdfIndirectObject );if !_afe {return _geb ,nil ;};_geb =_gbf .PdfObject ;_ ,_fbbc =_geb .(*PdfObjectReference );if _fbbc {return _gbf ,_f .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _geb ,nil ;};var _gffdb _fg .Map ;

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_gffdb .Store (filterName ,customStreamEncoder );};func (_gdd *PdfCrypt )isEncrypted (_ddge PdfObject )bool {_ ,_ffb :=_gdd ._cgf [_ddge ];if _ffb {_gc .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};_gc .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;
CF map[string ]_cbg .FilterDict ;};var _cdeg =_ea .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_fgcc *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_gaea :=range another .Keys (){_acde :=another .Get (_gaea );_fgcc .Set (_gaea ,_acde );};};return _fgcc ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_acdb :=MakeArray ();for _ ,_dfge :=range vals {_acdb .Append (MakeInteger (int64 (_dfge )));};return _acdb ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_beeeg :=PdfObjectName (s );return &_beeeg };func _dfc (_beafd *PdfObjectDictionary )(_gbaec *_fb .ImageBase ){var (_fedfc *PdfObjectInteger ;_egea bool ;);if _fedfc ,_egea =_beafd .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );
_egea {_gbaec =&_fb .ImageBase {Width :int (*_fedfc )};}else {return nil ;};if _fedfc ,_egea =_beafd .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_egea {_gbaec .Height =int (*_fedfc );};if _fedfc ,_egea =_beafd .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_egea {_gbaec .BitsPerComponent =int (*_fedfc );};if _fedfc ,_egea =_beafd .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_egea {_gbaec .ColorComponents =int (*_fedfc );};return _gbaec ;};
