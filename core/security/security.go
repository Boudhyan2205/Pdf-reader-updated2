//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_eg "bytes";_ea "crypto/aes";_e "crypto/cipher";_fa "crypto/md5";_d "crypto/rand";_g "crypto/rc4";_baa "crypto/sha256";_ba "crypto/sha512";_f "encoding/binary";_bc "errors";_ge "fmt";_ee "github.com/unidoc/unipdf/v3/common";_a "hash";_c "io";_gc "math";);func (_cgd stdHandlerR4 )alg6 (_ggb *StdEncryptDict ,_abad []byte )([]byte ,error ){var (_da []byte ;_dbg error ;);_dgf :=_cgd .alg2 (_ggb ,_abad );if _ggb .R ==2{_da ,_dbg =_cgd .alg4 (_dgf ,_abad );}else if _ggb .R >=3{_da ,_dbg =_cgd .alg5 (_dgf ,_abad );}else {return nil ,_bc .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _dbg !=nil {return nil ,_dbg ;};_ee .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_da ),string (_ggb .U ));_ga :=_da ;_ca :=_ggb .U ;if _ggb .R >=3{if len (_ga )> 16{_ga =_ga [0:16];};if len (_ca )> 16{_ca =_ca [0:16];};};if !_eg .Equal (_ga ,_ca ){return nil ,nil ;};return _dgf ,nil ;};func (_aad stdHandlerR6 )alg2a (_fbg *StdEncryptDict ,_bec []byte )([]byte ,Permissions ,error ){if _cbc :=_cgc ("\u0061\u006c\u00672\u0061","\u004f",48,_fbg .O );_cbc !=nil {return nil ,0,_cbc ;};if _caga :=_cgc ("\u0061\u006c\u00672\u0061","\u0055",48,_fbg .U );_caga !=nil {return nil ,0,_caga ;};if len (_bec )> 127{_bec =_bec [:127];};_fff ,_agd :=_aad .alg12 (_fbg ,_bec );if _agd !=nil {return nil ,0,_agd ;};var (_af []byte ;_afe []byte ;_gcc []byte ;);var _efg Permissions ;if len (_fff )!=0{_efg =PermOwner ;_bbbc :=make ([]byte ,len (_bec )+8+48);_baef :=copy (_bbbc ,_bec );_baef +=copy (_bbbc [_baef :],_fbg .O [40:48]);_baef +=copy (_bbbc [_baef :],_fbg .U [0:48]);_af =_bbbc ;_afe =_fbg .OE ;_gcc =_fbg .U [0:48];}else {_fff ,_agd =_aad .alg11 (_fbg ,_bec );if _agd ==nil &&len (_fff )==0{_fff ,_agd =_aad .alg11 (_fbg ,[]byte (""));};if _agd !=nil {return nil ,0,_agd ;}else if len (_fff )==0{return nil ,0,nil ;};_efg =_fbg .P ;_dee :=make ([]byte ,len (_bec )+8);_eagg :=copy (_dee ,_bec );_eagg +=copy (_dee [_eagg :],_fbg .U [40:48]);_af =_dee ;_afe =_fbg .UE ;_gcc =nil ;};if _egg :=_cgc ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_afe );_egg !=nil {return nil ,0,_egg ;};_afe =_afe [:32];_dbfd ,_agd :=_aad .alg2b (_fbg .R ,_af ,_bec ,_gcc );if _agd !=nil {return nil ,0,_agd ;};_fcgf ,_agd :=_ea .NewCipher (_dbfd [:32]);if _agd !=nil {return nil ,0,_agd ;};_ege :=make ([]byte ,_ea .BlockSize );_efd :=_e .NewCBCDecrypter (_fcgf ,_ege );_becb :=make ([]byte ,32);_efd .CryptBlocks (_becb ,_afe );if _fbg .R ==5{return _becb ,_efg ,nil ;};_agd =_aad .alg13 (_fbg ,_becb );if _agd !=nil {return nil ,0,_agd ;};return _becb ,_efg ,nil ;};func (_cbg stdHandlerR4 )alg7 (_fcg *StdEncryptDict ,_bcg []byte )([]byte ,error ){_aaf :=_cbg .alg3Key (_fcg .R ,_bcg );_dgb :=make ([]byte ,len (_fcg .O ));if _fcg .R ==2{_fceg ,_ade :=_g .NewCipher (_aaf );if _ade !=nil {return nil ,_bc .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fceg .XORKeyStream (_dgb ,_fcg .O );}else if _fcg .R >=3{_cfe :=append ([]byte {},_fcg .O ...);for _eaa :=0;_eaa < 20;_eaa ++{_ecc :=append ([]byte {},_aaf ...);for _ggc :=0;_ggc < len (_aaf );_ggc ++{_ecc [_ggc ]^=byte (19-_eaa );};_gfe ,_bea :=_g .NewCipher (_ecc );if _bea !=nil {return nil ,_bc .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_gfe .XORKeyStream (_dgb ,_cfe );_cfe =append ([]byte {},_dgb ...);};}else {return nil ,_bc .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_gge ,_fd :=_cbg .alg6 (_fcg ,_dgb );if _fd !=nil {return nil ,nil ;};return _gge ,nil ;};const (PermOwner =Permissions (_gc .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););

// Authenticate implements StdHandler interface.
func (_adc stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ee .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_cag ,_edb :=_adc .alg7 (d ,pass );if _edb !=nil {return nil ,0,_edb ;};if _cag !=nil {_ee .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cag ,PermOwner ,nil ;};_ee .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_cag ,_edb =_adc .alg6 (d ,pass );if _edb !=nil {return nil ,0,_edb ;};if _cag !=nil {_ee .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cag ,d .P ,nil ;};return nil ,0,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_feg Permissions )Allowed (p2 Permissions )bool {return _feg &p2 ==p2 };type stdHandlerR6 struct{};func (_beg stdHandlerR6 )alg9 (_beag *StdEncryptDict ,_aed []byte ,_eefc []byte )error {if _dad :=_cgc ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_aed );_dad !=nil {return _dad ;};if _cgf :=_cgc ("\u0061\u006c\u0067\u0039","\u0055",48,_beag .U );_cgf !=nil {return _cgf ;};var _gfeg [16]byte ;if _ ,_ddaa :=_c .ReadFull (_d .Reader ,_gfeg [:]);_ddaa !=nil {return _ddaa ;};_edf :=_gfeg [0:8];_bab :=_gfeg [8:16];_cff :=_beag .U [:48];_abb :=make ([]byte ,len (_eefc )+len (_edf )+len (_cff ));_fcd :=copy (_abb ,_eefc );_fcd +=copy (_abb [_fcd :],_edf );_fcd +=copy (_abb [_fcd :],_cff );_gad ,_ac :=_beg .alg2b (_beag .R ,_abb ,_eefc ,_cff );if _ac !=nil {return _ac ;};O :=make ([]byte ,len (_gad )+len (_edf )+len (_bab ));_fcd =copy (O ,_gad [:32]);_fcd +=copy (O [_fcd :],_edf );_fcd +=copy (O [_fcd :],_bab );_beag .O =O ;_fcd =len (_eefc );_fcd +=copy (_abb [_fcd :],_bab );_gad ,_ac =_beg .alg2b (_beag .R ,_abb ,_eefc ,_cff );if _ac !=nil {return _ac ;};_ggeg ,_ac :=_gedb (_gad [:32]);if _ac !=nil {return _ac ;};_eda :=make ([]byte ,_ea .BlockSize );_acf :=_e .NewCBCEncrypter (_ggeg ,_eda );OE :=make ([]byte ,32);_acf .CryptBlocks (OE ,_aed [:32]);_beag .OE =OE ;return nil ;};func _aab (_fgc []byte )([]byte ,error ){_dge :=_baa .New ();_dge .Write (_fgc );return _dge .Sum (nil ),nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_eeb errInvalidField )Error ()string {return _ge .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_eeb .Func ,_eeb .Field ,_eeb .Exp ,_eeb .Got );};func _bb (_ab _e .Block )_e .BlockMode {return (*ecbEncrypter )(_be (_ab ))};func (_cdfe stdHandlerR6 )alg2b (R int ,_aaa ,_cfb ,_ffe []byte )([]byte ,error ){if R ==5{return _aab (_aaa );};return _eff (_aaa ,_cfb ,_ffe );};func (_fcde stdHandlerR6 )alg11 (_ccg *StdEncryptDict ,_egf []byte )([]byte ,error ){if _dfa :=_cgc ("\u0061\u006c\u00671\u0031","\u0055",48,_ccg .U );_dfa !=nil {return nil ,_dfa ;};_cfeb :=make ([]byte ,len (_egf )+8);_dggg :=copy (_cfeb ,_egf );_dggg +=copy (_cfeb [_dggg :],_ccg .U [32:40]);_ffg ,_dbae :=_fcde .alg2b (_ccg .R ,_cfeb ,_egf ,nil );if _dbae !=nil {return nil ,_dbae ;};_ffg =_ffg [:32];if !_eg .Equal (_ffg ,_ccg .U [:32]){return nil ,nil ;};return _ffg ,nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_gbf stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_afb :=make ([]byte ,32);if _ ,_cfec :=_c .ReadFull (_d .Reader ,_afb );_cfec !=nil {return nil ,_cfec ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _afd :=_gbf .alg8 (d ,_afb ,upass );_afd !=nil {return nil ,_afd ;};if _bba :=_gbf .alg9 (d ,_afb ,opass );_bba !=nil {return nil ,_bba ;};if d .R ==5{return _afb ,nil ;};if _aabc :=_gbf .alg10 (d ,_afb );_aabc !=nil {return nil ,_aabc ;};return _afb ,nil ;};func _fe (_dg _e .Block )_e .BlockMode {return (*ecbDecrypter )(_be (_dg ))};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func _be (_gd _e .Block )*ecb {return &ecb {_cg :_gd ,_fb :_gd .BlockSize ()}};func (_cf stdHandlerR4 )alg2 (_de *StdEncryptDict ,_cdf []byte )[]byte {_ee .Log .Trace ("\u0061\u006c\u0067\u0032");_cb :=_cf .paddedPass (_cdf );_gb :=_fa .New ();_gb .Write (_cb );_gb .Write (_de .O );var _bca [4]byte ;_f .LittleEndian .PutUint32 (_bca [:],uint32 (_de .P ));_gb .Write (_bca [:]);_ee .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_bca );_gb .Write ([]byte (_cf .ID0 ));_ee .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_de .R ,_de .EncryptMetadata );if (_de .R >=4)&&!_de .EncryptMetadata {_gb .Write ([]byte {0xff,0xff,0xff,0xff});};_cde :=_gb .Sum (nil );if _de .R >=3{_gb =_fa .New ();for _fbe :=0;_fbe < 50;_fbe ++{_gb .Reset ();_gb .Write (_cde [0:_cf .Length /8]);_cde =_gb .Sum (nil );};};if _de .R >=3{return _cde [0:_cf .Length /8];};return _cde [0:5];};func (_efb stdHandlerR4 )alg4 (_geg []byte ,_efa []byte )([]byte ,error ){_edg ,_cbe :=_g .NewCipher (_geg );if _cbe !=nil {return nil ,_bc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dd :=[]byte (_fbb );_eag :=make ([]byte ,len (_dd ));_edg .XORKeyStream (_eag ,_dd );return _eag ,nil ;};func (_fce stdHandlerR4 )alg3 (R int ,_ada ,_gdf []byte )([]byte ,error ){var _bf []byte ;if len (_gdf )> 0{_bf =_fce .alg3Key (R ,_gdf );}else {_bf =_fce .alg3Key (R ,_ada );};_aga ,_bcc :=_g .NewCipher (_bf );if _bcc !=nil {return nil ,_bc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dc :=_fce .paddedPass (_ada );_bbb :=make ([]byte ,len (_dc ));_aga .XORKeyStream (_bbb ,_dc );if R >=3{_ec :=make ([]byte ,len (_bf ));for _ef :=0;_ef < 19;_ef ++{for _dec :=0;_dec < len (_bf );_dec ++{_ec [_dec ]=_bf [_dec ]^byte (_ef +1);};_gf ,_dba :=_g .NewCipher (_ec );if _dba !=nil {return nil ,_bc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gf .XORKeyStream (_bbb ,_bbb );};};return _bbb ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_faae stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_dbf :=_faae .alg3 (d .R ,upass ,opass );if _dbf !=nil {_ee .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dbf );return nil ,_dbf ;};d .O =O ;_ee .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_gbd :=_faae .alg2 (d ,upass );U ,_dbf :=_faae .alg5 (_gbd ,upass );if _dbf !=nil {_ee .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dbf );return nil ,_dbf ;};d .U =U ;_ee .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _gbd ,nil ;};const _fbb ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_fea stdHandlerR6 )alg12 (_agb *StdEncryptDict ,_agac []byte )([]byte ,error ){if _dgc :=_cgc ("\u0061\u006c\u00671\u0032","\u0055",48,_agb .U );_dgc !=nil {return nil ,_dgc ;};if _dbgf :=_cgc ("\u0061\u006c\u00671\u0032","\u004f",48,_agb .O );_dbgf !=nil {return nil ,_dbgf ;};_efbe :=make ([]byte ,len (_agac )+8+48);_acd :=copy (_efbe ,_agac );_acd +=copy (_efbe [_acd :],_agb .O [32:40]);_acd +=copy (_efbe [_acd :],_agb .U [0:48]);_cae ,_cbge :=_fea .alg2b (_agb .R ,_efbe ,_agac ,_agb .U [0:48]);if _cbge !=nil {return nil ,_cbge ;};_cae =_cae [:32];if !_eg .Equal (_cae ,_agb .O [:32]){return nil ,nil ;};return _cae ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_bg *StdEncryptDict ,_gce ,_cd []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ad *StdEncryptDict ,_cdb []byte )([]byte ,Permissions ,error );};func _cgc (_fg ,_fga string ,_bga int ,_fc []byte )error {if len (_fc )< _bga {return errInvalidField {Func :_fg ,Field :_fga ,Exp :_bga ,Got :len (_fc )};};return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_aa stdHandlerR4 )alg3Key (R int ,_cba []byte )[]byte {_gg :=_fa .New ();_bcd :=_aa .paddedPass (_cba );_gg .Write (_bcd );if R >=3{for _ae :=0;_ae < 50;_ae ++{_ega :=_gg .Sum (nil );_gg =_fa .New ();_gg .Write (_ega );};};_geb :=_gg .Sum (nil );if R ==2{_geb =_geb [0:5];}else {_geb =_geb [0:_aa .Length /8];};return _geb ;};func (_aba *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_aba ._fb !=0{_ee .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_ee .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_aba ._cg .Encrypt (dst ,src [:_aba ._fb ]);src =src [_aba ._fb :];dst =dst [_aba ._fb :];};};func (_cagg stdHandlerR6 )alg8 (_gfba *StdEncryptDict ,_edd []byte ,_eef []byte )error {if _cfg :=_cgc ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_edd );_cfg !=nil {return _cfg ;};var _dgd [16]byte ;if _ ,_bgf :=_c .ReadFull (_d .Reader ,_dgd [:]);_bgf !=nil {return _bgf ;};_daf :=_dgd [0:8];_gbdb :=_dgd [8:16];_ebb :=make ([]byte ,len (_eef )+len (_daf ));_bcb :=copy (_ebb ,_eef );_bcb +=copy (_ebb [_bcb :],_daf );_fde ,_eegg :=_cagg .alg2b (_gfba .R ,_ebb ,_eef ,nil );if _eegg !=nil {return _eegg ;};U :=make ([]byte ,len (_fde )+len (_daf )+len (_gbdb ));_bcb =copy (U ,_fde [:32]);_bcb +=copy (U [_bcb :],_daf );_bcb +=copy (U [_bcb :],_gbdb );_gfba .U =U ;_bcb =len (_eef );_bcb +=copy (_ebb [_bcb :],_gbdb );_fde ,_eegg =_cagg .alg2b (_gfba .R ,_ebb ,_eef ,nil );if _eegg !=nil {return _eegg ;};_dgg ,_eegg :=_gedb (_fde [:32]);if _eegg !=nil {return _eegg ;};_gccg :=make ([]byte ,_ea .BlockSize );_bccg :=_e .NewCBCEncrypter (_dgg ,_gccg );UE :=make ([]byte ,32);_bccg .CryptBlocks (UE ,_edd [:32]);_gfba .UE =UE ;return nil ;};func (_dcf stdHandlerR6 )alg13 (_bgcd *StdEncryptDict ,_eege []byte )error {if _dbaef :=_cgc ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_eege );_dbaef !=nil {return _dbaef ;};if _fffb :=_cgc ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_bgcd .Perms );_fffb !=nil {return _fffb ;};_cab :=make ([]byte ,16);copy (_cab ,_bgcd .Perms [:16]);_cgdc ,_agg :=_ea .NewCipher (_eege [:32]);if _agg !=nil {return _agg ;};_abe :=_fe (_cgdc );_abe .CryptBlocks (_cab ,_cab );if !_eg .Equal (_cab [9:12],[]byte ("\u0061\u0064\u0062")){return _bc .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gfg :=Permissions (_f .LittleEndian .Uint32 (_cab [0:4]));if _gfg !=_bgcd .P {return _bc .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};_ggbe :=true ;if _cab [8]=='T'{_ggbe =true ;}else if _cab [8]=='F'{_ggbe =false ;}else {return _bc .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _ggbe !=_bgcd .EncryptMetadata {return _bc .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};

// Authenticate implements StdHandler interface.
func (_cdad stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _cdad .alg2a (d ,pass );};func (_ed *ecbDecrypter )BlockSize ()int {return _ed ._fb };var _ StdHandler =stdHandlerR4 {};func (stdHandlerR4 )paddedPass (_ff []byte )[]byte {_ged :=make ([]byte ,32);_db :=copy (_ged ,_ff );for ;_db < 32;_db ++{_ged [_db ]=_fbb [_db -len (_ff )];};return _ged ;};func (_acc stdHandlerR6 )alg10 (_bge *StdEncryptDict ,_gefec []byte )error {if _bgc :=_cgc ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_gefec );_bgc !=nil {return _bgc ;};_ffd :=uint64 (uint32 (_bge .P ))|(_gc .MaxUint32 <<32);Perms :=make ([]byte ,16);_f .LittleEndian .PutUint64 (Perms [:8],_ffd );if _bge .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_cbgg :=_c .ReadFull (_d .Reader ,Perms [12:16]);_cbgg !=nil {return _cbgg ;};_bcgga ,_cdfeg :=_gedb (_gefec [:32]);if _cdfeg !=nil {return _cdfeg ;};_fgg :=_bb (_bcgga );_fgg .CryptBlocks (Perms ,Perms );_bge .Perms =Perms [:16];return nil ;};type ecbDecrypter ecb ;func (_eeg *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_eeg ._fb !=0{_ee .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_ee .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_eeg ._cg .Decrypt (dst ,src [:_eeg ._fb ]);src =src [_eeg ._fb :];dst =dst [_eeg ._fb :];};};type ecb struct{_cg _e .Block ;_fb int ;};var _ StdHandler =stdHandlerR6 {};func (_ag *ecbEncrypter )BlockSize ()int {return _ag ._fb };func _eff (_fgaa ,_decd ,_dca []byte )([]byte ,error ){var (_cdd ,_ecb ,_eae _a .Hash ;);_cdd =_baa .New ();_bde :=make ([]byte ,64);_dbag :=_cdd ;_dbag .Write (_fgaa );K :=_dbag .Sum (_bde [:0]);_fed :=make ([]byte ,64*(127+64+48));_bcda :=func (_ggg int )([]byte ,error ){_gfb :=len (_decd )+len (K )+len (_dca );_dda :=_fed [:_gfb ];_eb :=copy (_dda ,_decd );_eb +=copy (_dda [_eb :],K [:]);_eb +=copy (_dda [_eb :],_dca );if _eb !=_gfb {_ee .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_bc .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_fed [:_gfb *64];_fbga (K1 ,_gfb );_ebg ,_ecg :=_gedb (K [0:16]);if _ecg !=nil {return nil ,_ecg ;};_afc :=_e .NewCBCEncrypter (_ebg ,K [16:32]);_afc .CryptBlocks (K1 ,K1 );E :=K1 ;_add :=0;for _fgcg :=0;_fgcg < 16;_fgcg ++{_add +=int (E [_fgcg ]%3);};var _eed _a .Hash ;switch _add %3{case 0:_eed =_cdd ;case 1:if _ecb ==nil {_ecb =_ba .New384 ();};_eed =_ecb ;case 2:if _eae ==nil {_eae =_ba .New ();};_eed =_eae ;};_eed .Reset ();_eed .Write (E );K =_eed .Sum (_bde [:0]);return E ,nil ;};for _cc :=0;;{E ,_ccf :=_bcda (_cc );if _ccf !=nil {return nil ,_ccf ;};_feb :=uint8 (E [len (E )-1]);_cc ++;if _cc >=64&&_feb <=uint8 (_cc -32){break ;};};return K [:32],nil ;};func (_aea stdHandlerR4 )alg5 (_faa []byte ,_cda []byte )([]byte ,error ){_fad :=_fa .New ();_fad .Write ([]byte (_fbb ));_fad .Write ([]byte (_aea .ID0 ));_fge :=_fad .Sum (nil );_ee .Log .Trace ("\u0061\u006c\u0067\u0035");_ee .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_faa );_ee .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_aea .ID0 );if len (_fge )!=16{return nil ,_bc .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_ce ,_bae :=_g .NewCipher (_faa );if _bae !=nil {return nil ,_bc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gec :=make ([]byte ,16);_ce .XORKeyStream (_gec ,_fge );_fca :=make ([]byte ,len (_faa ));for _gef :=0;_gef < 19;_gef ++{for _bbbf :=0;_bbbf < len (_faa );_bbbf ++{_fca [_bbbf ]=_faa [_bbbf ]^byte (_gef +1);};_ce ,_bae =_g .NewCipher (_fca );if _bae !=nil {return nil ,_bc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ce .XORKeyStream (_gec ,_gec );_ee .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_gef ,_fca );_ee .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_gef ,_gec );};_efag :=make ([]byte ,32);for _ede :=0;_ede < 16;_ede ++{_efag [_ede ]=_gec [_ede ];};_ ,_bae =_d .Read (_efag [16:32]);if _bae !=nil {return nil ,_bc .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _efag ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};type ecbEncrypter ecb ;const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func _fbga (_bfd []byte ,_df int ){_cagb :=_df ;for _cagb < len (_bfd ){copy (_bfd [_cagb :],_bfd [:_cagb ]);_cagb *=2;};};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func _gedb (_gfd []byte )(_e .Block ,error ){_gaf ,_bcgg :=_ea .NewCipher (_gfd );if _bcgg !=nil {_ee .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bcgg );return nil ,_bcgg ;};return _gaf ,nil ;};