//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_gc "bytes";_dd "crypto/aes";_d "crypto/cipher";_ec "crypto/md5";_e "crypto/rand";_cf "crypto/rc4";_g "crypto/sha256";_b "crypto/sha512";_cbe "encoding/binary";_ba "errors";_a "fmt";_de "github.com/unidoc/unipdf/v3/common";_cb "hash";
_ce "io";_ef "math";);

// Allowed checks if a set of permissions can be granted.
func (_fe Permissions )Allowed (p2 Permissions )bool {return _fe &p2 ==p2 };func (_dge stdHandlerR6 )alg2a (_af *StdEncryptDict ,_caa []byte )([]byte ,Permissions ,error ){if _dfe :=_ed ("\u0061\u006c\u00672\u0061","\u004f",48,_af .O );_dfe !=nil {return nil ,0,_dfe ;
};if _fa :=_ed ("\u0061\u006c\u00672\u0061","\u0055",48,_af .U );_fa !=nil {return nil ,0,_fa ;};if len (_caa )> 127{_caa =_caa [:127];};_dcd ,_aece :=_dge .alg12 (_af ,_caa );if _aece !=nil {return nil ,0,_aece ;};var (_caf []byte ;_acg []byte ;_gcfe []byte ;
);var _cafg Permissions ;if len (_dcd )!=0{_cafg =PermOwner ;_ggd :=make ([]byte ,len (_caa )+8+48);_daeb :=copy (_ggd ,_caa );_daeb +=copy (_ggd [_daeb :],_af .O [40:48]);copy (_ggd [_daeb :],_af .U [0:48]);_caf =_ggd ;_acg =_af .OE ;_gcfe =_af .U [0:48];
}else {_dcd ,_aece =_dge .alg11 (_af ,_caa );if _aece ==nil &&len (_dcd )==0{_dcd ,_aece =_dge .alg11 (_af ,[]byte (""));};if _aece !=nil {return nil ,0,_aece ;}else if len (_dcd )==0{return nil ,0,nil ;};_cafg =_af .P ;_bbc :=make ([]byte ,len (_caa )+8);
_ceaf :=copy (_bbc ,_caa );copy (_bbc [_ceaf :],_af .U [40:48]);_caf =_bbc ;_acg =_af .UE ;_gcfe =nil ;};if _cae :=_ed ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_acg );_cae !=nil {return nil ,0,_cae ;};_acg =_acg [:32];_aed ,_aece :=_dge .alg2b (_af .R ,_caf ,_caa ,_gcfe );
if _aece !=nil {return nil ,0,_aece ;};_fde ,_aece :=_dd .NewCipher (_aed [:32]);if _aece !=nil {return nil ,0,_aece ;};_ecc :=make ([]byte ,_dd .BlockSize );_cg :=_d .NewCBCDecrypter (_fde ,_ecc );_cgc :=make ([]byte ,32);_cg .CryptBlocks (_cgc ,_acg );
if _af .R ==5{return _cgc ,_cafg ,nil ;};_aece =_dge .alg13 (_af ,_cgc );if _aece !=nil {return nil ,0,_aece ;};return _cgc ,_cafg ,nil ;};func _ebe (_fee []byte ,_edb int ){_caef :=_edb ;for _caef < len (_fee ){copy (_fee [_caef :],_fee [:_caef ]);_caef *=2;
};};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_adg stdHandlerR4 )alg5 (_gca []byte ,_adc []byte )([]byte ,error ){_beb :=_ec .New ();_beb .Write ([]byte (_ac ));_beb .Write ([]byte (_adg .ID0 ));
_ega :=_beb .Sum (nil );_de .Log .Trace ("\u0061\u006c\u0067\u0035");_de .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_gca );_de .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_adg .ID0 );if len (_ega )!=16{return nil ,_ba .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_gba ,_feg :=_cf .NewCipher (_gca );if _feg !=nil {return nil ,_ba .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gd :=make ([]byte ,16);_gba .XORKeyStream (_gd ,_ega );_eaeb :=make ([]byte ,len (_gca ));
for _ege :=0;_ege < 19;_ege ++{for _ddfg :=0;_ddfg < len (_gca );_ddfg ++{_eaeb [_ddfg ]=_gca [_ddfg ]^byte (_ege +1);};_gba ,_feg =_cf .NewCipher (_eaeb );if _feg !=nil {return nil ,_ba .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_gba .XORKeyStream (_gd ,_gd );_de .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ege ,_eaeb );_de .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ege ,_gd );
};_fef :=make ([]byte ,32);for _ab :=0;_ab < 16;_ab ++{_fef [_ab ]=_gd [_ab ];};_ ,_feg =_e .Read (_fef [16:32]);if _feg !=nil {return nil ,_ba .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _fef ,nil ;};func _ag (_geb _d .Block )_d .BlockMode {return (*ecbEncrypter )(_ea (_geb ))};

// Authenticate implements StdHandler interface.
func (_ada stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_de .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_edd ,_fgg :=_ada .alg7 (d ,pass );if _fgg !=nil {return nil ,0,_fgg ;};if _edd !=nil {_de .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _edd ,PermOwner ,nil ;
};_de .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_edd ,_fgg =_ada .alg6 (d ,pass );if _fgg !=nil {return nil ,0,_fgg ;
};if _edd !=nil {_de .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _edd ,d .P ,nil ;};return nil ,0,nil ;};func (_ded stdHandlerR6 )alg10 (_fda *StdEncryptDict ,_bccd []byte )error {if _gfda :=_ed ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_bccd );
_gfda !=nil {return _gfda ;};_acc :=uint64 (uint32 (_fda .P ))|(_ef .MaxUint32 <<32);Perms :=make ([]byte ,16);_cbe .LittleEndian .PutUint64 (Perms [:8],_acc );if _fda .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_bbg :=_ce .ReadFull (_e .Reader ,Perms [12:16]);_bbg !=nil {return _bbg ;};_ddb ,_dce :=_bebb (_bccd [:32]);if _dce !=nil {return _dce ;};_bca :=_ag (_ddb );_bca .CryptBlocks (Perms ,Perms );_fda .Perms =Perms [:16];return nil ;};func (_bf errInvalidField )Error ()string {return _a .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_bf .Func ,_bf .Field ,_bf .Exp ,_bf .Got );
};func (_agb stdHandlerR6 )alg8 (_bbfa *StdEncryptDict ,_eaa []byte ,_bgec []byte )error {if _ccd :=_ed ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_eaa );_ccd !=nil {return _ccd ;};var _gcd [16]byte ;if _ ,_dad :=_ce .ReadFull (_e .Reader ,_gcd [:]);
_dad !=nil {return _dad ;};_beba :=_gcd [0:8];_fec :=_gcd [8:16];_baf :=make ([]byte ,len (_bgec )+len (_beba ));_dcdd :=copy (_baf ,_bgec );copy (_baf [_dcdd :],_beba );_fag ,_fed :=_agb .alg2b (_bbfa .R ,_baf ,_bgec ,nil );if _fed !=nil {return _fed ;
};U :=make ([]byte ,len (_fag )+len (_beba )+len (_fec ));_dcdd =copy (U ,_fag [:32]);_dcdd +=copy (U [_dcdd :],_beba );copy (U [_dcdd :],_fec );_bbfa .U =U ;_dcdd =len (_bgec );copy (_baf [_dcdd :],_fec );_fag ,_fed =_agb .alg2b (_bbfa .R ,_baf ,_bgec ,nil );
if _fed !=nil {return _fed ;};_afa ,_fed :=_bebb (_fag [:32]);if _fed !=nil {return _fed ;};_cdb :=make ([]byte ,_dd .BlockSize );_bdd :=_d .NewCBCEncrypter (_afa ,_cdb );UE :=make ([]byte ,32);_bdd .CryptBlocks (UE ,_eaa [:32]);_bbfa .UE =UE ;return nil ;
};func (_ae *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ae ._da !=0{_de .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_de .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ae ._ge .Encrypt (dst ,src [:_ae ._da ]);src =src [_ae ._da :];dst =dst [_ae ._da :];};};type ecbEncrypter ecb ;

// Authenticate implements StdHandler interface.
func (_gdeg stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _gdeg .alg2a (d ,pass );};func _gab (_fdb []byte )([]byte ,error ){_eb :=_g .New ();_eb .Write (_fdb );return _eb .Sum (nil ),nil };func (_cbg stdHandlerR6 )alg12 (_gde *StdEncryptDict ,_fbd []byte )([]byte ,error ){if _ddbe :=_ed ("\u0061\u006c\u00671\u0032","\u0055",48,_gde .U );
_ddbe !=nil {return nil ,_ddbe ;};if _cead :=_ed ("\u0061\u006c\u00671\u0032","\u004f",48,_gde .O );_cead !=nil {return nil ,_cead ;};_ceg :=make ([]byte ,len (_fbd )+8+48);_fdg :=copy (_ceg ,_fbd );_fdg +=copy (_ceg [_fdg :],_gde .O [32:40]);_fdg +=copy (_ceg [_fdg :],_gde .U [0:48]);
_fdbb ,_gbde :=_cbg .alg2b (_gde .R ,_ceg ,_fbd ,_gde .U [0:48]);if _gbde !=nil {return nil ,_gbde ;};_fdbb =_fdbb [:32];if !_gc .Equal (_fdbb ,_gde .O [:32]){return nil ,nil ;};return _fdbb ,nil ;};func (_bb stdHandlerR4 )alg2 (_cfc *StdEncryptDict ,_bge []byte )[]byte {_de .Log .Trace ("\u0061\u006c\u0067\u0032");
_gcff :=_bb .paddedPass (_bge );_ee :=_ec .New ();_ee .Write (_gcff );_ee .Write (_cfc .O );var _gea [4]byte ;_cbe .LittleEndian .PutUint32 (_gea [:],uint32 (_cfc .P ));_ee .Write (_gea [:]);_de .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_gea );
_ee .Write ([]byte (_bb .ID0 ));_de .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_cfc .R ,_cfc .EncryptMetadata );
if (_cfc .R >=4)&&!_cfc .EncryptMetadata {_ee .Write ([]byte {0xff,0xff,0xff,0xff});};_cea :=_ee .Sum (nil );if _cfc .R >=3{_ee =_ec .New ();for _ceac :=0;_ceac < 50;_ceac ++{_ee .Reset ();_ee .Write (_cea [0:_bb .Length /8]);_cea =_ee .Sum (nil );};};
if _cfc .R >=3{return _cea [0:_bb .Length /8];};return _cea [0:5];};const _ac ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";type ecb struct{_ge _d .Block ;_da int ;
};func (_eded stdHandlerR6 )alg13 (_bebg *StdEncryptDict ,_dceg []byte )error {if _fgc :=_ed ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_dceg );_fgc !=nil {return _fgc ;};if _aee :=_ed ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_bebg .Perms );
_aee !=nil {return _aee ;};_fbff :=make ([]byte ,16);copy (_fbff ,_bebg .Perms [:16]);_bda ,_bgeg :=_dd .NewCipher (_dceg [:32]);if _bgeg !=nil {return _bgeg ;};_bebd :=_bg (_bda );_bebd .CryptBlocks (_fbff ,_fbff );if !_gc .Equal (_fbff [9:12],[]byte ("\u0061\u0064\u0062")){return _ba .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_eace :=Permissions (_cbe .LittleEndian .Uint32 (_fbff [0:4]));if _eace !=_bebg .P {return _ba .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _egc bool ;if _fbff [8]=='T'{_egc =true ;}else if _fbff [8]=='F'{_egc =false ;}else {return _ba .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _egc !=_bebg .EncryptMetadata {return _ba .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_ace stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_fgf :=make ([]byte ,32);if _ ,_gebc :=_ce .ReadFull (_e .Reader ,_fgf );_gebc !=nil {return nil ,_gebc ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _cebf :=_ace .alg8 (d ,_fgf ,upass );_cebf !=nil {return nil ,_cebf ;};if _gddc :=_ace .alg9 (d ,_fgf ,opass );_gddc !=nil {return nil ,_gddc ;};if d .R ==5{return _fgf ,nil ;
};if _bcf :=_ace .alg10 (d ,_fgf );_bcf !=nil {return nil ,_bcf ;};return _fgf ,nil ;};type ecbDecrypter ecb ;func (_ceb *ecbEncrypter )BlockSize ()int {return _ceb ._da };type stdHandlerR4 struct{Length int ;ID0 string ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_bd stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_bbf :=_bd .alg3 (d .R ,upass ,opass );if _bbf !=nil {_de .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bbf );
return nil ,_bbf ;};d .O =O ;_de .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_daed :=_bd .alg2 (d ,upass );U ,_bbf :=_bd .alg5 (_daed ,upass );if _bbf !=nil {_de .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bbf );
return nil ,_bbf ;};d .U =U ;_de .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _daed ,nil ;};func (_ffa stdHandlerR6 )alg9 (_feb *StdEncryptDict ,_gfc []byte ,_bbe []byte )error {if _acb :=_ed ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_gfc );
_acb !=nil {return _acb ;};if _gcae :=_ed ("\u0061\u006c\u0067\u0039","\u0055",48,_feb .U );_gcae !=nil {return _gcae ;};var _ebb [16]byte ;if _ ,_gfcg :=_ce .ReadFull (_e .Reader ,_ebb [:]);_gfcg !=nil {return _gfcg ;};_aeda :=_ebb [0:8];_eca :=_ebb [8:16];
_cee :=_feb .U [:48];_ccc :=make ([]byte ,len (_bbe )+len (_aeda )+len (_cee ));_fbc :=copy (_ccc ,_bbe );_fbc +=copy (_ccc [_fbc :],_aeda );_fbc +=copy (_ccc [_fbc :],_cee );_cebd ,_ccf :=_ffa .alg2b (_feb .R ,_ccc ,_bbe ,_cee );if _ccf !=nil {return _ccf ;
};O :=make ([]byte ,len (_cebd )+len (_aeda )+len (_eca ));_fbc =copy (O ,_cebd [:32]);_fbc +=copy (O [_fbc :],_aeda );_fbc +=copy (O [_fbc :],_eca );_feb .O =O ;_fbc =len (_bbe );_fbc +=copy (_ccc [_fbc :],_eca );_cebd ,_ccf =_ffa .alg2b (_feb .R ,_ccc ,_bbe ,_cee );
if _ccf !=nil {return _ccf ;};_bcb ,_ccf :=_bebb (_cebd [:32]);if _ccf !=nil {return _ccf ;};_ecd :=make ([]byte ,_dd .BlockSize );_gfd :=_d .NewCBCEncrypter (_bcb ,_ecd );OE :=make ([]byte ,32);_gfd .CryptBlocks (OE ,_gfc [:32]);_feb .OE =OE ;return nil ;
};func (stdHandlerR4 )paddedPass (_gcf []byte )[]byte {_bc :=make ([]byte ,32);_cfe :=copy (_bc ,_gcf );for ;_cfe < 32;_cfe ++{_bc [_cfe ]=_ac [_cfe -len (_gcf )];};return _bc ;};func (_be stdHandlerR4 )alg4 (_gef []byte ,_eae []byte )([]byte ,error ){_eac ,_cd :=_cf .NewCipher (_gef );
if _cd !=nil {return nil ,_ba .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dc :=[]byte (_ac );_eg :=make ([]byte ,len (_dc ));_eac .XORKeyStream (_eg ,_dc );return _eg ,nil ;};const (PermOwner =Permissions (_ef .MaxUint32 );
PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11);
);func (_fc *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_fc ._da !=0{_de .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_de .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_fc ._ge .Decrypt (dst ,src [:_fc ._da ]);src =src [_fc ._da :];dst =dst [_fc ._da :];};};func (_aaf stdHandlerR4 )alg7 (_bef *StdEncryptDict ,_fd []byte )([]byte ,error ){_gdd :=_aaf .alg3Key (_bef .R ,_fd );_adf :=make ([]byte ,len (_bef .O ));
if _bef .R ==2{_cfce ,_egd :=_cf .NewCipher (_gdd );if _egd !=nil {return nil ,_ba .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_cfce .XORKeyStream (_adf ,_bef .O );}else if _bef .R >=3{_abf :=append ([]byte {},_bef .O ...);
for _gfbf :=0;_gfbf < 20;_gfbf ++{_bfd :=append ([]byte {},_gdd ...);for _fgb :=0;_fgb < len (_gdd );_fgb ++{_bfd [_fgb ]^=byte (19-_gfbf );};_gga ,_aae :=_cf .NewCipher (_bfd );if _aae !=nil {return nil ,_ba .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_gga .XORKeyStream (_adf ,_abf );_abf =append ([]byte {},_adf ...);};}else {return nil ,_ba .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_dcg ,_gdg :=_aaf .alg6 (_bef ,_adf );if _gdg !=nil {return nil ,nil ;};return _dcg ,nil ;};func (_ad *ecbDecrypter )BlockSize ()int {return _ad ._da };
func (_eeg stdHandlerR4 )alg6 (_gfb *StdEncryptDict ,_dae []byte )([]byte ,error ){var (_gaa []byte ;_fg error ;);_aefc :=_eeg .alg2 (_gfb ,_dae );if _gfb .R ==2{_gaa ,_fg =_eeg .alg4 (_aefc ,_dae );}else if _gfb .R >=3{_gaa ,_fg =_eeg .alg5 (_aefc ,_dae );
}else {return nil ,_ba .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _fg !=nil {return nil ,_fg ;};_de .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_gaa ),string (_gfb .U ));
_gbg :=_gaa ;_fca :=_gfb .U ;if _gfb .R >=3{if len (_gbg )> 16{_gbg =_gbg [0:16];};if len (_fca )> 16{_fca =_fca [0:16];};};if !_gc .Equal (_gbg ,_fca ){return nil ,nil ;};return _aefc ,nil ;};var _ StdHandler =stdHandlerR4 {};var _ StdHandler =stdHandlerR6 {};


// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_dee stdHandlerR6 )alg11 (_dff *StdEncryptDict ,_edbd []byte )([]byte ,error ){if _fab :=_ed ("\u0061\u006c\u00671\u0031","\u0055",48,_dff .U );_fab !=nil {return nil ,_fab ;};_bddf :=make ([]byte ,len (_edbd )+8);
_daa :=copy (_bddf ,_edbd );_daa +=copy (_bddf [_daa :],_dff .U [32:40]);_bbd ,_eba :=_dee .alg2b (_dff .R ,_bddf ,_edbd ,nil );if _eba !=nil {return nil ,_eba ;};_bbd =_bbd [:32];if !_gc .Equal (_bbd ,_dff .U [:32]){return nil ,nil ;};return _bbd ,nil ;
};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_ff stdHandlerR4 )alg3 (R int ,_cfa ,_gf []byte )([]byte ,error ){var _ecf []byte ;if len (_gf )> 0{_ecf =_ff .alg3Key (R ,_gf );}else {_ecf =_ff .alg3Key (R ,_cfa );};_eeb ,_cfcg :=_cf .NewCipher (_ecf );if _cfcg !=nil {return nil ,_ba .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dde :=_ff .paddedPass (_cfa );_aef :=make ([]byte ,len (_dde ));_eeb .XORKeyStream (_aef ,_dde );if R >=3{_cag :=make ([]byte ,len (_ecf ));for _aec :=0;_aec < 19;_aec ++{for _gafg :=0;_gafg < len (_ecf );_gafg ++{_cag [_gafg ]=_ecf [_gafg ]^byte (_aec +1);
};_fbf ,_agd :=_cf .NewCipher (_cag );if _agd !=nil {return nil ,_ba .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fbf .XORKeyStream (_aef ,_aef );};};return _aef ,nil ;};func _ed (_cfb ,_ddc string ,_bgd int ,_add []byte )error {if len (_add )< _bgd {return errInvalidField {Func :_cfb ,Field :_ddc ,Exp :_bgd ,Got :len (_add )};
};return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_bbb stdHandlerR4 )alg3Key (R int ,_ga []byte )[]byte {_aa :=_ec .New ();_fb :=_bbb .paddedPass (_ga );_aa .Write (_fb );if R >=3{for _gaf :=0;_gaf < 50;
_gaf ++{_bcc :=_aa .Sum (nil );_aa =_ec .New ();_aa .Write (_bcc );};};_dg :=_aa .Sum (nil );if R ==2{_dg =_dg [0:5];}else {_dg =_dg [0:_bbb .Length /8];};return _dg ;};func (_gdf stdHandlerR6 )alg2b (R int ,_dcf ,_abg ,_bde []byte )([]byte ,error ){if R ==5{return _gab (_dcf );
};return _ebc (_dcf ,_abg ,_bde );};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func _ebc (_dgd ,_cfaa ,_dgb []byte )([]byte ,error ){var (_dfb ,_ede ,_bff _cb .Hash ;);_dfb =_g .New ();_bbfd :=make ([]byte ,64);_bab :=_dfb ;_bab .Write (_dgd );
K :=_bab .Sum (_bbfd [:0]);_bgb :=make ([]byte ,64*(127+64+48));_dgg :=func (_gdda int )([]byte ,error ){_ead :=len (_cfaa )+len (K )+len (_dgb );_bfdb :=_bgb [:_ead ];_aeb :=copy (_bfdb ,_cfaa );_aeb +=copy (_bfdb [_aeb :],K [:]);_aeb +=copy (_bfdb [_aeb :],_dgb );
if _aeb !=_ead {_de .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_ba .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");
};K1 :=_bgb [:_ead *64];_ebe (K1 ,_ead );_dfg ,_dgbe :=_bebb (K [0:16]);if _dgbe !=nil {return nil ,_dgbe ;};_cda :=_d .NewCBCEncrypter (_dfg ,K [16:32]);_cda .CryptBlocks (K1 ,K1 );E :=K1 ;_ebf :=0;for _edf :=0;_edf < 16;_edf ++{_ebf +=int (E [_edf ]%3);
};var _cge _cb .Hash ;switch _ebf %3{case 0:_cge =_dfb ;case 1:if _ede ==nil {_ede =_b .New384 ();};_cge =_ede ;case 2:if _bff ==nil {_bff =_b .New ();};_cge =_bff ;};_cge .Reset ();_cge .Write (E );K =_cge .Sum (_bbfd [:0]);return E ,nil ;};for _bffd :=0;
;{E ,_fbe :=_dgg (_bffd );if _fbe !=nil {return nil ,_fbe ;};_edg :=E [len (E )-1];_bffd ++;if _bffd >=64&&_edg <=uint8 (_bffd -32){break ;};};return K [:32],nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e");
);func _ea (_f _d .Block )*ecb {return &ecb {_ge :_f ,_da :_f .BlockSize ()}};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_gebf *StdEncryptDict ,_gb ,_dag []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ca *StdEncryptDict ,_ddf []byte )([]byte ,Permissions ,error );};func _bebb (_gbd []byte )(_d .Block ,error ){_cc ,_bfb :=_dd .NewCipher (_gbd );if _bfb !=nil {_de .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bfb );
return nil ,_bfb ;};return _cc ,nil ;};func _bg (_gg _d .Block )_d .BlockMode {return (*ecbDecrypter )(_ea (_gg ))};type stdHandlerR6 struct{};